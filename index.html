<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <style>
    pre {
      margin: 5%;
      font-family: Consolas, "Courier New", monospace;
      font-size: large;
      border: 2px solid green;
      padding: 5%;
      border-radius: 10px;
    }

    .textStyle {
      display: flex;
      justify-content: center;
      padding-bottom: 20px;
      color: blue;
      font-weight: 800;
      font-size: 24px;
      font-family: Consolas, "Courier New", monospace;
    }

    #line {
      color: green;
      font-size: 21px;
      font-weight: bolder;
      color: red;
    }
  </style>
</head>

<body>
  <div class="code">
    <pre id="getalltext">
          <div>
import java.util.*;
public class Main{
	public static void main(String[] args) {
	    Employee e1=new Employee("suma",10,"it");
	    Employee e2=new Employee("kumar",110,"cs");
	    Employee e3=new Employee("ram",102,"me");
	    Employee e4=new Employee("man",140,"ce");
	    Employee e5=new Employee("some",1,"house");
		  TreeSet t=new TreeSet();
		  t.add(e1);
		  t.add(e2);
		  t.add(e3);
		  t.add(e4);
		  t.add(e5);
	
		  System.out.println(t);
	}
}
class mycompare implements Comparator{
    public int compare(Object o1,Object o2){
       Employee e1=(Employee)o1;
       Employee e2=(Employee)o2;
       String s1=e1.name;
       String s2=e2.name;
       return s1.compareTo(s2);
    }
}
class Employee implements Comparable{
    String name;
    int id;
    String dept;
    Employee(String name,int id,String dept){
        this.name=name;
        this.id=id;
        this.dept=dept;
    }
    public String toString(){
        return name+" "+id+" "+dept;
    }
    public int compareTo(Object o1){
        // int eid1=this.id;
        // Employee e=(Employee)o1;
        // int eid2=e.id;
        // if(eid1< eid2)return -1;
        // else if(eid1> eid2)return 1;
        // else return 0;
        String dep1=this.dept;
        Employee e=(Employee)o1;
        String dep2=e.dept;
        return dep1.compareTo(dep2);
    }
}
<span id="line">---------------------------------------------------------------</span>
import java.util.Scanner;
public class Main{
	public static void main(String[] args) {
		Scanner sc=new Scanner(System.in);
		System.out.println("Enter string in number");
		String s=sc.nextLine();
		String[] arr=s.split(" ");
		int[] intarr=new int[arr.length];
		for(int i=0;i< arr.length;i++){
		    intarr[i]=Integer.parseInt(arr[i]);
		}
		int evensum=0;
		int oddsum=0;
	    for(int i=0;i< intarr.length;i++){
	        if(intarr[i]%2==0){
	           evensum+=intarr[i]; 
	        }else{
	            oddsum+=intarr[i];
	        }
	    }
		System.out.print("Even sum= "+evensum+"oddsum = "+oddsum);
	}
}
<span id="line">---------------------------------------------------------------</span>
import java.util.*;
public class Main{
	public static void main(String[] args) {
	   employee e1=new employee("suman",12,"CSE");
	   employee e2=new employee("suman",11,"EE");
	   employee e3=new employee("suman",14,"ME");
	   employee e4=new employee("suman",16,"CIVIL");
	   employee e5=new employee("suman",18,"CSE");
	   employee e6=new employee("suman",13,"NO");
	   TreeSet t=new TreeSet();
	   t.add(e1);
	   t.add(e2);
	   t.add(e3);
	   t.add(e4);
	   t.add(e5);
	   t.add(e6);
	   System.out.println(t);
	}
	
}
class employee implements Comparable{
    String name;
    int eid;
    String dep;
    employee(String name,int eid,String dep){
        this.name=name;
        this.eid=eid;
        this.dep=dep;
    }
    public String toString(){
        return name+" "+eid+" "+dep;
    }
    public  int compareTo(Object o1){
        //  int id1=this.eid;
        //  employee e=(employee)o1;
        //  int idid2=e.eid;
        //  if(id1< idid2)return -1;
        //  else if(id1>idid2)return -1;
        //  else return 0;
        
        String d1=this.dep;
        employee e=(employee)o1;
        String d2=e.dep;
        return d1.compareTo(d2);
    }
}
<span id="line">---------------------------------------------------------------</span>
Merge sort
public class Main{
	public static void main(String[] args) {
		System.out.println("Hello World");
		int[] arr1={1,12,45,67,89,3,5,7,9};
		int[] ans=new int[arr1.length];
		ans=mergesort(arr1,0,arr1.length-1);
	    for(int aa:ans){
	        System.out.print(" "+aa);
	    }
	}
	public static int[] mergesort(int[] arr,int lo,int hi){
	    if(lo==hi){
	        int[] ba=new int[1];
	        ba[0]=arr[lo];
	        return ba;
	    }
	    int mid=(lo+hi)/2;
	    int[] leftside=mergesort(arr,lo,mid);
	    int[] rightside=mergesort(arr,mid+1,hi);
	    int[] finalarray=mergetwosortedarray(leftside,rightside);
	    return finalarray;
	}
	 public static int[] mergetwosortedarray(int[] nums1, int[] nums2) {
	    int[] res=new int[nums1.length+nums2.length];
	    int i=0;
	    int j=0;
	    int k=0;
	    while(i< nums1.length&&j< nums2.length){
	        if(nums1[i]< nums2[j]){
	        res[k]=nums1[i];
	        i++;
	        k++;
	    }else{
	        res[k]=nums2[j];
	        j++;
	        k++;
	    }
	  }
	  while(i< nums1.length){
	      res[k]=nums1[i];
	        i++;
	        k++; 
	  }
	  while(j< nums2.length){
	       res[k]=nums2[j];
	        j++;
	        k++;
	  }
	  return res;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Tree set?</span> 	
import java.util.*;
public class Main{
	public static void main(String[] args) {
		System.out.println("Hello World");
		TreeSet t=new TreeSet();
		t.add(new employee("suman",12));
		t.add(new employee("kumar",1));
		t.add(new employee("anand",11));
		t.add(new employee("sharma",2));
		t.add(new employee("balment",112));
		System.out.println(t);
		Iterator itr=t.iterator();
		while(itr.hasNext()){
		    employee e1=(employee)itr.next();
		    int i=e1.id;
		    if(i%2==0){
		        System.out.println(e1);
		    }
		}
	}
}
class employee implements Comparable{
    String name;
    int id;
    employee(String name,int id){
        this.name=name;
        this.id=id;
    }
    public String toString(){
        return name+"->"+id;
    }
    public int compareTo(Object o1){
        String s1=this.name;
        employee e1=(employee)o1;
        String s2=e1.name;
        return s1.compareTo(s2);
    }
    
}
class mycompare implements Comparator{
    public int compare(Object o1,Object o2){
        employee e1=(employee)o1;
        employee e2=(employee)o2;
        String s1=e1.name;
        String s2=e2.name;
        return s1.compareTo(s2);
        // int id1=e1.id;
        // int id2=e2.id;
        // if(id1< id2)return -1;
        // else if(id1>id2)return +1;
        // else return 0;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">new myComparator()?</span> 	
import java.util.*;  
class Main{
       public static void main(String[] args){

        ArrayList<Student> al = new ArrayList<>();

        al.add(new Student("Ajay", 27));
        al.add(new Student("Sneha", 23));
        al.add(new Student("Simran", 37));
        al.add(new Student("Ajay", 22));
        al.add(new Student("Ajay", 29));
        al.add(new Student("Sneha", 22));

        Iterator<Student> itr = al.iterator();
        while (itr.hasNext()) {
            System.out.println(itr.next());
        }
        Collections.sort(al,new myComparator());
        System.out.println("After Sorting:\n");
        for (Student s : al) {
            System.out.println(s);
        }
    }

  }
class Student {
    String Name;
    int Age;
    public Student(String Name, Integer Age){
        this.Name = Name;
        this.Age = Age;
    }
    public String getName() { return Name; }
    public void setName(String Name) { this.Name = Name; }
    public Integer getAge() { return Age; }
    public void setAge(Integer Age) { this.Age = Age; }
    public String toString(){
        return "Customer{" + "Name=" + Name + ", Age=" + Age + '}';
    }  
}
  class myComparator implements Comparator< Student> {
        public int compare(Student s1,Student s2){
            int NameCompare = s1.getName().compareTo(s2.getName());
            int AgeCompare = s1.getAge().compareTo(s2.getAge());
 
            return (NameCompare == 0) ? AgeCompare : NameCompare;
        }
    }
<span id="line">---------------------------------------------------------------</span>

<span class="textStyle">Q. Word contains vowel or not?</span> 		  
import java.util.regex.Matcher;
import java.util.regex.Pattern;
public class Main {
   public static void main( String args[] ) {
      String regex = "[aeiouAEIOU]";
      String input = "suman";
      
      Pattern p = Pattern.compile(regex);
      Matcher matcher = p.matcher(input);
      if(matcher.find()) {
         System.out.println("The input string contains vowels");
      } else {
         System.out.println("The input string does not contain vowels");
      }
   }
}
In this article we are coding for that how we find that a word contains vowel or not one way is 
for(int i=0;i< str.length();i++){
	if(str.charAt(i)=='a'||.....till e,i ,o u,and in capital form also){
		//your message;
	}
}
as we can see that above program is not good due too condition in if block
so we can use 2 approach with the help of java.util.regex as we konow that is this package 2 class 
whose name is pattern and matcher .with the help of this class we can able to find wheather the 
word conatins vowel or not 
step 1..create a string in which we need to store all vowel  "[aeiouAEIOU]" in this format
step 2..input string
step 3..
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Q. Is a Number Prime?</span> 
import java.util.*;
public class Main {
  public static void main(String[] args) {
    Scanner scn = new Scanner(System.in);
    int t = scn.nextInt();

    for (int i = 0; i < t; i++) {
      int n = scn.nextInt();
      int div = 2;
      while (div * div <= n) {
        if (n % div == 0) {
          break;
        }
        div++;
      }
      if (div * div > n) {
        System.out.println("prime");
      } else {
        System.out.println("not prime");
      }
    }

  }
}
<span id="line">---------------------------------------------------------------</span>

<span class="textStyle">Q . Primes Till</span> 
import java.io.*;
import java.util.*;
public class Main {
  public static void main(String args) throw Exception {
    Scanner scn = new Scanner(System.in);
    int low = scn.nextInt(); //taking lower bound input
    int high = scn.nextInt(); //taking upper bound input

    for (int n = low; n <= high; n++) {
      int count = 0;
      for (int div = 2; div * div <= n; div++) {
        if (n % div == 0) {
          count++;
          break;
        }
      }
      if (count == 0) // checks if count is 0
        System.out.println(n);
    }
  }
}

import java.util.*;
public class Main {
  public static void main(String[] args) {
    Scanner scn = new Scanner(System.in);
    int low = scn.nextInt();
    int high = scn.nextInt();
    for (int num = low; num <= high; num++) {
      int div = 2;
      while (div * div <= num) {
        if (num % div == 0) {
          break;
        }
        div++;
      }
      if (div * div > num) {
        System.out.println(num);
      }
    }
  }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Q . Print Fibonacci Numbers Till N</span>
public class Main
{
	public static void main(String[] args) {
		int n=5;
		int f=0;
	  int s=1;
	  while(n-->0){
			int t=f+s;
			System.out.println(f+"--"+s+"--"+t);
			f=s;
			s=t;
	  }
	}

}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Q . Count Digits In A Number</span>
public class Main{
	public static void main(String[] args) {
		int num=1234432;
		int d=3;
		int count=0;
		while(num!=0){
		    if(num%10==d){
		        count++;
		    }
		    num/=10;
		}
		System.out.println(count);
	}
}

<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Q . Digits of a Number</span>
import java.util.*;

public class Main {
  public static void main(String[] args) {
    Scanner scn = new Scanner(System.in);
    int n = scn.nextInt();
    int power = 1;
    int temp = n;
    while (temp >= 10) {
      temp /= 10;
      power *= 10;
    }
    temp = n;
    while (power != 0) {
      int digit = temp / power;
      System.out.println(digit);
      temp = temp % power;
      power = power / 10;
    }
  }
}
Input:-125
output:-1
		2
		5
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Q . Reverse a Number</span>

import java.util.*;

public class Main {
  public static void main(String[] args) {
    Scanner scn = new Scanner(System.in);
    int n = 123;
    int ans=0;
    while (n !=0) {
        int l=n%10;
        ans=(ans*10)+l;
        n/=10;
    }
    System.out.println(ans);
  }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Q . Inverse a Number</span>
import java.util.*;

public class Main {
  public static void main(String[] args) {
    Scanner scn = new Scanner(System.in);
    int n = scn.nextInt();

    int inv = 0; //inverted number at the tart
    int op = 1; // original place

    while (n > 0) {
      int od = n % 10; //last digit  of original number
      int id = op; // id =  inverted digit
      int ip = od; // ip =  inverted place
      //Make change to inv  using ip and id
      inv = inv + (id * (int) Math.pow(10, ip - 1));
      n = n / 10;
      op++;
    }
    System.out.println(inv);
  }
}
<span class="textStyle">or</span>
import java.util.*;

public class Main {
  public static void main(String[] args) {
    Scanner scn = new Scanner(System.in);
    int n = scn.nextInt();

    int inverted = 0;
    int power = 1;

    while (n > 0) {
      int digit = n % 10;
      n = n / 10;
      inverted += power * Math.pow(10, digit - 1);
      power++;
    }
    System.out.println(inverted);
  }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Q . Rotate a Number</span>
import java.util.*;

import java.lang.*;
import java.io.*;
public class Main {
  public static void main(String[] args){
    Scanner scn = new Scanner(System.in);
    int n = scn.nextInt();
    int k = scn.nextInt();
    int nod = 0; //number of digits
    int temp = n;
    //temporarily storing number to perform division 
    while(temp != 0){
      temp /= 10;
      nod++;
    }
    //25398 will give nod = 5
    int div = 1; //initialize divisor = 1
    int mult = 1; //initialize multiplier = 1
    for (int i = 1; i <= nod; i++){
      if (i <= k){//while the iterator is less than k
        //we increase the value of divisor
        div *= 10;
      }
      else{//or else we increase the value of multiplier
        mult *= 10;
    }
  }
    int quo = n / div; // extracting the quotient int rem = n % div; // extracting the remainder
    int r = rem * mult + quo;
    //forming the rotated number
    System.out.println(r);
 }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Q . Gcd And Lcm</span>
import java.util.*;

public class Main {
  public static void main(String[] args){
    Scanner scn = new Scanner(System.in);
    int n1 = scn.nextInt();
    int n2 = scn.nextInt();
    int temp1 = n1;
    int temp2 = n2;

    while (n1 % n2 != 0){
      int remainder = n1 % n2;
      n1 = n2;
      n2 = remainder;
    }
    int gcd = n2;
    int lcm = (temp1 * temp2) / gcd;

    System.out.println(gcd);
    System.out.println(lcm);
  }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Q . Prime Factorization Of A Number</span>
import java.util.*;

public class Main {
  public static void main(String[] args) {
    Scanner scn = new Scanner(System.in);
    int a = scn.nextInt();
    int b = scn.nextInt();
    int c = scn.nextInt();

    int max = a;
    if (b >= max)
      max = b;

    if (c >= max)
      max = c;

    if (max == a) {
      System.out.println((b * b + c * c) == (a * a));
    } else if (max == b) {
      System.out.println((a * a + c * c) == (b * b));
    } else {
      System.out.println((a * a + b * b) == (c * c));
    }
  }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Q . Pythagorean Triplet</span>
import java.util.*;

public class Main {

  public static void main(String[] args) {
    Scanner scn = new Scanner(System.in);
    int a = scn.nextInt();
    int b = scn.nextInt();
    int c = scn.nextInt();

    int max = a;
    if (b >= max)
      max = b;

    if (c >= max)
      max = c;

    if (max == a) {
      System.out.println((b * b + c * c) == (a * a));
    } else if (max == b) {
      System.out.println((a * a + c * c) == (b * b));
    } else {
      System.out.println((a * a + b * b) == (c * c));
    }
  }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Q . he Curious Case Of Benjamin Bulbs</span>
import java.util.*;
public class Main {

  public static void main(String[] args) {
    Scanner scn = new Scanner(System.in);
    int n = scn.nextInt();

    for (int i = 1; i * i <= n; i++){
      System.out.println(i * i);
    }
  }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Q . Digit Frequency</span>
import java.util.*;

public class Main {
  public static void main(String[] args) {
    Scanner scn = new Scanner(System.in);
    int n = scn.nextInt();
    int d = scn.nextInt();
    int f = getDigitFrequency(n, d);
    System.out.println(f);
  }
  public static int getDigitFrequency(int n, int d) {
    int counter = 0;
    // initialize digit counter to 0
    while (n > 0){
      int temp = n % 10; // Extract Digits
      n = n / 10; // Divide N by 10
      if (temp == d) // Logic Applied
        counter++;
    }
    return counter;
  }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Q . Decimal To Any Base</span>
import java.util.*;

public class Main {
  public static void main(String[] args) {
    Scanner scn = new Scanner(System.in);
    int n = scn.nextInt();
    int b = scn.nextInt();
    System.out.println(getValueInBase(n, b));
    scn.close();
  }

  public static int getValueInBase(int n, int b) {
    int ans_num = 0, multiplier = 1;
    while (n > 0){
      int remainder = n % b;
      n = n / b;
      ans_num = ans_num + remainder * multiplier;
      multiplier *= 10;
    }
    return ans_num;
  }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Q . Any base to Decimal</span>
import java.io.*;
import java.util.*;
public class Main {
  public static void main(String[] args) {
    Scanner scn = new Scanner(System.in);
    int n = scn.nextInt();
    int b = scn.nextInt();
    scn.close();
    int d = toDecimal(n, b);
    System.out.println(d);
  }

  public static int toDecimal(int n, int b) {
    int multiplier = 0, ans_num = 0;
    while (n > 0) {
      int remainder = n % 10;
      n = n / 10;
      ans_num += remainder * Math.pow(b, multiplier);
      multiplier++;
    }
    return ans_num;
  }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Q . Any Base To Any Base</span>
import java.io.*;
import java.util.*;
public class Main {
  public static void main(String[] args) {
    Scanner scn = new Scanner(System.in);
    int n = scn.nextInt();
    int sourceBase = scn.nextInt();
    int  destBase = scn.nextInt();

    int res = getValue(n, sourceBase, destBase);
    System.out.println(res);
  }
  public static int getValue(int n, int b1, int b2) {
    int dec = getValueInDecimal(n, b1);
    int dn = getValueInBase(dec, b2);
    return dn;
  }
  public static int getValueInBase(int n, int b) {
    int rv = 0;
    int p = 1;
    while (n > 0) {
      int dig = n % b;
      n = n / b;
      rv = rv + (dig * p);
      p = p * 10;
    }
    return rv;
  }
  public static int getValueInDecimal(int n, int b) {
    int rv = 0;
    int p = 1;
    while (n > 0) {
      int dig = n % 10;
      n = n / 10;
      rv = rv + (dig * p);
      p = p * b;
    }
    return rv;
  }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Q . Any Base Addition</span>
import java.io.*;
import java.util.*;
public class Main {
  public static void main(String[] args) {
    Scanner scn = new Scanner(System.in);
    int b = scn.nextInt();
    int n1 = scn.nextInt();
    int n2 = scn.nextInt();
    int d = getSum(b, n1, n2);
    System.out.println(d);
  }
  public static int getSum(int b, int n1, int n2) {
    int result = 0;
    int sum = 0, carry = 0, multiplier = 1;
    while (n1 > 0 || n2 > 0 || carry > 0) {
      int digit1 = n1 % 10;
      int digit2 = n2 % 10;
      sum = (digit1 + digit2 + carry);
      carry = sum / b;
      int value = sum % b;

      result += multiplier * value;
      multiplier *= 10;

      n1 /= 10;
      n2 /= 10;
    }

    return result;
  }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Q . Any Base Subtraction</span>
import java.io.*;
import java.util.*;
public class Main {
  public static void main(String[] args) {
    Scanner scn = new Scanner(System.in);
    int b = scn.nextInt();
    int n1 = scn.nextInt();
    int n2 = scn.nextInt();

    int d = getDifference(b, n1, n2);
    System.out.println(d);
  }

  public static int getDifference(int b, int n1, int n2) {
    int rv = 0;

    int c = 0;
    int p = 1;
    while (n2 > 0) {
      int d1 = n1 % 10;
      int d2 = n2 % 10;
      n1 = n1 / 10;
      n2 = n2 / 10;

      int d = d2 - d1 - c;

      if (d < 0) {
        c = 1;
        d += b;
      } else {
        c = 0;
      }

      rv += d * p;
      p = p * 10;
    }

    return rv;
  }

}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Q . Any Base Multiplication</span>
import java.io.*;
import java.util.*;
public class Main {
  public static void main(String[] args) {
    Scanner scn = new Scanner(System.in);
    int b = scn.nextInt();
    int n1 = scn.nextInt();
    int n2 = scn.nextInt();

    int d = getProduct(b, n1, n2);
    System.out.println(d);
  }

  public static int getProduct(int b, int n1, int n2) {
    int rv = 0;

    int c = 0;
    int p = 1;
    while (n2 > 0) {
      int d2 = n2 % 10;
      n2 = n2 / 10;

      int pwd = getProductWithDigit(b, n1, d2);
      rv = getSum(b, rv, p * pwd);
      p = p * 10;
    }

    return rv;
  }

  public static int getProductWithDigit(int b, int n1, int d2) {
    int rv = 0;

    int c = 0;
    int p = 1;
    while (n1 > 0 || c > 0) {
      int d1 = n1 % 10;
      n1 = n1 / 10;

      int d = d1 * d2 + c;
      c = d / b;
      d = d % b;

      rv += d * p;
      p = p * 10;
    }

    return rv;
  }

  public static int getSum(int b, int n1, int n2) {
    int rv = 0;

    int c = 0;
    int p = 1;
    while (n1 > 0 || n2 > 0 || c > 0) {
      int d1 = n1 % 10;
      int d2 = n2 % 10;
      n1 = n1 / 10;
      n2 = n2 / 10;

      int d = d1 + d2 + c;
      c = d / b;
      d = d % b;

      rv += d * p;
      p = p * 10;
    }

    return rv;
  }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Q . Span of an Array</span>
import java.io.*;
import java.util.*;
public class Main {
  public static void main(String[] args) throws Exception {
    Scanner scn = new Scanner(System.in);
    int n = scn.nextInt();
    int[] arr = new int[n];

    for (int i = 0; i < n; i++) {
      arr[i] = scn.nextInt();
    }

    int min = arr[0];
    int max = arr[0];

    for (int i = 1; i < arr.length; i++) {
      if (arr[i] < min) {
        min = arr[i];
      }

      if (arr[i] > max) {
        max = arr[i];
      }
    }

    int span = max - min;
    System.out.println(span);
  }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Q . Find element in an Array</span>
import java.io.*;
import java.util.*;
public class Main {
  public static void main(String[] args) throws Exception {
    Scanner scn = new Scanner(System.in);
    int n = scn.nextInt();
    int[] arr = new int[n];

    for (int i = 0; i < n; i++) {
      arr[i] = scn.nextInt();
    }

    int d = scn.nextInt();

    for (int i = 0; i < arr.length; i++) {
      if (d == arr[i]) {
        System.out.println(i);
        return;
      }
    }
    System.out.println(-1);
  }

}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Q . BAR CHART</span>
import java.io.*;
import java.util.*;
public class Main {
  public static void main(String[] args) throws Exception {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    int n = 5;
    int[] arr = {3, 1, 0, 7, 5};
    int max = Integer.MIN_VALUE;
    for (int i = 0; i < n; i++) {
      max = Math.max(max, arr[i]);
    }
    for (int i = 0; i < max; i++) {
      for (int val : arr) {
        if (val >= max - i) {
          System.out.print("*	");
        } else {
          System.out.print("	");
        }
      }
      System.out.println();
    }
  }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Q . Sum Of Two Arrays</span>
import java.io.*;
import java.util.*;
public class Main {
  public static void main(String[] args) throws Exception {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

    int n1 = 5;
    int[] a1 = new int[]{ 3, 1, 0, 7, 5 };
    int n2 = 6;
    int[] a2 = new int[]{ 1, 1, 1, 1, 1, 1 };

    int[] sum = new int[n1 > n2 ? n1 : n2];
    int i = n1 - 1;
    int j = n2 - 1;
    int k = sum.length - 1;
    int c = 0;
    while (i >= 0 || j >= 0) {
      int d = c;

      if (i >= 0)
        d += a1[i];

      if (j >= 0)
        d += a2[j];

      c = d / 10;
      d = d % 10;
      sum[k] = d;

      i--;
      j--;
      k--;
    }

    if (c > 0) {
      System.out.println(c);
    }
    for (int val : sum) {
      System.out.println(val);
    }
  }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Q . Difference Of Two Arrays</span>
import java.io.*;
import java.util.*;
public class Main {
  public static void main(String[] args) throws Exception {
    Scanner scn = new Scanner(System.in);
    int n1 = scn.nextInt();
    int a1[] = new int[n1];

    for (int i = 0; i < a1.length; i++) {
      a1[i] = scn.nextInt();
    }

    int n2 = scn.nextInt();
    int a2[] = new int[n2];

    for (int i = 0; i < a2.length; i++) {
      a2[i] = scn.nextInt();
    }

    int diff[] = new int[n2];
    int c = 0;
    int i = a1.length - 1;
    int j = a2.length - 1;
    int k = diff.length - 1;

    while (k >= 0) {
      int d = 0;
      int a1v = (i >= 0 ? a1[i] : 0);
      if (a2[j] + c >= a1v) {
        d = a2[j] + c - a1v;
        c = 0;
      } else {
        d = a2[j] + 10 + c - a1v;
        c = -1;
      }

      diff[k] = d;
      i--;
      j--;
      k--;
    }

    int idx = 0;
    while (idx < diff.length && diff[idx] == 0) {
      idx++;
    }

    while (idx < diff.length) {
      System.out.println(diff[idx++]);

    }
  }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Q . Reverse an Array</span>
import java.io.*;
import java.util.*;
public class Main {
  public static void display(int[] a) {
    StringBuilder sb = new StringBuilder();

    for (int val : a) {
      sb.append(val + " ");
    }
    System.out.println(sb);
  }

  public static void reverse(int[] a) {
    int [] b = new int[a.length];
    for (int i = a.length - 1, j = 0; i >= 0; i--, j++){
      b[j] = a[i];
    }
    for (int i = 0; i < a.length; i++){
      a[i] = b[i];
    }
  }

  public static void main(String[] args) throws Exception {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

    int n = Integer.parseInt(br.readLine());
    int[] a = new int[n];
    for (int i = 0; i < n; i++) {
      a[i] = Integer.parseInt(br.readLine());
    }

    reverse(a);
    display(a);
  }

}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Q . Rotate an Array</span>
import java.io.*;

import java.util.*;

public class Main {
  public static void display(int[] a) {
    StringBuilder sb = new StringBuilder();

    for (int val : a) {
      sb.append(val + " ");
    }
    System.out.println(sb);
  }

  public static void reverse(int[] a, int li, int ri) {
    while (li < ri) {
      int temp = a[li];
      a[li] = a[ri];
      a[ri] = temp;

      li++;
      ri--;
    }
  }

  public static void rotate(int[] a, int k) {
    k = k % a.length;
    if (k < 0) {
      k += a.length;
    }

    reverse(a, 0, a.length - k - 1);
    reverse(a, a.length - k, a.length - 1);
    reverse(a, 0, a.length - 1);
  }

  public static void main(String[] args) throws Exception {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

    int n = Integer.parseInt(br.readLine());
    int[] a = new int[n];
    for (int i = 0; i < n; i++) {
      a[i] = Integer.parseInt(br.readLine());
    }
    int k = Integer.parseInt(br.readLine());

    rotate(a, k);
    display(a);
  }

}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Q . INVERSE OF AN ARRAY</span>
import java.io.*;
import java.util.*;
public class Main {
  public static void display(int[] a) {
    StringBuilder sb = new StringBuilder();
    for (int val : a) {
      sb.append(val + " ");
    }
    System.out.println(sb);
  }

  public static int[] inverse(int[] a) {
    int[] inv = new int[a.length];
    for (int i = 0; i < a.length; i++) {
      int val = a[i];
      inv[val] = i;
    }
    return inv;
  }

  public static void main(String[] args) throws Exception {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

    int n = Integer.parseInt(br.readLine());
    int[] a = new int[n];
    for (int i = 0; i < n; i++) {
      a[i] = Integer.parseInt(br.readLine());
    }
    int[] inv = inverse(a);
    display(inv);
  }

}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Q . Sub Arrays Of An Array</span>
import java.io.*;
import java.util.*;
public class Main {
  public static void main(String[] args) throws Exception {
    Scanner scn = new Scanner(System.in);
    int n = scn.nextInt;

    int[] arr = new int[n];
    for (int i = 0; i < n; i++) {
      arr[i] = scn.nextInt;
    }

    for (int i = 0; i < arr.length; i++) {
      for (int j = i; j < arr.length; j++) {
        for (int k = i; k <= j; k++) {
          System.out.print(arr[k] + "	");
        }
        System.out.println();
      }
    }
  }

}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Binary Search</span>
import java.io.*;
import java.util.*;
public class Main {
  public static void main(String[] args) {
    int[]arr = {10, 20, 30, 40, 50, 60, 70, 80, 90, 100};
    int data = 70;
    int l = 0;
    int h = arr.length - 1;

    while (l <= h) {
      int m = (l + h) / 2;
      if (data > arr[m]) {
        l = m + 1;
      } else if (data < arr[m]) {
        h = m - 1;
      } else {
        System.out.println(m);
        return;
      }
    }
    System.out.println(-1);
  }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Broken Economy</span>
import java.util.*;
import java.io.*;
public class Main {
  public static void main (String[]args) {
    Scanner scn = new Scanner (System.in);
    int n = scn.nextInt ();
    int[] arr = new int[n];
    for (int i = 0; i < n; i++) {
      arr[i] = scn.nextInt ();
    }
  }
    int low = 0;
    int high = arr.length - 1;
    int data = scn.nextInt ();
    int ceil = Integer.MAX_VALUE;
    int floor = Integer.MIN_VALUE;
    while (low <= high) {
      int mid = (low + high) / 2;
      if (data < arr[mid]) {
        high = mid - 1;
        ceil = arr[mid];
    }
      else if (data > arr[mid]) {
        low = mid + 1;
        floor = arr[mid];
    } else {
        ceil = floor = arr[mid];
        break;
    }

  }
    System.out.println (ceil);
    System.out.println (floor);
  }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">First And Last Index</span>
import java.io.*;
import java.util.*;
public class Main {
  public static void main(String[] args) throws Exception {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    int n = Integer.parseInt(br.readLine());
    int[] arr = new int[n];
    for (int i = 0; i < n; i++) {
      arr[i] = Integer.parseInt(br.readLine());
    }
    int data = Integer.parseInt(br.readLine());

    int left = 0;
    int right = arr.length - 1;
    int fi = -1; // First index = fi

    while (left <= right) {
      int mid = (left + right) / 2;
      if (data > arr[mid]) {
        left = mid + 1;
      } else if (data < arr[mid]) {
        right = mid - 1;
      } else  {
        fi = mid;
        right = mid - 1;
      }
    }

    left = 0;
    right = arr.length - 1;
    int li = -1; // last index = li
    while (left <= right) {
      int mid = (left + right) / 2;
      if (data > arr[mid]) {
        left = mid + 1;
      } else if (data < arr[mid]) {
        right = mid - 1;
      } else  {
        li = mid;
        left = mid + 1;
      }
    }

    System.out.println(fi);
    System.out.println(li);
  }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Subsets of Array</span>
import java.io.*;
import java.util.*;
public class Main{
  public static void main (String[]args) throws Exception{
    Scanner scn = new Scanner (System.in);
    int n = scn.nextInt ();
    int[] arr = new int[n];
    for (int i = 0; i < arr.length; i++){
      arr[i] = scn.nextInt ();
    }
    int limit = (int) Math.pow (2, arr.length); //calculating the number of subsets
    for (int i = 0; i < limit; i++){
      //convert i to binary and use 0's and 1's
      //to check if an array's element is to be printed or not
      String set = "";
      // we make use of set to print in required order
      int temp = i;
      // we store i because we need to use value
      // of i without manipulating the actual i
      // as i is the outer loop iterator
      for (int j = arr.length - 1; j > = 0; --j){
        //calculating the binary, extracting //
        // the remainder one and by one
        // and putting required element
        // in the String to be printed.
        int rem = temp % 2;
        temp = temp / 2;
        if (rem == 0)   //nothing to be printed
        {
          set = "-    " + set;
        }
        else
        {
          // we print the element, so we add it to our answer string
          set = arr[j] + "    " + set;
        }
      }
      System.out.println (set);
      // printing the required pattern line-by-line
    }
  }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Matrix Multiplication</span>
import java.io.*;
import java.util.*;
public class matrixMultiply {
  public static void main(String[] args) throws Exception {
    Scanner scn = new Scanner(System.in);
    int n1 = scn.nextInt();
    int m1 = scn.nextInt();
    int[][] arr1 = new int[n1][m1];
    for (int i = 0; i < n1; i++) {                      //1
      for (int j = 0; j < m1; j++) {
        arr1[i][j] = scn.nextInt();
      }
    }
    int n2 = scn.nextInt();
    int m2 = scn.nextInt();
    int[][] arr2 = new int[n2][m2];
    for (int i = 0; i < n2; i++) {                      //2
      for (int j = 0; j < m2; j++) {
        arr2[i][j] = scn.nextInt();
      }
    }

    if (m1 != n2) {
      System.out.print("Invalid input");              //3
      return;
    }
    int[][] ans = new int[n1][m2];
    for (int i = 0; i < n1; i++) {
      for (int j = 0; j < m2; j++) {                  //4
        for (int k = 0; k < m1; k++) {
          ans[i][j] += (arr1[i][k] * arr2[k][j]);
        }
      }
    }
    for (int i = 0; i < n1; i++) {
      for (int j = 0; j < m2; j++) {
        System.out.print(ans[i][j] + " ");          //5
      }
      System.out.println();
    }
  }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">The State Of Wakanda -1</span>
import java.io.*;
import java.util.*;
public class state of wakanda {
  public static void main(String[] args) throws Exception {
    Scanner scn = new Scanner(System.in);
    int n = scn.nextInt();
    int m = scn.nextInt();
    int[][] arr = new int[n][m];
    for (int i = 0; i < arr.length; i++) {
      for (int j = 0; j < arr[0].length; j++) {
        arr[i][j] = scn.nextInt();
      }
    }

    for (int j = 0; j < arr[0].length; j++) {
      if (j % 2 == 0) {
        for (int i = 0; i < arr.length; i++)
          System.out.println(arr[i][j]);
      } else {
        for (int i = arr.length - 1; i >= 0; i--)
          System.out.println(arr[i][j]);
      }
    }
  }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Spiral Display</span>
import java.io.*;
import java.util.*;
public class state of Spiral {
  public static void main(String[] args) throws Exception {
    Scanner scn = new Scanner(System.in);
    int n = scn.nextInt();
    int m = scn.nextInt();
    int[][] arr = new int[n][m];
    for (int i = 0; i < arr.length; i++) {
      for (int j = 0; j < arr[0].length; j++) {
        arr[i][j] = scn.nextInt();
      }
    }

    int minrow = 0;
    int mincol = 0;
    int maxrow = arr.length - 1;
    int maxcol = arr[0].length - 1;


    int tne = n * m;     //total numbers of elements
    int count = 0;

    while (count < tne) {
      //left wall
      if (count < tne) {
        for (int i = minrow; i <= maxrow; i++) {
          System.out.println(arr[i][mincol]);
          count++;
        }
      }
      mincol++;

      //bottom wall
      if (count < tne) {
        for (int i = mincol; i <= maxcol; i++) {
          System.out.println(arr[maxrow][i]);
          count++;
        }
      }
      maxrow--;

      //right wall
      if (count < tne) {
        for (int i = maxrow; i >= minrow; i--) {
          System.out.println(arr[i][maxcol]);
          count++;
        }
      }
      maxcol--;

      //top wall
      if (count < tne) {
        for (int i = maxcol; i >= mincol; i--) {
          System.out.println(arr[minrow][i]);
          count++;
        }
      }
      minrow++;
    }
  }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Exit Point of a Matrix</span>
import java.io.*;
import java.util.*;
public class Main {
  public static void main(String[] args) throws Exception {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    int n = Integer.parseInt(br.readLine());
    int m = Integer.parseInt(br.readLine());
    int[][] arr = new int[n][m];

    for (int i = 0; i < n; i++) {
      for (int j = 0; j < m; j++) {
        arr[i][j] = Integer.parseInt(br.readLine());
      }
    }

    int i = 0;
    int j = 0;
    int dir = 0;   //East->0 South->1 West->2 North->3
    while (true) {
      dir = (dir + arr[i][j]) % 4; //To Keep the values between 0 and 3
      if (dir == 0) {
        j++;  //Move in the same row (east direction)
      } else if (dir == 1) {
        i++;  //Move down the column (south direction)
      } else if (dir == 2) {
        j--;  //Move backwards in the row (west direction)
      } else if (dir == 3) {
        i--;  //Move up the column (north direction)
      }

      if (i < 0) {
        i++;  //exit point is one row head (in 0th row)
        break;
      } else if (j < 0) {
        j++;   //exit point is one col ahead (in 0th col)
        break;
      } else if (i == n) {
        i--;  //exit point is one row back (in last row)
        break;
      } else if (j == m) {
        j--;  //exit point is one col back (in last col)
        break;
      }
    }

    System.out.println(i);
    System.out.println(j);
  }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Rotate By 90 Degrees</span>
import java.io.*;
import java.util.*;
public class Main {
  public static void main(String[] args) throws Exception {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    int n = Integer.parseInt(br.readLine());
    int[][] arr = new int[n][n];

    for (int i = 0; i < n; i++) {
      for (int j = 0; j < n; j++) {
        arr[i][j] = Integer.parseInt(br.readLine());
      }
    }

    rotateby90(arr);
    display(arr);
  }

  public static void rotateby90(int[][] arr) {
    // transpose
    for (int i = 0; i < arr.length; i++) {
      for (int j = 0; j < i; j++) {
        int temp = arr[i][j];
        arr[i][j] = arr[j][i];
        arr[j][i] = temp;
      }
    }
    // reverse columns, row by row
    for (int i = 0; i < arr.length; i++) {
      int li = 0;
      int ri = arr[0].length - 1;
      while (li <= ri) {
        int temp = arr[i][li];
        arr[i][li] = arr[i][ri];
        arr[i][ri] = temp;

        li++;
        ri--;
      }
    }
  }
  public static void display(int[][] arr) {
    for (int i = 0; i < arr.length; i++) {
      for (int j = 0; j < arr[0].length; j++) {
        System.out.print(arr[i][j] + " ");
      }
      System.out.println();
    }
  }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Ring Rotate</span>
import java.io.*;
import java.util.*;
public class Main {
  public static void main(String[] args) throws Exception {
    Scanner scn = new Scanner(System.in);
    int n = scn.nextInt();
    int m = scn.nextInt();

    int[][] arr = new int[n][m];
    for (int i = 0; i < n; i++) {
      for (int j = 0; j < m; j++) {
        arr[i][j] = scn.nextInt();
      }
    }

    int s = scn.nextInt();
    int r = scn.nextInt();

    rotateShell(arr, s, r);
    display(arr);
  }

  public static void rotateShell(int[][] arr, int s, int r) {
    int[] oned = fillOnedFromShell(arr, s);
    rotate(oned, r);
    fillShellFromOned(arr, s, oned);
  }

  public static void rotate(int[] oned, int r) {
    r = r % oned.length;
    if (r < 0) {
      r += oned.length;
    }

    reverse(oned, 0, oned.length - r - 1);
    reverse(oned, oned.length - r, oned.length - 1);
    reverse(oned, 0, oned.length - 1);
  }

  public static void reverse(int[] arr, int i, int j) {
    while (i < j) {
      int temp = arr[i];
      arr[i] = arr[j];
      arr[j] = temp;
      i++;
      j--;
    }
  }

  public static int[] fillOnedFromShell(int[][] arr, int s) {
    int minr = s - 1;
    int minc = s - 1;
    int maxr = arr.length - s;
    int maxc = arr[0].length - s;
    int size = 2 * (maxr - minr) + 2 * (maxc - minc);
    int[] oned = new int[size];

    int index = 0;
    for (int i = minr, j = minc; i <= maxr; i++) {
      oned[index] = arr[i][j];
      index++;
    }

    for (int i = maxr, j = minc + 1; j <= maxc; j++) {
      oned[index] = arr[i][j];
      index++;
    }

    for (int i = maxr - 1, j = maxc; i >= minr; i--) {
      oned[index] = arr[i][j];
      index++;
    }

    for (int i = minr, j = maxc - 1; j > minc; j--) {
      oned[index] = arr[i][j];
      index++;
    }

    return oned;
  }

  public static void fillShellFromOned(int[][] arr, int s, int[] oned) {
    int minr = s - 1;
    int minc = s - 1;
    int maxr = arr.length - s;
    int maxc = arr[0].length - s;

    int index = 0;
    for (int i = minr, j = minc; i <= maxr; i++) {
      arr[i][j] = oned[index];
      index++;
    }

    for (int i = maxr, j = minc + 1; j <= maxc; j++) {
      arr[i][j] = oned[index];
      index++;
    }

    for (int i = maxr - 1, j = maxc; i >= minr; i--) {
      arr[i][j] = oned[index];
      index++;
    }

    for (int i = minr, j = maxc - 1; j > minc; j--) {
      arr[i][j] = oned[index];
      index++;
    }
  }

  public static void display(int[][] arr) {
    for (int i = 0; i < arr.length; i++) {
      for (int j = 0; j < arr[0].length; j++) {
        System.out.print(arr[i][j] + " ");
      }
      System.out.println();
    }
  }

}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">The State of Wakanda - 2</span>
import java.io.*;
import java.util.*;
public class Main {
  public static void main(String[] args) throws Exception {
    Scanner scn = new Scanner(System.in);
    int n = scn.nextInt();
    int[][] arr = new int[n][n];
    for (int i = 0; i < n; i++) {
      for (int j = 0; j < n; j++) {
        arr[i][j] = scn.nextInt();
      }
    }

    for (int gap = 0; gap < n; gap++) {
      for (int i = 0, j = gap; j < n; i++, j++) {
        System.out.println(arr[i][j]);
      }
    }
  }

}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Saddle Price</span>
import java.util.*;
public class Main {
  public static void main(String[] args) throws Exception {
    Scanner scn = new Scanner(System.in);
    int n = scn.nextInt();
    int[][] arr = new int[n][n];
    for (int i = 0; i < n; i++) {
      for (int j = 0; j < n; j++) {
        arr[i][j] = scn.nextInt();
      }
    }
    int colno = 0, min = 0;
    for (int i = 0; i < n; i++) {   // rows
      min = arr[i][0];
      for (int j = 0; j < n; j++) {   // columns
        if (min > arr[i][j]) {
          min = arr[i][j];
          colno = j;
        }
      }
      boolean potentialAns = true;
      for (int r = 0; r < n; r++) {
        if (min < arr[r][colno]) {
          potentialAns = false;
          break;
        }
      }
      if (potentialAns == true) {
        System.out.print(min);
        return;
      }
    }
    System.out.print("Invalid Input");
  }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Search in a 2D sorted array</span>
import java.util.*;


public class Main {

  public static void main(String[] args) throws Exception {
    Scanner scn = new Scanner(System.in);
    int n = scn.nextInt();
    int[][] arr = new int[n][n];
    for (int i = 0; i < n; i++) {
      for (int j = 0; j < n; j++) {
        arr[i][j] = scn.nextInt();
      }
    }
    int data = scn.nextInt();

    int row = 0;
    int col = n - 1;
    while (row < n && col >= 0) {
      if (arr[row][col] == data) {
        System.out.println(row);
        System.out.println(col);
        return;
      }
      if (arr[row][col] > data) {
        col--;
      } else {
        row++;
      }
    }
    System.out.print("Not Found");
  }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Print All Palindromic Substrings</span>
import java.io.*;

import java.util.*;

public class Main {

  public static void solution(String str) {
    for (int i = 0 ; i < str.length(); i++) {
      for (int j = i + 1; j <= str.length(); j++) {
        // i -> starting point of substring, j-> ending point of substring
        if (isPalindrome(str.substring(i, j))) {
          System.out.println(str.substring(i, j));
        }
      }
    }
  }

  public static boolean isPalindrome(String str) {
    int i = 0, j = str.length() - 1;
    while (i < j) {
      if (str.charAt(i) != str.charAt(j)) {
        return false;
      }
      i++;
      j--;
    }
    return true;
  }
  public static void main(String[] args) {
    Scanner scn = new Scanner(System.in);
    String str = scn.next();
    solution(str);
  }

}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">String Compression</span>
import java.io.*;

import java.util.*;

public class Main {

  public static String compression1(String s) {
    String ans = "";
    for (int i = 0 ; i < s.length(); i++) {
      while (i < s.length() - 1 && s.charAt(i) == s.charAt(i + 1)) {
        i++;
      }
      ans += s.charAt(i);
    }
    return ans;
  }

  public static String compression2(String s) {
    String ans = "";
    for (int i = 0 ; i < s.length(); i++) {
      int count = 1;
      while (i < s.length() - 1
             && s.charAt(i) == s.charAt(i + 1)) {
        count++;
        i++;
      }
      ans += s.charAt(i);
      if (count > 1) {
        ans += count;
      }
    }
    return ans;
  }
  public static void main(String[] args) {
    Scanner scn = new Scanner(System.in);
    String s = scn.next();
    System.out.println(compression1(s));
    System.out.println(compression2(s));
  }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Toggle Case</span>
import java.util.*;


public class Main {

  public static String toggleCase(String str) {
    StringBuilder sb = new StringBuilder(str);
    for (int i = 0 ; i < sb.length() ; i++) {
      char ch = sb.charAt(i);
      if (ch >= 'A' && ch <= 'Z') {
        // convert to lowerCase
        char lc = ( char ) ( ch - 'A' + 'a' );
        sb.setCharAt(i, lc);
      }
      else if (ch >= 'a' && ch <= 'z') {
        // convert to UpperCase
        char uc = (char) (ch - 'a' + 'A');
        sb.setCharAt(i, uc);
      }
    }
    return sb.toString();
  }

  public static void main(String[] args) {
    Scanner scn = new Scanner(System.in);
    String str = scn.next();
    System.out.println(toggleCase(str));
  }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Print All Permutations Of A String Iteratively</span>
import java.io.*;

import java.util.*;

public class Main {

  public static void solution(String str) {
    int len = str.length();
    int total = factorial(len);

    for (int number = 0; number < total; number++) {
      StringBuilder sb = new StringBuilder(str);
      int temp = number;

      for (int divisor = len; divisor >= 1; divisor--) {
        int q = temp / divisor;
        int r = temp % divisor;

        System.out.print(sb.charAt(r));
        sb.deleteCharAt(r);
        temp = q;
      }
      System.out.println();
    }
  }

  public static int factorial(int n) {
    int fact = 1;
    for (int i = 2; i <= n; i++) {
      fact *= i;
    }
    return fact;
  }

  public static void main(String[] args) {
    Scanner scn = new Scanner(System.in);
    String str = scn.next();

    solution(str);
    scn.close();
  }

}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">String With Difference Of Every Two Consecutive Characters</span>
import java.io.*;

import java.util.*;

public class Main {
  public static String solution(String str) {
    StringBuilder sb = new StringBuilder();
    sb.append(str.charAt(0));

    for (int i = 1; i < str.length(); i++) {
      char curr = str.charAt(i);
      char prev = str.charAt(i - 1);

      int gap = curr - prev;

      sb.append(gap);
      sb.append(curr);
    }
    return sb.toString();
  }
  public static void main(String[] args) {
    Scanner scn = new Scanner(System.in);
    String str = scn.next();
    System.out.println(solution(str));
  }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Remove All Primes</span>
import java.io.*;

import java.util.*;

public class Main {

  public static void solution(ArrayList< Integer> al) {
    for (int i = a1.size(); i >= 0; i--) {
      if (isPrime(al.get(i))) {
        al.remove(i);
      }
    }
  }

  public static boolean isPrime(int n) {
    for (int i = 2; i * i <= n; i++) {
      if (n % i == 0) {
        return false;
      }
    }
    return true;
  }
  public static void main(String[] args) {
    Scanner scn = new Scanner(System.in);
    int n = scn.nextInt();
    ArrayList< Integer> al = new ArrayList< >();
    for (int i = 0 ; i < n; i++) {
      al.add(scn.nextInt());
    }
    solution(al);
    System.out.println(al);
  }

}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Print Decreasing</span>
import java.io.*;

import java.util.*;

public class Main {

  public static void main(String[] args) throws Exception {
    Scanner sc = new Scanner(System.in);
    int n = scn.nextInt();
    printDecreasing(n);
  }

  public static void printDecreasing(int n) {
    //Base case
    if (n == 0)
      return;

    //Self Work
    System.out.println(n);

    //Recursive call
    printDecreasing(n - 1);
  }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Print Increasing</span>
import java.io.*;

import java.util.*;

public class Main {

  public static void main(String[] args) throws Exception {
    Scanner scn = new Scanner(System.in);
    int n = scn.nextInt();
    printDecreasing(n);
  }

  public static void printIncreasing(int n) {
    if (n == 0) //Base case
      return;
    printDecreasing(n - 1);//Recursive call
    System.out.println(n);//Self Work

  }

}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">PRINT INCREASING DECREASING</span>
import java.io.*;

import java.util.*;

public class Main {

  public static void main(String[] args) throws Exception {
    Scanner scn = new Scanner(System.in);
    int n = scn.nextInt();
    pdi(n);
  }

  public static void pdi(int n) {

    if (n == 0) {                 //1
      return;
    }
    System.out.println(n);        //2
    pdi(n - 1);                   //3
    System.out.println(n);        //4
  }

}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Factorial</span>
import java.io.*;

import java.util.*;

public class Main {

  public static void main(String[] args) throws Exception {
    Scanner scn = new Scanner(System.in);
    int n = scn.nextInt();
    int f = factorial(n);
    System.out.println(f);
  }

  public static int factorial(int n) {
    if (n == 1) { //1
      return 1;
    }

    int fnm1 = factorial(n - 1); //2
    int fn = n * fnm1;  //3
    return fn;  //4
  }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Power Function</span>
import java.io.*;

import java.util.*;

public class Main {

  public static void main(String[] args) throws Exception {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    int x = Integer.parseInt(br.readLine());
    int n = Integer.parseInt(br.readLine());
    int p = power(x, n);
    System.out.println(p);
  }

  public static int power(int x, int n) {
    if (n == 0) {
      return 1;
    }
    int xpnm1 = power(x, n - 1);
    int xpn = xpnm1 * x;
    return xpn;
  }

}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Print Zigzag</span>
import java.util.*;

public class zigzag {
  public static void main(String[] args) throws Exception {
    Scanner scn = new Scanner(System.in);
    int n = scn.nextInt();
    scn.close();
    pzz(n);
  }

  public static void pzz(int n) {
    if (n == 0)
      return;
    System.out.print(n + " ");
    pzz(n - 1);
    System.out.print(n + " ");
    pzz(n - 1);
    System.out.print(n + " ");
  }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Tower Of Hanoi</span>
import java.util.*;

public class Main
{
  public static void toh(int n, int t1, int t2, int t3)
  {
    if (n == 0)
      return;
    toh(n - 1, t1, t3, t2);
    System.out.println(n + "[" + t1 + " -> " + t2 + "]");
    toh(n - 1, t3, t2, t1);
  }
  public static void main(String[] args) throws Exception
  {
    Scanner scn = new Scanner(System.in);
    int n = scn.nextInt();
    int t1 = scn.nextInt();
    int t2 = scn.nextInt();
    int t3 = scn.nextInt();
    toh(n, t1, t2, t3);
  }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Display Array</span>
import java.io.*;

import java.util.*;

public class Main {

  public static void main(String[] args) throws Exception {
    Scanner scn = new Scanner(System.in);

    int n = scn.nextInt();
    int[] arr = new int[n];

    for (int i = 0; i < n; i++) {
      arr[i] = scn.nextInt();
    }

    displayArr(arr, 0);

  }

  public static void displayArr(int[] arr, int idx) {
    if (idx == arr.length) return;

    System.out.println(arr[idx]);
    displayArr(arr, idx + 1);
  }

}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Display Array Reverse</span></n>
import java.io.*;

import java.util.*;

public class Main {

  public static void main(String[] args) throws Exception {
    Scanner scn = new Scanner(System.in);

    int n = scn.nextInt();
    int[] arr = new int[n];

    for (int i = 0; i < n; i++) {
      arr[i] = scn.nextInt();
    }

    displayArrRev(arr, 0);

  }

  public static void displayArrRev(int[] arr, int idx) {
    if (idx == arr.length) return;
    displayArrRev(arr, idx + 1);
    System.out.println(arr[idx]);
  }

}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Max of an Array</span></n>
import java.io.*;

import java.util.*;

public class Main {

  public static void main(String[] args) throws Exception {

    Scanner scn = new Scanner(System.in);
    int n = scn.nextInt();

    int []a = new int[n];

    for (int i = 0; i < n; i++)
    {
      a[i] = scn.nextInt();
    }
    int max = maxOfArray(a, 0);
    System.out.println(max);

  }

  public static int maxOfArray(int[] arr, int idx) {

    if (idx >= arr.length)
    {
      return Integer.MIN_VALUE;  
      //we have the constraint that the size of array will not be zero 
      //hence we have not considered that case here
    }

    int misa = maxOfArray(arr, idx + 1); //misa stands for maximum in smaller array

    if (arr[idx] > misa)
    {
      return arr[idx];
    }
    return misa;

  }

}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">First Index Of Occurrence</span>
import java.io.*;

import java.util.*;

public class Main {

  public static void main(String[] args) throws Exception {
    Scanner scn = new Scanner(System.in);
    int n = scn.nextInt();
    int[] arr = new int[n];

    for (int i = 0; i < n; i++) {
      arr[i] = scn.nextInt();
    }
    int x = scn.nextInt();
    int fi = firstIndex(arr, 0, x);
    System.out.println(fi);
  }

  public static int firstIndex(int[] arr, int idx, int x) {

    if (idx == arr.length)
    {
      return -1;
    }


    if (arr[idx] == x)
    {
      return idx;
    }

    int fiisa = firstIndex(arr, idx + 1, x);

    return fiisa;
  }

}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Last Index</span></n>
import java.io.*;

import java.util.*;

public class Main {

  public static void main(String[] args) throws Exception {
    Scanner scn = new Scanner(System.in);
    int n = scn.nextInt();
    int[] arr = new int[n];
    for (int i = 0; i < n; i++) {
      arr[i] = scn.nextInt();
    }
    int x = scn.nextInt();
    ` int li = lastIndex(arr, 0, x);
    `System.out.println(li);
  }

  public static int lastIndex(int[] arr, int idx, int x) {
    if (idx == arr.length) {
      return -1;
    }

    int liisa = lastIndex(arr, idx + 1, x);
    if (liisa == -1) {
      if (arr[idx] == x) {
        return idx;
      } else {
        return -1;
      }
      else {
        return liisa;
      }
    }
  }
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">All Indices In An Array</span></n>
import java.io.*;

import java.util.*;

public class Main {

  public static void main(String[] args) throws Exception {
    Scanner scn = new Scanner(System.in);
    int n =

    int[] arr = new int[n];

    for (int i = 0; i < n; i++) {
      arr[i] = scn.nextInt();
    }
    int x = scn.nextInt();
    int[] iarr = allIndices(arr, x, 0, 0);

    if (iarr.length == 0) {
      System.out.println();
      return;
    }

    for (int i = 0; i < iarr.length; i++) {
      System.out.println(iarr[i]);
    }
  }

  public static int[] allIndices(int[] arr, int x, int idx, int fsf) {
    if (idx == arr.length) {
      return new int[fsf];
    }

    int[] iarr;

    if (arr[idx] == x) {
      iarr = allIndices(arr, x, idx + 1, fsf + 1);
      iarr[fsf] = idx;
    } else {
      iarr = allIndices(arr, x, idx + 1, fsf);
    }

    return iarr;
  }

}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Get Subsequence</span>
import java.io.*;

import java.util.*;

public class Main {

  public static void main(String[] args) throws Exception {
    Scanner scn = new Scanner(System.in);
    String str = scn.next();
    ArrayList< String> res = gss(str);
    System.out.println(res);
  }

  //bc ->  [ --,-c ,b-, bc ]
  //abc->  [ ---,--c, -b-, -bc, a--,ab-,abc]

  public static ArrayList< String> gss(String str) {
    if (str.length() == 0) {
      ArrayList< String> bres = new ArrayList< >();           //1
      bres.add("");
      return base;
    }
    char ch = str.charAt(0);                                      //2
    String ros = str.substring(1);                                //3

    ArrayList< String> rres = gss(ros);                            //4
    ArrayList< String> mres = new ArrayList< >();                   //5
    for (String val : rres) {
      mres.add("" + val);                                       //6
    }
    for (String val : rres) {
      mres.add(ch + val);                                       //7
    }

    return mres;                                                  //8
  }

}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Get Kpc</span>
import java.io.*;

import java.util.*;

public class Main {

  public static void main(String[] args) throws Exception {
    Scanner scn = new Scanner(System.in);
    String str = scn.next();
    ArrayList< String> words = getKPC(str);
    System.out.println(words);
  }
  static String[] codes = {".;", "abc", "def", "ghi", "jkl", "mno", "pqrs", "tu", "vwx",
                           "yz"
                          };                                                        //#

  public static ArrayList< String> getKPC(String str) {
    if (str.length() == 0) {                                  //1
      ArrayList< String>bres = new ArrayList< >();
      bres.add("");
      return bres;
    }

    char ch = str.charAt(0);                                      //2
    String ros = str.substring(1);                                //3
    ArrayList< String>rres = getKPC(bc);                           //4
    ArrayList< String> mres = new ArrayList< >();

    String codeforch = codes[ch - "0"];                           //5

    for (int i = 0; i < codeforch.length(); i++) {
      char chcode = codeforch.charAt(i);
      for (String val : rres) {                                   //6
        mres.add(chcode + val);
      }
    }
    return mres;                                                  //7
  }

}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Get Stair Paths</span>
import java.io.*;

import java.util.*;

public class Main {

  public static void main(String[] args) throws Exception {
    Scanner scn = new Scanner(System.in);
    int n = scn.nextInt();
    ArrayList< String> paths = getStairPaths(n);
    System.out.println(paths);
  }

  public static ArrayList< String> getStairPaths(int n) {
    if (n == 0) {                                      //1.1
      ArrayList< String> bres = new ArrayList< >();
      bres.add("");
      return bres;
    } else if (n < 0) {
      ArrayList< String> bres = new ArrayList< >();         //1.2
      return bres;
    }

    ArrayList< String> path1 = getStairPaths(n - 1);         //2.1
    ArrayList< String> path2 = getStairPaths(n - 2);         //2.2
    ArrayList< String> path3 = getStairPaths(n - 3);         //2.3

    ArrayList< String> paths = new ArrayList< >();            //3

    for (String path : paths1) {
      paths.add("1" + path);                               //4.1
    }
    for (String path : path2) {
      paths.add("2" + path);                               //4.2
    }
    for (String path : path3) {
      paths.add("3" + path);                               //4.3
    }
    return paths;                                           //5

  }

}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Get Maze Paths</span>
import java.io.*;

import java.util.*;

public class Main {

  public static void main(String[] args) throws Exception {
    Scanner scn = new Scanner(System.in);
    int n = scn.nextInt();
    int m = scn.nextInt();
    ArrayList< String> paths = getMazePaths(1, 1, n, m);
    System.out.println(paths);
  }

  // sr - source row
  // sc - source column
  // dr - destination row
  // dc - destination column
  public static ArrayList< String> getMazePaths(int sr, int sc, int dr, int dc) {
    if (sr == dr && sc == dc) {                              //1
      ArrayList< String> bres = new ArrayList< >();
      bres.add("");
      return bres;
    }
    ArrayList< String> hpaths = new ArrayList< >();           //2.1
    ArrayList< String> vpaths = new ArrayList< >();           //2.2

    if (sc < dc) {
      hpaths = getMazePaths(sr, sc + 1, dr, dc);          //3.1
    }
    if (sr < dr) {
      vpaths = getMazePaths(sr + 1, sc, dr, dc);          //3.2
    }

    ArrayList< String> paths = new ArrayList< >();             //4

    for (String hpath : hpaths) {
      paths.add("h" + hpath);                              //5.1
    }

    for (String vpath : vpaths) {
      paths.add("v" + vpath);                              //5.2
    }
    return paths;                                            //6
  }

}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Get Maze Path With Jumps</span>
import java.io.*;

import java.util.*;

public class Main {

  public static void main(String[] args) throws Exception {

    Scanner scn = new Scanner(System.in);
    int n = scn.nextInt();
    int m = scn.nextInt();

    ArrayList< String> paths = getMazePaths(1, 1, n, m);

    System.out.println(paths);
  }

  // sr - source row
  // sc - source column
  // dr - destination row
  // dc - destination column
  public static ArrayList< String> getMazePaths(int sr, int sc, int dr, int dc) {

    if (sr == dr && sc == dc)
    {
      ArrayList< String> bres = new ArrayList< >();
      bres.add("");
      return bres;
    }
    else if (sr > dr || sc > dc)
    {
      ArrayList< String> bres = new ArrayList< >();
      return bres;
    }

    ArrayList< String> paths = new ArrayList< >();
    for (int hms = 1; hms <= dc - sc; hms++)
    {
      ArrayList< String> hpaths = getMazePaths(sr, sc + hms, dr, dc);

      for (String hpath : hpaths)
      {
        paths.add("h" + hms + hpath);
      }
    }

    for (int vms = 1; vms <= dr - sr; vms++)
    {
      ArrayList< String> vpaths = getMazePaths(sr + vms, sc, dr, dc);

      for (String vpath : vpaths) {
        paths.add("v" + vms + vpath);
      }
    }

    for (int dms = 1; dms <= dr - sr && dms <= dc - sc; dms++)
    {
      ArrayList< String> dpaths = getMazePaths(sr + dms, sc + dms, dr, dc);

      for (String dpath : dpaths)    {
        paths.add("d" + dms + dpath);
      }
    }
    return paths;
  }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Print Subsequence</span>
import java.io.*;

import java.util.*;

public class Main {

  public static void main(String[] args) throws Exception {
    Scanner scn = new Scanner(System.in);
    String str = scn.next();
    printSS(str, "");                                            //1
  }

  public static void printSS(String ques, String ans) {
    if (ques.length() == 0) {                                  //2
      System.out.println(ans);
      return;
    }

    char ch = ques.charAt(0);                                   //3
    String roq = ques.substring(1);                             //4
    printSS(bc, ans + ch);                                      //5
    printSS(bc, ans + "");                                      //6
  }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">PRINT KPC</span>
import java.io.*;

import java.util.*;

public class Main {

  public static void main(String[] args) throws Exception {
    Scanner scn = new Scanner(System.in);
    String str = scn.next();
    printKPC(str, "");
  }

  static String[] codes = {".;", "abc", "def", "ghi", "jkl", "mno", "pqrs", "tu", "vwx",
                           "yz"
                          };                                                          //1

  public static void printKPC(String ques, String ans) {
    if (ques.length() == 0)                                    //2
    {
      System.out.println(ans);
      return;
    }
    char ch = ques.charAt(0);                                   //3
    String roq = ques.substring(1);                             //4
    String codeforch = codes[ch - "0"];                         //5
    for (int i = 0; i < codeforch.length(); i++)                 //6
    {
      char cho = codeforch.charAt(i);
      printKPC(roq, ans + cho);                                 //7
    }

  }

}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Print Stairs Paths</span>
import java.io.*;

import java.util.*;

public class Main {

  public static void main(String[] args) throws Exception {
    Scanner scn = new Scanner(System.in);
    int t = scn.nextInt();
    printStairPaths(n, "");
  }

  public static void printStairPaths(int n, String psf) {
    if (n <= 0) {
      if (n == 0) {
        System.out.println(psf);
      }

      return;
    }

    printStairPaths(n - 1, psf + 1);
    printStairPaths(n - 2, psf + 2);
    printStairPaths(n - 3, psf + 3);
  }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Print Maze Path</span>
import java.io.*;

import java.util.*;

public class Main {

  public static void main(String[] args) throws Exception {
    Scanner scn = new Scanner(System.in);
    int n = scn.nextInt();
    int m = scn.nextInt();
    printMazePaths(0, 0, n - 1, m - 1, "");
  }

  public static void printMazePaths(int sr, int sc, int dr, int dc, String psf) {
    if (sr > dr || sc > dc) {
      return;
    }

    if (sr == dr && sc == dc) {
      System.out.println(psf);
      return;
    }

    printMazePaths(sr, sc + 1, dr, dc, psf + "h");
    printMazePaths(sr + 1, sc, dr, dc, psf + "v");
  }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Print Maze Path With Jumps</span>
import java.io.*;

import java.util.*;

public class Main {

  public static void main(String[] args) throws Exception {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    int n = Integer.parseInt(br.readLine());
    int m = Integer.parseInt(br.readLine());
    printMazePaths(0, 0, n - 1, m - 1, "");
  }

  public static void printMazePaths(int sr, int sc, int dr, int dc, String psf) {

    if (sr == dr && sc == dc) {
      System.out.println(psf);
      return;
    }

    for (int move = 1; move <= dc - sc; move++) {
      printMazePaths(sr, sc + move, dr, dc, psf + "h" + move);
    }

    for (int move = 1; move <= dr - sr; move++) {
      printMazePaths(sr + move, sc, dr, dc, psf + "v" + move);
    }

    for (int move = 1; move <= dc - sc && move <= dr - sr; move++) {
      printMazePaths(sr + move, sc + move, dr, dc, psf + "d" + move);
    }
  }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Print Permutations</span>
import java.io.*;

import java.util.*;

public class Main {

  public static void main(String[] args) throws Exception {

    Scanner scn = new Scanner(System.in);
    String str = scn.next();

    printPermutations(str, "");

  }

  public static void printPermutations(String str, String asf) {

    if (str.length() == 0)
    {
      System.out.println(asf); //Question string is empty so print the answer now and return
      return ;
    }
    //Extracting each character at a time from the question string and appending it to answer so far
    for (int i = 0; i < str.length(); i++)
    {
      char ch = str.charAt(i);
      String leftPart = str.substring(0, i); //Substring from 0 to i-1 (left to ch)
      String rightPart = str.substring(i + 1); //Substring from i+1 till end of String (right to ch)
      String roq = leftPart + rightPart; //Remaining string after extracting ch
      printPermutations(roq, asf + ch);
    }

  }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Print Encodings</span>
import java.io.*;

import java.util.*;

public class Main {

  public static void main(String[] args) throws Exception {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
      String str = br.readLine();
      printEncodings(str, "");
  }

  public static void printEncodings(String ques, String ans) {
    if (ques.length() == 0) {
      System.out.println(ans);
      return;
    } else if (ques.length() == 1) {
      if (ques.charAt(0) == '0') {
        return;
      } else {
        String ch0 = ques.substring(0, 1);
        String roq0 = ques.substring(1);
        String code0 = (char)('a' +
                              (Integer.parseInt(ch0) - 1)) + "";
        printEncodings(roq0, ans + code0);
      }
    } else {
      if (ques.charAt(0) == '0') {
        return;
      } else {
        String ch0 = ques.substring(0, 1);
        String roq0 = ques.substring(1);
        String code0 = (char)('a' +
                              (Integer.parseInt(ch0) - 1)) + "";
        printEncodings(roq0, ans + code0);

        String ch01 = ques.substring(0, 2);
        String roq01 = ques.substring(2);
        String code01 = (char)('a' +
                               (Integer.parseInt(ch01) - 1)) + "";

        if (Integer.parseInt(ch01) <= 26) {
          printEncodings(roq01, ans + code01);
        }
      }
    }
  }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Flood Fill</span>
import java.io.*;

import java.util.*;

public class Main {
  public static void main(String[] args) throws Exception {
    Scanner scn = new Scanner(System.in);
    int n = scn.nextInt();
    int m = scn.nextInt();
    int[][] arr = new int[n][m];
    for (int i = 0; i < n; i++) {
      for (int j = 0; j < m; j++) {
        arr[i][j] = scn.nextInt();
      }
    }
    floodfill(arr, 0, 0, "");
  }


  // asf -> answer so far
  public static void floodfill(int[][] maze, int sr, int sc, String asf) {
    if (sr < 0 || sc < 0 || sr == maze.length || sc == maze[0].length || maze[sr][sc] == 1) {
      return;         //1
    }
    if (sr == maze.length - 1 && sc == maze[0].length - 1) { //2
      System.out.println(asf);
      return;
    }

    floodfill(maze, sr - 1, sc, asf + "t"); //3
    floodfill(maze, sr, sc - 1, asf + "l"); //4
    floodfill(maze, sr + 1, sc, asf + "d"); //5
    floodfill(maze, sr, sc + 1, asf + "r"); //6

  }
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Target Sum Subsets</span>
import java.io.*;

import java.util.*;

public class Main {

  public static void main(String[] args) throws Exception {
    Scanner scn = new Scanner(System.in);
    int n = scn.nextInt();
    int[]arr = new int[n];
    for (int i = 0; i < n; i++) {
      arr[i] = scn.nextInt();
    }
    int tar = scn.nextInt();
    printTargetSumSubsets(arr, 0, "", 0, tar);      //1

  }

  // set is the subset
  // sos is sum of subset
  // tar is target
  public static void printTargetSumSubsets(int[] arr, int idx, String set, int sos, int tar) {

    if (idx == arr.length) { //2
      if (sos == tar) {
        System.out.println(set + ".");
      }
      return;
    }

    printTargetSumSubsets(arr, idx + 1, set + arr[idx] + ", ", sos + arr[idx], tar); //3
    printTargetSumSubsets(arr, idx + 1, set, sos, tar); //4



  }

}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">N Queens</span>
import java.io.*;

import java.util.*;

public class Main {

  public static void main(String[] args) throws Exception {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    int n = Integer.parseInt(br.readLine());
    int[][] chess = new int[n][n];
    printNQueens(chess, "", 0);
  }

  public static void printNQueens(int[][] chess, String qsf, int row) {
    if (row == chess.length) {
      System.out.println(qsf + ".");
      return;
    }
    for (int col = 0; col < chess.length; col++) {
      if (chess[row][col] == 0
          && isQueenSafe(chess, row, col) == true) {
        chess[row][col] = 1;
        printNQueens(chess,
                     qsf + row + "-" + col + ", ", row + 1);
        chess[row][col] = 0;
      }
    }
  }

  public static boolean isQueenSafe(int[][] chess,
                                    int row, int col) {
    for (int i = row - 1, j = col - 1;
         i >= 0 && j >= 0; i--, j--) {
      if (chess[i][j] == 1) {
        return false;
      }
    }

    for (int i = row - 1, j = col; i >= 0; i--) {
      if (chess[i][j] == 1) {
        return false;
      }
    }

    for (int i = row - 1, j = col + 1; i >= 0
         && j < chess.length; i--, j++) {
      if (chess[i][j] == 1) {
        return false;
      }
    }

    for (int i = row, j = col - 1; j >= 0; j--) {
      if (chess[i][j] == 1) {
        return false;
      }
    }

    return true;
  }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Knight's Tour</span>
import java.io.*;

import java.util.*;

public class Main {

  public static void main(String[] args) throws Exception {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    int n = Integer.parseInt(br.readLine());
    int[][] chess = new int[n][n];
    printNQueens(chess, "", 0);
  }

  public static void printNQueens(int[][] chess, String qsf, int row) {
    if (row == chess.length) {
      System.out.println(qsf + ".");
      return;
    }
    for (int col = 0; col < chess.length; col++) {
      if (chess[row][col] == 0
          && isQueenSafe(chess, row, col) == true) {
        chess[row][col] = 1;
        printNQueens(chess,
                     qsf + row + "-" + col + ", ", row + 1);
        chess[row][col] = 0;
      }
    }
  }

  public static boolean isQueenSafe(int[][] chess,
                                    int row, int col) {
    for (int i = row - 1, j = col - 1;
         i >= 0 && j >= 0; i--, j--) {
      if (chess[i][j] == 1) {
        return false;
      }
    }

    for (int i = row - 1, j = col; i >= 0; i--) {
      if (chess[i][j] == 1) {
        return false;
      }
    }

    for (int i = row - 1, j = col + 1; i >= 0
         && j < chess.length; i--, j++) {
      if (chess[i][j] == 1) {
        return false;
      }
    }

    for (int i = row, j = col - 1; j >= 0; j--) {
      if (chess[i][j] == 1) {
        return false;
      }
    }

    return true;
  }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Dynamic Programming start</span>
Fibonacci (DP)</span>
import java.io.*;

import java.util.*;

public class Main {

  public static void main(String[] args) throws Exception {
    Scanner scn = new Scanner(System.in);
    int n = scn.nextInt();
    int[] qb = new int[n + 1];
    int FibMemoized = FibMemoized(n, qb);

    System.out.println(FibMemoized);

    scn.close();
  }

  public static int FibMemoized(int n, int[] qb) {
    if (n == 0 || n == 1) {
      return n;
    }
    if (qb[n] != 0) {
      return qb[n];
    }
    int fibn1 = FibMemoized(n - 1, qb);
    int fibn2 = FibMemoized(n - 2, qb);
    int fibn = fibn1 + fibn2;

    qb[n] = fibn;

    return fibn;
  }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Climb Stairs</span>
import java.io.*;

import java.util.*;

public class Main {

  public static void main(String[] args) throws Exception {
    Scanner scn = new Scanner(System.in);
    int n = scn.nextInt();
    int[] qb = new int[n + 1];
    int paths = countPaths(n, qb);
    System.out.println(paths);

    scn.close();
  }

  public static int countPaths(int n, int[] qb) {
    if (n == 0) {
      return 1;
    } else if (n < 0) {
      return 0;
    }
    if (qb[n] != 0) {
      return qb[n];
    }
    int p1 = countPaths(n - 1, qb);
    int p2 = countPaths(n - 2, qb);
    int p3 = countPaths(n - 3, qb);

    qb[n] = p1 + p2 + p3;
    return p1 + p2 + p3;
  }
}
<span class="textStyle">Approach :3 (Tabulation)</span>
import java.io.*;

import java.util.*;

public class Main {

  public static void main(String[] args) throws Exception {
    Scanner scn = new Scanner(System.in);
    int n = scn.nextInt();
    int paths = countPathsTab(n);
    System.out.println(paths);

    scn.close();
  }

  public static int countPathsTab(int n) {
    if (n == 0) {
      return 1;
    } else if (n < 0) {
      return 0;
    }
    int[] dp = new int[n + 1];

    dp[0] = 1;
    for (int i = 1; i <= n; i++) {
      dp[i] = dp[i - 1];
      if (i >= 2)
        dp[i] += dp[i - 2];
      if (i >= 3)
        dp[i] += dp[i - 3];
    }

    return dp[n];
  }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Climb Stairs With Variable Jumps</span>

Approach :1 (Recursion)
import java.io.*;

import java.util.*;

public class Main {

  public static void main(String[] args) throws Exception {
    Scanner scn = new Scanner(System.in);
    int n = scn.nextInt();
    int[] arr = new int[n];
    for (int i = 0; i < n; i++) {
      arr[i] = scn.nextInt();
    }
    int paths = countPaths(arr, 0, n);
    System.out.println(paths);
    scn.close();
  }

  public static int countPaths(int[] arr, int index, int len) {
    if (index == len) {
      return 1;
    }
    int count = 0;
    for (int jump = 1; jump <= arr[index]; jump++) {
      if ((jump + index) <= len) {
        count += countPaths(arr, jump + index, len);
      } else {
        break;
      }
    }
    return count;
  }

}

<span class="textStyle">Approach :2 (DP - Tabulation)</span>
import java.io.*;

import java.util.*;

public class Main {

  public static void main(String[] args) throws Exception {
    Scanner scn = new Scanner(System.in);
    int n = scn.nextInt();
    int[] arr = new int[n];
    for (int i = 0; i < n; i++) {
      arr[i] = scn.nextInt();
    }
    int[] dp = new int[n + 1];
    dp[n] = 1;

    for (int i = n - 1; i >= 0; i--) {
      for (int reach = i + 1; reach <= Math.min(n, i + arr[i]); reach++) {
        dp[i] += dp[reach];
      }
    }
    System.out.println(dp[0]);
    scn.close();
  }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Climb Stairs With Minimum Moves</span>
import java.io.*;

import java.io.*;
import java.util.*;

public class Main {

  public static void main(String[] args) throws Exception {
    Scanner scn = new Scanner(System.in);
    int n = scn.nextInt();
    int[] arr = new int[n];
    for (int i = 0; i < n; i++) {
      arr[i] = scn.nextInt();
    }
    Integer[] dp = new Integer[n + 1];
    dp[n] = 0;

    for (int i = n - 1; i >= 0; i--) {
      if (arr[i] == 0)
        continue;
      int min = Integer.MAX_VALUE;
      for (int j = 1; j <= arr[i] && i + j < dp.length; j++) {
        if (dp[i + j] != null) {
          min = Math.min(min, dp[i + j]);
        }
      }
      if (min != Integer.MAX_VALUE)
        dp[i] = min + 1;
    }
    System.out.println(dp[0]);
    scn.close();
  }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Min cost In Maze Traversal</span>
import java.io.*;

import java.util.*;

public class Main {

  public static void main(String[] args) throws Exception {

    Scanner scn = new Scanner(System.in);
    int n = scn.nextInt();
    int m = scn.nextInt();
    int[][]arr = new int[n][m];
    for (int i = 0; i < n; i++) {                  //1
      for (int j = 0; j < m; j++) {
        arr[i][j] = scn.nextInt();
      }
    }

    int[][]dp = new int[n][m];                   //2
    for (int i = n - 1; i >= 0; i--) {           //3
      for (int j = m - 1; j >= 0; j--) {       //4
        if (i == n - 1 && j == m - 1) {      //5
          dp[i][j] = arr[i][j];
        }
        else if (i == n - 1) {          //6
          dp[i][j] = arr[i][j] + dp[i][j + 1];
        }
        else if (j == m - 1) {               //7
          dp[i][j] = arr[i][j] + dp[i + 1][j];
        }
        else {                               //8
          int min = Math.min(dp[i + 1][j], dp[i][j + 1]);
          dp[i][j] = arr[i][j] + min;
        }
      }
    }
    System.out.println(dp[0][0]);                //9



  }

}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Goldmine</span>
import java.io.*;

import java.util.*;

public class Main {

  public static void main(String[] args) throws Exception {

    Scanner scn = new Scanner(System.in);
    int n = scn.nextInt();
    int m = scn.nextInt();
    int[][] arr = new int[n][m];
    for (int i = 0; i < n; i++) {
      for (int j = 0; j < m; j++) {                       //1
        arr[i][j] = scn.nextInt();
      }
    }

    int[][]dp = new int[n][m];                                 //2
    for (int j = m - 1; j >= 0; j--) {                         //3
      for (int i = n - 1; i >= 0; i--) {                     //4

        if (j == m - 1) {
          dp[i][j] = arr[i][j];                          //5
        }
        else if (i == 0) {                                 //6
          dp[i][j] = arr[i][j] + Math.max(dp[i][j + 1], dp[i + 1][j + 1]);
        }
        else if (i == n - 1) {                             //7
          dp[i][j] = arr[i][j] + Math.max(dp[i][j + 1], dp[i - 1][j + 1]);
        }
        else {                                             //8
          dp[i][j] = arr[i][j] + Math.max(dp[i][j + 1], Math.max(dp[i + 1][j + 1],
                                          dp [i - 1][j + 1]));
        }
      }

    }
    int max = dp[0][0];                                        //9
    for (int i = 1; i < n; i++) {
      if (dp[i][0] > max)                                //10
        max = dp[i][0];
    }
    System.out.println(max);                                   //11
  }

}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Target Sum Subsets-DP</span>
import java.io.*;

import java.util.*;

public class Main {

  public static void main(String[] args) throws Exception {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    int n = Integer.parseInt(br.readLine());
    int[] arr = new int[n];

    for (int i = 0; i < n; i++) {
      arr[i] = Integer.parseInt(br.readLine());
    }

    int tar = Integer.parseInt(br.readLine());

    boolean[][] dp = new boolean[arr.length + 1][tar + 1];
    for (int i = 0; i < dp.length; i++) {
      for (int j = 0; j < dp[0].length; j++) {
        if (i == 0 && j == 0) {
          dp[i][j] = true;
        } else if (i == 0) {
          dp[i][j] = false;
        } else if (j == 0) {
          dp[i][j] = true;
        } else {
          if (dp[i - 1][j] == true) {
            dp[i][j] = true;
          } else {
            int val = arr[i - 1];
            if (j >= val
                && dp[i - 1][j - val] == true) {
              dp[i][j] = true;
            }
          }
        }
      }
    }

    System.out.println(dp[dp.length - 1][tar]);
  }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Coin Change - Combinations</span>
import java.io.*;

import java.util.*;

public class Main {

  public static void main(String[] args) throws Exception {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    int n = Integer.parseInt(br.readLine());
    int[] coins = new int[n];

    for (int i = 0; i < n; i++) {
      coins[i] = Integer.parseInt(br.readLine());
    }

    int amt = Integer.parseInt(br.readLine());

    int[] dp = new int[amt + 1];
    dp[0] = 1;

    for (int coin : coins) {
      for (int i = 1; i < dp.length; i++) {
        if (i >= coin) {
          dp[i] += dp[i - coin];
        }
      }
    }
    System.out.println(dp[amt]);
  }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Coin Change - Permutations</span>
import java.io.*;

import java.util.*;

public class Main {

  public static void main(String[] args) throws Exception {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    int n = Integer.parseInt(br.readLine());
    int[] coins = new int[n];

    for (int i = 0; i < n; i++) {
      coins[i] = Integer.parseInt(br.readLine());
    }

    int amt = Integer.parseInt(br.readLine());

    int[] dp = new int[amt + 1];
    dp[0] = 1;

    for (int i = 1; i < dp.length; i++) {
      for (int coin : coins) {
        if (i >= coin) {
          dp[i] += dp[i - coin];
        }
      }
    }

    System.out.println(dp[amt]);
  }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">0-1 Knapsack Problem</span>
import java.io.*;

import java.util.*;

//Backtracking and recursion approach for 0-1 knapsack problem
public class Main {


  static int max(int a, int b)
  {
    return (a > b) ? a : b;
  }

  static int knapSack(int cap, int weight[], int price[], int n)
  {
    // Base Case
    if (n == 0 || cap == 0)
      return 0;

    if (weight[n - 1] > cap)  //if weight of nth item is larger than the capacity then do not include it
      return knapSack(cap, weight, price, n - 1);

    else
      return max(price[n - 1] + knapSack(cap - weight[n - 1], weight, price, n - 1),
       knapSack(cap, weight, price, n - 1));
  }

  public static void main(String args[])
  {
    Scanner scn = new Scanner(System.in);
    int n = scn.nextInt();

    int [] weight = new int[n];
    int [] price = new int[n];

    for (int i = 0; i < n; i++)
    {
      price[i] = scn.nextInt();
    }

    for (int i = 0; i < n; i++)
    {
      weight[i] = scn.nextInt();
    }
    int cap = scn.nextInt();

    int k = knapSack(cap, weight, price, n);
    System.out.println(k);
  }
}
<span class="textStyle">DP</span>
import java.io.*;

import java.util.*;

public class Main {

  public static void main(String[] args) throws Exception {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    int n = Integer.parseInt(br.readLine());

    int[] price = new int[n];
    String str1 = br.readLine();
    for (int i = 0; i < n; i++) {
      price[i] = Integer.parseInt(str1.split(" ")[i]);
    }

    int[] weight = new int[n];
    String str2 = br.readLine();
    for (int i = 0; i < n; i++) {
      weight[i] = Integer.parseInt(str2.split(" ")[i]);
    }

    int cap = Integer.parseInt(br.readLine());

    int[][] dp = new int[n + 1][cap + 1];
    for (int i = 1; i < dp.length; i++) {
      for (int j = 1; j < dp[0].length; j++) {
        int val = price[i - 1];
        int wt = weight[i - 1];

        if (j >= wt) { //If the current capacity is greater than the weight of the current item
          dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - wt] + val); 
          // max cost will be max of cost before putting the item and after putting it
        } else {
          dp[i][j] = dp[i - 1][j]; //If current capacity is less than weight do not add item to the bag
        }
      }
    }

    System.out.println(dp[n][cap]);
  }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Unbounded Knapsack</span>
import java.io.*;

import java.util.*;

public class Main {

  public static void main(String[] args) throws Exception {

    Scanner scn = new Scanner(System.in);
    int n = scn.nextInt();
    int[] values = new int[n];
    int[] wts = new int[n];

    for (int i = 0; i < n; i++)
    {
      values[i] = scn.nextInt();
    }

    for (int i = 0; i < n; i++)
    {
      wts[i] = scn.nextInt();
    }
    int cap = scn.nextInt();
    int[] dp = new int[cap + 1];
    dp[0] = 0;

    for (int bagc = 1; bagc < = cap; bagc++)
    {
      int max = 0;
      for (int i = 0; i < n; i++)
      {

        if (wts[i] < = bagc)
        {
          int rbagc = bagc - wts[i];
          int rbagv = dp[rbagc];
          int tbagv = rbagv + values[i];

          if (tbagv > max)
          {
            max = tbagv;
          }
        }
      }
      dp[bagc] = max;
    }
    System.out.println(dp[cap]);
  }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Count Binary Strings</span>
import java.io.*;

import java.util.*;

public class Main {

  public static void main(String[] args) throws Exception {
    Scanner scn = new Scanner(System.in);
    int n = scn.nextInt();

    int zeroes = 1;
    int ones = 1;
    for (int i = 2; i <= n; i++) {
      int nzeroes = ones;
      int nones = ones + zeroes;

      zeroes = nzeroes;
      ones = nones;
    }

    System.out.println(zeroes + ones);
  }

}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Arrange Buildings</span>
import java.io.*;

import java.util.*;

public class Main {

  public static void main(String[] args) throws Exception {
    Scanner scn = new Scanner(System.in);
    long n = scn.nextInt();

    long ob = 1;
    long os = 1;
    for (int i = 2; i <= n; i++) {
      long nb = os;
      long ns = os + ob;

      ob = nb;
      os = ns;
    }
    int total = ob + os;
    System.out.println(total * total);
  }

}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Count Encodings</span>
import java.io.*;

import java.util.*;

public class Main {
  public static void main(String[] args) throws Exception {
    Scanner scn = new Scanner(System.in);
    String str = scn.next();
    int[] dp = new int[str.length()];

    dp[0] = 1;
    for (int i = 1; i < str.length(); i++) {
      if (str.charAt(i - 1) == '0' && str.charAt(i) == '0') {
        dp[i] = 0;
      } else if (str.charAt(i - 1) == '0' && str.charAt(i) != '0') {
        dp[i] = dp[i - 1];
      } else if (str.charAt(i - 1) != '0' && str.charAt(i) == '0') {
        if (str.charAt(i - 1) == '1' || str.charAt(i - 1) == '2') {
          dp[i] = (i >= 2 ? dp[i - 2] : 1);
        }
      } else {
        dp[i] = dp[i - 1];
        if (Integer.parseInt(str.substring(i - 1, i + 1)) <= 26) {
          dp[i] += (i >= 2 ? dp[i - 2] : 1);
        }
      }
    }
    System.out.println(dp[str.length() - 1]);
    scn.close();
  }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Count A+B+C+ Subsequences</span>
import java.io.*;

import java.util.*;

public class Main {
  public static void main(String[] args) throws Exception {
    Scanner scn = new Scanner(System.in);
    String str = scn.next();
    int a = 0;
    int ab = 0;
    int abc = 0;

    for (int i = 0; i < str.length(); i++) {
      char ch = str.charAt(i);

      if (ch == 'a') {
        a = 2 * a + 1;
      } else if (ch == 'b') {
        ab = 2 * ab + a;
      } else if (ch == 'c') {
        abc = 2 * abc + ab;
      }
    }
    System.out.println(abc);
    scn.close();
  }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Maximum Sum Non Adjacent Elements</span>
import java.io.*;

import java.util.*;

public class Main {

  public static void main(String[] args) throws Exception {
    Scanner scn = new Scanner(System.in);
    int n = scn.nextInt();
    int[]arr = new int[n];
    for (int i = 0; i < n; i++) {
      arr[i] = scn.nextInt();
    }

    int inc = arr[0];                                       //1
    int exc = 0;
    for (int i = 1; i < n; i++) {
      int ninc = exc + arr[i];                            //2
      int nexc = Math.max(inc, exc);
      inc = ninc;                                         //3
      exc = nexc;
    }

    System.out.println(Math.max(inc, exc));                 //4


  }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Paint House</span>
import java.io.*;

import java.util.*;

public class Main {

  public static void main(String[] args) throws Exception {
    Scanner scn = new Scanner(System.in);
    int n = scn.nextInt();
    int[][]arr = new int[n][3];
    for (int i = 0; i < n; i++) {
      for (int j = 0; j < 3; j++) {              //1
        arr[i][j] = scn.nextInt();
      }
    }
    int[][] dp = new int[n][3];                   //2
    dp[0][0] = arr[0][0];
    dp[0][1] = arr[0][1];                         //3
    dp[0][2] = arr[0][2];


    for (int i = 1; i < n; i++) {                  //4
      dp[i][0] = Math.min(dp[i - 1][1], dp[i - 1][2]) + arr[i][0];
      dp[i][1] = Math.min(dp[i - 1][0], dp[i - 1][2]) + arr[i][1];
      dp[i][2] = Math.min(dp[i - 1][1], dp[i - 1][0]) + arr[i][2];
    }
    System.out.println(Math.min(dp[n - 1][0], (Math.min(dp[n - 1][1], dp[n - 1][2]))));
    //5
  }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Paint House-Many Colors</span>
import java.io.*;

import java.util.*;

public class Main {

  public static void main(String[] args) throws Exception {
    Scanner scn = new Scanner(System.in);
    int n = scn.nextInt();
    int k = scn.nextInt();

    int[][] arr = new int[n][k];
    for (int i = 0; i < n; i++) {
      for (int j = 0; j < k; j++) {
        arr[i][j] = scn.nextInt();
      }
    }

    int[][] dp = new int[arr.length][arr[0].length];
    for (int j = 0; j < arr.length[0]; j++) {
      dp[0][j] = arr[0][j];
    }

    for (int i = 0; i < dp.length; i++) {
      for (int j = 0; j < dp[0].length; j++) {
        int min = Integer.MAX_VALUE;

        for (int k = 0; k < dp[0].length; k++) {
          if () {
            if (dp[i - 1] [k] < min) {
              min = dp[i - 1][k];
            }
          }
        }
        dp[i][j] = arr[i][j] + min;
      }
    }

    int min = Integer.MAX_VALUE;
    for ( int k = 0; k < dp[0].length; k++) {
      if (dp[n - 1][k]) < min) {
        min = dp[i - 1][k];
      }
    }

    System.out.print(min);
  }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Paint Fence</span>
import java.io.*;

import java.util.*;

public class Main {

  public static void main(String[] args) throws Exception {
    Scanner scn = new Scanner(System.in);
    int n = scn.nextInt();
    int k = scn.nextInt();

    long[] dp = new long[n + 1];
    long same = k * 1;
    long diff = k *  (k - 1);
    long total = same + diff;

    for (int i = 3; i <= dp.length; i++) {
      same = diff * 1;
      e
      diff = total * (k - 1);
      toatl = same + diff;
    }

    System.out.println(total);
  }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Tiling with 2x1 tiles</span>
import java.io.*;

import java.util.*;

public class Main {

  public static void main(String[] args) throws Exception {

    Scanner scn = new Scanner(System.in);
    int n = scn.nextInt();
    int[] dp = new int[n + 1];
    dp[0] = 0;
    dp[1] = 1;
    dp[2] = 2;
    for (int i = 3; i < dp.length; i++)
    {
      dp[i] = dp[i - 1] + dp[i - 2];
    }
    System.out.println(dp[n]);
  }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Tiling With Mx1 Tiles</span>
import java.io.*;

import java.util.*;

public class Main {

  public static void main(String[] args) throws Exception {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    int n = Integer.parseInt(br.readLine());
    int m = Integer.parseInt(br.readLine());
    int[] dp = new int[n + 1];
    dp[1] = 1;
    for (int i = 2; i <= n; i++) {
      if (i < m) {
        dp[i] = 1;
      } else if (i == m) {
        dp[i] = 2;
      } else {
        dp[i] = dp[i - 1] + dp[i - m];
      }
    }

    System.out.println(dp[n]);
  }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Friends Pairing</span>
import java.io.*;

import java.util.*;

public class Main {

  public static void main(String[] args) throws Exception {
    Scanner scn = new Scanner(System.in);
    int n = scn.nextInt();
    int[] dp = new int[n + 1];

    dp[0] = 1;
    dp[1] = 1;

    for (int i = 2; i <= n; i++) {
      dp[i] = dp[i - 1] + (i - 1) * dp[i - 2];
    }
    System.out.println(dp[n]);
    scn.close();
  }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Partition Into Subsets</span>
import java.io.*;

import java.util.*;

public class Main {

  public static void main(String[] args) throws Exception {
    Scanner scn = new Scanner(System.in);
    int n = scn.nextInt();
    int k = scn.nextInt();

    if (n == 0 || k == 0 || n < k) {
      System.out.println(0);
      scn.close();
      return;
    }

    long[][] dp = new long[k + 1][n + 1];

    for (int t = 1; t <= k; t++) {
      for (int p = 1; p <= n; p++) {
        if (p == t)
          dp[t][p] = 1;
        else if (p > t)
          dp[t][p] = t * dp[t][p - 1] + dp[t - 1][p - 1];
      }
    }
    System.out.println(dp[k][n]);
    scn.close();
  }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Buy and sell Stocks-1 tran allowed</span>
import java.io.*;

import java.util.*;

public class Main {

  public static void main(String[] args) throws Exception {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    int n = Integer.parseInt(br.readLine());
    int[] arr = new int[n];
    for (int i = 0; i < arr.length; i++) {
      arr[i] = Integer.parseInt(br.readLine());
    }

    int msf = arr[0];
    int op = 0;
    for (int i = 1; i < arr.length; i++) {
      if (arr[i] < msf) {
        msf = arr[i];
      }

      int cp = arr[i] - msf;
      if (cp > op) {
        op = cp;
      }
    }

    System.out.println(op);
  }

}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Buy & Sell Stock - Infinite Transactions Allowed</span>
import java.io.*;

import java.util.*;

public class Main {

  public static void main(String[] args) throws Exception {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    int n = Integer.parseInt(br.readLine());
    int[] arr = new int[n];
    for (int i = 0; i < arr.length; i++) {
      arr[i] = Integer.parseInt(br.readLine());
    }

    int bon = 0;
    int son = 0;
    int op = 0;
    for (int i = 1; i < arr.length; i++) {
      if (arr[i] < arr[i - 1]) {
        op += arr[son] - arr[bon];
        bon = son = i;
      } else {
        son++;
      }
    }

    op += arr[son] - arr[bon];
    System.out.println(op);
  }

}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Buy And Sell Stocks With Transaction Fee</span>
import java.io.*;

import java.util.*;

public class Main {

  public static void main(String[] args) throws Exception {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    int n = Integer.parseInt(br.readLine());
    int[] arr = new int[n];
    for (int i = 0; i < arr.length; i++) {
      arr[i] = Integer.parseInt(br.readLine());
    }
    int fee = Integer.parseInt(br.readLine());

    int bstp = -arr[0];
    int sstp = 0;
    for (int i = 1; i < arr.length; i++) {
      int nsstp = 0;
      int nbstp = 0;

      if (sstp - arr[i] > bstp) {
        nbstp = sstp - arr[i];
      } else {
        nbstp = bstp;
      }

      if (bstp + arr[i] - fee > sstp) {
        nsstp = bstp + arr[i] - fee;
      } else {
        nsstp = sstp;
      }

      bstp = nbstp;
      sstp = nsstp;
    }

    System.out.println(sstp);
  }

}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Buy & Sell Stock - Cooldown</span>
import java.io.*;

import java.util.*;

public class Main {

  public static void main(String[] args) throws Exception {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    int n = Integer.parseInt(br.readLine());
    int[] arr = new int[n];
    for (int i = 0; i < arr.length; i++) {
      arr[i] = Integer.parseInt(br.readLine());
    }

    int bstp = -arr[0];
    int sstp = 0;
    int cstp = 0;
    for (int i = 1; i < arr.length; i++) {
      int nbstp = 0;
      int nsstp = 0;
      int ncstp = 0;

      if (cstp - arr[i] > bstp) {
        nbstp = cstp - arr[i];
      } else {
        nbstp = bstp;
      }

      if (bstp + arr[i] > sstp) {
        nsstp = bstp + arr[i];
      } else {
        nsstp = sstp;
      }

      if (sstp > cstp) {
        ncstp = sstp;
      } else {
        ncstp = cstp;
      }

      bstp = nbstp;
      sstp = nsstp;
      cstp = ncstp;
    }

    System.out.println(Math.max(sstp, cstp));
  }

}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Buy and Sell Stocks- Two Transactions Allowed</span>
import java.io.*;

import java.util.*;

public class Main {


  public static void main(String[] args) throws Exception {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    int n = Integer.parseInt(br.readLine());
    int[] arr = new int[n];
    for (int i = 0; i < arr.length; i++) {
      arr[i] = Integer.parseInt(br.readLine());
    }

    int misf = arr[0];
    int[] ps = new int[arr.length];
    for (int i = 1; i < arr.length; i++) {
      if (arr[i] < misf) {
        misf = arr[i];
      }

      if (arr[i] - misf > ps[i - 1]) {
        ps[i] = arr[i] - misf;
      } else {
        ps[i] = ps[i - 1];
      }
    }

    int masf = arr[arr.length - 1];
    int[] pb = new int[arr.length];
    for (int i = arr.length - 2; i >= 0; i--) {
      if (arr[i] > masf) {
        masf = arr[i];
      }

      if (masf - arr[i] > pb[i + 1]) {
        pb[i] = masf - arr[i];
      } else {
        pb[i] = pb[i + 1];
      }
    }

    int mp = Integer.MIN_VALUE;
    for (int i = 0; i < arr.length; i++) {
      if (ps[i] + pb[i] > mp) {
        mp = ps[i] + pb[i];
      }
    }

    System.out.println(mp);
  }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Buy and Sell Stocks- K Transactions Allowed</span>
import java.io.*;

import java.util.*;

public class Main {

  public static void main(String[] args) throws Exception {

    Scanner scn = new Scanner(System.in);
    int n = scn.nextInt();
    int[] arr = new int[n];

    for (int i = 0; i < n; i++)
    {
      arr[i] = scn.nextInt();
    }
    int k = scn.nextInt();

    int[][]dp = new int[k + 1][n];

    for (int t = 1; t <= k; t++)
    {
      for (int d = 1; d < arr.length; d++)
      {
        int max = dp[t][d - 1];
        for (int pd = 0; pd < d; pd++)
        {
          int ptilltm1 = dp[t - 1][pd];
          int ptth = arr[d] - arr[pd];

          if (ptilltm1 + ptth > max)
          {
            max = ptilltm1 + ptth;
          }
        }
        dp[t][d] = max;
      }
    }
    System.out.println(dp[k][n - 1]);
  }

}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Time and Space Complexity</span>
Bubble Sort
import java.io.*;

import java.util.*;

public class Main {

  public static void bubbleSort(int[] arr) {
    int n = arr.length;
    for (int itr = 1; itr < n; itr++) {
      for (int j = 0; j < n - itr; j++) {
        if (isSmaller(arr, j + 1, j) == true) {
          swap(arr, j + 1, j);
        }
      }
    }
  }

  // used for swapping ith and jth elements of array
  public static void swap(int[] arr, int i, int j) {
    System.out.println("Swapping " + arr[i] + " and " + arr[j]);
    int temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
  }

  // return true if ith element is smaller than jth element
  public static boolean isSmaller(int[] arr, int i, int j) {
    System.out.println("Comparing " + arr[i] + " and " + arr[j]);
    if (arr[i] < arr[j]) {
      return true;
    } else {
      return false;
    }
  }

  public static void print(int[] arr) {
    for (int i = 0; i < arr.length; i++) {
      System.out.println(arr[i]);
    }
  }

  public static void main(String[] args) throws Exception {
    Scanner scn = new Scanner(System.in);
    int n = scn.nextInt();
    int[] arr = new int[n];
    for (int i = 0; i < n; i++) {
      arr[i] = scn.nextInt();
    }
    bubbleSort(arr);
    print(arr);
  }

}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Selection Sort</span>
import java.io.*;

import java.util.*;
public class Main {

  public static void selectionSort(int[] arr) {
    int n = arr.length;
    for (int i = 0; i < n - 1; i++) {
      int minidx = i;
      for (int j = i + 1; j < n; j++) {
        if (isSmaller(arr, j, minidx)) {
          minidx = j;
        }
      }
      swap(arr, i, minidx);
    }
  }

  // used for swapping ith and jth elements of array
  public static void swap(int[] arr, int i, int j) {
    System.out.println("Swapping " + arr[i] + " and " + arr[j]);
    int temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
  }

  // return true if ith element is smaller than jth element
  public static boolean isSmaller(int[] arr, int i, int j) {
    System.out.println("Comparing " + arr[i] + " and " + arr[j]);
    if (arr[i] < arr[j]) {
      return true;
    } else {
      return false;
    }
  }

  public static void print(int[] arr) {
    for (int i = 0; i < arr.length; i++) {
      System.out.println(arr[i]);
    }
  }

  public static void main(String[] args) throws Exception {
    Scanner scn = new Scanner(System.in);
    int n = scn.nextInt();
    int[] arr = new int[n];
    for (int i = 0; i < n; i++) {
      arr[i] = scn.nextInt();
    }
    selectionSort(arr);
    print(arr);
  }

}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Insertion Sort</span>
import java.io.*;

import java.util.*;

public class Main {

  public static void insertionSort(int[] arr) {
    for (int i = 1; i < arr.length; i++) {
      for (int j = i - 1; j >= 0; j--) {
        if (isGreater(arr, j, j + 1)) {
          swap(arr, j, j + 1);
        } else {
          break;
        }
      }
    }
  }

  // used for swapping ith and jth elements of array
  public static void swap(int[] arr, int i, int j) {
    System.out.println("Swapping " + arr[i] + " and " + arr[j]);
    int temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
  }

  // return true if jth element is greater than ith element
  public static boolean isGreater(int[] arr, int j, int i) {
    System.out.println("Comparing " + arr[i] + " and " + arr[j]);
    if (arr[i] < arr[j]) {
      return true;
    } else {
      return false;
    }
  }

  public static void print(int[] arr) {
    for (int i = 0; i < arr.length; i++) {
      System.out.println(arr[i]);
    }
  }

  public static void main(String[] args) throws Exception {
    Scanner scn = new Scanner(System.in);
    int n = scn.nextInt();
    int[] arr = new int[n];
    for (int i = 0; i < n; i++) {
      arr[i] = scn.nextInt();
    }
    insertionSort(arr);
    print(arr);
  }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Merge Two Sorted Arrays</span>
import java.io.*;

import java.util.*;

public class Main {

  public static int[] mergeTwoSortedArrays(int[] a, int[] b) {
    // write your code here
    int alen = a.length;
    int blen = b.length;

    int[] res = new int[alen + blen];

    int i = 0;
    int j = 0;
    int k = 0;

    // when there are elements in both the array
    while (i < alen && j < blen) {
      if (a[i] < b[j]) {
        res[k] = a[i];
        i++;
      } else {
        res[k] = b[j];
        j++;
      }
      k++;
    }


    while (i < alen) {
      res[k] = a[i];
      i++;
      k++;
    }

    while (j < blen) {
      res[k] = b[j];
      j++;
      k++;
    }

    return res;
  }

  public static void print(int[] arr) {
    for (int i = 0; i < arr.length; i++) {
      System.out.println(arr[i]);
    }
  }

  public static void main(String[] args) {
    Scanner scn = new Scanner(System.in);
    int n = scn.nextInt();
    int[] a = new int[n];
    for (int i = 0; i < n; i++) {
      a[i] = scn.nextInt();
    }
    int m = scn.nextInt();
    int[] b = new int[m];
    for (int i = 0; i < m; i++) {
      b[i] = scn.nextInt();
    }
    int[] mergedArray = mergeTwoSortedArrays(a, b);
    print(mergedArray);
  }

}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Merge sort</span>
class Merge{
	public static void main(String[] args){
		int[] arr={9,8,7,6,5,4,3,2,1};
		int[] ans=Merge_Sort(arr,0,arr.length);
		for(int nn:ans){
			System.out.print(nn+"-");
		}
	}	
	static int[] Merge_Sort(int[] arr,int lo,int hi){
        if(lo==hi){
          int[] na=new int[1];
          na[0]=arr[lo];
          return na;
      }
          int mid=(lo+hi)/2;
          int[] leftside=Merge_Sort(arr, lo, mid);
          int[] righside=Merge_Sort(arr, mid+1, hi);
          int[] finalarray=mergetwoarray(leftside,righside);
          
          return finalarray;
      }
      static int[] mergetwoarray(int[] a1,int[] a2){
        int i=0,j=0,k=0;
        int[] res=new int[a1.length+a2.length];
        while(i < a1.length && j < a2.length){
          if(a1[i]< a2[j]){
            res[k]=a1[i];
            k++;i++;
          }else{
            res[k]=a2[j];
            k++;j++;
          }
        }
        while(i< a1.length){
          res[k]=a1[i];
          k++;i++;
        }
        while(j< a2.length){
          res[k]=a2[j];
          k++;j++;
        }
        return res;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Partition An Array</span>
import java.io.*;

import java.util.*;

public class Main {

  public static void partition(int[] arr, int pivot) {
    int i = 0;
    int j = 0;
    while (i < arr.length) {
      if (arr[i] > pivot)
      {
        i++;
      }
      else if (arr[i] <= pivot)
      {
        swap(arr, i, j);
        i++;
        j++;
      }
    }

  }

  // used for swapping ith and jth elements of array
  public static void swap(int[] arr, int i, int j) {
    System.out.println("Swapping " + arr[i] + " and " + arr[j]);
    int temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
  }

  public static void print(int[] arr) {
    for (int i = 0; i < arr.length; i++) {
      System.out.print(arr[i] + " ");
    }
    System.out.println();
  }

  public static void main(String[] args) throws Exception {

    Scanner scn = new Scanner(System.in);
    int n = scn.nextInt();
    int[] arr = new int[n];
    for (int i = 0; i < n; i++) {
      arr[i] = scn.nextInt();
    }
    int pivot = scn.nextInt();
    partition(arr, pivot);
    print(arr);
  }

}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Quick Sort</span>
import java.io.*;
import java.util.*;

public class Main {

  public static void quickSort(int[] arr, int lo, int hi) {

    if (lo >= hi)
    {
      return;
    }

    int pivot = arr[hi];
    int pi = partition(arr, pivot, lo, hi);
    quickSort(arr, lo, pi - 1);
    quickSort(arr, pi + 1, hi);

  }

  public static int partition(int[] arr, int pivot, int lo, int hi) {
    System.out.println("pivot -> " + pivot);
    int i = lo, j = lo;
    while (i <= hi) {
      if (arr[i] <= pivot) {
        swap(arr, i, j);
        i++;
        j++;
      } else {
        i++;
      }
    }
    System.out.println("pivot index -> " + (j - 1));
    return (j - 1);
  }

  // used for swapping ith and jth elements of array
  public static void swap(int[] arr, int i, int j) {
    System.out.println("Swapping " + arr[i] + " and " + arr[j]);
    int temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
  }

  public static void print(int[] arr) {
    for (int i = 0; i < arr.length; i++) {
      System.out.print(arr[i] + " ");
    }
    System.out.println();
  }

  public static void main(String[] args) throws Exception {
    Scanner scn = new Scanner(System.in);
    int n = scn.nextInt();
    int[] arr = new int[n];
    for (int i = 0; i < n; i++) {
      arr[i] = scn.nextInt();
    }
    quickSort(arr, 0, arr.length - 1);
    print(arr);
  }

}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Quick Select</span>
import java.io.*;

import java.util.*;

public class Main {

  public static int quickSelect(int[] arr, int lo, int hi, int k) {

    int pivot = arr[hi];
    int pi = partition(arr, pivot, lo, hi);
    if (pi > k)
    {
      return quickSelect(arr, lo, pi - 1, k);
    }
    else if (pi < k)
    {
      return quickSelect(arr, pi + 1, hi, k);
    }
    return pivot;
  }

  public static int partition(int[] arr, int pivot, int lo, int hi) {
    System.out.println("pivot -> " + pivot);
    int i = lo, j = lo;
    while (i <= hi) {
      if (arr[i] <= pivot) {
        swap(arr, i, j);
        i++;
        j++;
      } else {
        i++;
      }
    }
    System.out.println("pivot index -> " + (j - 1));
    return (j - 1);
  }

  // used for swapping ith and jth elements of array
  public static void swap(int[] arr, int i, int j) {
    System.out.println("Swapping " + arr[i] + " and " + arr[j]);
    int temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
  }

  public static void print(int[] arr) {
    for (int i = 0; i < arr.length; i++) {
      System.out.print(arr[i] + " ");
    }
    System.out.println();
  }

  public static void main(String[] args) throws Exception {
    Scanner scn = new Scanner(System.in);
    int n = scn.nextInt();
    int[] arr = new int[n];
    for (int i = 0; i < n; i++) {
      arr[i] = scn.nextInt();
    }
    int k = scn.nextInt();
    System.out.println(quickSelect(arr, 0, arr.length - 1, k - 1)); 
	//we passed k-1 as the kth smallest element will be index k-1 in the array
  }

}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Count Sort</span>
import java.io.*;

import java.util.*;

public class Main {

  public static void countSort(int[] arr, int min, int max) {
    int range = max - min + 1;
    int[] ans = new int[arr.length];
    //make frequency arr
    int[] farr = new int[range];
    for (int i = 0 ; i < arr.length; i++) {
      farr[arr[i] - min]++;
    }
    //convert it into prefix sum array
    for (int i = 1 ; i < farr.length; i++) {
      farr[i] += farr[i - 1];
    }
    //stable sorting(filling ans array)
    for (int i = arr.length - 1; i >= 0; i--) {
      int pos = farr[arr[i] - min] - 1;
      ans[pos] = arr[i];
      farr[arr[i] - min]--;
    }
    //filling original array with the help of ans array
    for (int i = 0 ; i < arr.length; i++) {
      arr[i] = ans[i];
    }
  }

  public static void print(int[] arr) {
    for (int i = 0; i < arr.length; i++) {
      System.out.println(arr[i]);
    }
  }

  public static void main(String[] args) throws Exception {
    Scanner scn = new Scanner(System.in);
    int n = scn.nextInt();
    int[] arr = new int[n];
    int max = Integer.MIN_VALUE;
    int min = Integer.MAX_VALUE;
    for (int i = 0; i < n; i++) {
      arr[i] = scn.nextInt();
      max = Math.max(max, arr[i]);
      min = Math.min(min, arr[i]);
    }
    countSort(arr, min, max);
    print(arr);
  }

}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Radix Sort</span>
import java.io.*;

import java.util.*;

public class Main {

  public static void radixSort(int[] arr) {
    int max = Integer.MIN_VALUE;
    for (int i = 0; i < arr.length; i++) {
      max = Math.max(max, arr[i]);
    }
    //call countSort for every digit from right to left
    for (int exp = 1; max / exp >= 1; exp *= 10)
      countSort(arr, exp);
  }

  public static void countSort(int[] arr, int exp) {

    int[] ans = new int[arr.length];
    // make frequency arr
    int[] farr = new int[10];
    for (int i = 0; i < arr.length; i++) {
      farr[(arr[i] / exp) % 10]++;
    }
    // convert it into prefix sum array
    for (int i = 1; i < farr.length; i++) {
      farr[i] += farr[i - 1];
    }
    // stable sorting(filling ans array)
    for (int i = arr.length - 1; i >= 0; i--) {
      int pos = farr[(arr[i] / exp) % 10] - 1;
      ans[pos] = arr[i];
      farr[(arr[i] / exp) % 10]--;
    }
    // filling original array with the help of ans array
    for (int i = 0; i < arr.length; i++) {
      arr[i] = ans[i];
    }
    System.out.print("After sorting on " + exp + " place -> ");
    print(arr);
  }

  public static void print(int[] arr) {
    for (int i = 0; i < arr.length; i++) {
      System.out.print(arr[i] + " ");
    }
    System.out.println();
  }

  public static void main(String[] args) throws Exception {
    Scanner scn = new Scanner(System.in);
    int n = scn.nextInt();
    int[] arr = new int[n];
    for (int i = 0; i < n; i++) {
      arr[i] = scn.nextInt();
    }
    radixSort(arr);
    print(arr);
  }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Sort Dates</span>
import java.io.*;

import java.util.*;

public class Main {

  public static void sortDates(String[] arr) {
    countSort(arr, 1000000, 100, 32);
    countSort(arr, 10000, 100, 13);
    countSort(arr, 1, 10000, 2501);
  }

  public static void countSort(String[] arr, int div, int mod, int range) {
    String[] ans = new String[arr.length];
    // make frequency arr
    int[] farr = new int[range];
    for (int i = 0; i < arr.length; i++) {
      farr[Integer.parseInt(arr[i], 10) / div % mod]++;
    }
    // convert it into prefix sum array
    for (int i = 1; i < farr.length; i++) {
      farr[i] += farr[i - 1];
    }
    // stable sorting(filling ans array)
    for (int i = arr.length - 1; i >= 0; i--) {
      int pos = farr[Integer.parseInt(arr[i], 10) / div % mod] - 1;
      ans[pos] = arr[i];
      farr[Integer.parseInt(arr[i], 10) / div % mod]--;
    }
    // filling original array with the help of ans array
    for (int i = 0; i < arr.length; i++) {
      arr[i] = ans[i];
    }
  }

  public static void print(String[] arr) {
    for (int i = 0; i < arr.length; i++) {
      System.out.println(arr[i]);
    }
  }

  public static void main(String[] args) throws Exception {
    Scanner scn = new Scanner(System.in);
    int n = scn.nextInt();
    String[] arr = new String[n];
    for (int i = 0; i < n; i++) {
      String str = scn.next();
      arr[i] = str;
    }
    sortDates(arr);
    print(arr);
  }

}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Sort 01</span>
import java.io.*;

import java.util.*;

public class Main {

  public static void sort01(int[] arr) {
    // 0 to j-1  ->  All Zeroes //
    // j to i-1  ->  All One's //
    /* i to arr.length-1 -> All unknowns */

    int i = 0, j = 0;
    while (i < arr.length) {
      if (arr[i] == 0) {
        swap(arr, i, j);
        i++;
        j++;
      } else {
        i++;
      }
    }
  }

  // used for swapping ith and jth elements of array
  public static void swap(int[] arr, int i, int j) {
    System.out.println("Swapping index " + i + " and index " + j);
    int temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
  }

  public static void print(int[] arr) {
    for (int i = 0 ; i < arr.length; i++) {
      System.out.println(arr[i]);
    }
  }
  public static void main(String[] args) throws Exception {
    Scanner scn = new Scanner(System.in);
    int n = scn.nextInt();
    int[] arr = new int[n];
    for (int i = 0 ; i < n; i++) {
      arr[i] = scn.nextInt();
    }
    sort01(arr);
    print(arr);
  }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Sort 012</span>
import java.io.*;

import java.util.*;

public class Main {

  public static void sort012(int[] arr) {
    // 0 to j-1  ->  All Zeroes
    // j to i-1  ->  All One's
    // i to k - 1  ->  All unknowns
    // k to last -> All Two's

    int i = 0, j = 0, k = arr.length - 1;
    while (i <= k) {
      if (arr[i] == 0) {
        swap(arr, i, j);
        i++;
        j++;
      } else if (arr[i] == 1) {
        i++;
      } else {
        swap(arr, i, k);
        k--;
      }
    }
  }

  // used for swapping ith and jth elements of array
  public static void swap(int[] arr, int i, int j) {
    System.out.println("Swapping index " + i + " and index " + j);
    int temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
  }

  public static void print(int[] arr) {
    for (int i = 0 ; i < arr.length; i++) {
      System.out.println(arr[i]);
    }
  }
  public static void main(String[] args) throws Exception {
    Scanner scn = new Scanner(System.in);
    int n = scn.nextInt();
    int[] arr = new int[n];
    for (int i = 0 ; i < n; i++) {
      arr[i] = scn.nextInt();
    }
    sort012(arr);
    print(arr);
  }

}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Target Sum Pair 1</span>
import java.io.*;

import java.util.*;

public class Main {

  public static void targetSumPair(int[] arr, int target) {
    Arrays.sort(arr);

    int left = 0, right = arr.length - 1;
    while (left < right) {
      if (arr[left] + arr[right] == target) {
        System.out.println(arr[left] + ", " + arr[right]);
        left++;
        right--;
      } else if (arr[left] + arr[right] > target) {
        right--;
      } else {
        left++;
      }
    }
  }

  public static void main(String[] args) throws Exception {
    Scanner scn = new Scanner(System.in);
    int n = scn.nextInt();
    int[] arr = new int[n];
    for (int i = 0; i < n; i++) {
      arr[i] = scn.nextInt();
    }
    int target = scn.nextInt();
    targetSumPair(arr, target);
  }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Pivot of Sorted Rotated Array</span>
import java.io.*;

import java.util.*;

public class Main {

  public static int findPivot(int[] arr) {
    int lo = 0, hi = arr.length - 1;
    while (lo < hi) {
      int mid = (lo + hi) / 2;
      if (arr[mid] > arr[hi]) {
        lo = mid + 1;
      } else {
        hi = mid;
      }
    }
    return arr[lo];
  }

  public static void main(String[] args) throws Exception {
    Scanner scn = new Scanner(System.in);
    int n = scn.nextInt();
    int[] arr = new int[n];
    for (int i = 0; i < n; i++) {
      arr[i] = scn.nextInt();
    }
    int pivot = findPivot(arr);
    System.out.println(pivot);
  }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Introduction To Stacks</span>
import java.util.*;

import java.lang.*;
import java.io.*;

class Main
{
  public static void main (String[] args) throws java.lang.Exception
  {
    Stack< Integer> st = new Stack< >();
    st.push(10);
    System.out.println(st + "->" + st.peek() + " " + st.size());
    st.push(20);
    System.out.println(st + "->" + st.peek() + " " + st.size());
    st.push(30);
    System.out.println(st + "->" + st.peek() + " " + st.size());
    st.push(40);
    System.out.println(st + "->" + st.peek() + " " + st.size());
    System.out.println("Is Stack Empty: " + st.empty());
    st.pop();
    System.out.println(st + "->" + st.peek() + " " + st.size());
    st.pop();
    System.out.println(st + "->" + st.peek() + " " + st.size());
    st.pop();
    System.out.println(st + "->" + st.peek() + " " + st.size());
    st.pop();
    System.out.println(st + "->" + " " + st.size());
    System.out.println("Is Stack Empty: " + st.empty());
  }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Duplicate Brackets</span>
import java.io.*;

import java.util.*;

public class Main {
  public static void main(String[] args) throws Exception {
    BufferedReader br = new
    BufferedReader(new InputStreamReader(System.in));
    String str = br.readLine();

    Stack< Character> st = new Stack< >();
    for (int i = 0; i < str.length(); i++) {
      char ch = str.charAt(i);
      if (ch == ')') {
        if (st.peek() == '(') {
          System.out.println(true);
          return;
        } else {
          while (st.peek() != '(') {
            st.pop();
          }
          st.pop();
        }
      } else {
        st.push(ch);
      }
    }

    System.out.println(false);
  }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Balanced Brackets</span>
import java.io.*;

import java.util.*;

public class Main {

  public static void main(String[] args) throws Exception {

    Scanner scn = new Scanner(System.in);
    String str = scn.nextLine();
    Stack< Character> st = new Stack<>();

    for (int i = 0; i < str.length(); i++){
      char ch = str.charAt(i);
      if (ch == '(' || ch == '[' || ch == '{'){
        st.push(ch);
      }
      else if (ch == ')'){
        boolean val = handleClosing(st, '(');
        if (val == false){
          System.out.println(val);
          return;
        }
      }
      else if (ch == ']'){
        boolean val = handleClosing(st, '[');
        if (val == false){
          System.out.println(val);
          return;
        }
      }
      else if (ch == '}'){
        boolean val = handleClosing(st, '{');
        if (val == false){
          System.out.println(val);
          return;
        }
      }
      else{

      }
    }
    if (st.size() == 0){
      System.out.println(true);
    }
    else{
      System.out.println(false);
    }
  }
  public static boolean handleClosing(Stack < Character> st, char corresopch){
    if (st.size() == 0){
      return false;
    }
    else if (st.peek() != corresopch){
      return false;
    }
    else{
      st.pop();
      return true;
    }
  }

}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Next Greater element to the Right</span>
import java.io.*;

import java.util.*;

public static int[] solve(int[] arr) {

  int[] nge = new int[arr.length];
  Stack< Integer> st = new Stack< >();

  nge[arr.length - 1] = -1;
  st.push(arr[arr.length - 1]);

  for (int i = arr.length - 2; i >= 0; i--) {

    while (st.size() > 0 && arr[i] >= st.peek()) {
      st.pop();
    }

    if (st.size() == 0) {
      nge[i] = -1;
    } else {
      nge[i] = st.peek();
    }

    st.push(arr[i]);
  }

  return nge;
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Stock Span</span>
import java.io.*;

import java.util.*;

public class Main {
  public static void display(int[] a) {
    StringBuilder sb = new StringBuilder();

    for (int val : a) {
      sb.append(val + "
                ");
    }
    System.out.println(sb);
  }

  public static void main(String[] args) throws Exception {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

    int n = Integer.parseInt(br.readLine());
    int[] a = new int[n];
    for (int i = 0; i < n; i++) {
      a[i] = Integer.parseInt(br.readLine());
    }

    int[] span = solve(a);
    display(span);
  }

  public static int[] solve(int[] arr) {
    int[] span = new int[arr.length];
    Stack< Integer> st = new Stack<>();
    st.push(0);
    span[0] = 1;

    for (int i = 1; i < arr.length; i++) {
      while (st.size() > 0 && arr[i] >= arr[st.peek()]) {
        st.pop();
      }
      if (st.size() == 0) {
        span[i] = i + 1;
      } else {
        span[i] = i - st.peek();
      }

      st.push(i);
    }
    return span;
  }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Largest Area Histogram</span>

} import java.io.*;

import java.util.*;

public class Main {

  public static void main(String[] args) throws Exception {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

    int n = Integer.parseInt(br.readLine());
    int[] a = new int[n];
    for (int i = 0; i < n; i++) {
      a[i] = Integer.parseInt(br.readLine());
    }

    // code
    int[] rb = new int[n]; // nse index to right
    Stack< Integer> st = new Stack<>();
    st.push(n - 1);
    rb[n - 1] = n;

    for (int i = n - 2; i >= 0; i--) {
      while (st.size() > 0 && a[i] <= a[st.peek()]) {
        st.pop();
      }
      if (st.size() > 0) {
        rb[i] = st.peek();
      } else {
        rb[i] = n;
      }
      st.push(i);
    }

    int[] lb = new int[n]; // nse index to left

    st = new Stack<>();
    st.push(0);
    lb[0] = -1;

    for (int i = 1; i < n; i++) {
      while (st.size() > 0 && a[i] <= a[st.peek()]) {
        st.pop();
      }
      if (st.size() > 0) {
        lb[i] = st.peek();
      } else {
        lb[i] = -1;
      }
      st.push(i);
    }

    int maxArea = 0;
    for (int i = 0; i < n; i++) {
      int width = rb[i] - lb[i] - 1;
      int area = a[i] * width;

      if (area > maxArea) {
        maxArea = area;
      }
    }

    System.out.println(maxArea);
  }
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Sliding Window Maximum</span>
import java.io.*;

import java.util.*;

public class Main {
  public static void main(String[] args) throws Exception {
    BufferedReader br = new BufferedReader(new
                                           InputStreamReader(System.in));

    int n = Integer.parseInt(br.readLine());
    int[] arr = new int[n];
    for (int i = 0; i < n; i++) {
      arr[i] = Integer.parseInt(br.readLine());
    }
    int k = Integer.parseInt(br.readLine());

    // nge begin
    int[] nge = new int[arr.length];
    Stack< Integer> st = new Stack<>();
    st.push(arr.length - 1);
    nge[arr.length - 1] = arr.length;

    for (int i = arr.length - 2; i >= 0; i--) {
      while (st.size() > 0 && arr[i] >= arr[st.peek()]) {
        st.pop();
      }

      if (st.size() == 0) {
        nge[i] = arr.length;
      } else {
        nge[i] = st.peek();
      }

      st.push(i);
    }

    // nge end
    int i = 0;
    for (int w = 0; w <= arr.length - k; w++) {
      if (i < w) {
        i = w;
      }

      while (nge[i] < w + k) {
        i = nge[i];
      }
      System.out.println(arr[i]);
    }
  }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Infix Evaluation</span>
import java.io.*;

import java.util.*;

public class Main {
  public static void main(String[] args) throws Exception {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

    int n = Integer.parseInt(br.readLine());
    int[] arr = new int[n];
    for (int i = 0; i < n; i++) {
      arr[i] = Integer.parseInt(br.readLine());
    }
    int k = Integer.parseInt(br.readLine());

    // nge begin
    int[] nge = new int[arr.length];
    Stack< Integer> st = new Stack<>();
    st.push(arr.length - 1);
    nge[arr.length - 1] = arr.length;

    for (int i = arr.length - 2; i >= 0; i--) {
      while (st.size() > 0 && arr[i] >= arr[st.peek()]) {
        st.pop();
      }

      if (st.size() == 0) {
        nge[i] = arr.length;
      } else {
        nge[i] = st.peek();
      }

      st.push(i);
    }

    // nge end
    int i = 0;
    for (int w = 0; w <= arr.length - k; w++) {
      if (i < w) {
        i = w;
      }

      while (nge[i] < w + k) {
        i = nge[i];
      }
      System.out.println(arr[i]);
    }
  }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Infix Conversion</span>
import java.io.*;

import java.util.*;

public class Main {

  public static void main(String[] args) throws Exception {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    String exp = br.readLine();

    // code
    Stack< String> postfix = new Stack<>();
    Stack< String> prefix = new Stack<>();
    Stack< Character> operators = new Stack<>();

    for (int i = 0; i < exp.length(); i++) {
      char ch = exp.charAt(i);

      if (ch == '(') {
        operators.push(ch);
      } else if ((ch >= '0' && ch <= '9') || (ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z'))  {
        postfix.push(ch + "");
        prefix.push(ch + "");
      } else if (ch == '+' || ch == '-' || ch == '*' || ch == '/') {
        while (operators.size() > 0 && operators.peek() != '(' && 
                precedence(ch) <= precedence(operators.peek())) {
          char op = operators.pop();

          String postval2 = postfix.pop();
          String postval1 = postfix.pop();
          postfix.push(postval1 + postval2 + op);

          String preval2 = prefix.pop();
          String preval1 = prefix.pop();
          prefix.push(op + preval1 + preval2);
        }

        operators.push(ch);
      } else if (ch == ')') {
        while (operators.size() > 0 && operators.peek() != '(') {
          char op = operators.pop();

          String postval2 = postfix.pop();
          String postval1 = postfix.pop();
          postfix.push(postval1 + postval2 + op);

          String preval2 = prefix.pop();
          String preval1 = prefix.pop();
          prefix.push(op + preval1 + preval2);
        }

        if (operators.size() > 0) {
          operators.pop();
        }
      }
    }

    while (operators.size() > 0) {
      char op = operators.pop();

      String postval2 = postfix.pop();
      String postval1 = postfix.pop();
      postfix.push(postval1 + postval2 + op);

      String preval2 = prefix.pop();
      String preval1 = prefix.pop();
      prefix.push(op + preval1 + preval2);
    }

    System.out.println(postfix.peek());
    System.out.println(prefix.peek());
  }

  public static int precedence(char op) {
    if (op == '+') {
      return 1;
    } else if (op == '-') {
      return 1;
    } else if (op == '*') {
      return 2;
    } else {
      return 2;
    }
  }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Postfix Evaluation and Conversion</span>
import java.io.*;

import java.util.*;

public class Main {


  public static void main(String[] args) throws Exception {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    String exp = br.readLine();
    Stack< Integer> vs = new Stack< >();      //1
    Stack< String> is = new Stack< >();
    Stack< String> ps = new Stack< >();

    for (int i = 0; i < exp.length(); i++) {
      char ch = exp.charAt(i);   //2

      if (ch == '+' || ch == '-' || ch == '*' || ch == '/') { //3
        int v2 = vs.pop();
        int v1 = vs.pop();
        int val = operation(v1, v2, ch);
        vs.push(val);

        String iv2 = is.pop();     //4
        String iv1 = is.pop();
        String ival = "(" + iv1 + ch + iv2 + ")";
        is.push(ival);

        String pv2 = ps.pop(); //5
        String pv1 = ps.pop();
        String pval = ch + pv1 + pv2;
        ps.push(pval);
      } else {
        vs.push(ch - '0'); //6
        is.push(ch + "");
        ps.push(ch + "");
      }
    }
    System.out.println(vs.pop());    //7
    System.out.println(is.pop());
    System.out.println(ps.pop());
  }
  public static int operation (int v1, int v2, char op) {  //8


    if (op == '+') {
      return v1 + v2;
    } else if (op == '-') {
      return v1 - v2;
    } else if (op == '*') {
      return v1 * v2;
    } else {
      return v1 / v2;
    }

  }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Prefix Evaluation and Conversion</span>
import java.io.*;

import java.util.*;

public class Main {


  public static void main(String[] args) throws Exception {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    String exp = br.readLine();
    Stack< Integer> vs = new Stack< >();      //1
    Stack< String> is = new Stack< >();
    Stack< String> ps = new Stack< >();

    for (int i = exp.length() - 1; i >= 0; i--) {
      char ch = exp.charAt(i);   //2

      if (ch == '+' || ch == '-' || ch == '*' || ch == '/') { //3
        int v1 = vs.pop();
        int v2 = vs.pop();
        int val = operation(v1, v2, ch);
        vs.push(val);

        String iv1 = is.pop();     //4
        String iv2 = is.pop();
        String ival = "(" + iv1 + ch + iv2 + ")";
        is.push(ival);

        String pv1 = ps.pop(); //5
        String pv2 = ps.pop();
        String pval = pv1 + pv2 + ch;
        ps.push(pval);
      } else {
        vs.push(ch - '0'); //6
        is.push(ch + "");
        ps.push(ch + "");
      }
    }
    System.out.println(vs.pop());    //7
    System.out.println(is.pop());
    System.out.println(ps.pop());
  }
  public static int operation (int v1, int v2, char op) {  //8


    if (op == '+') {
      return v1 + v2;
    } else if (op == '-') {
      return v1 - v2;
    } else if (op == '*') {
      return v1 * v2;
    } else {
      return v1 / v2;
    }

  }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Celebrity Problem</span>
import java.io.*;

import java.util.*;

public class Main {

  public static void main(String[] args) throws Exception {
    // write your code here
    BufferedReader br = new BufferedReader(new
                                           InputStreamReader(System.in));
    int n = Integer.parseInt(br.readLine());
    int[][] arr = new int[n][n];

    for (int j = 0; j < n; j++) {
      String line = br.readLine();
      for (int k = 0; k < n; k++) {
        arr[j][k] = line.charAt(k) - '0';
      }
    }

    findCelebrity(arr);
  }

  public static void findCelebrity(int[][] arr) {
    // if a celebrity is there print it's index (not position),
    // if there is not then print "none"
    Stack < Integer > st = new Stack < > ();
    for (int i = 0; i < arr.length; i++) {
      st.push(i);
    }

    while (st.size() > 1) {
      int i = st.pop();
      int j = st.pop();

      if (arr[i][j] == 1) {
        st.push(j);
      } else {
        st.push(i);
      }
    }

    int pot = st.pop();
    boolean flag = true;
    for (int i = 0; i < arr.length; i++) {
      if (i != pot) {
        if (arr[i][pot] == 0 || arr[pot][i] == 1) {
          flag = false;
          break;
        }
      }
    }

    if (flag) {
      System.out.println(pot);
    } else {
      System.out.println("none");
    }
  }

}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Merge Overlapping Interval</span>
import java.io.*;

import java.util.*;

public class Main {

  public static void main(String[] args) throws Exception {
    // write your code here
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    int n = Integer.parseInt(br.readLine());
    int[][] arr = new int[n][2];

    for (int j = 0; j < n; j++) {
      String line = br.readLine();
      arr[j][0] = Integer.parseInt(line.split(" ")[0]);
      arr[j][1] = Integer.parseInt(line.split(" ")[1]);
    }

    mergeOverlappingIntervals(arr);
  }

  public static void mergeOverlappingIntervals(int[][] arr) {
    Pair[] pairs = new Pair[arr.length];
    for (int i = 0; i < arr.length; i++) {
      pairs[i] = new Pair(arr[i][0], arr[i][1]);
    }

    Arrays.sort(pairs);
    Stack< Pair> st = new Stack< >();
    for (int i = 0; i < pairs.length; i++) {
      if (i == 0) {
        st.push(pairs[i]);
      } else {
        Pair top = st.peek();
        if (pairs[i].st > top.et) {
          st.push(pairs[i]);
        } else {
          top.et = Math.max(top.et, pairs[i].et);
        }
      }
    }

    Stack< Pair> rs = new Stack< >();
    while (st.size() > 0) {
      rs.push(st.pop());
    }

    while (rs.size() > 0) {
      Pair p = rs.pop();
      System.out.println(p.st + " " + p.et);
    }

  }

  public static class Pair implements Comparable< Pair> {
    int st;
    int et;

    Pair(int st, int et) {
      this.st = st;
      this.et = et;
    }

    public int compareTo(Pair other) {
      if (this.st != other.st) {
        return this.st - other.st;
      } else {
        return this.et - other.et;
      }
    }
  }

}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Smallest Number Following Pattern</span>
import java.io.*;

import java.util.*;

public class Main {

  public static void main(String[] args) throws Exception {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    String str = br.readLine();

    // code
    Stack< Integer> st = new Stack< >();

    int num = 1;
    for (int i = 0; i < str.length(); i++) {
      char ch = str.charAt(i);
      if (ch == 'd') { // when we encounter d
        st.push(num);
        num++;
      } else { // when we encounter i
        st.push(num);
        num++;
        while (st.size() > 0) {
          System.out.print(st.pop());
        }
      }
    }
    st.push(num); // for last number
    while (st.size() > 0) {
      System.out.print(st.pop());
    }
  }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Normal Stack</span>
import java.io.*;

import java.util.*;

public class Main {

  public static class CustomStack {
    int[] data;
    int tos;

    public CustomStack(int cap) {
      data = new int[cap];
      tos = -1;
    }

    int size() {
      return tos + 1;
    }

    void display() {
      for (int i = tos; i >= 0; i--) {
        System.out.print(data[i] + " ");
      }
      System.out.println();
    }

    void push(int val) {
      if (tos == data.length - 1) {
        System.out.println("Stack overflow");
      } else {
        tos++;
        data[tos] = val;
      }
    }

    int pop() {
      if (tos == -1) {
        System.out.println("Stack underflow");
        return -1;
      } else {
        int val = data[tos];
        tos--;
        return val;
      }
    }

    int top() {
      if (tos == -1) {
        System.out.println("Stack underflow");
        return -1;
      } else {
        return data[tos];
      }
    }
  }

  public static void main(String[] args) throws Exception {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    int n = Integer.parseInt(br.readLine());
    CustomStack st = new CustomStack(n);

    String str = br.readLine();
    while (str.equals("quit") == false) {
      if (str.startsWith("push")) {
        int val = Integer.parseInt(str.split(" ")[1]);
        st.push(val);
      } else if (str.startsWith("pop")) {
        int val = st.pop();
        if (val != -1) {
          System.out.println(val);
        }
      } else if (str.startsWith("top")) {
        int val = st.top();
        if (val != -1) {
          System.out.println(val);
        }
      } else if (str.startsWith("size")) {
        System.out.println(st.size());
      } else if (str.startsWith("display")) {
        st.display();
      }
      str = br.readLine();
    }
  }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Dynamic Stack</span>
import java.io.*;

import java.util.*;

public class Main {

  public static class CustomStack {
    int[] data;
    int tos;

    public CustomStack(int cap) {
      data = new int[cap];
      tos = -1;
    }

    int size() {
      return tos + 1;
    }

    void display() {
      for (int i = tos; i >= 0; i--) {
        System.out.print(data[i] + " ");
      }
      System.out.println();
    }

    void push(int val) {
      if (tos == data.length - 1) {
        int[] ndata = new int[2 * data.length];
        for (int i = 0; i < data.length; i++) {
          ndata[i] = data[i];
        }
        data = ndata;
      }

      tos++;
      data[tos] = val;
    }

    int pop() {
      if (tos == -1) {
        System.out.println("Stack underflow");
        return -1;
      } else {
        int val = data[tos];
        tos--;
        return val;
      }
    }

    int top() {
      if (tos == -1) {
        System.out.println("Stack underflow");
        return -1;
      } else {
        return data[tos];
      }
    }
  }

  public static void main(String[] args) throws Exception {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    int n = Integer.parseInt(br.readLine());
    CustomStack st = new CustomStack(n);

    String str = br.readLine();
    while (str.equals("quit") == false) {
      if (str.startsWith("push")) {
        int val = Integer.parseInt(str.split(" ")[1]);
        st.push(val);
      } else if (str.startsWith("pop")) {
        int val = st.pop();
        if (val != -1) {
          System.out.println(val);
        }
      } else if (str.startsWith("top")) {
        int val = st.top();
        if (val != -1) {
          System.out.println(val);
        }
      } else if (str.startsWith("size")) {
        System.out.println(st.size());
      } else if (str.startsWith("display")) {
        st.display();
      }
      str = br.readLine();
    }
  }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Minimum Stack -1</span>
import java.io.*;
import java.util.*;
public class Main {
  public static class MinStack {
    Stack< Integer> allData;
    Stack< Integer> minData;

    public MinStack() {
      allData = new Stack< >();
      minData = new Stack< >();
    }

    int size() {
      return allData.size();
    }

    void push(int val) {
      allData.push(val);
      if (minData.size() == 0 || val <= minData.peek()) {
        minData.push(val);
      }
    }

    int pop() {
      if (size() == 0) {
        System.out.println("Stack underflow");
        return -1;
      } else {
        int val = allData.pop();
        if (val == minData.peek()) {
          minData.pop();
        }
        return val;
      }
    }

    int top() {
      if (size() == 0) {
        System.out.println("Stack underflow");
        return -1;
      } else {
        return allData.peek();
      }
    }

    int min() {
      if (size() == 0) {
        System.out.println("Stack underflow");
        return -1;
      } else {
        return minData.peek();
      }
    }
  }

  public static void main(String[] args) throws Exception {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    MinStack st = new MinStack();

    String str = br.readLine();
    while (str.equals("quit") == false) {
      if (str.startsWith("push")) {
        int val = Integer.parseInt(str.split(" ")[1]);
        st.push(val);
      } else if (str.startsWith("pop")) {
        int val = st.pop();
        if (val != -1) {
          System.out.println(val);
        }
      } else if (str.startsWith("top")) {
        int val = st.top();
        if (val != -1) {
          System.out.println(val);
        }
      } else if (str.startsWith("size")) {
        System.out.println(st.size());
      } else if (str.startsWith("min")) {
        int val = st.min();
        if (val != -1) {
          System.out.println(val);
        }
      }
      str = br.readLine();
    }
  }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Minimum Stack - Constant Space</span>
import java.io.*;
import java.util.*;
public class Main {
  public static class MinStack {
    Stack< Integer> data;
    int min;

    public MinStack() {
      data = new Stack< >();
    }

    int size() {
      return data.size();
    }

    void push(int val) {
      if (size() == 0) {
        data.push(val);
        min = val;
      } else if (val < min) {
        data.push(val + val - min);
        min = val;
      } else {
        data.push(val);
      }
    }

    int pop() {
      if (size() == 0) {
        System.out.println("Stack underflow");
        return -1;
      } else{ 
        if (data.peek() < min) {
          int oval = min;
          min = 2 * min - data.pop();
          return oval;
        } else {
          return data.pop();
        }
      }
    }

    int top() {
      if (size() == 0) {
        System.out.println("Stack underflow");
        return -1;
      } else {
        if (data.peek() >= min) {
          return data.peek();
        } else {
          return min;
        }
      }
    }

    int min() {
      if (size() == 0) {
        System.out.println("Stack underflow");
        return -1;
      }
      else return min;
    }
  }

  public static void main(String[] args) throws Exception {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    MinStack st = new MinStack();

    String str = br.readLine();
    while (str.equals("quit") == false) {
      if (str.startsWith("push")) {
        int val = Integer.parseInt(str.split(" ")[1]);
        st.push(val);
      } else if (str.startsWith("pop")) {
        int val = st.pop();
        if (val != -1) {
          System.out.println(val);
        }
      } else if (str.startsWith("top")) {
        int val = st.top();
        if (val != -1) {
          System.out.println(val);
        }
      } else if (str.startsWith("size")) {
        System.out.println(st.size());
      } else if (str.startsWith("min")) {
        int val = st.min();
        if (val != -1) {
          System.out.println(val);
        }
      }
      str = br.readLine();
    }
  }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Introduction to Queues</span>
import java.util.*;
import java.lang.*;
import java.io.*;
class Main{
  public static void main (String[] args) throws java.lang.Exception{
    Queue< Integer> q = new ArrayDeque< >();
    q.add(10);
    System.out.println(q + "->" + q.peek() + " " + q.size());
    q.add(20);
    System.out.println(q + "->" + q.peek() + " " + q.size());
    q.add(30);
    System.out.println(q + "->" + q.peek() + " " + q.size());
    q.add(40);
    System.out.println(q + "->" + q.peek() + " " + q.size());
    q.remove();
    System.out.println(q + "->" + q.peek() + " " + q.size());
    q.remove();
    System.out.println(q + "->" + q.peek() + " " + q.size());
    q.remove();
    System.out.println(q + "->" + q.peek() + " " + q.size());
    q.remove();
    System.out.println(q + "->" + " " + q.size());
  }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Normal Queue-----Java Code For Linear Queue:</span>
import java.io.*;
import java.util.*;
public class Main {
  public static class CustomQueue {
    int[] data;
    int front;
    int size;

    public CustomQueue(int cap) {
      data = new int[cap];
      front = 0;
      size = 0;
    }

    int size() {
      return size;
    }

    void display() {
      for (int i = front; i < size; i++) {
        System.out.print(data[i] + " ");
      }
      System.out.println();
    }

    void add(int val) {

      if (size == data.length) { //if queue is already full
        System.out.println("Queue overflow");
      }
      else{
        int rear = front + size;
        data[rear] = val;
        size++; //as a new values is added
      }
    }

    int remove() {

      if (size == 0) { //if queue is already empty
        System.out.println("Queue underflow");
        return -1;
      } else {
        int val = data[front];
        front++; //queue will be from front to size
        size--; //as a value is removed

        return val;
      }
    }

    int peek() {

      if (size == 0) { //if queue is empty
        System.out.println("Queue underflow");
        return -1;
      } else {
        int val = data[front];
        return val;
      }
    }
  }

  public static void main(String[] args) throws Exception {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    int n = Integer.parseInt(br.readLine());
    CustomQueue qu = new CustomQueue(n);

    String str = br.readLine();
    while (str.equals("quit") == false) {
      if (str.startsWith("add")) {
        int val = Integer.parseInt(str.split(" ")[1]);
        qu.add(val);
      } else if (str.startsWith("remove")) {
        int val = qu.remove();
        if (val != -1) {
          System.out.println(val);
        }
      } else if (str.startsWith("peek")) {
        int val = qu.peek();
        if (val != -1) {
          System.out.println(val);
        }
      } else if (str.startsWith("size")) {
        System.out.println(qu.size());
      } else if (str.startsWith("display")) {
        qu.display();
      }
      str = br.readLine();
    }
  }
}
<span class="textStyle">Java Code For Circular Queue:</span>
import java.io.*;
import java.util.*;
public class Main {
  public static class CustomQueue {
    int[] data;
    int front;
    int size;

    public CustomQueue(int cap) {
      data = new int[cap];
      front = 0;
      size = 0;
    }

    int size() {
      return size;
    }

    void display() {
      for (int i = 0; i < size; i++) {
        int idx = (front + i) % data.length;
        System.out.print(data[idx] + " ");
      }
      System.out.println();
    }

    void add(int val) {

      if (size == data.length) {
        System.out.println("Queue overflow");
      } else {
        int idx = (front + size) % data.length;
        data[idx] = val;
        size++;
      }
    }

    int remove() {
      if (size == 0) {
        System.out.println("Queue underflow");
        return -1;
      } else {
        int val = data[front];

        front = (front + 1) % data.length;
        size--;

        return val;
      }
    }

    int peek() {

      if (size == 0) {
        System.out.println("Queue underflow");
        return -1;
      } else {
        int val = data[front];
        return val;
      }
    }
  }

  public static void main(String[] args) throws Exception {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    int n = Integer.parseInt(br.readLine());
    CustomQueue qu = new CustomQueue(n);

    String str = br.readLine();
    while (str.equals("quit") == false) {
      if (str.startsWith("add")) {
        int val = Integer.parseInt(str.split(" ")[1]);
        qu.add(val);
      } else if (str.startsWith("remove")) {
        int val = qu.remove();
        if (val != -1) {
          System.out.println(val);
        }
      } else if (str.startsWith("peek")) {
        int val = qu.peek();
        if (val != -1) {
          System.out.println(val);
        }
      } else if (str.startsWith("size")) {
        System.out.println(qu.size());
      } else if (str.startsWith("display")) {
        qu.display();
      }
      str = br.readLine();
    }
  }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Dynamic Queue</span>
import java.io.*;
import java.util.*;
public class Main {
  public static class CustomQueue {
    int[] data;
    int front;
    int size;

    public CustomQueue(int cap) {
      data = new int[cap];
      front = 0;
      size = 0;
    }

    int size() {
      return size;
    }

    void display() {
      for (int i = 0; i < size; i++) {
        int idx = (front + i) % data.length;
        System.out.print(data[idx] + " ");
      }
      System.out.println();
    }

    void add(int val) {

      if (size == data.length) {
        System.out.println("Queue overflow");
      } else {
        int idx = (front + size) % data.length;
        data[idx] = val;
        size++;
      }
    }

    int remove() {

      if (size == 0) {
        System.out.println("Queue underflow");
        return -1;
      } else {
        int val = data[front];

        front = (front + 1) % data.length;
        size--;

        return val;
      }
    }

    int peek() {

      if (size == 0) {
        System.out.println("Queue underflow");
        return -1;
      } else {
        int val = data[front];
        return val;
      }
    }
  }

  public static void main(String[] args) throws Exception {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    int n = Integer.parseInt(br.readLine());
    CustomQueue qu = new CustomQueue(n);

    String str = br.readLine();
    while (str.equals("quit") == false) {
      if (str.startsWith("add")) {
        int val = Integer.parseInt(str.split(" ")[1]);
        qu.add(val);
      } else if (str.startsWith("remove")) {
        int val = qu.remove();
        if (val != -1) {
          System.out.println(val);
        }
      } else if (str.startsWith("peek")) {
        int val = qu.peek();
        if (val != -1) {
          System.out.println(val);
        }
      } else if (str.startsWith("size")) {
        System.out.println(qu.size());
      } else if (str.startsWith("display")) {
        qu.display();
      }
      str = br.readLine();
    }
  }
}
<span class="textStyle">other approch</span>
import java.io.*;
import java.util.*;
public class Main {
  public static class CustomQueue {
    int[] data;
    int front;
    int size;

    public CustomQueue(int cap) {
      data = new int[cap];
      front = 0;
      size = 0;
    }

    int size() {
      return size;
    }

    void display() {
      for (int i = 0; i < size; i++) {
        int idx = (front + i) % data.length;
        System.out.print(data[idx] + " ");
      }
      System.out.println();
    }

    void add(int val) {

      if (size == data.length) {
        int[] arr = new int[2 * data.length];
        for (int i = 0; i < size; i++) {
          int idx = (front + i) % data.length;
          arr[i] = data[idx];
        }
        data = arr;
        front = 0;
      }

      int idx = (front + size) % data.length;
      data[idx] = val;
      size++;
    }

    int remove() {
      if (size == 0) {
        System.out.println("Queue underflow");
        return -1;
      } else {
        int val = data[front];

        front = (front + 1) % data.length;
        size--;

        return val;
      }
    }

    int peek() {

      if (size == 0) {
        System.out.println("Queue underflow");
        return -1;
      } else {
        int val = data[front];
        return val;
      }
    }
  }

  public static void main(String[] args) throws Exception {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    int n = Integer.parseInt(br.readLine());
    CustomQueue qu = new CustomQueue(n);

    String str = br.readLine();
    while (str.equals("quit") == false) {
      if (str.startsWith("add")) {
        int val = Integer.parseInt(str.split(" ")[1]);
        qu.add(val);
      } else if (str.startsWith("remove")) {
        int val = qu.remove();
        if (val != -1) {
          System.out.println(val);
        }
      } else if (str.startsWith("peek")) {
        int val = qu.peek();
        if (val != -1) {
          System.out.println(val);
        }
      } else if (str.startsWith("size")) {
        System.out.println(qu.size());
      } else if (str.startsWith("display")) {
        qu.display();
      }
      str = br.readLine();
    }
  }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Queue to Stack Adapter - Push Efficient</span>
import java.io.*;
import java.util.*;
public class Main {
  public static class QueueToStackAdapter {
    Queue< Integer> mainQ;
    Queue< Integer> helperQ;

    public QueueToStackAdapter() {
      mainQ = new ArrayDeque< >();
      helperQ = new ArrayDeque< >();
    }

    int size() {
      return mainQ.size();
    }

    void push(int val) {
      mainQ.add(val);
    }

    int pop() {
      if (size() == 0) {
        System.out.println("Stack underflow");
        return -1;
      } else {
        while (mainQ.size() > 1) {
          helperQ.add(mainQ.remove());
        }

        int val = mainQ.remove();

        while (helperQ.size() > 0) {
          mainQ.add(helperQ.remove());
        }

        return val;
      }
    }

    int top() {
      if (size() == 0) {
        System.out.println("Stack underflow");
        return -1;
      } else {
        while (mainQ.size() > 1) {
          helperQ.add(mainQ.remove());
        }

        int val = mainQ.remove();
        helperQ.add(val);

        while (helperQ.size() > 0) {
          mainQ.add(helperQ.remove());
        }

        return val;
      }
    }
  }

  public static void main(String[] args) throws Exception {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    QueueToStackAdapter st = new QueueToStackAdapter();

    String str = br.readLine();
    while (str.equals("quit") == false) {
      if (str.startsWith("push")) {
        int val = Integer.parseInt(str.split(" ")[1]);
        st.push(val);
      } else if (str.startsWith("pop")) {
        int val = st.pop();
        if (val != -1) {
          System.out.println(val);
        }
      } else if (str.startsWith("top")) {
        int val = st.top();
        if (val != -1) {
          System.out.println(val);
        }
      } else if (str.startsWith("size")) {
        System.out.println(st.size());
      }
      str = br.readLine();
    }
  }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Queue to Stack Adapter - Pop Efficient</span>
import java.io.*;
import java.util.*;
public class Main {
  public static class QueueToStackAdapter {
    Queue< Integer> mainQ;
    Queue< Integer> helperQ;

    public QueueToStackAdapter() {
      mainQ = new ArrayDeque< >();
      helperQ = new ArrayDeque< >();
    }

    int size() {
      return mainQ.size();
    }

    void push(int val) {
      while (mainQ.size() > 0) {
        helperQ.add(mainQ.remove());
      }

      mainQ.add(val);

      while (helperQ.size() > 0) {
        mainQ.add(helperQ.remove());
      }
    }

    int pop() {
      if (size() == 0) {
        System.out.println("Stack underflow");
        return -1;
      } else {
        return mainQ.remove();
      }
    }

    int top() {
      if (size() == 0) {
        System.out.println("Stack underflow");
        return -1;
      } else {
        return mainQ.peek();
      }
    }
  }

  public static void main(String[] args) throws Exception {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    QueueToStackAdapter st = new QueueToStackAdapter();

    String str = br.readLine();
    while (str.equals("quit") == false) {
      if (str.startsWith("push")) {
        int val = Integer.parseInt(str.split(" ")[1]);
        st.push(val);
      } else if (str.startsWith("pop")) {
        int val = st.pop();
        if (val != -1) {
          System.out.println(val);
        }
      } else if (str.startsWith("top")) {
        int val = st.top();
        if (val != -1) {
          System.out.println(val);
        }
      } else if (str.startsWith("size")) {
        System.out.println(st.size());
      }
      str = br.readLine();
    }
  }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Stack to Queue Adapter - Add Efficient</span>
import java.io.*;
import java.util.*;
public class Main {
  public static class StackToQueueAdapter {
    Stack< Integer> mainS;
    Stack< Integer> helperS;

    public StackToQueueAdapter() {
      mainS = new Stack< >();
      helperS = new Stack< >();
    }

    int size() {
      return mainS.size();
    }

    void add(int val) {
      mainS.push(val);
    }

    int remove() {
      if (size() == 0) {
        System.out.println("Queue underflow");
        return -1;
      } else {
        while (mainS.size() > 1) {
          helperS.push(mainS.pop());
        }

        int val = mainS.pop();

        while (helperS.size() > 0) {
          mainS.push(helperS.pop());
        }

        return val;
      }
    }

    int peek() {
      if (size() == 0) {
        System.out.println("Queue underflow");
        return -1;
      } else {
        while (mainS.size() > 1) {
          helperS.push(mainS.pop());
        }

        int val = mainS.pop();
        helperS.push(val);

        while (helperS.size() > 0) {
          mainS.push(helperS.pop());
        }

        return val;
      }
    }
  }

  public static void main(String[] args) throws Exception {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    StackToQueueAdapter qu = new StackToQueueAdapter();

    String str = br.readLine();
    while (str.equals("quit") == false) {
      if (str.startsWith("add")) {
        int val = Integer.parseInt(str.split(" ")[1]);
        qu.add(val);
      } else if (str.startsWith("remove")) {
        int val = qu.remove();
        if (val != -1) {
          System.out.println(val);
        }
      } else if (str.startsWith("peek")) {
        int val = qu.peek();
        if (val != -1) {
          System.out.println(val);
        }
      } else if (str.startsWith("size")) {
        System.out.println(qu.size());
      }
      str = br.readLine();
    }
  }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Stack to Queue Adapter- Remove Efficient</span>
import java.io.*;

import java.util.*;

public class Main {

  public static class StackToQueueAdapter {
    Stack< Integer> mainS;
    Stack< Integer> helperS;

    public StackToQueueAdapter() {
      mainS = new Stack< >();
      helperS = new Stack< >();
    }

    int size() {
      return mainS.size();
    }

    void add(int val) {
      while (mainS.size() > 0) {
        helperS.push(mainS.pop());
      }

      mainS.push(val);

      while (helperS.size() > 0) {
        mainS.push(helperS.pop());
      }
    }

    int remove() {
      if (size() == 0) {
        System.out.println("Queue underflow");
        return -1;
      } else {
        return mainS.pop();
      }
    }

    int peek() {
      if (size() == 0) {
        System.out.println("Queue underflow");
        return -1;
      } else {
        return mainS.peek();
      }
    }
  }

  public static void main(String[] args) throws Exception {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    StackToQueueAdapter qu = new StackToQueueAdapter();

    String str = br.readLine();
    while (str.equals("quit") == false) {
      if (str.startsWith("add")) {
        int val = Integer.parseInt(str.split(" ")[1]);
        qu.add(val);
      } else if (str.startsWith("remove")) {
        int val = qu.remove();
        if (val != -1) {
          System.out.println(val);
        }
      } else if (str.startsWith("peek")) {
        int val = qu.peek();
        if (val != -1) {
          System.out.println(val);
        }
      } else if (str.startsWith("size")) {
        System.out.println(qu.size());
      }
      str = br.readLine();
    }
  }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">TWO STACKS IN AN ARRAY</span>
import java.io.*;

import java.util.*;

public class Main {

  public static class TwoStack {
    int[] data;
    int tos1;
    int tos2;

    public TwoStack(int cap) {
      data = new int[cap];
      tos1 = -1;
      tos2 = data.length;
    }

    int size1() {
      return tos1 + 1;
    }

    int size2() {
      return data.length - tos2;
    }

    void push1(int val) {
      if (tos2 == tos1 + 1) {
        System.out.println("Stack overflow");

      } else {
        tos1++;
        data[tos1] = val;
      }
    }

    void push2(int val) {
      if (tos2 == tos1 + 1) {
        System.out.println("Stack overflow");

      } else {
        tos2--;
        data[tos2] = val;
      }
    }

    int pop1() {
      if (size1() == 0) {
        System.out.println("Stack underflow");
        return -1;

      } else {
        int val = data[tos1];
        tos1--;
        return val;
      }
    }

    int pop2() {
      if (size2() == 0) {
        System.out.println("Stack underflow");
        return -1;
      } else {
        int val = data[tos2];
        tos2++;
        return val;
      }
    }

    int top1() {
      if (size1() == 0) {
        System.out.println("Stack underflow");
        return -1;
      } else {
        int val = data[tos1];
        return val;
      }
    }

    int top2() {
      if (size2() == 0) {
        System.out.println("Stack underflow");
        return -1;
      } else {
        int val = data[tos2];
        return val;
      }
    }
  }

  public static void main(String[] args) throws Exception {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    int n = Integer.parseInt(br.readLine());
    TwoStack st = new TwoStack(n);

    String str = br.readLine();
    while (str.equals("quit") == false) {
      if (str.startsWith("push1")) {
        int val = Integer.parseInt(str.split(" ")[1]);
        st.push1(val);
      } else if (str.startsWith("pop1")) {
        int val = st.pop1();
        if (val != -1) {
          System.out.println(val);
        }
      } else if (str.startsWith("top1")) {
        int val = st.top1();
        if (val != -1) {
          System.out.println(val);
        }
      } else if (str.startsWith("size1")) {
        System.out.println(st.size1());
      } else if (str.startsWith("push2")) {
        int val = Integer.parseInt(str.split(" ")[1]);
        st.push2(val);
      } else if (str.startsWith("pop2")) {
        int val = st.pop2();
        if (val != -1) {
          System.out.println(val);
        }
      } else if (str.startsWith("top2")) {
        int val = st.top2();
        if (val != -1) {
          System.out.println(val);
        }
      } else if (str.startsWith("size2")) {
        System.out.println(st.size2());
      }
      str = br.readLine();
    }
  }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">LINKED LIST-INTRODUCTION</span>

Add Last in Linked List
import java.io.*;

import java.util.*;

public class Main {
  public static class Node {
    int data;
    Node next;
  }

  public static class LinkedList {
    Node head;
    Node tail;
    int size;

    void addLast(int val) {
      Node temp = new Node();
      temp.data = val;
      temp.next = null;

      if (size == 0) {
        head = tail = temp;
      } else {
        tail.next = temp;
        tail = temp;
      }

      size++;
    }
  }

  public static void testList(LinkedList list) {
    for (Node temp = list.head; temp != null; temp = temp.next) {
      System.out.println(temp.data);
    }
    System.out.println(list.size);

    if (list.size > 0) {
      System.out.println(list.tail.data);
    }
  }
  public static void main(String[] args) throws Exception {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    LinkedList list = new LinkedList();

    String str = br.readLine();
    while (str.equals("quit") == false) {
      if (str.startsWith("addLast")) {
        int val = Integer.parseInt(str.split(" ")[1]);
        list.addLast(val);
      }
      str = br.readLine();
    }

    testList(list);
  }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Display a Linked List</span>
import java.io.*;

import java.util.*;

public class Main {
  public static class Node {
    int data;
    Node next;
  }

  public static class LinkedList {
    Node head;
    Node tail;
    int size;

    void addLast(int val) {
      Node temp = new Node();
      temp.data = val;
      temp.next = null;

      if (size == 0) {
        head = tail = temp;
      } else {
        tail.next = temp;
        tail = temp;
      }

      size++;
    }

    public int size() {
      return size;
    }

    public void display() {
      for (Node temp = head; temp != null; temp = temp.next) {
        System.out.print(temp.data + " ");
      }
      System.out.println();
    }
  }

  public static void main(String[] args) throws Exception {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    LinkedList list = new LinkedList();

    String str = br.readLine();
    while (str.equals("quit") == false) {
      if (str.startsWith("addLast")) {
        int val = Integer.parseInt(str.split(" ")[1]);
        list.addLast(val);
      } else if (str.startsWith("size")) {
        System.out.println(list.size());
      } else if (str.startsWith("display")) {
        list.display();
      }
      str = br.readLine();
    }
  }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Remove First In LinkedList</span>
import java.io.*;

import java.util.*;

public class Main {
  public static class Node {
    int data;
    Node next;
  }

  public static class LinkedList {
    Node head;
    Node tail;
    int size;

    void addLast(int val) {
      Node temp = new Node();
      temp.data = val;
      temp.next = null;

      if (size == 0) {
        head = tail = temp;
      } else {
        tail.next = temp;
        tail = temp;
      }

      size++;
    }

    public int size() {
      return size;
    }

    public void display() {
      for (Node temp = head; temp != null; temp = temp.next) {
        System.out.print(temp.data + " ");
      }
      System.out.println();
    }

    public void removeFirst() {
      if (size == 0) {
        System.out.println("List is empty");
      } else if (size == 1) {
        head = tail = null;
        size--;
      } else {
        head = head.next;
        size--;
      }
    }
  }

  public static void main(String[] args) throws Exception {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    LinkedList list = new LinkedList();

    String str = br.readLine();
    while (str.equals("quit") == false) {
      if (str.startsWith("addLast")) {
        int val = Integer.parseInt(str.split(" ")[1]);
        list.addLast(val);
      } else if (str.startsWith("size")) {
        System.out.println(list.size());
      } else if (str.startsWith("display")) {
        list.display();
      } else if (str.startsWith("removeFirst")) {
        list.removeFirst();
      }
      str = br.readLine();
    }
  }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Get Value in Linked List</span>
import java.io.*;

import java.util.*;

public class Main {
  public static class Node {
    int data;
    Node next;
  }

  public static class LinkedList {
    Node head;
    Node tail;
    int size;

    void addLast(int val) {
      Node temp = new Node();
      temp.data = val;
      temp.next = null;

      if (size == 0) {
        head = tail = temp;
      } else {
        tail.next = temp;
        tail = temp;
      }

      size++;
    }

    public int size() {
      return size;
    }

    public void display() {
      for (Node temp = head; temp != null; temp = temp.next) {
        System.out.print(temp.data + " ");
      }
      System.out.println();
    }

    public void removeFirst() {
      if (size == 0) {
        System.out.println("List is empty");
      } else if (size == 1) {
        head = tail = null;
        size = 0;
      } else {
        head = head.next;
        size--;
      }
    }

    public int getFirst() {
      if (size == 0) {
        System.out.println("List is empty");
        return -1;
      } else {
        return head.data;
      }
    }

    public int getLast() {
      if (size == 0) {
        System.out.println("List is empty");
        return -1;
      } else {
        return tail.data;
      }
    }


    public int getAt(int idx) {
      if (size == 0) {
        System.out.println("List is empty");
        return -1;
      } else if (idx < 0 || idx >= size) {
        System.out.println("Invalid arguments");
        return -1;
      } else {
        Node temp = head;
        for (int i = 0; i < idx; i++) {
          temp = temp.next;
        }
        return temp.data;
      }
    }
  }

  public static void main(String[] args) throws Exception {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    LinkedList list = new LinkedList();

    String str = br.readLine();
    while (str.equals("quit") == false) {
      if (str.startsWith("addLast")) {
        int val = Integer.parseInt(str.split(" ")[1]);
        list.addLast(val);
      } else if (str.startsWith("size")) {
        System.out.println(list.size());
      } else if (str.startsWith("display")) {
        list.display();
      } else if (str.startsWith("removeFirst")) {
        list.removeFirst();
      } else if (str.startsWith("getFirst")) {
        int val = list.getFirst();
        if (val != -1) {
          System.out.println(val);
        }
      } else if (str.startsWith("getLast")) {
        int val = list.getLast();
        if (val != -1) {
          System.out.println(val);
        }
      } else if (str.startsWith("getAt")) {
        int idx = Integer.parseInt(str.split(" ")[1]);
        int val = list.getAt(idx);
        if (val != -1) {
          System.out.println(val);
        }
      }
      str = br.readLine();
    }
  }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Add First in a Linked List</span>
import java.io.*;

import java.util.*;

public class Main {
  public static class Node {
    int data;
    Node next;
  }

  public static class LinkedList {
    Node head;
    Node tail;
    int size;

    void addLast(int val) {
      Node temp = new Node();
      temp.data = val;
      temp.next = null;

      if (size == 0) {
        head = tail = temp;
      } else {
        tail.next = temp;
        tail = temp;
      }

      size++;
    }

    public int size() {
      return size;
    }

    public void display() {
      for (Node temp = head; temp != null; temp = temp.next) {
        System.out.print(temp.data + " ");
      }
      System.out.println();
    }

    public void removeFirst() {
      if (size == 0) {
        System.out.println("List is empty");
      } else if (size == 1) {
        head = tail = null;
        size = 0;
      } else {
        head = head.next;
        size--;
      }
    }

    public int getFirst() {
      if (size == 0) {
        System.out.println("List is empty");
        return -1;
      } else {
        return head.data;
      }
    }

    public int getLast() {
      if (size == 0) {
        System.out.println("List is empty");
        return -1;
      } else {
        return tail.data;
      }
    }

    public int getAt(int idx) {
      if (size == 0) {
        System.out.println("List is empty");
        return -1;
      } else if (idx < 0 || idx >= size) {
        System.out.println("Invalid arguments");
        return -1;
      } else {
        Node temp = head;
        for (int i = 0; i < idx; i++) {
          temp = temp.next;
        }
        return temp.data;
      }
    }

    public void addFirst(int val) {
      // write your code here

      Node t = new Node();
      t.data = val;
      t.next = head;
      if (size == 0)
      {
        tail = t;
      }
      head = t;
      size++;
    }
  }

  public static void main(String[] args) throws Exception {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    LinkedList list = new LinkedList();

    String str = br.readLine();
    while (str.equals("quit") == false) {
      if (str.startsWith("addLast")) {
        int val = Integer.parseInt(str.split(" ")[1]);
        list.addLast(val);
      } else if (str.startsWith("size")) {
        System.out.println(list.size());
      } else if (str.startsWith("display")) {
        list.display();
      } else if (str.startsWith("removeFirst")) {
        list.removeFirst();
      } else if (str.startsWith("getFirst")) {
        int val = list.getFirst();
        if (val != -1) {
          System.out.println(val);
        }
      } else if (str.startsWith("getLast")) {
        int val = list.getLast();
        if (val != -1) {
          System.out.println(val);
        }
      } else if (str.startsWith("getAt")) {
        int idx = Integer.parseInt(str.split(" ")[1]);
        int val = list.getAt(idx);
        if (val != -1) {
          System.out.println(val);
        }
      } else if (str.startsWith("addFirst")) {
        int val = Integer.parseInt(str.split(" ")[1]);
        list.addFirst(val);
      }
      str = br.readLine();
    }
  }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Add At Index In Linked List</span>
import java.io.*;

import java.util.*;

public class Main {
  public static class Node {
    int data;
    Node next;
  }

  public static class LinkedList {
    Node head;
    Node tail;
    int size;

    void addLast(int val) {
      Node temp = new Node();
      temp.data = val;
      temp.next = null;

      if (size == 0) {
        head = tail = temp;
      } else {
        tail.next = temp;
        tail = temp;
      }

      size++;
    }

    public int size() {
      return size;
    }

    public void display() {
      for (Node temp = head; temp != null; temp = temp.next) {
        System.out.print(temp.data + " ");
      }
      System.out.println();
    }

    public void removeFirst() {
      if (size == 0) {
        System.out.println("List is empty");
      } else if (size == 1) {
        head = tail = null;
        size = 0;
      } else {
        head = head.next;
        size--;
      }
    }

    public int getFirst() {
      if (size == 0) {
        System.out.println("List is empty");
        return -1;
      } else {
        return head.data;
      }
    }

    public int getLast() {
      if (size == 0) {
        System.out.println("List is empty");
        return -1;
      } else {
        return tail.data;
      }
    }

    public int getAt(int idx) {
      if (size == 0) {
        System.out.println("List is empty");
        return -1;
      } else if (idx < 0 || idx >= size) {
        System.out.println("Invalid arguments");
        return -1;
      } else {
        Node temp = head;
        for (int i = 0; i < idx; i++) {
          temp = temp.next;
        }
        return temp.data;
      }
    }

    public void addFirst(int val) {
      Node temp = new Node();
      temp.data = val;
      temp.next = head;
      head = temp;

      if (size == 0) {
        tail = temp;
      }

      size++;
    }

    public void addAt(int idx, int val) {
      if (idx < 0 || idx > size) {
        System.out.println("Invalid arguments");
      } else if (idx == 0) {
        addFirst(val);
      } else if (idx == size) {
        addLast(val);
      } else {
        Node node = new Node();
        node.data = val;
        Node temp = head;
        for (int i = 0; i < idx - 1; i++) {
          temp = temp.next;
        }
        node.next = temp.next;
        temp.next = node;
        size++;
      }
    }
  }

  public static void main(String[] args) throws Exception {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    LinkedList list = new LinkedList();

    String str = br.readLine();
    while (str.equals("quit") == false) {
      if (str.startsWith("addLast")) {
        int val = Integer.parseInt(str.split(" ")[1]);
        list.addLast(val);
      } else if (str.startsWith("size")) {
        System.out.println(list.size());
      } else if (str.startsWith("display")) {
        list.display();
      } else if (str.startsWith("removeFirst")) {
        list.removeFirst();
      } else if (str.startsWith("getFirst")) {
        int val = list.getFirst();
        if (val != -1) {
          System.out.println(val);
        }
      } else if (str.startsWith("getLast")) {
        int val = list.getLast();
        if (val != -1) {
          System.out.println(val);
        }
      } else if (str.startsWith("getAt")) {
        int idx = Integer.parseInt(str.split(" ")[1]);
        int val = list.getAt(idx);
        if (val != -1) {
          System.out.println(val);
        }
      } else if (str.startsWith("addFirst")) {
        int val = Integer.parseInt(str.split(" ")[1]);
        list.addFirst(val);
      } else if (str.startsWith("addAt")) {
        int idx = Integer.parseInt(str.split(" ")[1]);
        int val = Integer.parseInt(str.split(" ")[2]);
        list.addAt(idx, val);
      }
      str = br.readLine();
    }
  }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Remove Last in Linked List</span>
import java.io.*;

import java.util.*;

public class Main {
  public static class Node {
    int data;
    Node next;
  }

  public static class LinkedList {
    Node head;
    Node tail;
    int size;

    void addLast(int val) {
      Node temp = new Node();
      temp.data = val;
      temp.next = null;

      if (size == 0) {
        head = tail = temp;
      } else {
        tail.next = temp;
        tail = temp;
      }
      size++;
    }

    public int size() {
      return size;
    }

    public void display() {
      for (Node temp = head; temp != null; temp = temp.next) {
        System.out.print(temp.data + " ");
      }
      System.out.println();
    }

    public void removeFirst() {
      if (size == 0) {
        System.out.println("List is empty");
      } else if (size == 1) {
        head = tail = null;
        size = 0;
      } else {
        head = head.next;
        size--;
      }
    }

    public int getFirst() {
      if (size == 0) {
        System.out.println("List is empty");
        return -1;
      } else {
        return head.data;
      }
    }

    public int getLast() {
      if (size == 0) {
        System.out.println("List is empty");
        return -1;
      } else {
        return tail.data;
      }
    }

    public int getAt(int idx) {
      if (size == 0) {
        System.out.println("List is empty");
        return -1;
      } else if (idx < 0 || idx >= size) {
        System.out.println("Invalid arguments");
        return -1;
      } else {
        Node temp = head;
        for (int i = 0; i < idx; i++) {
          temp = temp.next;
        }
        return temp.data;
      }
    }

    public void addFirst(int val) {
      Node temp = new Node();
      temp.data = val;
      temp.next = head;
      head = temp;

      if (size == 0) {
        tail = temp;
      }
      size++;
    }

    public void addAt(int idx, int val) {
      if (idx < 0 || idx > size) {
        System.out.println("Invalid arguments");
      } else if (idx == 0) {
        addFirst(val);
      } else if (idx == size) {
        addLast(val);
      } else {
        Node node = new Node();
        node.data = val;

        Node temp = head;
        for (int i = 0; i < idx - 1; i++) {
          temp = temp.next;
        }
        node.next = temp.next;
        temp.next = node;
        size++;
      }
    }

    public void removeLast() {
      if (size == 0) {
        System.out.println("List is empty");
      } else if (size == 1) {
        head = tail = null;
        size = 0;
      } else {
        Node temp = head;
        for (int i = 0; i < size - 2; i++) {
          temp = temp.next;
        }
        tail = temp;
        tail.next = null;
        size--;
      }
    }
  }

  public static void main(String[] args) throws Exception {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    LinkedList list = new LinkedList();

    String str = br.readLine();
    while (str.equals("quit") == false) {
      if (str.startsWith("addLast")) {
        int val = Integer.parseInt(str.split(" ")[1]);
        list.addLast(val);
      } else if (str.startsWith("size")) {
        System.out.println(list.size());
      } else if (str.startsWith("display")) {
        list.display();
      } else if (str.startsWith("removeFirst")) {
        list.removeFirst();
      } else if (str.startsWith("getFirst")) {
        int val = list.getFirst();
        if (val != -1) {
          System.out.println(val);
        }
      } else if (str.startsWith("getLast")) {
        int val = list.getLast();
        if (val != -1) {
          System.out.println(val);
        }
      } else if (str.startsWith("getAt")) {
        int idx = Integer.parseInt(str.split(" ")[1]);
        int val = list.getAt(idx);
        if (val != -1) {
          System.out.println(val);
        }
      } else if (str.startsWith("addFirst")) {
        int val = Integer.parseInt(str.split(" ")[1]);
        list.addFirst(val);
      } else if (str.startsWith("addAt")) {
        int idx = Integer.parseInt(str.split(" ")[1]);
        int val = Integer.parseInt(str.split(" ")[2]);
        list.addAt(idx, val);
      } else if (str.startsWith("removeLast")) {
        list.removeLast();
      }
      str = br.readLine();
    }
  }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Remove At Index in Linked List</span>
import java.io.*;

import java.util.*;

public class Main {
  public static class Node {
    int data;
    Node next;
  }

  public static class LinkedList {
    Node head;
    Node tail;
    int size;

    void addLast(int val) {
      Node temp = new Node();
      temp.data = val;
      temp.next = null;

      if (size == 0) {
        head = tail = temp;
      } else {
        tail.next = temp;
        tail = temp;
      }

      size++;
    }

    public int size() {
      return size;
    }

    public void display() {
      for (Node temp = head; temp != null; temp = temp.next) {
        System.out.print(temp.data + " ");
      }
      System.out.println();
    }

    public void removeFirst() {
      if (size == 0) {
        System.out.println("List is empty");
      } else if (size == 1) {
        head = tail = null;
        size = 0;
      } else {
        head = head.next;
        size--;
      }
    }

    public int getFirst() {
      if (size == 0) {
        System.out.println("List is empty");
        return -1;
      } else {
        return head.data;
      }
    }

    public int getLast() {
      if (size == 0) {
        System.out.println("List is empty");
        return -1;
      } else {
        return tail.data;
      }
    }

    public int getAt(int idx) {
      if (size == 0) {
        System.out.println("List is empty");
        return -1;
      } else if (idx < 0 || idx >= size) {
        System.out.println("Invalid arguments");
        return -1;
      } else {
        Node temp = head;
        for (int i = 0; i < idx; i++) {
          temp = temp.next;
        }
        return temp.data;
      }
    }

    public void addFirst(int val) {
      Node temp = new Node();
      temp.data = val;
      temp.next = head;
      head = temp;

      if (size == 0) {
        tail = temp;
      }

      size++;
    }

    public void addAt(int idx, int val) {
      if (idx < 0 || idx > size) {
        System.out.println("Invalid arguments");
      } else if (idx == 0) {
        addFirst(val);
      } else if (idx == size) {
        addLast(val);
      } else {
        Node node = new Node();
        node.data = val;

        Node temp = head;
        for (int i = 0; i < idx - 1; i++) {
          temp = temp.next;
        }
        node.next = temp.next;

        temp.next = node;
        size++;
      }
    }

    public void removeLast() {
      if (size == 0) {
        System.out.println("List is empty");
      } else if (size == 1) {
        head = tail = null;
        size = 0;
      } else {
        Node temp = head;
        for (int i = 0; i < size - 2; i++) {
          temp = temp.next;
        }

        tail = temp;
        tail.next = null;
        size--;
      }
    }

    c

    public static void main(String[] args) throws Exception {
      BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
      LinkedList list = new LinkedList();

      String str = br.readLine();
      while (str.equals("quit") == false) {
        if (str.startsWith("addLast")) {
          int val = Integer.parseInt(str.split(" ")[1]);
          list.addLast(val);
        } else if (str.startsWith("size")) {
          System.out.println(list.size());
        } else if (str.startsWith("display")) {
          list.display();
        } else if (str.startsWith("removeFirst")) {
          list.removeFirst();
        } else if (str.startsWith("getFirst")) {
          int val = list.getFirst();
          if (val != -1) {
            System.out.println(val);
          }
        } else if (str.startsWith("getLast")) {
          int val = list.getLast();
          if (val != -1) {
            System.out.println(val);
          }
        } else if (str.startsWith("getAt")) {
          int idx = Integer.parseInt(str.split(" ")[1]);
          int val = list.getAt(idx);
          if (val != -1) {
            System.out.println(val);
          }
        } else if (str.startsWith("addFirst")) {
          int val = Integer.parseInt(str.split(" ")[1]);
          list.addFirst(val);
        } else if (str.startsWith("addAt")) {
          int idx = Integer.parseInt(str.split(" ")[1]);
          int val = Integer.parseInt(str.split(" ")[2]);
          list.addAt(idx, val);
        } else if (str.startsWith("removeLast")) {
          list.removeLast();
        } else if (str.startsWith("removeAt")) {
          int idx = Integer.parseInt(str.split(" ")[1]);
          list.removeAt(idx);
        }
        str = br.readLine();
      }
    }
  }
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Reverse A Linked List (data Iterative)</span>
import java.io.*;

import java.util.*;

public class Main {
  public static class Node {
    int data;
    Node next;
  }

  public static class LinkedList {
    Node head;
    Node tail;
    int size;

    void addLast(int val) {
      Node temp = new Node();
      temp.data = val;
      temp.next = null;

      if (size == 0) {
        head = tail = temp;
      } else {
        tail.next = temp;
        tail = temp;
      }

      size++;
    }

    public int size() {
      return size;
    }

    public void display() {
      for (Node temp = head; temp != null; temp = temp.next) {
        System.out.print(temp.data + " ");
      }
      System.out.println();
    }

    public void removeFirst() {
      if (size == 0) {
        System.out.println("List is empty");
      } else if (size == 1) {
        head = tail = null;
        size = 0;
      } else {
        head = head.next;
        size--;
      }
    }

    public int getFirst() {
      if (size == 0) {
        System.out.println("List is empty");
        return -1;
      } else {
        return head.data;
      }
    }

    public int getLast() {
      if (size == 0) {
        System.out.println("List is empty");
        return -1;
      } else {
        return tail.data;
      }
    }

    public int getAt(int idx) {
      if (size == 0) {
        System.out.println("List is empty");
        return -1;
      } else if (idx < 0 || idx >= size) {
        System.out.println("Invalid arguments");
        return -1;
      } else {
        Node temp = head;
        for (int i = 0; i < idx; i++) {
          temp = temp.next;
        }
        return temp.data;
      }
    }

    public void addFirst(int val) {
      Node temp = new Node();
      temp.data = val;
      temp.next = head;
      head = temp;

      if (size == 0) {
        tail = temp;
      }

      size++;
    }

    public void addAt(int idx, int val) {
      if (idx < 0 || idx > size) {
        System.out.println("Invalid arguments");
      } else if (idx == 0) {
        addFirst(val);
      } else if (idx == size) {
        addLast(val);
      } else {
        Node node = new Node();
        node.data = val;

        Node temp = head;
        for (int i = 0; i < idx - 1; i++) {
          temp = temp.next;
        }
        node.next = temp.next;

        temp.next = node;
        size++;
      }
    }

    public void removeLast() {
      if (size == 0) {
        System.out.println("List is empty");
      } else if (size == 1) {
        head = tail = null;
        size = 0;
      } else {
        Node temp = head;
        for (int i = 0; i < size - 2; i++) {
          temp = temp.next;
        }

        tail = temp;
        tail.next = null;
        size--;
      }
    }

    public void removeAt(int idx) {
      if (idx < 0 || idx >= size) {
        System.out.println("Invalid arguments");
      } else if (idx == 0) {
        removeFirst();
      } else if (idx == size - 1) {
        removeLast();
      } else {
        Node temp = head;
        for (int i = 0; i < idx - 1; i++) {
          temp = temp.next;
        }

        temp.next = temp.next.next;
        size--;
      }
    }

    private Node getNodeAt(int idx) {
      Node temp = head;
      for (int i = 0; i < idx; i++) {
        temp = temp.next;
      }
      return temp;
    }

    public void reverseDI() {
      int li = 0;
      int ri = size - 1;

      while (li < ri) {
        Node left = getNodeAt(li);
        Node right = getNodeAt(ri);

        int temp = left.data;
        left.data = right.data;
        right.data = temp;

        li++;
        ri--;
      }
    }
  }

  public static void main(String[] args) throws Exception {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    LinkedList list = new LinkedList();

    String str = br.readLine();
    while (str.equals("quit") == false) {
      if (str.startsWith("addLast")) {
        int val = Integer.parseInt(str.split(" ")[1]);
        list.addLast(val);
      } else if (str.startsWith("size")) {
        System.out.println(list.size());
      } else if (str.startsWith("display")) {
        list.display();
      } else if (str.startsWith("removeFirst")) {
        list.removeFirst();
      } else if (str.startsWith("getFirst")) {
        int val = list.getFirst();
        if (val != -1) {
          System.out.println(val);
        }
      } else if (str.startsWith("getLast")) {
        int val = list.getLast();
        if (val != -1) {
          System.out.println(val);
        }
      } else if (str.startsWith("getAt")) {
        int idx = Integer.parseInt(str.split(" ")[1]);
        int val = list.getAt(idx);
        if (val != -1) {
          System.out.println(val);
        }
      } else if (str.startsWith("addFirst")) {
        int val = Integer.parseInt(str.split(" ")[1]);
        list.addFirst(val);
      } else if (str.startsWith("addAt")) {
        int idx = Integer.parseInt(str.split(" ")[1]);
        int val = Integer.parseInt(str.split(" ")[2]);
        list.addAt(idx, val);
      } else if (str.startsWith("removeLast")) {
        list.removeLast();
      } else if (str.startsWith("removeAt")) {
        int idx = Integer.parseInt(str.split(" ")[1]);
        list.removeAt(idx);
      } else if (str.startsWith("reverseDI")) {
        list.reverseDI();
      }
      str = br.readLine();
    }
  }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Reverse Linked List (pointer Iterative)</span>
import java.io.*;

import java.util.*;

public class Main {
  public static class Node {
    int data;
    Node next;
  }

  public static class LinkedList {
    Node head;
    Node tail;
    int size;

    void addLast(int val) {
      Node temp = new Node();
      temp.data = val;
      temp.next = null;

      if (size == 0) {
        head = tail = temp;
      } else {
        tail.next = temp;
        tail = temp;
      }

      size++;
    }

    public int size() {
      return size;
    }

    public void display() {
      for (Node temp = head; temp != null; temp = temp.next) {
        System.out.print(temp.data + " ");
      }
      System.out.println();
    }

    public void removeFirst() {
      if (size == 0) {
        System.out.println("List is empty");
      } else if (size == 1) {
        head = tail = null;
        size = 0;
      } else {
        head = head.next;
        size--;
      }
    }

    public int getFirst() {
      if (size == 0) {
        System.out.println("List is empty");
        return -1;
      } else {
        return head.data;
      }
    }

    public int getLast() {
      if (size == 0) {
        System.out.println("List is empty");
        return -1;
      } else {
        return tail.data;
      }
    }

    public int getAt(int idx) {
      if (size == 0) {
        System.out.println("List is empty");
        return -1;
      } else if (idx < 0 || idx >= size) {
        System.out.println("Invalid arguments");
        return -1;
      } else {
        Node temp = head;
        for (int i = 0; i < idx; i++) {
          temp = temp.next;
        }
        return temp.data;
      }
    }

    public void addFirst(int val) {
      Node temp = new Node();
      temp.data = val;
      temp.next = head;
      head = temp;

      if (size == 0) {
        tail = temp;
      }

      size++;
    }

    public void addAt(int idx, int val) {
      if (idx < 0 || idx > size) {
        System.out.println("Invalid arguments");
      } else if (idx == 0) {
        addFirst(val);
      } else if (idx == size) {
        addLast(val);
      } else {
        Node node = new Node();
        node.data = val;

        Node temp = head;
        for (int i = 0; i < idx - 1; i++) {
          temp = temp.next;
        }
        node.next = temp.next;

        temp.next = node;
        size++;
      }
    }

    public void removeLast() {
      if (size == 0) {
        System.out.println("List is empty");
      } else if (size == 1) {
        head = tail = null;
        size = 0;
      } else {
        Node temp = head;
        for (int i = 0; i < size - 2; i++) {
          temp = temp.next;
        }

        tail = temp;
        tail.next = null;
        size--;
      }
    }

    public void removeAt(int idx) {
      if (idx < 0 || idx >= size) {
        System.out.println("Invalid arguments");
      } else if (idx == 0) {
        removeFirst();
      } else if (idx == size - 1) {
        removeLast();
      } else {
        Node temp = head;
        for (int i = 0; i < idx - 1; i++) {
          temp = temp.next;
        }

        temp.next = temp.next.next;
        size--;
      }
    }

    private Node getNodeAt(int idx) {
      Node temp = head;
      for (int i = 0; i < idx; i++) {
        temp = temp.next;
      }
      return temp;
    }

    public void reverseDI() {
      int li = 0;
      int ri = size - 1;
      while (li < ri) {
        Node left = getNodeAt(li);
        Node right = getNodeAt(ri);

        int temp = left.data;
        left.data = right.data;
        right.data = temp;

        li++;
        ri--;
      }
    }

    public void reversePI() {
      Node prev = null;
      Node curr = head;

      while (curr != null) {
        Node temp = curr.next;
        curr.next = prev;
        prev = curr;
        curr = temp;
      }

      Node t = head;
      head = tail;
      tail = t;
    }
  }

  public static void main(String[] args) throws Exception {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    LinkedList list = new LinkedList();

    String str = br.readLine();
    while (str.equals("quit") == false) {
      if (str.startsWith("addLast")) {
        int val = Integer.parseInt(str.split(" ")[1]);
        list.addLast(val);
      } else if (str.startsWith("size")) {
        System.out.println(list.size());
      } else if (str.startsWith("display")) {
        list.display();
      } else if (str.startsWith("removeFirst")) {
        list.removeFirst();
      } else if (str.startsWith("getFirst")) {
        int val = list.getFirst();
        if (val != -1) {
          System.out.println(val);
        }
      } else if (str.startsWith("getLast")) {
        int val = list.getLast();
        if (val != -1) {
          System.out.println(val);
        }
      } else if (str.startsWith("getAt")) {
        int idx = Integer.parseInt(str.split(" ")[1]);
        int val = list.getAt(idx);
        if (val != -1) {
          System.out.println(val);
        }
      } else if (str.startsWith("addFirst")) {
        int val = Integer.parseInt(str.split(" ")[1]);
        list.addFirst(val);
      } else if (str.startsWith("addAt")) {
        int idx = Integer.parseInt(str.split(" ")[1]);
        int val = Integer.parseInt(str.split(" ")[2]);
        list.addAt(idx, val);
      } else if (str.startsWith("removeLast")) {
        list.removeLast();
      } else if (str.startsWith("removeAt")) {
        int idx = Integer.parseInt(str.split(" ")[1]);
        list.removeAt(idx);
      } else if (str.startsWith("reverseDI")) {
        list.reverseDI();
      } else if (str.startsWith("reversePI")) {
        list.reversePI();
      }
      str = br.readLine();
    }
  }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Linked List to Stack Adapter</span>
import java.io.*;

import java.util.*;

public class Main {

  public static class LLToStackAdapter {
    LinkedList< Integer> list;

    public LLToStackAdapter() {
      list = new LinkedList< >();
    }

    int size() {
      return list.size();
    }

    void push(int val) {
      list.addFirst(val);
    }

    int pop() {
      if (size() == 0) {
        System.out.println("Stack underflow");
        return -1;
      } else {
        int val = list.getFirst();
        list.removeFirst();
        return val;
      }
    }

    int top() {
      if (size() == 0) {
        System.out.println("Stack underflow");
        return -1;
      } else {
        int val = list.getFirst();
        return val;
      }
    }
  }

  public static void main(String[] args) throws Exception {
    BufferedReader br = new BufferedReader(new    InputStreamReader(System.in));
    LLToStackAdapter st = new LLToStackAdapter();

    String str = br.readLine();
    while (str.equals("quit") == false) {
      if (str.startsWith("push")) {
        int val = Integer.parseInt(str.split(" ")[1]);
        st.push(val);
      } else if (str.startsWith("pop")) {
        int val = st.pop();
        if (val != -1) {
          System.out.println(val);
        }
      } else if (str.startsWith("top")) {
        int val = st.top();
        if (val != -1) {
          System.out.println(val);
        }
      } else if (str.startsWith("size")) {
        System.out.println(st.size());
      }
      str = br.readLine();
    }
  }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Linked List to Queue Adapter</span>
import java.io.*;

import java.util.*;

public class Main {

  public static class LLToQueueAdapter {
    LinkedList< Integer> list;

    public LLToQueueAdapter() {
      list = new LinkedList< >();
    }

    int size() {
      return list.size();
    }

    void add(int val) {
      list.addLast(val);
    }

    int remove() {
      if (size() == 0) {
        System.out.println("Queue underflow");
        return -1;
      } else {
        return list.removeFirst();
      }
    }

    int peek() {
      if (size() == 0) {
        System.out.println("Queue underflow");
        return -1;
      } else {
        return list.getFirst();
      }
    }
  }

  public static void main(String[] args) throws Exception {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    LLToQueueAdapter qu = new LLToQueueAdapter();

    String str = br.readLine();
    while (str.equals("quit") == false) {
      if (str.startsWith("add")) {
        int val = Integer.parseInt(str.split(" ")[1]);
        qu.add(val);
      } else if (str.startsWith("remove")) {
        int val = qu.remove();
        if (val != -1) {
          System.out.println(val);
        }
      } else if (str.startsWith("peek")) {
        int val = qu.peek();
        if (val != -1) {
          System.out.println(val);
        }
      } else if (str.startsWith("size")) {
        System.out.println(qu.size());
      }
      str = br.readLine();
    }
  }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Kth Node from End of Linked List</span>
import java.io.*;

import java.util.*;

public class Main {
  public static class Node {
    int data;
    Node next;
  }

  public static class LinkedList {
    Node head;
    Node tail;
    int size;

    void addLast(int val) {
      Node temp = new Node();
      temp.data = val;
      temp.next = null;

      if (size == 0) {
        head = tail = temp;
      } else {
        tail.next = temp;
        tail = temp;
      }

      size++;
    }

    public int size() {
      return size;
    }

    public void display() {
      for (Node temp = head; temp != null; temp = temp.next) {
        System.out.print(temp.data + " ");
      }
      System.out.println();
    }

    public void removeFirst() {
      if (size == 0) {
        System.out.println("List is empty");
      } else if (size == 1) {
        head = tail = null;
        size = 0;
      } else {
        head = head.next;
        size--;
      }
    }

    public int getFirst() {
      if (size == 0) {
        System.out.println("List is empty");
        return -1;
      } else {
        return head.data;
      }
    }

    public int getLast() {
      if (size == 0) {
        System.out.println("List is empty");
        return -1;
      } else {
        return tail.data;
      }
    }

    public int getAt(int idx) {
      if (size == 0) {
        System.out.println("List is empty");
        return -1;
      } else if (idx < 0 || idx >= size) {
        System.out.println("Invalid arguments");
        return -1;
      } else {
        Node temp = head;
        for (int i = 0; i < idx; i++) {
          temp = temp.next;
        }
        return temp.data;
      }
    }

    public void addFirst(int val) {
      Node temp = new Node();
      temp.data = val;
      temp.next = head;
      head = temp;

      if (size == 0) {
        tail = temp;
      }

      size++;
    }

    public void addAt(int idx, int val) {
      if (idx < 0 || idx > size) {
        System.out.println("Invalid arguments");
      } else if (idx == 0) {
        addFirst(val);
      } else if (idx == size) {
        addLast(val);
      } else {
        Node node = new Node();
        node.data = val;

        Node temp = head;
        for (int i = 0; i < idx - 1; i++) {
          temp = temp.next;
        }
        node.next = temp.next;

        temp.next = node;
        size++;
      }
    }

    public void removeLast() {
      if (size == 0) {
        System.out.println("List is empty");
      } else if (size == 1) {
        head = tail = null;
        size = 0;
      } else {
        Node temp = head;
        for (int i = 0; i < size - 2; i++) {
          temp = temp.next;
        }

        tail = temp;
        tail.next = null;
        size--;
      }
    }

    public void removeAt(int idx) {
      if (idx < 0 || idx >= size) {
        System.out.println("Invalid arguments");
      } else if (idx == 0) {
        removeFirst();
      } else if (idx == size - 1) {
        removeLast();
      } else {
        Node temp = head;
        for (int i = 0; i < idx - 1; i++) {
          temp = temp.next;
        }

        temp.next = temp.next.next;
        size--;
      }
    }

    private Node getNodeAt(int idx) {
      Node temp = head;
      for (int i = 0; i < idx; i++) {
        temp = temp.next;
      }
      return temp;
    }

    public void reverseDI() {
      int li = 0;
      int ri = size - 1;
      while (li < ri) {
        Node left = getNodeAt(li);
        Node right = getNodeAt(ri);

        int temp = left.data;
        left.data = right.data;
        right.data = temp;

        li++;
        ri--;
      }
    }

    public void reversePI() {
      if (size <= 1) {
        return;
      }

      Node prev = null;
      Node curr = head;
      while (curr != null) {
        Node next = curr.next;

        curr.next = prev;
        prev = curr;
        curr = next;
      }

      Node temp = head;
      head = tail;
      tail = temp;
    }

    public int kthFromLast(int k) {
      Node slow = head;
      Node fast = head;
      for (int i = 0; i < k; i++) {
        fast = fast.next;
      }

      while (fast != tail) {
        slow = slow.next;
        fast = fast.next;
      }

      return slow.data;
    }
  }

  public static void main(String[] args) throws Exception {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    LinkedList list = new LinkedList();

    String str = br.readLine();
    while (str.equals("quit") == false) {
      if (str.startsWith("addLast")) {
        int val = Integer.parseInt(str.split(" ")[1]);
        list.addLast(val);
      } else if (str.startsWith("size")) {
        System.out.println(list.size());
      } else if (str.startsWith("display")) {
        list.display();
      } else if (str.startsWith("removeFirst")) {
        list.removeFirst();
      } else if (str.startsWith("getFirst")) {
        int val = list.getFirst();
        if (val != -1) {
          System.out.println(val);
        }
      } else if (str.startsWith("getLast")) {
        int val = list.getLast();
        if (val != -1) {
          System.out.println(val);
        }
      } else if (str.startsWith("getAt")) {
        int idx = Integer.parseInt(str.split(" ")[1]);
        int val = list.getAt(idx);
        if (val != -1) {
          System.out.println(val);
        }
      } else if (str.startsWith("addFirst")) {
        int val = Integer.parseInt(str.split(" ")[1]);
        list.addFirst(val);
      } else if (str.startsWith("addAt")) {
        int idx = Integer.parseInt(str.split(" ")[1]);
        int val = Integer.parseInt(str.split(" ")[2]);
        list.addAt(idx, val);
      } else if (str.startsWith("removeLast")) {
        list.removeLast();
      } else if (str.startsWith("removeAt")) {
        int idx = Integer.parseInt(str.split(" ")[1]);
        list.removeAt(idx);
      } else if (str.startsWith("reverseDI")) {
        list.reverseDI();
      } else if (str.startsWith("reversePI")) {
        list.reversePI();
      } else if (str.startsWith("kthFromEnd")) {
        int idx = Integer.parseInt(str.split(" ")[1]);
        System.out.println(list.kthFromLast(idx));
      }
      str = br.readLine();
    }
  }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Mid of Linked List</span>
import java.io.*;

import java.util.*;

public int mid() {
  Node s = head;
  Node f = head;
  while (f.next != null && f.next.next != null)
  { s = s.next;
    f = f.next.next;
  }
  return s.data;
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Merge Two Sorted Linked List</span>
import java.io.*;

import java.util.*;

public static LinkedList mergeTwoSortedLists(LinkedList l1, LinkedList l2) {
  Node one = l1.head;
  Node two = l2.head;
  LinkedList res = new LinkedList();
  while (one != null && two != null) {
    if (one.data < two.data) {
      res.addLast(one.data);
      one = one.next;
    } else {
      res.addLast(two.data);
      two = two.next;
    }
  }
  while (one != null) {
    res.addLast(one.data);
    one = one.next;
  }
  while (two != null) {
    res.addLast(two.data);
    two = two.next;
  }
  return res;
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Merge Sort Linked List</span>
import java.io.*;

import java.util.*;

public class Main {
  public static class Node {
    int data;
    Node next;
  }

  public static class LinkedList {
    Node head;
    Node tail;
    int size;

    void addLast(int val) {
      Node temp = new Node();
      temp.data = val;
      temp.next = null;

      if (size == 0) {
        head = tail = temp;
      } else {
        tail.next = temp;
        tail = temp;
      }

      size++;
    }

    public int size() {
      return size;
    }

    public void display() {
      for (Node temp = head; temp != null; temp = temp.next) {
        System.out.print(temp.data + " ");
      }
      System.out.println();
    }

    public void removeFirst() {
      if (size == 0) {
        System.out.println("List is empty");
      } else if (size == 1) {
        head = tail = null;
        size = 0;
      } else {
        head = head.next;
        size--;
      }
    }

    public int getFirst() {
      if (size == 0) {
        System.out.println("List is empty");
        return -1;
      } else {
        return head.data;
      }
    }

    public int getLast() {
      if (size == 0) {
        System.out.println("List is empty");
        return -1;
      } else {
        return tail.data;
      }
    }

    public int getAt(int idx) {
      if (size == 0) {
        System.out.println("List is empty");
        return -1;
      } else if (idx < 0 || idx >= size) {
        System.out.println("Invalid arguments");
        return -1;
      } else {
        Node temp = head;
        for (int i = 0; i < idx; i++) {
          temp = temp.next;
        }
        return temp.data;
      }
    }

    public void addFirst(int val) {
      Node temp = new Node();
      temp.data = val;
      temp.next = head;
      head = temp;

      if (size == 0) {
        tail = temp;
      }

      size++;
    }

    public void addAt(int idx, int val) {
      if (idx < 0 || idx > size) {
        System.out.println("Invalid arguments");
      } else if (idx == 0) {
        addFirst(val);
      } else if (idx == size) {
        addLast(val);
      } else {
        Node node = new Node();
        node.data = val;

        Node temp = head;
        for (int i = 0; i < idx - 1; i++) {
          temp = temp.next;
        }
        node.next = temp.next;

        temp.next = node;
        size++;
      }
    }

    public void removeLast() {
      if (size == 0) {
        System.out.println("List is empty");
      } else if (size == 1) {
        head = tail = null;
        size = 0;
      } else {
        Node temp = head;
        for (int i = 0; i < size - 2; i++) {
          temp = temp.next;
        }

        tail = temp;
        tail.next = null;
        size--;
      }
    }

    public void removeAt(int idx) {
      if (idx < 0 || idx >= size) {
        System.out.println("Invalid arguments");
      } else if (idx == 0) {
        removeFirst();
      } else if (idx == size - 1) {
        removeLast();
      } else {
        Node temp = head;
        for (int i = 0; i < idx - 1; i++) {
          temp = temp.next;
        }

        temp.next = temp.next.next;
        size--;
      }
    }

    private Node getNodeAt(int idx) {
      Node temp = head;
      for (int i = 0; i < idx; i++) {
        temp = temp.next;
      }
      return temp;
    }

    public void reverseDI() {
      int li = 0;
      int ri = size - 1;
      while (li < ri) {
        Node left = getNodeAt(li);
        Node right = getNodeAt(ri);

        int temp = left.data;
        left.data = right.data;
        right.data = temp;

        li++;
        ri--;
      }
    }

    public void reversePI() {
      if (size <= 1) {
        return;
      }

      Node prev = null;
      Node curr = head;
      while (curr != null) {
        Node next = curr.next;

        curr.next = prev;
        prev = curr;
        curr = next;
      }

      Node temp = head;
      head = tail;
      tail = temp;
    }

    public int kthFromLast(int k) {
      Node slow = head;
      Node fast = head;
      for (int i = 0; i < k; i++) {
        fast = fast.next;
      }

      while (fast != tail) {
        slow = slow.next;
        fast = fast.next;
      }

      return slow.data;
    }

    public int mid() {
      Node f = head;
      Node s = head;

      while (f.next != null && f.next.next != null) {
        f = f.next.next;
        s = s.next;
      }

      return s.data;
    }

    public static LinkedList mergeTwoSortedLists(LinkedList l1, LinkedList l2) {
      LinkedList ml = new LinkedList();

      Node one = l1.head;
      Node two = l2.head;
      while (one != null && two != null) {
        if (one.data < two.data) {
          ml.addLast(one.data);
          one = one.next;
        } else {
          ml.addLast(two.data);
          two = two.next;
        }
      }

      while (one != null) {
        ml.addLast(one.data);
        one = one.next;
      }

      while (two != null) {
        ml.addLast(two.data);
        two = two.next;
      }

      return ml;
    }

    public static Node midNode(Node head, Node tail) {
      Node f = head;
      Node s = head;

      while (f != tail && f.next != tail) {
        f = f.next.next;
        s = s.next;
      }

      return s;
    }

    public static LinkedList mergeSort(Node head, Node tail) {
      if (head == tail) {
        LinkedList br = new LinkedList();
        br.addLast(head.data);
        return br;
      }

      Node mid = midNode(head, tail);
      LinkedList fsh = mergeSort(head, mid);
      LinkedList ssh = mergeSort(mid.next, tail);
      LinkedList sl = mergeTwoSortedLists(fsh, ssh);
      return sl;
    }
  }

  public static void main(String[] args) throws Exception {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

    int n1 = Integer.parseInt(br.readLine());
    LinkedList l1 = new LinkedList();
    String[] values1 = br.readLine().split(" ");
    for (int i = 0; i < n1; i++) {
      int d = Integer.parseInt(values1[i]);
      l1.addLast(d);
    }

    LinkedList sorted = LinkedList.mergeSort(l1.head, l1.tail);
    sorted.display();
    l1.display();
  }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Remove Duplicates in Sorted Linked List</span>
import java.io.*;

import java.util.*;

public class Main {
  public static class Node {
    int data;
    Node next;
  }

  public static class LinkedList {
    Node head;
    Node tail;
    int size;

    void addLast(int val) {
      Node temp = new Node();
      temp.data = val;
      temp.next = null;

      if (size == 0) {
        head = tail = temp;
      } else {
        tail.next = temp;
        tail = temp;
      }

      size++;
    }

    public int size() {
      return size;
    }

    public void display() {
      for (Node temp = head; temp != null; temp = temp.next) {
        System.out.print(temp.data + " ");
      }
      System.out.println();
    }

    public void removeFirst() {
      if (size == 0) {
        System.out.println("List is empty");
      } else if (size == 1) {
        head = tail = null;
        size = 0;
      } else {
        head = head.next;
        size--;
      }
    }

    public int getFirst() {
      if (size == 0) {
        System.out.println("List is empty");
        return -1;
      } else {
        return head.data;
      }
    }

    public int getLast() {
      if (size == 0) {
        System.out.println("List is empty");
        return -1;
      } else {
        return tail.data;
      }
    }

    public int getAt(int idx) {
      if (size == 0) {
        System.out.println("List is empty");
        return -1;
      } else if (idx < 0 || idx >= size) {
        System.out.println("Invalid arguments");
        return -1;
      } else {
        Node temp = head;
        for (int i = 0; i < idx; i++) {
          temp = temp.next;
        }
        return temp.data;
      }
    }

    public void addFirst(int val) {
      Node temp = new Node();
      temp.data = val;
      temp.next = head;
      head = temp;

      if (size == 0) {
        tail = temp;
      }

      size++;
    }

    public void addAt(int idx, int val) {
      if (idx < 0 || idx > size) {
        System.out.println("Invalid arguments");
      } else if (idx == 0) {
        addFirst(val);
      } else if (idx == size) {
        addLast(val);
      } else {
        Node node = new Node();
        node.data = val;

        Node temp = head;
        for (int i = 0; i < idx - 1; i++) {
          temp = temp.next;
        }
        node.next = temp.next;

        temp.next = node;
        size++;
      }
    }

    public void removeLast() {
      if (size == 0) {
        System.out.println("List is empty");
      } else if (size == 1) {
        head = tail = null;
        size = 0;
      } else {
        Node temp = head;
        for (int i = 0; i < size - 2; i++) {
          temp = temp.next;
        }

        tail = temp;
        tail.next = null;
        size--;
      }
    }

    public void removeAt(int idx) {
      if (idx < 0 || idx >= size) {
        System.out.println("Invalid arguments");
      } else if (idx == 0) {
        removeFirst();
      } else if (idx == size - 1) {
        removeLast();
      } else {
        Node temp = head;
        for (int i = 0; i < idx - 1; i++) {
          temp = temp.next;
        }

        temp.next = temp.next.next;
        size--;
      }
    }

    private Node getNodeAt(int idx) {
      Node temp = head;
      for (int i = 0; i < idx; i++) {
        temp = temp.next;
      }
      return temp;
    }

    // removes duplicates from a sorted linked list
    public void removeDuplicates() {
      LinkedList res = new LinkedList();

      while (this.size() > 0) {
        int val = this.getFirst();
        this.removeFirst();

        if (res.size() == 0 || val != res.tail.data) {
          res.addLast(val);
        }
      }

      this.head = res.head;
      this.tail = res.tail;
      this.size = res.size;
    }
  }

  public static void main(String[] args) throws Exception {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

    int n1 = Integer.parseInt(br.readLine());
    LinkedList l1 = new LinkedList();
    String[] values1 = br.readLine().split(" ");
    for (int i = 0; i < n1; i++) {
      int d = Integer.parseInt(values1[i]);
      l1.addLast(d);
    }

    l1.display();
    l1.removeDuplicates();
    l1.display();
  }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Odd Even Linked List</span>
import java.io.*;

import java.util.*;

public class Main {
  public static class Node {
    int data;
    Node next;
  }

  public static class LinkedList {
    Node head;
    Node tail;
    int size;

    void addLast(int val) {
      Node temp = new Node();
      temp.data = val;
      temp.next = null;

      if (size == 0) {
        head = tail = temp;
      } else {
        tail.next = temp;
        tail = temp;
      }

      size++;
    }

    public int size() {
      return size;
    }

    public void display() {
      for (Node temp = head; temp != null; temp = temp.next) {
        System.out.print(temp.data + " ");
      }
      System.out.println();
    }

    public void removeFirst() {
      if (size == 0) {
        System.out.println("List is empty");
      } else if (size == 1) {
        head = tail = null;
        size = 0;
      } else {
        head = head.next;
        size--;
      }
    }

    public int getFirst() {
      if (size == 0) {
        System.out.println("List is empty");
        return -1;
      } else {
        return head.data;
      }
    }

    public int getLast() {
      if (size == 0) {
        System.out.println("List is empty");
        return -1;
      } else {
        return tail.data;
      }
    }

    public void addFirst(int val) {
      Node temp = new Node();
      temp.data = val;
      temp.next = head;
      head = temp;

      if (size == 0) {
        tail = temp;
      }

      size++;
    }

    public void removeLast() {
      if (size == 0) {
        System.out.println("List is empty");
      } else if (size == 1) {
        head = tail = null;
        size = 0;
      } else {
        Node temp = head;
        for (int i = 0; i < size - 2; i++) {
          temp = temp.next;
        }

        tail = temp;
        tail.next = null;
        size--;
      }
    }

    private Node getNodeAt(int idx) {
      Node temp = head;
      for (int i = 0; i < idx; i++) {
        temp = temp.next;
      }
      return temp;
    }


    public void oddEven() {
      LinkedList odd = new LinkedList();
      LinkedList even = new LinkedList();

      while (this.size > 0) {
        int val = this.getFirst();
        this.removeFirst();

        if (val % 2 == 0) {
          even.addLast(val);
        } else {
          odd.addLast(val);
        }
      }

      if (odd.size > 0 && even.size > 0) {
        odd.tail.next = even.head;

        this.head = odd.head;
        this.tail = even.tail;
        this.size = odd.size + even.size;
      } else if (odd.size > 0) {
        this.head = odd.head;
        this.tail = odd.tail;
        this.size = odd.size;
      } else if (even.size > 0) {
        this.head = even.head;
        this.tail = even.tail;
        this.size = even.size;
      }
    }
  }

  public static void main(String[] args) throws Exception {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

    int n1 = Integer.parseInt(br.readLine());
    LinkedList l1 = new LinkedList();
    String[] values1 = br.readLine().split(" ");
    for (int i = 0; i < n1; i++) {
      int d = Integer.parseInt(values1[i]);
      l1.addLast(d);
    }

    int a = Integer.parseInt(br.readLine());
    int b = Integer.parseInt(br.readLine());

    l1.display();
    l1.oddEven();
    l1.display();
    l1.addFirst(a);
    l1.addLast(b);
    l1.display();
  }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">K Reverse In Linked List</span>
import java.io.*;

import java.util.*;

public class Main {
  public static class Node {
    int data;
    Node next;
  }

  public static class LinkedList {
    Node head;
    Node tail;
    int size;

    void addLast(int val) {
      Node temp = new Node();
      temp.data = val;
      temp.next = null;

      if (size == 0) {
        head = tail = temp;
      } else {
        tail.next = temp;
        tail = temp;
      }

      size++;
    }

    public int size() {
      return size;
    }

    public void display() {
      for (Node temp = head; temp != null; temp = temp.next) {
        System.out.print(temp.data + " ");
      }
      System.out.println();
    }

    public void removeFirst() {
      if (size == 0) {
        System.out.println("List is empty");
      } else if (size == 1) {
        head = tail = null;
        size = 0;
      } else {
        head = head.next;
        size--;
      }
    }

    public int getFirst() {
      if (size == 0) {
        System.out.println("List is empty");
        return -1;
      } else {
        return head.data;
      }
    }

    public int getLast() {
      if (size == 0) {
        System.out.println("List is empty");
        return -1;
      } else {
        return tail.data;
      }
    }

    public int getAt(int idx) {
      if (size == 0) {
        System.out.println("List is empty");
        return -1;
      } else if (idx < 0 || idx >= size) {
        System.out.println("Invalid arguments");
        return -1;
      } else {
        Node temp = head;
        for (int i = 0; i < idx; i++) {
          temp = temp.next;
        }
        return temp.data;
      }
    }

    public void addFirst(int val) {
      Node temp = new Node();
      temp.data = val;
      temp.next = head;
      head = temp;

      if (size == 0) {
        tail = temp;
      }

      size++;
    }

    public void addAt(int idx, int val) {
      if (idx < 0 || idx > size) {
        System.out.println("Invalid arguments");
      } else if (idx == 0) {
        addFirst(val);
      } else if (idx == size) {
        addLast(val);
      } else {
        Node node = new Node();
        node.data = val;

        Node temp = head;
        for (int i = 0; i < idx - 1; i++) {
          temp = temp.next;
        }
        node.next = temp.next;

        temp.next = node;
        size++;
      }
    }

    public void removeLast() {
      if (size == 0) {
        System.out.println("List is empty");
      } else if (size == 1) {
        head = tail = null;
        size = 0;
      } else {
        Node temp = head;
        for (int i = 0; i < size - 2; i++) {
          temp = temp.next;
        }

        tail = temp;
        tail.next = null;
        size--;
      }
    }

    public void removeAt(int idx) {
      if (idx < 0 || idx >= size) {
        System.out.println("Invalid arguments");
      } else if (idx == 0) {
        removeFirst();
      } else if (idx == size - 1) {
        removeLast();
      } else {
        Node temp = head;
        for (int i = 0; i < idx - 1; i++) {
          temp = temp.next;
        }

        temp.next = temp.next.next;
        size--;
      }
    }

    private Node getNodeAt(int idx) {
      Node temp = head;
      for (int i = 0; i < idx; i++) {
        temp = temp.next;
      }
      return temp;
    }

    public void kReverse(int k) {
      LinkedList prev = null;

      while (this.size > 0) {
        LinkedList curr = new LinkedList();

        if (this.size >= k) {
          for (int i = 0; i < k; i++) {
            int val = this.getFirst();
            this.removeFirst();
            curr.addFirst(val);
          }
        } else {
          int sz = this.size;
          for (int i = 0; i < sz; i++) {
            int val = this.getFirst();
            this.removeFirst();
            curr.addLast(val);
          }
        }

        if (prev == null) {
          prev = curr;
        } else {
          prev.tail.next = curr.head;
          prev.tail = curr.tail;
          prev.size += curr.size;
        }
      }

      this.head = prev.head;
      this.tail = prev.tail;
      this.size = prev.size;
    }
  }

  public static void main(String[] args) throws Exception {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

    int n1 = Integer.parseInt(br.readLine());
    LinkedList l1 = new LinkedList();
    String[] values1 = br.readLine().split(" ");
    for (int i = 0; i < n1; i++) {
      int d = Integer.parseInt(values1[i]);
      l1.addLast(d);
    }

    int k = Integer.parseInt(br.readLine());
    int a = Integer.parseInt(br.readLine());
    int b = Integer.parseInt(br.readLine());

    l1.display();
    l1.kReverse(k);
    l1.display();
    l1.addFirst(a);
    l1.addLast(b);
    l1.display();
  }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Display Reverse Recursive</span>
import java.io.*;

import java.util.*;

public class Main {
  public static class Node {
    int data;
    Node next;
  }

  public static class LinkedList {
    Node head;
    Node tail;
    int size;

    void addLast(int val) {
      Node temp = new Node();
      temp.data = val;
      temp.next = null;

      if (size == 0) {
        head = tail = temp;
      } else {
        tail.next = temp;
        tail = temp;
      }

      size++;
    }

    public int size() {
      return size;
    }

    public void display() {
      for (Node temp = head; temp != null; temp = temp.next) {
        System.out.print(temp.data + " ");
      }
      System.out.println();
    }

    public void removeFirst() {
      if (size == 0) {
        System.out.println("List is empty");
      } else if (size == 1) {
        head = tail = null;
        size = 0;
      } else {
        head = head.next;
        size--;
      }
    }

    public int getFirst() {
      if (size == 0) {
        System.out.println("List is empty");
        return -1;
      } else {
        return head.data;
      }
    }

    public int getLast() {
      if (size == 0) {
        System.out.println("List is empty");
        return -1;
      } else {
        return tail.data;
      }
    }

    public int getAt(int idx) {
      if (size == 0) {
        System.out.println("List is empty");
        return -1;
      } else if (idx < 0 || idx >= size) {
        System.out.println("Invalid arguments");
        return -1;
      } else {
        Node temp = head;
        for (int i = 0; i < idx; i++) {
          temp = temp.next;
        }
        return temp.data;
      }
    }

    public void addFirst(int val) {
      Node temp = new Node();
      temp.data = val;
      temp.next = head;
      head = temp;

      if (size == 0) {
        tail = temp;
      }

      size++;
    }

    public void addAt(int idx, int val) {
      if (idx < 0 || idx > size) {
        System.out.println("Invalid arguments");
      } else if (idx == 0) {
        addFirst(val);
      } else if (idx == size) {
        addLast(val);
      } else {
        Node node = new Node();
        node.data = val;

        Node temp = head;
        for (int i = 0; i < idx - 1; i++) {
          temp = temp.next;
        }
        node.next = temp.next;

        temp.next = node;
        size++;
      }
    }

    public void removeLast() {
      if (size == 0) {
        System.out.println("List is empty");
      } else if (size == 1) {
        head = tail = null;
        size = 0;
      } else {
        Node temp = head;
        for (int i = 0; i < size - 2; i++) {
          temp = temp.next;
        }

        tail = temp;
        tail.next = null;
        size--;
      }
    }

    public void removeAt(int idx) {
      if (idx < 0 || idx >= size) {
        System.out.println("Invalid arguments");
      } else if (idx == 0) {
        removeFirst();
      } else if (idx == size - 1) {
        removeLast();
      } else {
        Node temp = head;
        for (int i = 0; i < idx - 1; i++) {
          temp = temp.next;
        }

        temp.next = temp.next.next;
        size--;
      }
    }

    private Node getNodeAt(int idx) {
      Node temp = head;
      for (int i = 0; i < idx; i++) {
        temp = temp.next;
      }
      return temp;
    }

    public void reverseDI() {
      int li = 0;
      int ri = size - 1;
      while (li < ri) {
        Node left = getNodeAt(li);
        Node right = getNodeAt(ri);

        int temp = left.data;
        left.data = right.data;
        right.data = temp;

        li++;
        ri--;
      }
    }

    public void reversePI() {
      if (size <= 1) {
        return;
      }

      Node prev = null;
      Node curr = head;
      while (curr != null) {
        Node next = curr.next;

        curr.next = prev;
        prev = curr;
        curr = next;
      }

      Node temp = head;
      head = tail;
      tail = temp;
    }

    public int kthFromLast(int k) {
      Node slow = head;
      Node fast = head;
      for (int i = 0; i < k; i++) {
        fast = fast.next;
      }

      while (fast != tail) {
        slow = slow.next;
        fast = fast.next;
      }

      return slow.data;
    }

    public int mid() {
      Node f = head;
      Node s = head;

      while (f.next != null && f.next.next != null) {
        f = f.next.next;
        s = s.next;
      }

      return s.data;
    }

    public static LinkedList mergeTwoSortedLists(LinkedList l1, LinkedList l2) {
      LinkedList ml = new LinkedList();

      Node one = l1.head;
      Node two = l2.head;
      while (one != null && two != null) {
        if (one.data < two.data) {
          ml.addLast(one.data);
          one = one.next;
        } else {
          ml.addLast(two.data);
          two = two.next;
        }
      }

      while (one != null) {
        ml.addLast(one.data);
        one = one.next;
      }

      while (two != null) {
        ml.addLast(two.data);
        two = two.next;
      }

      return ml;
    }

    public static Node midNode(Node head, Node tail) {
      Node f = head;
      Node s = head;

      while (f != tail && f.next != tail) {
        f = f.next.next;
        s = s.next;
      }

      return s;
    }

    public static LinkedList mergeSort(Node head, Node tail) {
      if (head == tail) {
        LinkedList br = new LinkedList();
        br.addLast(head.data);
        return br;
      }

      Node mid = midNode(head, tail);
      LinkedList fsh = mergeSort(head, mid);
      LinkedList ssh = mergeSort(mid.next, tail);
      LinkedList sl = mergeTwoSortedLists(fsh, ssh);
      return sl;
    }

    public void removeDuplicates() {
      LinkedList res = new LinkedList();

      while (this.size() > 0) {
        int val = this.getFirst();
        this.removeFirst();

        if (res.size() == 0 || val != res.tail.data) {
          res.addLast(val);
        }
      }

      this.head = res.head;
      this.tail = res.tail;
      this.size = res.size;
    }

    public void oddEven() {
      LinkedList odd = new LinkedList();
      LinkedList even = new LinkedList();

      while (this.size > 0) {
        int val = this.getFirst();
        this.removeFirst();

        if (val % 2 == 0) {
          even.addLast(val);
        } else {
          odd.addLast(val);
        }
      }

      if (odd.size > 0 && even.size > 0) {
        odd.tail.next = even.head;

        this.head = odd.head;
        this.tail = even.tail;
        this.size = odd.size + even.size;
      } else if (odd.size > 0) {
        this.head = odd.head;
        this.tail = odd.tail;
        this.size = odd.size;
      } else if (even.size > 0) {
        this.head = even.head;
        this.tail = even.tail;
        this.size = even.size;
      }
    }

    public void kReverse(int k) {
      LinkedList prev = null;

      while (this.size > 0) {
        LinkedList curr = new LinkedList();

        if (this.size >= k) {
          for (int i = 0; i < k; i++) {
            int val = this.getFirst();
            this.removeFirst();
            curr.addFirst(val);
          }
        } else {
          int sz = this.size;
          for (int i = 0; i < sz; i++) {
            int val = this.getFirst();
            this.removeFirst();
            curr.addLast(val);
          }
        }

        if (prev == null) {
          prev = curr;
        } else {
          prev.tail.next = curr.head;
          prev.tail = curr.tail;
          prev.size += curr.size;
        }
      }

      this.head = prev.head;
      this.tail = prev.tail;
      this.size = prev.size;
    }

    private void displayReverseHelper(Node node) {
      if (node == null) {
        return;
      }
      displayReverseHelper(node.next);
      System.out.print(node.data + " ");
    }

    public void displayReverse() {
      displayReverseHelper(head);
      System.out.println();
    }
  }

  public static void main(String[] args) throws Exception {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

    int n1 = Integer.parseInt(br.readLine());
    LinkedList l1 = new LinkedList();
    String[] values1 = br.readLine().split(" ");
    for (int i = 0; i < n1; i++) {
      int d = Integer.parseInt(values1[i]);
      l1.addLast(d);
    }

    int a = Integer.parseInt(br.readLine());
    int b = Integer.parseInt(br.readLine());

    l1.display();
    l1.displayReverse();
    l1.addLast(a);
    l1.addFirst(b);
    l1.display();
  }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Reverse Linked List Pointer Recursive</span>
import java.io.*;

import java.util.*;

public class Main {
  public static class Node {
    int data;
    Node next;
  }

  public static class LinkedList {
    Node head;
    Node tail;
    int size;

    void addLast(int val) {
      Node temp = new Node();
      temp.data = val;
      temp.next = null;

      if (size == 0) {
        head = tail = temp;
      } else {
        tail.next = temp;
        tail = temp;
      }

      size++;
    }

    public int size() {
      return size;
    }

    public void display() {
      for (Node temp = head; temp != null; temp = temp.next) {
        System.out.print(temp.data + " ");
      }
      System.out.println();
    }

    public void removeFirst() {
      if (size == 0) {
        System.out.println("List is empty");
      } else if (size == 1) {
        head = tail = null;
        size = 0;
      } else {
        head = head.next;
        size--;
      }
    }

    public int getFirst() {
      if (size == 0) {
        System.out.println("List is empty");
        return -1;
      } else {
        return head.data;
      }
    }

    public int getLast() {
      if (size == 0) {
        System.out.println("List is empty");
        return -1;
      } else {
        return tail.data;
      }
    }

    public int getAt(int idx) {
      if (size == 0) {
        System.out.println("List is empty");
        return -1;
      } else if (idx < 0 || idx >= size) {
        System.out.println("Invalid arguments");
        return -1;
      } else {
        Node temp = head;
        for (int i = 0; i < idx; i++) {
          temp = temp.next;
        }
        return temp.data;
      }
    }

    public void addFirst(int val) {
      Node temp = new Node();
      temp.data = val;
      temp.next = head;
      head = temp;

      if (size == 0) {
        tail = temp;
      }

      size++;
    }

    public void addAt(int idx, int val) {
      if (idx < 0 || idx > size) {
        System.out.println("Invalid arguments");
      } else if (idx == 0) {
        addFirst(val);
      } else if (idx == size) {
        addLast(val);
      } else {
        Node node = new Node();
        node.data = val;

        Node temp = head;
        for (int i = 0; i < idx - 1; i++) {
          temp = temp.next;
        }
        node.next = temp.next;

        temp.next = node;
        size++;
      }
    }

    public void removeLast() {
      if (size == 0) {
        System.out.println("List is empty");
      } else if (size == 1) {
        head = tail = null;
        size = 0;
      } else {
        Node temp = head;
        for (int i = 0; i < size - 2; i++) {
          temp = temp.next;
        }

        tail = temp;
        tail.next = null;
        size--;
      }
    }

    public void removeAt(int idx) {
      if (idx < 0 || idx >= size) {
        System.out.println("Invalid arguments");
      } else if (idx == 0) {
        removeFirst();
      } else if (idx == size - 1) {
        removeLast();
      } else {
        Node temp = head;
        for (int i = 0; i < idx - 1; i++) {
          temp = temp.next;
        }

        temp.next = temp.next.next;
        size--;
      }
    }

    private Node getNodeAt(int idx) {
      Node temp = head;
      for (int i = 0; i < idx; i++) {
        temp = temp.next;
      }
      return temp;
    }

    public void reverseDI() {
      int li = 0;
      int ri = size - 1;
      while (li < ri) {
        Node left = getNodeAt(li);
        Node right = getNodeAt(ri);

        int temp = left.data;
        left.data = right.data;
        right.data = temp;

        li++;
        ri--;
      }
    }

    public void reversePI() {
      if (size <= 1) {
        return;
      }

      Node prev = null;
      Node curr = head;
      while (curr != null) {
        Node next = curr.next;

        curr.next = prev;
        prev = curr;
        curr = next;
      }

      Node temp = head;
      head = tail;
      tail = temp;
    }

    public int kthFromLast(int k) {
      Node slow = head;
      Node fast = head;
      for (int i = 0; i < k; i++) {
        fast = fast.next;
      }

      while (fast != tail) {
        slow = slow.next;
        fast = fast.next;
      }

      return slow.data;
    }

    public int mid() {
      Node f = head;
      Node s = head;

      while (f.next != null && f.next.next != null) {
        f = f.next.next;
        s = s.next;
      }

      return s.data;
    }

    public static LinkedList mergeTwoSortedLists(LinkedList l1, LinkedList l2) {
      LinkedList ml = new LinkedList();

      Node one = l1.head;
      Node two = l2.head;
      while (one != null && two != null) {
        if (one.data < two.data) {
          ml.addLast(one.data);
          one = one.next;
        } else {
          ml.addLast(two.data);
          two = two.next;
        }
      }

      while (one != null) {
        ml.addLast(one.data);
        one = one.next;
      }

      while (two != null) {
        ml.addLast(two.data);
        two = two.next;
      }

      return ml;
    }

    public static Node midNode(Node head, Node tail) {
      Node f = head;
      Node s = head;

      while (f != tail && f.next != tail) {
        f = f.next.next;
        s = s.next;
      }

      return s;
    }

    public static LinkedList mergeSort(Node head, Node tail) {
      if (head == tail) {
        LinkedList br = new LinkedList();
        br.addLast(head.data);
        return br;
      }

      Node mid = midNode(head, tail);
      LinkedList fsh = mergeSort(head, mid);
      LinkedList ssh = mergeSort(mid.next, tail);
      LinkedList sl = mergeTwoSortedLists(fsh, ssh);
      return sl;
    }

    public void removeDuplicates() {
      LinkedList res = new LinkedList();

      while (this.size() > 0) {
        int val = this.getFirst();
        this.removeFirst();

        if (res.size() == 0 || val != res.tail.data) {
          res.addLast(val);
        }
      }

      this.head = res.head;
      this.tail = res.tail;
      this.size = res.size;
    }

    public void oddEven() {
      LinkedList odd = new LinkedList();
      LinkedList even = new LinkedList();

      while (this.size > 0) {
        int val = this.getFirst();
        this.removeFirst();

        if (val % 2 == 0) {
          even.addLast(val);
        } else {
          odd.addLast(val);
        }
      }

      if (odd.size > 0 && even.size > 0) {
        odd.tail.next = even.head;

        this.head = odd.head;
        this.tail = even.tail;
        this.size = odd.size + even.size;
      } else if (odd.size > 0) {
        this.head = odd.head;
        this.tail = odd.tail;
        this.size = odd.size;
      } else if (even.size > 0) {
        this.head = even.head;
        this.tail = even.tail;
        this.size = even.size;
      }
    }

    public void kReverse(int k) {
      LinkedList prev = null;

      while (this.size > 0) {
        LinkedList curr = new LinkedList();

        if (this.size >= k) {
          for (int i = 0; i < k; i++) {
            int val = this.getFirst();
            this.removeFirst();
            curr.addFirst(val);
          }
        } else {
          int sz = this.size;
          for (int i = 0; i < sz; i++) {
            int val = this.getFirst();
            this.removeFirst();
            curr.addLast(val);
          }
        }

        if (prev == null) {
          prev = curr;
        } else {
          prev.tail.next = curr.head;
          prev.tail = curr.tail;
          prev.size += curr.size;
        }
      }

      this.head = prev.head;
      this.tail = prev.tail;
      this.size = prev.size;
    }

    private void displayReverseHelper(Node node) {
      if (node == null) {
        return;
      }
      displayReverseHelper(node.next);
      System.out.print(node.data + " ");
    }

    public void displayReverse() {
      displayReverseHelper(head);
      System.out.println();
    }

    private void reversePRHelper(Node node) {
      if (node == tail) {
        return;
      }
      reversePRHelper(node.next);
      node.next.next = node;
    }

    public void reversePR() {
      reversePRHelper(head);
      Node temp = head;
      head = tail;
      tail = temp;
      tail.next = null;
    }
  }

  public static void main(String[] args) throws Exception {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

    int n1 = Integer.parseInt(br.readLine());
    LinkedList l1 = new LinkedList();
    String[] values1 = br.readLine().split(" ");
    for (int i = 0; i < n1; i++) {
      int d = Integer.parseInt(values1[i]);
      l1.addLast(d);
    }

    int a = Integer.parseInt(br.readLine());
    int b = Integer.parseInt(br.readLine());

    l1.display();
    l1.reversePR();
    l1.addLast(a);
    l1.addFirst(b);
    l1.display();
  }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Is Linked List A Palindrome?</span>
import java.io.*;

import java.util.*;

public class Main {
  public static class Node {
    int data;
    Node next;
  }

  public static class LinkedList {
    Node head;
    Node tail;
    int size;

    void addLast(int val) {
      Node temp = new Node();
      temp.data = val;
      temp.next = null;

      if (size == 0) {
        head = tail = temp;
      } else {
        tail.next = temp;
        tail = temp;
      }

      size++;
    }

    public int size() {
      return size;
    }

    public void display() {
      for (Node temp = head; temp != null; temp = temp.next) {
        System.out.print(temp.data + " ");
      }
      System.out.println();
    }

    public void removeFirst() {
      if (size == 0) {
        System.out.println("List is empty");
      } else if (size == 1) {
        head = tail = null;
        size = 0;
      } else {
        head = head.next;
        size--;
      }
    }

    public int getFirst() {
      if (size == 0) {
        System.out.println("List is empty");
        return -1;
      } else {
        return head.data;
      }
    }

    public int getLast() {
      if (size == 0) {
        System.out.println("List is empty");
        return -1;
      } else {
        return tail.data;
      }
    }

    public int getAt(int idx) {
      if (size == 0) {
        System.out.println("List is empty");
        return -1;
      } else if (idx < 0 || idx >= size) {
        System.out.println("Invalid arguments");
        return -1;
      } else {
        Node temp = head;
        for (int i = 0; i < idx; i++) {
          temp = temp.next;
        }
        return temp.data;
      }
    }

    public void addFirst(int val) {
      Node temp = new Node();
      temp.data = val;
      temp.next = head;
      head = temp;

      if (size == 0) {
        tail = temp;
      }

      size++;
    }

    public void addAt(int idx, int val) {
      if (idx < 0 || idx > size) {
        System.out.println("Invalid arguments");
      } else if (idx == 0) {
        addFirst(val);
      } else if (idx == size) {
        addLast(val);
      } else {
        Node node = new Node();
        node.data = val;

        Node temp = head;
        for (int i = 0; i < idx - 1; i++) {
          temp = temp.next;
        }
        node.next = temp.next;

        temp.next = node;
        size++;
      }
    }

    public void removeLast() {
      if (size == 0) {
        System.out.println("List is empty");
      } else if (size == 1) {
        head = tail = null;
        size = 0;
      } else {
        Node temp = head;
        for (int i = 0; i < size - 2; i++) {
          temp = temp.next;
        }

        tail = temp;
        tail.next = null;
        size--;
      }
    }

    public void removeAt(int idx) {
      if (idx < 0 || idx >= size) {
        System.out.println("Invalid arguments");
      } else if (idx == 0) {
        removeFirst();
      } else if (idx == size - 1) {
        removeLast();
      } else {
        Node temp = head;
        for (int i = 0; i < idx - 1; i++) {
          temp = temp.next;
        }

        temp.next = temp.next.next;
        size--;
      }
    }

    private Node getNodeAt(int idx) {
      Node temp = head;
      for (int i = 0; i < idx; i++) {
        temp = temp.next;
      }
      return temp;
    }

    public void reverseDI() {
      int li = 0;
      int ri = size - 1;
      while (li < ri) {
        Node left = getNodeAt(li);
        Node right = getNodeAt(ri);

        int temp = left.data;
        left.data = right.data;
        right.data = temp;

        li++;
        ri--;
      }
    }

    public void reversePI() {
      if (size <= 1) {
        return;
      }

      Node prev = null;
      Node curr = head;
      while (curr != null) {
        Node next = curr.next;

        curr.next = prev;
        prev = curr;
        curr = next;
      }

      Node temp = head;
      head = tail;
      tail = temp;
    }

    public int kthFromLast(int k) {
      Node slow = head;
      Node fast = head;
      for (int i = 0; i < k; i++) {
        fast = fast.next;
      }

      while (fast != tail) {
        slow = slow.next;
        fast = fast.next;
      }

      return slow.data;
    }

    public int mid() {
      Node f = head;
      Node s = head;

      while (f.next != null && f.next.next != null) {
        f = f.next.next;
        s = s.next;
      }

      return s.data;
    }

    public static LinkedList mergeTwoSortedLists(LinkedList l1, LinkedList l2) {
      LinkedList ml = new LinkedList();

      Node one = l1.head;
      Node two = l2.head;
      while (one != null && two != null) {
        if (one.data < two.data) {
          ml.addLast(one.data);
          one = one.next;
        } else {
          ml.addLast(two.data);
          two = two.next;
        }
      }

      while (one != null) {
        ml.addLast(one.data);
        one = one.next;
      }

      while (two != null) {
        ml.addLast(two.data);
        two = two.next;
      }

      return ml;
    }

    public static Node midNode(Node head, Node tail) {
      Node f = head;
      Node s = head;

      while (f != tail && f.next != tail) {
        f = f.next.next;
        s = s.next;
      }

      return s;
    }

    public static LinkedList mergeSort(Node head, Node tail) {
      if (head == tail) {
        LinkedList br = new LinkedList();
        br.addLast(head.data);
        return br;
      }

      Node mid = midNode(head, tail);
      LinkedList fsh = mergeSort(head, mid);
      LinkedList ssh = mergeSort(mid.next, tail);
      LinkedList sl = mergeTwoSortedLists(fsh, ssh);
      return sl;
    }

    public void removeDuplicates() {
      LinkedList res = new LinkedList();

      while (this.size() > 0) {
        int val = this.getFirst();
        this.removeFirst();

        if (res.size() == 0 || val != res.tail.data) {
          res.addLast(val);
        }
      }

      this.head = res.head;
      this.tail = res.tail;
      this.size = res.size;
    }

    public void oddEven() {
      LinkedList odd = new LinkedList();
      LinkedList even = new LinkedList();

      while (this.size > 0) {
        int val = this.getFirst();
        this.removeFirst();

        if (val % 2 == 0) {
          even.addLast(val);
        } else {
          odd.addLast(val);
        }
      }

      if (odd.size > 0 && even.size > 0) {
        odd.tail.next = even.head;

        this.head = odd.head;
        this.tail = even.tail;
        this.size = odd.size + even.size;
      } else if (odd.size > 0) {
        this.head = odd.head;
        this.tail = odd.tail;
        this.size = odd.size;
      } else if (even.size > 0) {
        this.head = even.head;
        this.tail = even.tail;
        this.size = even.size;
      }
    }

    public void kReverse(int k) {
      LinkedList prev = null;

      while (this.size > 0) {
        LinkedList curr = new LinkedList();

        if (this.size >= k) {
          for (int i = 0; i < k; i++) {
            int val = this.getFirst();
            this.removeFirst();
            curr.addFirst(val);
          }
        } else {
          int sz = this.size;
          for (int i = 0; i < sz; i++) {
            int val = this.getFirst();
            this.removeFirst();
            curr.addLast(val);
          }
        }

        if (prev == null) {
          prev = curr;
        } else {
          prev.tail.next = curr.head;
          prev.tail = curr.tail;
          prev.size += curr.size;
        }
      }

      this.head = prev.head;
      this.tail = prev.tail;
      this.size = prev.size;
    }

    private void displayReverseHelper(Node node) {
      if (node == null) {
        return;
      }
      displayReverseHelper(node.next);
      System.out.print(node.data + " ");
    }

    public void displayReverse() {
      displayReverseHelper(head);
      System.out.println();
    }

    private void reversePRHelper(Node node) {
      if (node == tail) {
        return;
      }
      reversePRHelper(node.next);
      node.next.next = node;
    }

    public void reversePR() {
      reversePRHelper(head);
      Node temp = head;
      head = tail;
      tail = temp;
      tail.next = null;
    }

    private boolean IsPalindromeHelper(Node right) {
      if (right == null) {
        return true;
      }

      boolean rres = IsPalindromeHelper(right.next);
      if (rres == false) {
        return false;
      } else if (right.data != pleft.data) {
        return false;
      }
      pleft = pleft.next;
      return true;
    }
    Node pleft;
    public boolean IsPalindrome() {
      // write your code here
      pleft = head;
      return IsPalindromeHelper(head);
    }
  }

  public static void main(String[] args) throws Exception {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

    int n1 = Integer.parseInt(br.readLine());
    LinkedList l1 = new LinkedList();
    String[] values1 = br.readLine().split(" ");
    for (int i = 0; i < n1; i++) {
      int d = Integer.parseInt(values1[i]);
      l1.addLast(d);
    }

    System.out.println(l1.IsPalindrome());
  }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Fold A Linked List</span>
import java.io.*;

import java.util.*;

public class Main {
  public static class Node {
    int data;
    Node next;
  }

  public static class LinkedList {
    Node head;
    Node tail;
    int size;

    void addLast(int val) {
      Node temp = new Node();
      temp.data = val;
      temp.next = null;

      if (size == 0) {
        head = tail = temp;
      } else {
        tail.next = temp;
        tail = temp;
      }

      size++;
    }

    public int size() {
      return size;
    }

    public void display() {
      for (Node temp = head; temp != null; temp = temp.next) {
        System.out.print(temp.data + " ");
      }
      System.out.println();
    }

    public void removeFirst() {
      if (size == 0) {
        System.out.println("List is empty");
      } else if (size == 1) {
        head = tail = null;
        size = 0;
      } else {
        head = head.next;
        size--;
      }
    }

    public int getFirst() {
      if (size == 0) {
        System.out.println("List is empty");
        return -1;
      } else {
        return head.data;
      }
    }

    public int getLast() {
      if (size == 0) {
        System.out.println("List is empty");
        return -1;
      } else {
        return tail.data;
      }
    }

    public int getAt(int idx) {
      if (size == 0) {
        System.out.println("List is empty");
        return -1;
      } else if (idx < 0 || idx >= size) {
        System.out.println("Invalid arguments");
        return -1;
      } else {
        Node temp = head;
        for (int i = 0; i < idx; i++) {
          temp = temp.next;
        }
        return temp.data;
      }
    }

    public void addFirst(int val) {
      Node temp = new Node();
      temp.data = val;
      temp.next = head;
      head = temp;

      if (size == 0) {
        tail = temp;
      }

      size++;
    }

    public void addAt(int idx, int val) {
      if (idx < 0 || idx > size) {
        System.out.println("Invalid arguments");
      } else if (idx == 0) {
        addFirst(val);
      } else if (idx == size) {
        addLast(val);
      } else {
        Node node = new Node();
        node.data = val;

        Node temp = head;
        for (int i = 0; i < idx - 1; i++) {
          temp = temp.next;
        }
        node.next = temp.next;

        temp.next = node;
        size++;
      }
    }

    public void removeLast() {
      if (size == 0) {
        System.out.println("List is empty");
      } else if (size == 1) {
        head = tail = null;
        size = 0;
      } else {
        Node temp = head;
        for (int i = 0; i < size - 2; i++) {
          temp = temp.next;
        }

        tail = temp;
        tail.next = null;
        size--;
      }
    }

    public void removeAt(int idx) {
      if (idx < 0 || idx >= size) {
        System.out.println("Invalid arguments");
      } else if (idx == 0) {
        removeFirst();
      } else if (idx == size - 1) {
        removeLast();
      } else {
        Node temp = head;
        for (int i = 0; i < idx - 1; i++) {
          temp = temp.next;
        }

        temp.next = temp.next.next;
        size--;
      }
    }

    private Node getNodeAt(int idx) {
      Node temp = head;
      for (int i = 0; i < idx; i++) {
        temp = temp.next;
      }
      return temp;
    }

    public void reverseDI() {
      int li = 0;
      int ri = size - 1;
      while (li < ri) {
        Node left = getNodeAt(li);
        Node right = getNodeAt(ri);

        int temp = left.data;
        left.data = right.data;
        right.data = temp;

        li++;
        ri--;
      }
    }

    public void reversePI() {
      if (size <= 1) {
        return;
      }

      Node prev = null;
      Node curr = head;
      while (curr != null) {
        Node next = curr.next;

        curr.next = prev;
        prev = curr;
        curr = next;
      }

      Node temp = head;
      head = tail;
      tail = temp;
    }

    public int kthFromLast(int k) {
      Node slow = head;
      Node fast = head;
      for (int i = 0; i < k; i++) {
        fast = fast.next;
      }

      while (fast != tail) {
        slow = slow.next;
        fast = fast.next;
      }

      return slow.data;
    }

    public int mid() {
      Node f = head;
      Node s = head;

      while (f.next != null && f.next.next != null) {
        f = f.next.next;
        s = s.next;
      }

      return s.data;
    }

    public static LinkedList mergeTwoSortedLists(LinkedList l1, LinkedList l2) {
      LinkedList ml = new LinkedList();

      Node one = l1.head;
      Node two = l2.head;
      while (one != null && two != null) {
        if (one.data < two.data) {
          ml.addLast(one.data);
          one = one.next;
        } else {
          ml.addLast(two.data);
          two = two.next;
        }
      }

      while (one != null) {
        ml.addLast(one.data);
        one = one.next;
      }

      while (two != null) {
        ml.addLast(two.data);
        two = two.next;
      }

      return ml;
    }

    public static Node midNode(Node head, Node tail) {
      Node f = head;
      Node s = head;

      while (f != tail && f.next != tail) {
        f = f.next.next;
        s = s.next;
      }

      return s;
    }

    public static LinkedList mergeSort(Node head, Node tail) {
      if (head == tail) {
        LinkedList br = new LinkedList();
        br.addLast(head.data);
        return br;
      }

      Node mid = midNode(head, tail);
      LinkedList fsh = mergeSort(head, mid);
      LinkedList ssh = mergeSort(mid.next, tail);
      LinkedList sl = mergeTwoSortedLists(fsh, ssh);
      return sl;
    }

    public void removeDuplicates() {
      LinkedList res = new LinkedList();

      while (this.size() > 0) {
        int val = this.getFirst();
        this.removeFirst();

        if (res.size() == 0 || val != res.tail.data) {
          res.addLast(val);
        }
      }

      this.head = res.head;
      this.tail = res.tail;
      this.size = res.size;
    }

    public void oddEven() {
      LinkedList odd = new LinkedList();
      LinkedList even = new LinkedList();

      while (this.size > 0) {
        int val = this.getFirst();
        this.removeFirst();

        if (val % 2 == 0) {
          even.addLast(val);
        } else {
          odd.addLast(val);
        }
      }

      if (odd.size > 0 && even.size > 0) {
        odd.tail.next = even.head;

        this.head = odd.head;
        this.tail = even.tail;
        this.size = odd.size + even.size;
      } else if (odd.size > 0) {
        this.head = odd.head;
        this.tail = odd.tail;
        this.size = odd.size;
      } else if (even.size > 0) {
        this.head = even.head;
        this.tail = even.tail;
        this.size = even.size;
      }
    }

    public void kReverse(int k) {
      LinkedList prev = null;

      while (this.size > 0) {
        LinkedList curr = new LinkedList();

        if (this.size >= k) {
          for (int i = 0; i < k; i++) {
            int val = this.getFirst();
            this.removeFirst();
            curr.addFirst(val);
          }
        } else {
          int sz = this.size;
          for (int i = 0; i < sz; i++) {
            int val = this.getFirst();
            this.removeFirst();
            curr.addLast(val);
          }
        }

        if (prev == null) {
          prev = curr;
        } else {
          prev.tail.next = curr.head;
          prev.tail = curr.tail;
          prev.size += curr.size;
        }
      }

      this.head = prev.head;
      this.tail = prev.tail;
      this.size = prev.size;
    }

    private void displayReverseHelper(Node node) {
      if (node == null) {
        return;
      }
      displayReverseHelper(node.next);
      System.out.print(node.data + " ");
    }

    public void displayReverse() {
      displayReverseHelper(head);
      System.out.println();
    }

    private void reversePRHelper(Node node) {
      if (node == tail) {
        return;
      }
      reversePRHelper(node.next);
      node.next.next = node;
    }

    public void reversePR() {
      reversePRHelper(head);
      Node temp = head;
      head = tail;
      tail = temp;
      tail.next = null;
    }
    Node fleft;
    private void foldHelper(Node right, int floor) {
      if (right == null) {
        return;
      }
      foldHelper(right.next, floor + 1);
      if (floor > size / 2) {
        Node temp = fleft.next;
        fleft.next = right;
        right.next = temp;
        fleft = temp;
      } else if (floor == size / 2) {
        tail = right;
        tail.next = null;
      }
    }
    public void fold() {
      fleft = head;
      foldHelper(head, 0);
    }
  }

  public static void main(String[] args) throws Exception {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

    int n1 = Integer.parseInt(br.readLine());
    LinkedList l1 = new LinkedList();
    String[] values1 = br.readLine().split(" ");
    for (int i = 0; i < n1; i++) {
      int d = Integer.parseInt(values1[i]);
      l1.addLast(d);
    }

    int a = Integer.parseInt(br.readLine());
    int b = Integer.parseInt(br.readLine());

    l1.display();
    l1.fold();
    l1.display();
    l1.addFirst(a);
    l1.addLast(b);
    l1.display();
  }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Add Two Linked List</span>
private static int addhelper(Node one, int pv1, Node two, int pv2, LinkedList res) {
  if (one == null && two == null) {
    return 0;

  }
  int sum = 0;
  if (pv1 > pv2) {
    int oc = addhelper(one.next, pv1 - 1, two, pv2, res); //pv1=place value of 1
    sum = one.data + oc;
  }
  else if (pv2 > pv1) {
    int oc = addhelper(one, pv1, two.next, pv2 - 1, res); //pv2=place value of 2
    sum = two.data + oc;
  }
  else {
    int oc = addhelper(one.next, pv1 - 1, two.next, pv2 - 1, res); //oc= old carry
    sum = one.data + two.data + oc;
  }

  int c = sum / 10;   //new carry
  int d = sum % 10;   //new digit of "res"
  res.addFirst(d);
  return c;

}
public static LinkedList addTwoLists(LinkedList one, LinkedList two) {
  LinkedList res = new LinkedList();
  int oc = addhelper(one.head, one.size, two.head, two.size, res);
  if (oc > 0) {
    res.addFirst(oc);
  }
  return res;
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">INTERSECTION POINT OF LINKED LISTS</span>
public static int findIntersection(LinkedList one, LinkedList two) {

  Node t1 = one.head;
  //1
  Node t2 = two.head;
  int delta = Math.abs(one.size - two.size); //2

  if (one.size > two.size) { //3
    for (int i = 0; i < delta; i++) {
      t1 = t1.next;
    }
  } else if (two.size > one.size) {
    for (int i = 0; i < delta; i++) {
      t2 = t2.next;
    }
  }

  while (t1 != t2) { //4
    t1 = t1.next;
    t2 = t2.next;
  }

  return t1.data; //5
}
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Generic Trees- Introduction and Data Members</span>
import java.util.*;

import java.io.*;
public class Main
{
  public class Node
  {
    int data;  //for storing the data
    ArrayList< Node> children = new ArrayList< >(); //for storing the child nodes
  }
  public static void main(String[] args)
  {
    Node root; //unique node for a tree
  }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Generic Tree Constructor</span>
import java.util.*;

import java.io.*;
public class Main
{
  public class Node
  {
    int data;  //for storing the data
    ArrayList< Node> children = new ArrayList< >(); //for storing the child nodes
  }
  public static void main(String[] args)
  {
    Node root; //unique node for a tree
    int[] arr = {10, 20, 50, -1, 60, -1, -1, 30, 70, -1, 80, 110, -1, 120, -1, -1, 90, -1, -1, 40, 100, -1, -1, -1};
    Stack< Node> st = new Stack< >();
    for (int i = 0; i < arr.length; i++)
    {
      if (arr[i] == -1)
      {
        st.pop();
      } else {
        Node t = new Node();
        t.data = arr[i];

        if (st.size() > 0) {
          st.peek().children.add(t);

        }
        else
        {
          root = t;
        }
        st.push(t);
      }
    }
  }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Display a Generic Tree</span>
import java.io.*;

import java.util.*;

public class Main {
  private static class Node {
    int data;
    ArrayList< Node> children = new ArrayList< >();
  }

  public static void display(Node node) {
    String str = node.data + " -> ";
    for (Node child : node.children) {
      str += child.data + ", ";
    }
    str += ".";
    System.out.println(str);

    for (Node child : node.children) {
      display(child);
    }
  }

  public static Node construct(int[] arr) {
    Node root = null;

    Stack< Node> st = new Stack< >();
    for (int i = 0; i < arr.length; i++) {
      if (arr[i] == -1) {
        st.pop();
      } else {
        Node t = new Node();
        t.data = arr[i];

        if (st.size() > 0) {
          st.peek().children.add(t);
        } else {
          root = t;
        }

        st.push(t);
      }
    }

    return root;
  }

  public static void main(String[] args) throws Exception {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    int n = Integer.parseInt(br.readLine());
    int[] arr = new int[n];
    String[] values = br.readLine().split(" ");
    for (int i = 0; i < n; i++) {
      arr[i] = Integer.parseInt(values[i]);
    }

    Node root = construct(arr);
    display(root);
  }

}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Size Of Generic Tree</span>
import java.io.*;

import java.util.*;

public class Main {
  private static class Node {
    int data;
    ArrayList< Node> children = new ArrayList< >();
  }

  public static void display(Node node) {
    String str = node.data + " -> ";
    for (Node child : node.children) {
      str += child.data + ", ";
    }
    str += ".";
    System.out.println(str);

    for (Node child : node.children) {
      display(child);
    }
  }

  public static Node construct(int[] arr) {
    Node root = null;

    Stack< Node> st = new Stack< >();
    for (int i = 0; i < arr.length; i++) {
      if (arr[i] == -1) {
        st.pop();
      } else {
        Node t = new Node();
        t.data = arr[i];

        if (st.size() > 0) {
          st.peek().children.add(t);
        } else {
          root = t;
        }

        st.push(t);
      }
    }

    return root;
  }

  public static int size(Node node) {
    if (node == null) {
      return 0;
    }

    int sz = 1;
    for (Node child : node.children) {
      sz += size(child);
    }
    return sz;
  }

  public static void main(String[] args) throws Exception {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    int n = Integer.parseInt(br.readLine());
    int[] arr = new int[n];
    String[] values = br.readLine().split(" ");
    for (int i = 0; i < n; i++) {
      arr[i] = Integer.parseInt(values[i]);
    }

    Node root = construct(arr);
    int sz = size(root);
    System.out.println(sz);
    // display(root);
  }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Maximum in a Generic Tree</span>
import java.io.*;

import java.util.*;

public class Main {
  private static class Node {
    int data;
    ArrayList< Node> children = new ArrayList< >();
  }

  public static void display(Node node) {
    String str = node.data + " -> ";
    for (Node child : node.children) {
      str += child.data + ", ";
    }
    str += ".";
    System.out.println(str);

    for (Node child : node.children) {
      display(child);
    }
  }

  public static Node construct(int[] arr) {
    Node root = null;

    Stack< Node> st = new Stack< >();
    for (int i = 0; i < arr.length; i++) {
      if (arr[i] == -1) {
        st.pop();
      } else {
        Node t = new Node();
        t.data = arr[i];

        if (st.size() > 0) {
          st.peek().children.add(t);
        } else {
          root = t;
        }

        st.push(t);
      }
    }

    return root;
  }

  public static int size(Node node) {
    int s = 0;

    for (Node child : node.children) {
      s += size(child);
    }
    s += 1;

    return s;
  }

  public static int max(Node node) {
    int m = Integer.MIN_VALUE;

    for (Node child : node.children) {
      int cm = max(child);
      if (cm > m)
      {
        m = cm;
      }
    }
    if (node.data > m)
    {
      m = node.data;
    }

    return m;
  }

  public static void main(String[] args) throws Exception {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    int n = Integer.parseInt(br.readLine());
    int[] arr = new int[n];
    String[] values = br.readLine().split(" ");
    for (int i = 0; i < n; i++) {
      arr[i] = Integer.parseInt(values[i]);
    }

    Node root = construct(arr);
    int m = max(root);
    System.out.println(m);
    // display(root);
  }

}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Height of a Generic Tree</span>
import java.io.*;

import java.util.*;

public class Main {
  private static class Node {
    int data;
    ArrayList< Node> children = new ArrayList< >();
  }

  public static void display(Node node) {
    String str = node.data + " -> ";
    for (Node child : node.children) {
      str += child.data + ", ";
    }
    str += ".";
    System.out.println(str);

    for (Node child : node.children) {
      display(child);
    }
  }

  public static Node construct(int[] arr) {
    Node root = null;

    Stack< Node> st = new Stack< >();
    for (int i = 0; i < arr.length; i++) {
      if (arr[i] == -1) {
        st.pop();
      } else {
        Node t = new Node();
        t.data = arr[i];

        if (st.size() > 0) {
          st.peek().children.add(t);
        } else {
          root = t;
        }

        st.push(t);
      }
    }
    return root;
  }

  public static int size(Node node) {
    int s = 0;

    for (Node child : node.children) {
      s += size(child);
    }
    s += 1;
    return s;
  }

  public static int max(Node node) {
    int m = Integer.MIN_VALUE;

    for (Node child : node.children) {
      int cm = max(child);
      m = Math.max(m, cm);
    }
    m = Math.max(m, node.data);
    return m;
  }

  public static int height(Node node) {
    int h = -1;

    for (Node child : node.children) {
      int ch = height(child);
      h = Math.max(h, ch);
    }
    h += 1;
    return h;
  }

  public static void main(String[] args) throws Exception {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    int n = Integer.parseInt(br.readLine());
    int[] arr = new int[n];
    String[] values = br.readLine().split(" ");
    for (int i = 0; i < n; i++) {
      arr[i] = Integer.parseInt(values[i]);
    }
    Node root = construct(arr);
    int h = height(root);
    System.out.println(h);
    // display(root);
  }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Traversals In Generic Tree</span>
public static void traversals(Node node) {

  //Euler's Left/ Node Pre/ Into the recursion
  System.out.println("Node Pre " + node.data);


  for (Node child : node.children)
  {
    //Edge Pre
    System.out.println("Edge Pre " + node.data + "--" + child.data);
    traversals(child);
    System.out.println("Edge Post " + node.data + "--" + child.data);
    //Edge Post
  }
  System.out.println("Node Post " + node.data);
  //Euler's right/Node Post/on the way out of recursion


}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Level Order of Generic Tree</span>
import java.io.*;

import java.util.*;

public class Main {
  private static class Node {
    int data;
    ArrayList< Node> children = new ArrayList< >();
  }

  public static void display(Node node) {
    String str = node.data + " -> ";
    for (Node child : node.children) {
      str += child.data + ", ";
    }
    str += ".";
    System.out.println(str);

    for (Node child : node.children) {
      display(child);
    }
  }

  public static Node construct(int[] arr) {
    Node root = null;

    Stack< Node> st = new Stack< >();
    for (int i = 0; i < arr.length; i++) {
      if (arr[i] == -1) {
        st.pop();
      } else {
        Node t = new Node();
        t.data = arr[i];

        if (st.size() > 0) {
          st.peek().children.add(t);
        } else {
          root = t;
        }

        st.push(t);
      }
    }

    return root;
  }

  public static int size(Node node) {
    int s = 0;

    for (Node child : node.children) {
      s += size(child);
    }
    s += 1;

    return s;
  }

  public static int max(Node node) {
    int m = Integer.MIN_VALUE;

    for (Node child : node.children) {
      int cm = max(child);
      m = Math.max(m, cm);
    }
    m = Math.max(m, node.data);

    return m;
  }

  public static int height(Node node) {
    int h = -1;

    for (Node child : node.children) {
      int ch = height(child);
      h = Math.max(h, ch);
    }
    h += 1;

    return h;
  }

  public static void traversals(Node node) {
    System.out.println("Node Pre " + node.data);

    for (Node child : node.children) {
      System.out.println("Edge Pre " + node.data + "--" + child.data);
      traversals(child);
      System.out.println("Edge Post " + node.data + "--" + child.data);
    }

    System.out.println("Node Post " + node.data);
  }

  public static void levelOrder(Node node) {
    Queue< Node> queue = new ArrayDeque< >();
    queue.add(node);

    while (queue.size() > 0) {
      node = queue.remove();

      System.out.print(node.data + " ");

      for (Node child : node.children) {
        queue.add(child);
      }
    }

    System.out.println(".");
  }

  public static void main(String[] args) throws Exception {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    int n = Integer.parseInt(br.readLine());
    int[] arr = new int[n];
    String[] values = br.readLine().split(" ");
    for (int i = 0; i < n; i++) {
      arr[i] = Integer.parseInt(values[i]);
    }
    Node root = construct(arr);
    levelOrder(root);
  }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Level Order-Line Wise</span>
import java.io.*;

import java.util.*;

public class Main {
  private static class Node {
    int data;
    ArrayList< Node> children = new ArrayList< >();
  }

  public static void display(Node node) {
    String str = node.data + " -> ";
    for (Node child : node.children) {
      str += child.data + ", ";
    }
    str += ".";
    System.out.println(str);

    for (Node child : node.children) {
      display(child);
    }
  }

  public static Node construct(int[] arr) {
    Node root = null;

    Stack< Node> st = new Stack< >();
    for (int i = 0; i < arr.length; i++) {
      if (arr[i] == -1) {
        st.pop();
      } else {
        Node t = new Node();
        t.data = arr[i];

        if (st.size() > 0) {
          st.peek().children.add(t);
        } else {
          root = t;
        }

        st.push(t);
      }
    }

    return root;
  }

  public static int size(Node node) {
    int s = 0;

    for (Node child : node.children) {
      s += size(child);
    }
    s += 1;

    return s;
  }

  public static int max(Node node) {
    int m = Integer.MIN_VALUE;

    for (Node child : node.children) {
      int cm = max(child);
      m = Math.max(m, cm);
    }
    m = Math.max(m, node.data);

    return m;
  }

  public static int height(Node node) {
    int h = -1;

    for (Node child : node.children) {
      int ch = height(child);
      h = Math.max(h, ch);
    }
    h += 1;

    return h;
  }

  public static void traversals(Node node) {
    System.out.println("Node Pre " + node.data);

    for (Node child : node.children) {
      System.out.println("Edge Pre " + node.data + "--" + child.data);
      traversals(child);
      System.out.println("Edge Post " + node.data + "--" + child.data);
    }

    System.out.println("Node Post " + node.data);
  }

  public static void levelOrderLinewise(Node node) {
    Queue< Node> queue = new ArrayDeque< >();
    queue.add(node);

    Queue< Node> cqueue = new ArrayDeque< >();
    while (queue.size() > 0) {
      node = queue.remove();
      System.out.print(node.data + " ");

      for (Node child : node.children) {
        cqueue.add(child);
      }

      if (queue.size() == 0) {
        queue = cqueue;
        cqueue = new ArrayDeque< >();
        System.out.println();
      }
    }
  }

  public static void main(String[] args) throws Exception {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    int n = Integer.parseInt(br.readLine());
    int[] arr = new int[n];
    String[] values = br.readLine().split(" ");
    for (int i = 0; i < n; i++) {
      arr[i] = Integer.parseInt(values[i]);
    }

    Node root = construct(arr);
    levelOrderLinewise(root);
  }

}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Level order Linewise Zig Zag</span>
import java.io.*;

import java.util.*;

public class Main {
  private static class Node {
    int data;
    ArrayList< Node> children = new ArrayList< >();
  }

  public static void display(Node node) {
    String str = node.data + " -> ";
    for (Node child : node.children) {
      str += child.data + ", ";
    }
    str += ".";
    System.out.println(str);

    for (Node child : node.children) {
      display(child);
    }
  }

  public static Node construct(int[] arr) {
    Node root = null;

    Stack< Node> st = new Stack< >();
    for (int i = 0; i < arr.length; i++) {
      if (arr[i] == -1) {
        st.pop();
      } else {
        Node t = new Node();
        t.data = arr[i];

        if (st.size() > 0) {
          st.peek().children.add(t);
        } else {
          root = t;
        }

        st.push(t);
      }
    }

    return root;
  }

  public static int size(Node node) {
    int s = 0;

    for (Node child : node.children) {
      s += size(child);
    }
    s += 1;

    return s;
  }

  public static int max(Node node) {
    int m = Integer.MIN_VALUE;

    for (Node child : node.children) {
      int cm = max(child);
      m = Math.max(m, cm);
    }
    m = Math.max(m, node.data);

    return m;
  }

  public static int height(Node node) {
    int h = -1;

    for (Node child : node.children) {
      int ch = height(child);
      h = Math.max(h, ch);
    }
    h += 1;

    return h;
  }

  public static void traversals(Node node) {
    System.out.println("Node Pre " + node.data);

    for (Node child : node.children) {
      System.out.println("Edge Pre " + node.data + "--" + child.data);
      traversals(child);
      System.out.println("Edge Post " + node.data + "--" + child.data);
    }

    System.out.println("Node Post " + node.data);
  }

  public static void levelOrderLinewiseZZ(Node node) {
    Stack< Node> ms = new Stack< >();
    ms.push(node);

    Stack< Node> cs = new Stack< >();
    int level = 0;

    while (ms.size() > 0) {
      node = ms.pop();
      System.out.print(node.data + " ");
      if (level % 2 == 1) {
        for (int i = 0; i < node.children.size(); i++) {
          cs.push(node.children.get(i));
        }
      } else {
        for (int i = node.children.size() - 1; i >= 0; i--) {
          cs.push(node.children.get(i));
        }
      }

      if (ms.size() == 0) {
        ms = cs;
        cs = new Stack< >();
        level++;
        System.out.println();
      }
    }
  }

  public static void main(String[] args) throws Exception {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    int n = Integer.parseInt(br.readLine());
    int[] arr = new int[n];
    String[] values = br.readLine().split(" ");
    for (int i = 0; i < n; i++) {
      arr[i] = Integer.parseInt(values[i]);
    }

    Node root = construct(arr);
    levelOrderLinewiseZZ(root);
  }

}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Level Order Traversal - More Approaches</span>
public static void levelOrderLinewise(Node node) {
  Queue < Node > mq = new ArrayDeque < > ( );

  mq.add(node);
  mq.add(new Node (-1));

  while (mq.size() > 0) {
    node = mq.remove();
    if (node.data != -1) {
      System.out.print(node.data + " ");

      for (Node child : node.children) {
        mq.add(child);
      }
    } else {
      if (mq.size() > 0) {
        mq.add(new Node(-1));
        System.out.println();
      }
    }
  }
}
<span class="textStyle">||||||||||||||||||||||||</span>
public static void levelOrderLinewise3(Node node) {
  Queue < Node > mq = new ArrayDeque < > ( );

  mq.add(node);

  while (mq.size() > 0) {
    int cicl = mq.size();
    for (int i = 0; i < cicl; i++) {
      node = mq.remove();
      System.out.print(node.data + " ");

      for (Node child : node.children) {
        mq.add(child);
      }
    }
    System.out.println();
  }
}
<span class="textStyle">||||||||||||||||||||</span>
public static void levelOrderLinewise4(Node node) {
  Queue < Pair > mq = new ArrayDeque < > ( );

  mq.add(new Pair(node, 1));

  int level = 1;
  while (mq.size() > 0) {
    Pair p = mq.remove();
    if (p.level > level) {
      level = p.level;
      System.out.println();
    }

    System.out.print(p.node.data + " ");
    for (Node child : p.node.children) {
      Pair cp = new Pair(child, p.level + 1);
      mq.add(cp);
    }
  }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Mirror Of A Generic Tree</span>
import java.io.*;

import java.util.*;

public class Main {
  private static class Node {
    int data;
    ArrayList< Node> children = new ArrayList< >();
  }

  public static void display(Node node) {
    String str = node.data + " -> ";
    for (Node child : node.children) {
      str += child.data + ", ";
    }
    str += ".";
    System.out.println(str);

    for (Node child : node.children) {
      display(child);
    }
  }

  public static Node construct(int[] arr) {
    Node root = null;
    Stack< Node> st = new Stack< >();
    for (int i = 0; i < arr.length; i++) {
      if (arr[i] == -1) {
        st.pop();
      } else {
        Node t = new Node();
        t.data = arr[i];

        if (st.size() > 0) {
          st.peek().children.add(t);
        } else {
          root = t;
        }
        st.push(t);
      }
    }
    return root;
  }

  public static void mirror(Node node) {

    for (Node child : node.children) { //1
      mirror(child);
    }
    Collections.reverse(node.children); //2

  }
  public static void main(String[] args) throws Exception {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    int n = Integer.parseInt(br.readLine());
    int[] arr = new int[n];
    String[] values = br.readLine().split(" ");
    for (int i = 0; i < n; i++) {
      arr[i] = Integer.parseInt(values[i]);
    }

    Node root = construct(arr);
    display(root);
    mirror(root);
    display(root);
  }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Remove Leaves in Generic Tree</span>
import java.io.*;

import java.util.*;

public class Main {
  private static class Node {
    int data;
    ArrayList< Node> children = new ArrayList< >();
  }

  public static void display(Node node) {
    String str = node.data + " -> ";
    for (Node child : node.children) {
      str += child.data + ", ";
    }
    str += ".";
    System.out.println(str);

    for (Node child : node.children) {
      display(child);
    }
  }

  public static Node construct(int[] arr) {
    Node root = null;

    Stack< Node> st = new Stack< >();
    for (int i = 0; i < arr.length; i++) {
      if (arr[i] == -1) {
        st.pop();
      } else {
        Node t = new Node();
        t.data = arr[i];

        if (st.size() > 0) {
          st.peek().children.add(t);
        } else {
          root = t;
        }

        st.push(t);
      }
    }

    return root;
  }

  public static void removeLeaves(Node node) {
    for (int i = node.children.size() - 1; i >= 0; i--) {
      Node child = node.children.get(i);
      if (child.children.size() == 0) {
        node.children.remove(i);
      }
    }

    for (Node child : node.children) {
      removeLeaves(child);
    }
  }

  public static void main(String[] args) throws Exception {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    int n = Integer.parseInt(br.readLine());
    int[] arr = new int[n];
    String[] values = br.readLine().split(" ");
    for (int i = 0; i < n; i++) {
      arr[i] = Integer.parseInt(values[i]);
    }

    Node root = construct(arr);
    removeLeaves(root);
    display(root);
  }

}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Linearize A Generic Tree</span>
import java.io.*;

import java.util.*;

public class Main {
  private static class Node {
    int data;
    ArrayList< Node> children = new ArrayList< >();
  }

  public static void display(Node node) {
    String str = node.data + " -> ";
    for (Node child : node.children) {
      str += child.data + ", ";
    }
    str += ".";
    System.out.println(str);

    for (Node child : node.children) {
      display(child);
    }
  }

  public static Node construct(int[] arr) {
    Node root = null;

    Stack< Node> st = new Stack< >();
    for (int i = 0; i < arr.length; i++) {
      if (arr[i] == -1) {
        st.pop();
      } else {
        Node t = new Node();
        t.data = arr[i];

        if (st.size() > 0) {
          st.peek().children.add(t);
        } else {
          root = t;
        }

        st.push(t);
      }
    }

    return root;
  }

  public static int size(Node node) {
    int s = 0;

    for (Node child : node.children) {
      s += size(child);
    }
    s += 1;

    return s;
  }

  public static int max(Node node) {
    int m = Integer.MIN_VALUE;

    for (Node child : node.children) {
      int cm = max(child);
      m = Math.max(m, cm);
    }
    m = Math.max(m, node.data);

    return m;
  }

  public static int height(Node node) {
    int h = -1;

    for (Node child : node.children) {
      int ch = height(child);
      h = Math.max(h, ch);
    }
    h += 1;

    return h;
  }

  public static void traversals(Node node) {
    System.out.println("Node Pre " + node.data);

    for (Node child : node.children) {
      System.out.println("Edge Pre " + node.data + "--" + child.data);
      traversals(child);
      System.out.println("Edge Post " + node.data + "--" + child.data);
    }

    System.out.println("Node Post " + node.data);
  }

  public static void levelOrderLinewiseZZ(Node node) {
    Stack< Node> stack = new Stack< >();
    stack.add(node);

    Stack< Node> cstack = new Stack< >();
    int level = 0;

    while (stack.size() > 0) {
      node = stack.pop();
      System.out.print(node.data + " ");

      if (level % 2 == 0) {
        for (int i = 0; i < node.children.size(); i++) {
          Node child = node.children.get(i);
          cstack.push(child);
        }
      } else {
        for (int i = node.children.size() - 1; i >= 0; i--) {
          Node child = node.children.get(i);
          cstack.push(child);
        }
      }

      if (stack.size() == 0) {
        stack = cstack;
        cstack = new Stack< >();
        level++;
        System.out.println();
      }
    }
  }

  public static void mirror(Node node) {
    for (Node child : node.children) {
      mirror(child);
    }
    Collections.reverse(node.children);
  }

  public static void removeLeaves(Node node) {
    for (int i = node.children.size() - 1; i >= 0; i--) {
      Node child = node.children.get(i);
      if (child.children.size() == 0) {
        node.children.remove(i);
      }
    }

    for (Node child : node.children) {
      removeLeaves(child);
    }
  }

  private static Node getTail(Node node) {
    while (node.children.size() == 1) {
      node = node.children.get(0);
    }
    return node;
  }

  public static void linearize(Node node) {
    for (Node child : node.children) {
      linearize(child);
    }

    while (node.children.size() > 1) {
      Node lc = node.children.remove(node.children.size() - 1);
      Node sl = node.children.get(node.children.size() - 1);
      Node slt = getTail(sl);
      slt.children.add(lc);
    }
  }

  public static void main(String[] args) throws Exception {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    int n = Integer.parseInt(br.readLine());
    int[] arr = new int[n];
    String[] values = br.readLine().split(" ");
    for (int i = 0; i < n; i++) {
      arr[i] = Integer.parseInt(values[i]);
    }

    Node root = construct(arr);
    linearize(root);
    display(root);
  }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Linearize a Generic Tree- Efficient Approach</span>
import java.io.*;

import java.util.*;

public class Main {
  private static class Node {
    int data;
    ArrayList< Node> children = new ArrayList< >();
  }

  public static void display(Node node) {
    String str = node.data + " -> ";
    for (Node child : node.children) {
      str += child.data + ", ";
    }
    str += ".";
    System.out.println(str);

    for (Node child : node.children) {
      display(child);
    }
  }

  public static Node construct(int[] arr) {
    Node root = null;

    Stack< Node> st = new Stack< >();
    for (int i = 0; i < arr.length; i++) {
      if (arr[i] == -1) {
        st.pop();
      } else {
        Node t = new Node();
        t.data = arr[i];

        if (st.size() > 0) {
          st.peek().children.add(t);
        } else {
          root = t;
        }

        st.push(t);
      }
    }

    return root;
  }

  public static int size(Node node) {
    int s = 0;

    for (Node child : node.children) {
      s += size(child);
    }
    s += 1;

    return s;
  }

  public static int max(Node node) {
    int m = Integer.MIN_VALUE;

    for (Node child : node.children) {
      int cm = max(child);
      m = Math.max(m, cm);
    }
    m = Math.max(m, node.data);

    return m;
  }

  public static int height(Node node) {
    int h = -1;

    for (Node child : node.children) {
      int ch = height(child);
      h = Math.max(h, ch);
    }
    h += 1;

    return h;
  }

  public static void traversals(Node node) {
    System.out.println("Node Pre " + node.data);

    for (Node child : node.children) {
      System.out.println("Edge Pre " + node.data + "--" + child.data);
      traversals(child);
      System.out.println("Edge Post " + node.data + "--" + child.data);
    }

    System.out.println("Node Post " + node.data);
  }

  public static void levelOrderLinewiseZZ(Node node) {
    Stack< Node> stack = new Stack< >();
    stack.add(node);

    Stack< Node> cstack = new Stack< >();
    int level = 0;

    while (stack.size() > 0) {
      node = stack.pop();
      System.out.print(node.data + " ");

      if (level % 2 == 0) {
        for (int i = 0; i < node.children.size(); i++) {
          Node child = node.children.get(i);
          cstack.push(child);
        }
      } else {
        for (int i = node.children.size() - 1; i >= 0; i--) {
          Node child = node.children.get(i);
          cstack.push(child);
        }
      }

      if (stack.size() == 0) {
        stack = cstack;
        cstack = new Stack< >();
        level++;
        System.out.println();
      }
    }
  }

  public static void mirror(Node node) {
    for (Node child : node.children) {
      mirror(child);
    }
    Collections.reverse(node.children);
  }

  public static void removeLeaves(Node node) {
    for (int i = node.children.size() - 1; i >= 0; i--) {
      Node child = node.children.get(i);
      if (child.children.size() == 0) {
        node.children.remove(i);
      }
    }

    for (Node child : node.children) {
      removeLeaves(child);
    }
  }

  public static Node linearize(Node node) {

    if (node.children.size() == 0)
    {
      return node;
    }
    Node lkt = linearize(node.children.get(node.children.size() - 1));
    while (node.children.size() > 1)
    {
      Node last = node.children.remove(node.children.size() - 1);
      Node sl = node.children.get(node.children.size() - 1);
      Node slt = linearize(sl);
      slt.children.add(last);
    }
    return lkt;
  }

  public static void main(String[] args) throws Exception {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    int n = Integer.parseInt(br.readLine());
    int[] arr = new int[n];
    String[] values = br.readLine().split(" ");
    for (int i = 0; i < n; i++) {
      arr[i] = Integer.parseInt(values[i]);
    }

    Node root = construct(arr);
    linearize(root);
    display(root);
  }

}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Find in Generic Tree</span>
import java.io.*;

import java.util.*;

public class Main {
  private static class Node {
    int data;
    ArrayList< Node> children = new ArrayList< >();
  }

  public static void display(Node node) {
    String str = node.data + " -> ";
    for (Node child : node.children) {
      str += child.data + ", ";
    }
    str += ".";
    System.out.println(str);

    for (Node child : node.children) {
      display(child);
    }
  }

  public static Node construct(int[] arr) {
    Node root = null;

    Stack< Node> st = new Stack< >();
    for (int i = 0; i < arr.length; i++) {
      if (arr[i] == -1) {
        st.pop();
      } else {
        Node t = new Node();
        t.data = arr[i];

        if (st.size() > 0) {
          st.peek().children.add(t);
        } else {
          root = t;
        }

        st.push(t);
      }
    }

    return root;
  }

  public static boolean find(Node node, int data) {
    if (node.data == data) {
      return true;
    }

    for (Node child : node.children) {
      boolean fic = find(child, data);
      if (fic) {
        return true;
      }
    }

    return false;
  }

  public static void main(String[] args) throws Exception {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    int n = Integer.parseInt(br.readLine());
    int[] arr = new int[n];
    String[] values = br.readLine().split(" ");
    for (int i = 0; i < n; i++) {
      arr[i] = Integer.parseInt(values[i]);
    }

    int data = Integer.parseInt(br.readLine());

    Node root = construct(arr);
    boolean flag = find(root, data);
    System.out.println(flag);
    // display(root);
  }

}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Node To Root Path In Generic Tree</span>
import java.io.*;

import java.util.*;

public class Main {
  private static class Node {
    int data;
    ArrayList< Node> children = new ArrayList< >();
  }

  public static void display(Node node) {
    String str = node.data + " -> ";
    for (Node child : node.children) {
      str += child.data + ", ";
    }
    str += ".";
    System.out.println(str);

    for (Node child : node.children) {
      display(child);
    }
  }

  public static Node construct(int[] arr) {
    Node root = null;
    Stack< Node> st = new Stack< >();
    for (int i = 0; i < arr.length; i++) {
      if (arr[i] == -1) {
        st.pop();
      } else {
        Node t = new Node();
        t.data = arr[i];
        if (st.size() > 0) {
          st.peek().children.add(t);
        } else {
          root = t;
        }
        st.push(t);
      }
    }
    return root;
  }

  public static ArrayList< Integer> nodeToRootPath(Node node, int data) {
    if (node.data == data) { //1
      ArrayList < Integer> list = new ArrayList< >();
      list.add(node.data);
      return list;
    }
    for (Node child : node.children) {
      ArrayList< Integer> ptc = nodeToRootPath(child, data); //2
      if (ptc.size() > 0) { //3
        ptc.add(node.data);
        return ptc;
      }
    }
    return new ArrayList< >(); //4
  }

  public static void main(String[] args) throws Exception {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    int n = Integer.parseInt(br.readLine());
    int[] arr = new int[n];
    String[] values = br.readLine().split(" ");
    for (int i = 0; i < n; i++) {
      arr[i] = Integer.parseInt(values[i]);
    }

    int data = Integer.parseInt(br.readLine());

    Node root = construct(arr);
    ArrayList< Integer> path = nodeToRootPath(root, data);
    System.out.println(path);
    // display(root);
  }

}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Lowest Common Ancestor - Generic Tree</span>
import java.io.*;

import java.util.*;

public class Main {
  private static class Node {
    int data;
    ArrayList< Node> children = new ArrayList< >();
  }

  public static Node construct(int[] arr) {
    Node root = null;

    Stack< Node> st = new Stack< >();
    for (int i = 0; i < arr.length; i++) {
      if (arr[i] == -1) {
        st.pop();
      } else {
        Node t = new Node();
        t.data = arr[i];

        if (st.size() > 0) {
          st.peek().children.add(t);
        } else {
          root = t;
        }

        st.push(t);
      }
    }

    return root;
  }

  public static ArrayList< Integer> nodeToRootPath(Node node, int data) {
    if (node.data == data) {
      ArrayList< Integer> path = new ArrayList< >();
      path.add(node.data);
      return path;
    }

    for (Node child : node.children) {
      ArrayList< Integer> ptc = nodeToRootPath(child, data);
      if (ptc.size() > 0) {
        ptc.add(node.data);
        return ptc;
      }
    }

    return new ArrayList< >();
  }

  public static int lca(Node node, int d1, int d2) {
    ArrayList< Integer> p1 = nodeToRootPath(node, d1);
    ArrayList< Integer> p2 = nodeToRootPath(node, d2);

    int i = p1.size() - 1;
    int j = p2.size() - 1;

    while (i >= 0 && j >= 0 && p1.get(i) == p2.get(j)) {
      i--;
      j--;
    }

    return p1.get(i + 1);
  }

  public static void main(String[] args) throws Exception {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    int n = Integer.parseInt(br.readLine());
    int[] arr = new int[n];
    String[] values = br.readLine().split(" ");
    for (int i = 0; i < n; i++) {
      arr[i] = Integer.parseInt(values[i]);
    }

    int d1 = Integer.parseInt(br.readLine());
    int d2 = Integer.parseInt(br.readLine());

    Node root = construct(arr);
    int lca = lca(root, d1, d2);
    System.out.println(lca);
  }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Distance Between Two Nodes In A Generic Tree</span>
import java.io.*;

import java.util.*;

public class Main {
  private static class Node {
    int data;
    ArrayList< Node> children = new ArrayList< >();
  }

  public static void display(Node node) {
    String str = node.data + " -> ";
    for (Node child : node.children) {
      str += child.data + ", ";
    }
    str += ".";
    System.out.println(str);

    for (Node child : node.children) {
      display(child);
    }
  }

  public static Node construct(int[] arr) {
    Node root = null;

    Stack< Node> st = new Stack< >();
    for (int i = 0; i < arr.length; i++) {
      if (arr[i] == -1) {
        st.pop();
      } else {
        Node t = new Node();
        t.data = arr[i];

        if (st.size() > 0) {
          st.peek().children.add(t);
        } else {
          root = t;
        }

        st.push(t);
      }
    }

    return root;
  }

  public static ArrayList< Integer> nodeToRootPath(Node node, int data) {
    if (node.data == data) {
      ArrayList< Integer> path = new ArrayList< >();
      path.add(node.data);
      return path;
    }

    for (Node child : node.children) {
      ArrayList< Integer> ptc = nodeToRootPath(child, data);
      if (ptc.size() > 0) {
        ptc.add(node.data);
        return ptc;
      }
    }

    return new ArrayList< >();
  }

  public static int lca(Node node, int d1, int d2) {
    ArrayList< Integer> p1 = nodeToRootPath(node, d1);
    ArrayList< Integer> p2 = nodeToRootPath(node, d2);

    int i = p1.size() - 1;
    int j = p2.size() - 1;

    while (i >= 0 && j >= 0 && p1.get(i) == p2.get(j)) {
      i--;
      j--;
    }

    return p1.get(i + 1);
  }

  public static int distanceBetweenNodes(Node node, int d1, int d2) {
    ArrayList< Integer> p1 = nodeToRootPath(node, d1);
    ArrayList< Integer> p2 = nodeToRootPath(node, d2);

    int i = p1.size() - 1;
    int j = p2.size() - 1;

    while (i >= 0 && j >= 0 && p1.get(i) == p2.get(j)) {
      i--;
      j--;
    }
    i++;
    j++;
    return i + j;
  }

  public static void main(String[] args) throws Exception {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    int n = Integer.parseInt(br.readLine());
    int[] arr = new int[n];
    String[] values = br.readLine().split(" ");
    for (int i = 0; i < n; i++) {
      arr[i] = Integer.parseInt(values[i]);
    }

    int d1 = Integer.parseInt(br.readLine());
    int d2 = Integer.parseInt(br.readLine());

    Node root = construct(arr);
    int dist = distanceBetweenNodes(root, d1, d2);
    System.out.println(dist);
    // display(root);
  }

}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Are Trees Similar In Shape</span>
import java.io.*;

import java.util.*;

public class Main {
  private static class Node {
    int data;
    ArrayList< Node> children = new ArrayList< >();
  }

  public static void display(Node node) {
    String str = node.data + " -> ";
    for (Node child : node.children) {
      str += child.data + ", ";
    }
    str += ".";
    System.out.println(str);

    for (Node child : node.children) {
      display(child);
    }
  }

  public static Node construct(int[] arr) {
    Node root = null;

    Stack< Node> st = new Stack< >();
    for (int i = 0; i < arr.length; i++) {
      if (arr[i] == -1) {
        st.pop();
      } else {
        Node t = new Node();
        t.data = arr[i];

        if (st.size() > 0) {
          st.peek().children.add(t);
        } else {
          root = t;
        }

        st.push(t);
      }
    }

    return root;
  }

  public static int size(Node node) {
    int s = 0;

    for (Node child : node.children) {
      s += size(child);
    }
    s += 1;

    return s;
  }

  public static int max(Node node) {
    int m = Integer.MIN_VALUE;

    for (Node child : node.children) {
      int cm = max(child);
      m = Math.max(m, cm);
    }
    m = Math.max(m, node.data);

    return m;
  }

  public static int height(Node node) {
    int h = -1;

    for (Node child : node.children) {
      int ch = height(child);
      h = Math.max(h, ch);
    }
    h += 1;

    return h;
  }

  public static boolean areSimilar(Node n1, Node n2) {
    if (n1.children.size() != n2.children.size()) {
      return false;
    }

    for (int i = 0; i < n1.children.size(); i++) {
      Node c1 = n1.children.get(i);
      Node c2 = n2.children.get(i);
      if (areSimilar(c1, c2) == false) {
        return false;
      }
    }

    return true;
  }

  public static void main(String[] args) throws Exception {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

    int n1 = Integer.parseInt(br.readLine());
    int[] arr1 = new int[n1];
    String[] values1 = br.readLine().split(" ");
    for (int i = 0; i < n1; i++) {
      arr1[i] = Integer.parseInt(values1[i]);
    }
    Node root1 = construct(arr1);

    int n2 = Integer.parseInt(br.readLine());
    int[] arr2 = new int[n2];
    String[] values2 = br.readLine().split(" ");
    for (int i = 0; i < n2; i++) {
      arr2[i] = Integer.parseInt(values2[i]);
    }
    Node root2 = construct(arr2);

    boolean similar = areSimilar(root1, root2);
    System.out.println(similar);
  }

}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Is Generic tree Symmetric</span>
import java.io.*;

import java.util.*;

public class Main {
  private static class Node {
    int data;
    ArrayList< Node> children = new ArrayList< >();
  }

  public static void display(Node node) {
    String str = node.data + " -> ";
    for (Node child : node.children) {
      str += child.data + ", ";
    }
    str += ".";
    System.out.println(str);

    for (Node child : node.children) {
      display(child);
    }
  }

  public static Node construct(int[] arr) {
    Node root = null;

    Stack< Node> st = new Stack< >();
    for (int i = 0; i < arr.length; i++) {
      if (arr[i] == -1) {
        st.pop();
      } else {
        Node t = new Node();
        t.data = arr[i];

        if (st.size() > 0) {
          st.peek().children.add(t);
        } else {
          root = t;
        }

        st.push(t);
      }
    }

    return root;
  }

  public static int size(Node node) {
    int s = 0;

    for (Node child : node.children) {
      s += size(child);
    }
    s += 1;

    return s;
  }

  public static int max(Node node) {
    int m = Integer.MIN_VALUE;

    for (Node child : node.children) {
      int cm = max(child);
      m = Math.max(m, cm);
    }
    m = Math.max(m, node.data);

    return m;
  }

  public static int height(Node node) {
    int h = -1;

    for (Node child : node.children) {
      int ch = height(child);
      h = Math.max(h, ch);
    }
    h += 1;

    return h;
  }

  public static boolean areMirror(Node n1, Node n2) {
    if (n1.children.size() != n2.children.size()) {
      return false;
    }

    for (int i = 0; i < n1.children.size(); i++) {
      Node c1 = n1.children.get(i);
      Node c2 = n2.children.get(n2.children.size() - 1 - i);
      if (areMirror(c1, c2) == false) {
        return false;
      }
    }

    return true;
  }

  public static boolean IsSymmetric(Node node) {
    return areMirror(node, node);
  }

  public static void main(String[] args) throws Exception {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    int n = Integer.parseInt(br.readLine());
    int[] arr = new int[n];
    String[] values = br.readLine().split(" ");
    for (int i = 0; i < n; i++) {
      arr[i] = Integer.parseInt(values[i]);
    }

    Node root = construct(arr);
    boolean sym = IsSymmetric(root);
    System.out.println(sym);
    // display(root);
  }

}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Multisolver For Generic Tree</span>
import java.io.*;

import java.util.*;

public class Main {
  private static class Node {
    int data;
    ArrayList< Node> children = new ArrayList< >();
  }

  public static void display(Node node) {
    String str = node.data + " -> ";
    for (Node child : node.children) {
      str += child.data + ", ";
    }
    str += ".";
    System.out.println(str);

    for (Node child : node.children) {
      display(child);
    }
  }

  public static Node construct(int[] arr) {
    Node root = null;

    Stack< Node> st = new Stack< >();
    for (int i = 0; i < arr.length; i++) {
      if (arr[i] == -1) {
        st.pop();
      } else {
        Node t = new Node();
        t.data = arr[i];

        if (st.size() > 0) {
          st.peek().children.add(t);
        } else {
          root = t;
        }

        st.push(t);
      }
    }

    return root;
  }
  //******************************MULTISOLVER*******************************

  static int size;        //1
  static int min;
  static int max;
  static int height;

  public static void multisolver(Node node, int depth) { //3

    size++;  //4
    min = Math.min(min, node.data);
    max = Math.max(max, node.data);
    height = Math.max(height, depth);

    for (Node child : node.children) { //5
      multisolver(child, depth + 1);
    }
  }


  public static void main(String[] args) throws Exception {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    int n = Integer.parseInt(br.readLine());
    int[] arr = new int[n];
    String[] values = br.readLine().split(" ");
    for (int i = 0; i < n; i++) {
      arr[i] = Integer.parseInt(values[i]);
    }

    Node root = construct(arr);

    size = 0;         //2
    min = Integer.MAX_VALUE;
    max = Integer.MIN_VALUE;
    height = 0;

    multisolver(root, 0);

    System.out.println("Size=" + size);
    System.out.println("Min=" + min);
    System.out.println("Max=" + max);
    System.out.println("Height=" + height);
  }

}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Predecessor and Successor of an Element</span>
import java.io.*;

import java.util.*;

public class Main {
  private static class Node {
    int data;
    ArrayList< Node> children = new ArrayList< >();
  }

  public static void display(Node node) {
    String str = node.data + " -> ";
    for (Node child : node.children) {
      str += child.data + ", ";
    }
    str += ".";
    System.out.println(str);

    for (Node child : node.children) {
      display(child);
    }
  }

  public static Node construct(int[] arr) {
    Node root = null;

    Stack< Node> st = new Stack< >();
    for (int i = 0; i < arr.length; i++) {
      if (arr[i] == -1) {
        st.pop();
      } else {
        Node t = new Node();
        t.data = arr[i];

        if (st.size() > 0) {
          st.peek().children.add(t);
        } else {
          root = t;
        }

        st.push(t);
      }
    }

    return root;
  }

  static Node predecessor;
  static Node successor;
  static int state;

  public static void predecessorAndSuccessor(Node node, int data) {
    if (state == 0) {
      if (node.data == data) {
        state++;
      } else {
        predecessor = node;
      }
    } else if (state == 1) {
      successor = node;
      state++;
    }

    for (Node child : node.children) {
      predecessorAndSuccessor(child, data);
    }
  }

  public static void main(String[] args) throws Exception {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    int n = Integer.parseInt(br.readLine());
    int[] arr = new int[n];
    String[] values = br.readLine().split(" ");
    for (int i = 0; i < n; i++) {
      arr[i] = Integer.parseInt(values[i]);
    }

    int data = Integer.parseInt(br.readLine());

    Node root = construct(arr);
    predecessor = null;
    successor = null;
    state = 0;
    predecessorAndSuccessor(root, data);
    if (predecessor == null) {
      System.out.println("Predecessor = Not found");
    } else {
      System.out.println("Predecessor = " + predecessor.data);
    }

    if (successor == null) {
      System.out.println("Successor = Not found");
    } else {
      System.out.println("Successor = " + successor.data);
    }
  }

}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Ceil and Floor in a Generic Tree</span>
import java.io.*;

import java.util.*;

public class Main {
  private static class Node {
    int data;
    ArrayList< Node> children = new ArrayList<>();
  }

  public static void display(Node node) {
    String str = node.data + " -> ";
    for (Node child : node.children) {
      str += child.data + ", ";
    }
    str += ".";
    System.out.println(str);

    for (Node child : node.children) {
      display(child);
    }
  }

  public static Node construct(int[] arr) {
    Node root = null;

    Stack< Node> st = new Stack<>();
    for (int i = 0; i < arr.length; i++) {
      if (arr[i] == -1) {
        st.pop();
      } else {
        Node t = new Node();
        t.data = arr[i];

        if (st.size() > 0) {
          st.peek().children.add(t);
        } else {
          root = t;
        }

        st.push(t);
      }
    }

    return root;
  }


  static int ceil;
  static int floor;
  public static void ceilAndFloor(Node node, int data) {
    if (node.data > data) {
      if (node.data < ceil) {
        ceil = node.data;
      }
    }

    if (node.data < data) {
      if (node.data > floor) {
        floor = node.data;
      }
    }

    for (Node child : node.children) {
      ceilAndFloor(child, data);
    }
  }

  public static void main(String[] args) throws Exception {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    int n = Integer.parseInt(br.readLine());
    int[] arr = new int[n];
    String[] values = br.readLine().split(" ");
    for (int i = 0; i < n; i++) {
      arr[i] = Integer.parseInt(values[i]);
    }

    int data = Integer.parseInt(br.readLine());

    Node root = construct(arr);
    ceil = Integer.MAX_VALUE;
    floor = Integer.MIN_VALUE;
    ceilAndFloor(root, data);
    System.out.println("CEIL = " + ceil);
    System.out.println("FLOOR = " + floor);
  }

}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Kth Largest Element - Generic Tree</span>
import java.io.*;

import java.util.*;

public class Main {
  private static class Node {
    int data;
    ArrayList< Node> children = new ArrayList<>();
  }

  public static void display(Node node) {
    String str = node.data + " -> ";
    for (Node child : node.children) {
      str += child.data + ", ";
    }
    str += ".";
    System.out.println(str);

    for (Node child : node.children) {
      display(child);
    }
  }

  public static Node construct(int[] arr) {
    Node root = null;

    Stack< Node> st = new Stack<>();
    for (int i = 0; i < arr.length; i++) {
      if (arr[i] == -1) {
        st.pop();
      } else {
        Node t = new Node();
        t.data = arr[i];

        if (st.size() > 0) {
          st.peek().children.add(t);
        } else {
          root = t;
        }

        st.push(t);
      }
    }

    return root;
  }


  static int floor;
  public static void ceilAndFloor(Node node, int data) {
    if (node.data < data) {
      if (node.data > floor) {
        floor = node.data;
      }
    }

    for (Node child : node.children) {
      ceilAndFloor(child, data);
    }
  }

  public static int kthLargest(Node node, int k) {
    int data = Integer.MAX_VALUE;
    floor = Integer.MIN_VALUE;

    for (int i = 0; i < k; i++) {
      ceilAndFloor(node, data);
      data = floor;
      floor = Integer.MIN_VALUE;
    }

    return data;
  }

  public static void main(String[] args) throws Exception {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    int n = Integer.parseInt(br.readLine());
    int[] arr = new int[n];
    String[] values = br.readLine().split(" ");
    for (int i = 0; i < n; i++) {
      arr[i] = Integer.parseInt(values[i]);
    }

    int k = Integer.parseInt(br.readLine());

    Node root = construct(arr);
    int kthLargest = kthLargest(root, k);
    System.out.println(kthLargest);
  }

}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Node with Maximum Subtree Sum:</span>
import java.io.*;

import java.util.*;

public class Main {
  private static class Node {
    int data;
    ArrayList< Node> children = new ArrayList< >();
  }

  public static void display(Node node) {
    String str = node.data + " -> ";
    for (Node child : node.children) {
      str += child.data + ", ";
    }
    str += ".";
    System.out.println(str);

    for (Node child : node.children) {
      display(child);
    }
  }

  public static Node construct(int[] arr) {
    Node root = null;

    Stack< Node> st = new Stack< >();
    for (int i = 0; i < arr.length; i++) {
      if (arr[i] == -1) {
        st.pop();
      } else {
        Node t = new Node();
        t.data = arr[i];

        if (st.size() > 0) {
          st.peek().children.add(t);
        } else {
          root = t;
        }

        st.push(t);
      }
    }

    return root;
  }

  static int mSum = Integer.MIN_VALUE;
  static int mSumNode = Integer.MIN_VALUE;
  public static int nodeWithMaximumSubtreeSum(Node node) {
    int sum = node.data;

    for (Node child : node.children) {
      int cstSum = nodeWithMaximumSubtreeSum(child);
      sum += cstSum;
    }

    if (sum > mSum) {
      mSum = sum;
      mSumNode = node.data;
    }

    return sum;
  }

  public static void main(String[] args) throws Exception {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    int n = Integer.parseInt(br.readLine());
    int[] arr = new int[n];
    String[] values = br.readLine().split(" ");
    for (int i = 0; i < n; i++) {
      arr[i] = Integer.parseInt(values[i]);
    }

    Node root = construct(arr);
    mSum = Integer.MIN_VALUE;
    mSumNode = 0;
    nodeWithMaximumSubtreeSum(root);
    System.out.println(mSumNode + "@" + mSum);
  }

}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Diameter in a Generic Tree</span>
import java.io.*;

import java.util.*;

public class Main {
  private static class Node {
    int data;
    ArrayList< Node> children = new ArrayList<>();
  }

  public static void display(Node node) {
    String str = node.data + " -> ";
    for (Node child : node.children) {
      str += child.data + ", ";
    }
    str += ".";
    System.out.println(str);

    for (Node child : node.children) {
      display(child);
    }
  }

  public static Node construct(int[] arr) {
    Node root = null;

    Stack< Node> st = new Stack< >();
    for (int i = 0; i < arr.length; i++) {
      if (arr[i] == -1) {
        st.pop();
      } else {
        Node t = new Node();
        t.data = arr[i];

        if (st.size() > 0) {
          st.peek().children.add(t);
        } else {
          root = t;
        }

        st.push(t);
      }
    }

    return root;
  }

  static class Pair {
    Node node;
    int state;

    Pair(Node node, int state) {
      this.node = node;
      this.state = state;
    }
  }

  public static void IterativePreandPostOrder(Node node) {
    Pair p = new Pair(node, -1);
    Stack< Pair> st = new Stack< >();
    st.push(p);

    String preOrder = "";
    String postOrder = "";

    while (st.size() > 0) {
      Pair top = st.peek();
      if (top.state == -1) {
        preOrder += top.node.data + " ";
        top.state++;
      } else if (top.state >= 0 && top.state < top.node.children.size()) {
        Pair cp = new Pair(top.node.children.get(top.state), -1);
        st.push(cp);

        top.state++;
      } else {
        postOrder += top.node.data + " ";
        st.pop();
      }
    }

    System.out.println(preOrder);
    System.out.println(postOrder);
  }

  public static void main(String[] args) throws Exception {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    int n = Integer.parseInt(br.readLine());
    int[] arr = new int[n];
    String[] values = br.readLine().split(" ");
    for (int i = 0; i < n; i++) {
      arr[i] = Integer.parseInt(values[i]);
    }

    Node root = construct(arr);
    IterativePreandPostOrder(root);
  }

}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Iterative Preorder and Postorder of Generic Tree</span>
import java.io.*;

import java.util.*;

public class Main {
  private static class Node {
    int data;
    ArrayList< Node> children = new ArrayList< >();
  }

  public static void display(Node node) {
    String str = node.data + " -> ";
    for (Node child : node.children) {
      str += child.data + ", ";
    }
    str += ".";
    System.out.println(str);

    for (Node child : node.children) {
      display(child);
    }
  }

  public static Node construct(int[] arr) {
    Node root = null;

    Stack< Node> st = new Stack< >();
    for (int i = 0; i < arr.length; i++) {
      if (arr[i] == -1) {
        st.pop();
      } else {
        Node t = new Node();
        t.data = arr[i];

        if (st.size() > 0) {
          st.peek().children.add(t);
        } else {
          root = t;
        }

        st.push(t);
      }
    }

    return root;
  }

  static class Pair {
    Node node;
    int state;

    Pair(Node node, int state) {
      this.node = node;
      this.state = state;
    }
  }

  public static void IterativePreandPostOrder(Node node) {
    Pair p = new Pair(node, -1);
    Stack< Pair> st = new Stack< >();
    st.push(p);

    String preOrder = "";
    String postOrder = "";

    while (st.size() > 0) {
      Pair top = st.peek();
      if (top.state == -1) {
        preOrder += top.node.data + " ";
        top.state++;
      } else if (top.state >= 0 && top.state < top.node.children.size()) {
        Pair cp = new Pair(top.node.children.get(top.state), -1);
        st.push(cp);

        top.state++;
      } else {
        postOrder += top.node.data + " ";
        st.pop();
      }
    }

    System.out.println(preOrder);
    System.out.println(postOrder);
  }

  public static void main(String[] args) throws Exception {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    int n = Integer.parseInt(br.readLine());
    int[] arr = new int[n];
    String[] values = br.readLine().split(" ");
    for (int i = 0; i < n; i++) {
      arr[i] = Integer.parseInt(values[i]);
    }

    Node root = construct(arr);
    IterativePreandPostOrder(root);
  }

}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">ITERABLE AND ITERATOR</span>
public class GenericTree
{
  Node root;

  GenericTree(Node root)
  {
    this.root = root
  }
}
public static class GenericTree implements Iterable< Integer> {
  Node root;

  GenericTree(Node root) {
    this.root = root
  }
  public Iterator< Integer> iterator() {
    Iterator< Integer> obj = new GTPreorderIterator();
    return obj;
  }
}
<span class="textStyle">//**********************hasNext() function************************</span>
public boolean hasNext()
{
  if (nval == null)
  {
    return false;

  } else
  {
    return false;
  }
}

<span class="textStyle">//**********************next() function************************</span>
public Integer next() {
  Integer fr = nval;
  // moves nval forward, if not possible sets it to null
  nval = null;
  while (st.size() > 0) {
    Pair top = st.peek();
    if (top.state == -1) {
      nval = top.node.data;
      top.state++;
      break;
    }
    else if (top.state >= 0 && top.state < top.node.children.size()) {
      Pair cp = new Pair(top.node.children.get(top.state), -1);
      st.push(cp);
      top.state++;

    }
    else {
      st.pop();
    }
  }
  return fr;
}
}

<span class="textStyle">//**********************CLASS PAIR************************</span>
private static class Pair {
  Node node;
  int state;
  Pair(Node node, int state) {
    this.node = node;
    this.state = state;
  }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Binary Tree Intro</span>
<span class="textStyle">Binary Tree Intro</span>
import java.io.*;

import java.util.*;

public class Main {
  public static class Node {
    int data;
    Node left;
    Node right;
  }

  Node (int data, Node left, Node right) {
    this.data = data;
    this.left = left;
    this.right = right;
  }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Binary Tree Constructor</span>
import java.util.*;

public class Main {
  public static class Node {
    int data;
    Node left;
    Node right;
    Node() {
    }
    Node(int data) {
      this.data = data;
    }
  }
  public static class Pair {
    Node node;
    int state;

    Pair() {
    }

    Pair(Node node, int state) {
      this.node = node;
      this.state = state;
    }
  }

  public static Node construct(Integer[]arr) {
    Node root = new Node(arr[0]);

    Stack< Pair>st = new Stack< >();
    Pair root_pair = new Pair(root, 1);

    st.push(root_pair);
    int idx = 1;

    while (st.size() > 0) {
      Pair top = st.peek();

      if (top.state == 1) {
        //waiting for left child
        top.state++;
        if (arr[idx] != null) {
          Node lc = new Node(arr[idx]);
          top.node.left = lc;

          Pair lcp = new Pair(lc, 1);
          st.push(lcp);
        }
        idx++;
      }
      else if (top.state == 2) {
        //waiting for right child
        top.state++;
        if (arr[idx] != null) {
          Node rc = new Node(arr[idx]);
          top.node.right = rc;

          Pair rcp = new Pair(rc, 1);
          st.push(rcp);
        }
        idx++;
      }
      else if (top.state == 3) {
        st.pop();
      }
    }
    return root;

  }

  public static void display(Node node) {
    if (node == null) {
      return;
    }

    String str = " <- " + node.data + " -> ";

    String left = (node.left == null) ? "." :  "" + node.left.data;
    String right = (node.right == null) ? "." : "" + node.right.data;

    str = left + str + right;

    System.out.println(str);

    display(node.left);
    display(node.right);
  }

  public static void main(String[]args) {
    Integer[]arr = {50, 25, 12, null, null, 37, 30, null, null, null, 75, 62, null, 70, null, null, 87, null, null};

    Node root = construct(arr);
  }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Display Binary Tree</span>
import java.util.*;


public class Main {

  public static class Node {
    int data;
    Node left;
    Node right;


    Node(int data) {
      this.data = data;
    }
  }

  public static class Pair {
    Node node;
    int state;

    Pair() {

    }

    Pair(Node node, int state) {
      this.node = node;
      this.state = state;
    }
  }

  public static Node construct(Integer[]arr) {
    Node root = new Node(arr[0]);

    Stack< Pair>st = new Stack< >();
    Pair root_pair = new Pair(root, 1);

    st.push(root_pair);
    int idx = 1;

    while (st.size() > 0) {
      Pair top = st.peek();

      if (top.state == 1) {
        //waiting for left child
        top.state++;
        if (arr[idx] != null) {
          Node lc = new Node(arr[idx]);
          top.node.left = lc;

          Pair lcp = new Pair(lc, 1);
          st.push(lcp);
        }
        idx++;
      }
      else if (top.state == 2) {
        //waiting for right child
        top.state++;
        if (arr[idx] != null) {
          Node rc = new Node(arr[idx]);
          top.node.right = rc;

          Pair rcp = new Pair(rc, 1);
          st.push(rcp);
        }
        idx++;
      }
      else if (top.state == 3) {
        st.pop();
      }
    }

    return root;

  }

  public static void display(Node node) {
    if (node == null) {
      return;
    }
    String str = " <- " + node.data + " -> ";

    str += (node.left == null) ? "." :  "" + node.left.data;
    str += (node.right == null) ? "." : "" + node.right.data;

    System.out.println(str);


    display(node.left);
    display(node.right);
  }

  public static void main(String[]args) {
    Integer[]arr = {50, 25, 12, null, null, 37, 30, null, null, null,75, 62, null, 70, null, null, 87, null, null};
    Node root = construct(arr);
    display(root);
  }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Size, Sum, Max and Height of a Binary Tree</span>
import java.util.*;

public class Main {
  public static class Node {
    int data;
    Node left;
    Node right;
    Node() {
    }
    Node(int data) {
      this.data = data;
    }
  }
  public static class Pair {
    Node node;
    int state;

    Pair() {
    }

    Pair(Node node, int state) {
      this.node = node;
      this.state = state;
    }
  }

  public static Node construct(Integer[]arr) {
    Node root = new Node(arr[0]);

    Stack< Pair>st = new Stack< >();
    Pair root_pair = new Pair(root, 1);

    st.push(root_pair);
    int idx = 1;

    while (st.size() > 0) {
      Pair top = st.peek();

      if (top.state == 1) {
        //waiting for left child
        top.state++;
        if (arr[idx] != null) {
          Node lc = new Node(arr[idx]);
          top.node.left = lc;

          Pair lcp = new Pair(lc, 1);
          st.push(lcp);
        }
        idx++;
      }
      else if (top.state == 2) {
        //waiting for right child
        top.state++;
        if (arr[idx] != null) {
          Node rc = new Node(arr[idx]);
          top.node.right = rc;

          Pair rcp = new Pair(rc, 1);
          st.push(rcp);
        }
        idx++;
      }
      else if (top.state == 3) {
        st.pop();
      }
    }
    return root;

  }

  public static void display(Node node) {
    if (node == null) {
      return;
    }

    String str = " <- " + node.data + " -> ";

    String left = (node.left == null) ? "." :  "" + node.left.data;
    String right = (node.right == null) ? "." : "" + node.right.data;

    str = left + str + right;

    System.out.println(str);

    display(node.left);
    display(node.right);
  }

  public static void main(String[]args) {
    Integer[]arr = {50, 25, 12, null, null, 37, 30, null, null, null, 75, 62, null, 70, null, null, 87, null, null};

    Node root = construct(arr);
  }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Traversals in a Binary Tree</span>
import java.io.*;

import java.util.*;

public class Main {
  public static class Node {
    int data;
    Node left;
    Node right;

    Node(int data, Node left, Node right) {
      this.data = data;
      this.left = left;
      this.right = right;
    }
  }

  public static class Pair {
    Node node;
    int state;

    Pair(Node node, int state) {
      this.node = node;
      this.state = state;
    }
  }

  public static Node construct(Integer[] arr) {
    Node root = new Node(arr[0], null, null);
    Pair rtp = new Pair(root, 1);

    Stack< Pair> st = new Stack< >();
    st.push(rtp);

    int idx = 0;
    while (st.size() > 0) {
      Pair top = st.peek();
      if (top.state == 1) {
        idx++;
        if (arr[idx] != null) {
          top.node.left = new Node(arr[idx], null, null);
          Pair lp = new Pair(top.node.left, 1);
          st.push(lp);
        } else {
          top.node.left = null;
        }

        top.state++;
      } else if (top.state == 2) {
        idx++;
        if (arr[idx] != null) {
          top.node.right = new Node(arr[idx], null, null);
          Pair rp = new Pair(top.node.right, 1);
          st.push(rp);
        } else {
          top.node.right = null;
        }

        top.state++;
      } else {
        st.pop();
      }
    }

    return root;
  }

  public static void display(Node node) {
    if (node == null) {
      return;
    }

    String str = "";
    str += node.left == null ? "." : node.left.data + "";
    str += " <- " + node.data + " -> ";
    str += node.right == null ? "." : node.right.data + "";
    System.out.println(str);

    display(node.left);
    display(node.right);
  }

  public static void traversalPreorder(Node node)
  {
    if (node == null)
    {
      return;
    }
    System.out.print(node.data + " ");
    traversalPreorder(node.left);
    traversalPreorder(node.right);
  }

  public static void traversalPostorder(Node node)
  {
    if (node == null)
    {
      return;
    }
    traversalPreorder(node.left);
    traversalPreorder(node.right);
    System.out.print(node.data + " ");
  }

  public static void traversalInorder(Node node)
  {
    if (node == null)
    {
      return;
    }
    traversalPreorder(node.left);
    System.out.print(node.data + " ");
    traversalPreorder(node.right);

  }

  public static void main(String[] args) throws Exception {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    int n = Integer.parseInt(br.readLine());
    Integer[] arr = new Integer[n];
    String[] values = br.readLine().split(" ");
    for (int i = 0; i < n; i++) {
      if (values[i].equals("n") == false) {
        arr[i] = Integer.parseInt(values[i]);
      } else {
        arr[i] = null;
      }
    }

    Node root = construct(arr);
    traversalPreorder(root);
    System.out.println();
    traversalPostorder(root);
    System.out.println();
    traversalInorder(root);

  }

}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Level Order Traversal Of Binary Tree</span>
import java.io.*;

import java.util.*;

public class Main {
  public static class Node {
    int data;
    Node left;
    Node right;

    Node(int data, Node left, Node right) {
      this.data = data;
      this.left = left;
      this.right = right;
    }
  }

  public static class Pair {
    Node node;
    int state;

    Pair(Node node, int state) {
      this.node = node;
      this.state = state;
    }
  }

  public static Node construct(Integer[] arr) {
    Node root = new Node(arr[0], null, null);
    Pair rtp = new Pair(root, 1);
    Stack< Pair> st = new Stack< >();
    st.push(rtp);
    int idx = 0;
    while (st.size() > 0) {
      Pair top = st.peek();
      if (top.state == 1) {
        idx++;
        if (arr[idx] != null) {
          top.node.left = new Node(arr[idx], null, null);
          Pair lp = new Pair(top.node.left, 1);
          st.push(lp);
        } else {
          top.node.left = null;
        }
        top.state++;
      } else if (top.state == 2) {
        idx++;
        if (arr[idx] != null) {
          top.node.right = new Node(arr[idx], null, null);
          Pair rp = new Pair(top.node.right, 1);
          st.push(rp);
        } else {
          top.node.right = null;
        }
        top.state++;
      } else {
        st.pop();
      }
    }
    return root;
  }

  public static void display(Node node) {
    if (node == null) {
      return;
    }
    String str = "";
    str += node.left == null ? "." : node.left.data + "";
    str += " <- " + node.data + " -> ";
    str += node.right == null ? "." : node.right.data + "";
    System.out.println(str);
    display(node.left);
    display(node.right);
  }

  public static void levelOrder(Node node) {
    Queue< Node> mq = new ArrayDeque< >();
    mq.add(node);
    while (mq.size() > 0) {
      int count = mq.size();
      for (int i = 0; i < count; i++) {
        node = q.remove();
        System.out.print(node.data + " ");
        if (node.left != null) {
          mq.add(node.left);
        }
        if (node.right != null) {
          mq.add(node.right);
        }
      }
      System.out.println();
    }
  }
  public static void main(String[] args) throws Exception {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    int n = Integer.parseInt(br.readLine());
    Integer[] arr = new Integer[n];
    String[] values = br.readLine().split(" ");
    for (int i = 0; i < n; i++) {
      if (values[i].equals("n") == false) {
        arr[i] = Integer.parseInt(values[i]);
      } else {
        arr[i] = null;
      }
    }

    Node root = construct(arr);
    levelOrder(root);
  }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Iterative Pre, Post And Inorder In Binary Tree</span>
import java.io.*;

import java.util.*;

public class Main {
  public static class Node {
    int data;
    Node left;
    Node right;

    Node(int data, Node left, Node right) {
      this.data = data;
      this.left = left;
      this.right = right;
    }
  }

  public static class Pair {
    Node node;
    int state;
    Pair(Node node, int state) {
      this.node = node;
      this.state = state;
    }
  }
  public static Node construct(Integer[] arr) {
    Node root = new Node(arr[0], null, null);
    Pair rtp = new Pair(root, 1);

    Stack< Pair> st = new Stack< >();
    st.push(rtp);

    int idx = 0;
    while (st.size() > 0) {
      Pair top = st.peek();
      if (top.state == 1) {
        idx++;
        if (arr[idx] != null) {
          top.node.left = new Node(arr[idx], null, null);
          Pair lp = new Pair(top.node.left, 1);
          st.push(lp);
        } else {
          top.node.left = null;
        }
        top.state++;
      } else if (top.state == 2) {
        idx++;
        if (arr[idx] != null) {
          top.node.right = new Node(arr[idx], null, null);
          Pair rp = new Pair(top.node.right, 1);
          st.push(rp);
        } else {
          top.node.right = null;
        }
        top.state++;
      } else {
        st.pop();
      }
    }
    return root;
  }

  public static void display(Node node) {
    if (node == null) {
      return;
    }
    String str = "";
    str += node.left == null ? "." : node.left.data + "";
    str += " <- " + node.data + " -> ";
    str += node.right == null ? "." : node.right.data + "";
    System.out.println(str);

    display(node.left);
    display(node.right);
  }

  public static void iterativePrePostInTraversal(Node node) {
    Stack < Pair> st = new Stack< >();
    Pair rtp = new Pair(node, 1);
    st.push(rtp);
    String pre = "";
    String in = "";
    String post = "";

    while (st.size() > 0) {
      Pair top = st.peek();
      if (top.state == 1) {  //pre,s++,left
        pre += top.node.data + " ";
        top.state++;
        if (top.node.left != null) {
          Pair lp = new Pair(top.node.left, 1);
          st.push(lp);
        }
      }
      else if (top.state == 2) { //in,s++,right
        in += top.node.data + " ";
        top.state++;
        if (top.node.right != null) {
          Pair rp = new Pair(top.node.right, 1);
          st.push(rp);
        }
      }
      else {        //post,pop
        post += top.node.data + " ";
        st.pop();
      }
    }
    System.out.println(pre);
    System.out.println(in);
    System.out.println(post);

  }
  public static void main(String[] args) throws Exception {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    int n = Integer.parseInt(br.readLine());
    Integer[] arr = new Integer[n];
    String[] values = br.readLine().split(" ");
    for (int i = 0; i < n; i++) {
      if (values[i].equals("n") == false) {
        arr[i] = Integer.parseInt(values[i]);
      } else {
        arr[i] = null;
      }
    }

    Node root = construct(arr);
    iterativePrePostInTraversal(root);
  }

}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Find Node to Root Path in Binary Tree</span>
import java.io.*;

import java.util.*;

public class Main {
  public static class Node {
    int data;
    Node left;
    Node right;

    Node(int data, Node left, Node right) {
      this.data = data;
      this.left = left;
      this.right = right;
    }
  }

  public static class Pair {
    Node node;
    int state;

    Pair(Node node, int state) {
      this.node = node;
      this.state = state;
    }
  }

  public static Node construct(Integer[] arr) {
    Node root = new Node(arr[0], null, null);
    Pair rtp = new Pair(root, 1);

    Stack< Pair> st = new Stack< >();
    st.push(rtp);

    int idx = 0;
    while (st.size() > 0) {
      Pair top = st.peek();
      if (top.state == 1) {
        idx++;
        if (arr[idx] != null) {
          top.node.left = new Node(arr[idx], null, null);
          Pair lp = new Pair(top.node.left, 1);
          st.push(lp);
        } else {
          top.node.left = null;
        }

        top.state++;
      } else if (top.state == 2) {
        idx++;
        if (arr[idx] != null) {
          top.node.right = new Node(arr[idx], null, null);
          Pair rp = new Pair(top.node.right, 1);
          st.push(rp);
        } else {
          top.node.right = null;
        }

        top.state++;
      } else {
        st.pop();
      }
    }

    return root;
  }

  public static void display(Node node) {
    if (node == null) {
      return;
    }

    String str = "";
    str += node.left == null ? "." : node.left.data + "";
    str += " <- " + node.data + " -> ";
    str += node.right == null ? "." : node.right.data + "";
    System.out.println(str);

    display(node.left);
    display(node.right);
  }

  public static boolean find(Node node, int data) {
    if (node == null) {
      return false;
    }

    if (node.data == data) {
      return true;
    }

    boolean filc = find(node.left, data);
    if (filc) {
      return true;
    }

    boolean firc = find(node.right, data);
    if (firc) {
      return true;
    }

    return false;
  }

  public static ArrayList< Integer> nodeToRootPath(Node node, int data) {
    if (node == null) {
      return new ArrayList< >();
    }

    if (node.data == data) {
      ArrayList< Integer> list = new ArrayList< >();
      list.add(node.data);
      return list;
    }

    ArrayList< Integer> llist = nodeToRootPath(node.left, data);
    if (llist.size() > 0) {
      llist.add(node.data);
      return llist;
    }

    ArrayList< Integer> rlist = nodeToRootPath(node.right, data);
    if (rlist.size() > 0) {
      rlist.add(node.data);
      return rlist;
    }
    return new ArrayList< >();
  }

  public static void main(String[] args) throws Exception {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    int n = Integer.parseInt(br.readLine());
    Integer[] arr = new Integer[n];
    String[] values = br.readLine().split(" ");
    for (int i = 0; i < n; i++) {
      if (values[i].equals("n") == false) {
        arr[i] = Integer.parseInt(values[i]);
      } else {
        arr[i] = null;
      }
    }

    int data = Integer.parseInt(br.readLine());
    Node root = construct(arr);
    boolean found = find(root, data);
    System.out.println(found);

    ArrayList< Integer> path = nodeToRootPath(root, data);
    System.out.println(path);
  }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Print K Levels Down</span>
import java.io.*;

import java.util.*;

public class Main {
  public static class Node {
    int data;
    Node left;
    Node right;

    Node(int data, Node left, Node right) {
      this.data = data;
      this.left = left;
      this.right = right;
    }
  }

  public static class Pair {
    Node node;
    int state;

    Pair(Node node, int state) {
      this.node = node;
      this.state = state;
    }
  }

  public static Node construct(Integer[] arr) {
    Node root = new Node(arr[0], null, null);
    Pair rtp = new Pair(root, 1);

    Stack< Pair> st = new Stack< >();
    st.push(rtp);

    int idx = 0;
    while (st.size() > 0) {
      Pair top = st.peek();
      if (top.state == 1) {
        idx++;
        if (arr[idx] != null) {
          top.node.left = new Node(arr[idx], null, null);
          Pair lp = new Pair(top.node.left, 1);
          st.push(lp);
        } else {
          top.node.left = null;
        }

        top.state++;
      } else if (top.state == 2) {
        idx++;
        if (arr[idx] != null) {
          top.node.right = new Node(arr[idx], null, null);
          Pair rp = new Pair(top.node.right, 1);
          st.push(rp);
        } else {
          top.node.right = null;
        }

        top.state++;
      } else {
        st.pop();
      }
    }

    return root;
  }

  public static void display(Node node) {
    if (node == null) {
      return;
    }

    String str = "";
    str += node.left == null ? "." : node.left.data + "";
    str += " <- " + node.data + " -> ";
    str += node.right == null ? "." : node.right.data + "";
    System.out.println(str);

    display(node.left);
    display(node.right);
  }

  public static void printKLevelsDown(Node node, int k) {
    if (node == null || k < 0) {
      return;
    }

    if (k == 0) {
      System.out.println(node.data);
      return;
    }

    printKLevelsDown(node.left, k - 1);
    printKLevelsDown(node.right, k - 1);
  }

  public static void main(String[] args) throws Exception {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    int n = Integer.parseInt(br.readLine());
    Integer[] arr = new Integer[n];
    String[] values = br.readLine().split(" ");
    for (int i = 0; i < n; i++) {
      if (values[i].equals("n") == false) {
        arr[i] = Integer.parseInt(values[i]);
      } else {
        arr[i] = null;
      }
    }

    int k = Integer.parseInt(br.readLine());

    Node root = construct(arr);
    printKLevelsDown(root, k);
  }

}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Print Nodes K Distance Away</span>
import java.io.*;

import java.io.*;
import java.util.*;

public class Main {
  public static class Node {
    int data;
    Node left;
    Node right;

    Node(int data, Node left, Node right) {
      this.data = data;
      this.left = left;
      this.right = right;
    }
  }

  public static class Pair {
    Node node;
    int state;

    Pair(Node node, int state) {
      this.node = node;
      this.state = state;
    }
  }

  public static Node construct(Integer[] arr) {
    Node root = new Node(arr[0], null, null);
    Pair rtp = new Pair(root, 1);
    Stack< Pair> st = new Stack< >();
    st.push(rtp);
    int idx = 0;
    while (st.size() > 0) {
      Pair top = st.peek();
      if (top.state == 1) {
        idx++;
        if (arr[idx] != null) {
          top.node.left = new Node(arr[idx], null, null);
          Pair lp = new Pair(top.node.left, 1);
          st.push(lp);
        } else {
          top.node.left = null;
        }
        top.state++;
      } else if (top.state == 2) {
        idx++;
        if (arr[idx] != null) {
          top.node.right = new Node(arr[idx], null, null);
          Pair rp = new Pair(top.node.right, 1);
          st.push(rp);
        } else {
          top.node.right = null;
        }
        top.state++;
      } else {
        st.pop();
      }
    }

    return root;
  }

  public static void display(Node node) {
    if (node == null) {
      return;
    }
    String str = "";
    str += node.left == null ? "." : node.left.data + "";
    str += " <- " + node.data + " -> ";
    str += node.right == null ? "." : node.right.data + "";
    System.out.println(str);
    display(node.left);
    display(node.right);
  }

  // *******************PRINT K NODES FAR******************
  public static void printKNodesFar(Node node, int data, int k) {
    ArrayList< Node> path = find(node, data); //1
    for (int i = 0; i < path.size(); i++) { //2
      printKLevelsDown(path.get(i), k - i, i == 0 ? null : path.get(i - 1)); //3
    }

  }

  //**************** FIND FUNCTION ******************
  static ArrayList< Node> path;
  public static boolean find(Node node, int data) {
    if (node == null)
      return false;
    if (node.data == data) {
      path.add(node);
      return true;
    }
    boolean filc = find(node.left, data);
    if (filc) {
      path.add(node);
      return true;
    }
    boolean firc = find(node.right, data);
    if (firc) {
      path.add(node);
      return true;
    }
    return false;
  }
  //****************PRINT K LEVELS DOWN****************
  public static void printKLevelsDown(Node node, int k, Node blocker) {
    if (node == null || k < 0 || node == blocker)
      return;
    if (k == 0)
      System.out.println(node.data);
    printKLevelsDown(node.left, k - 1, blocker);
    printKLevelsDown(node.right, k - 1, blocker);

  }
  public static void main(String[] args) throws Exception {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    int n = Integer.parseInt(br.readLine());
    Integer[] arr = new Integer[n];
    String[] values = br.readLine().split(" ");
    for (int i = 0; i < n; i++) {
      if (values[i].equals("n") == false) {
        arr[i] = Integer.parseInt(values[i]);
      } else {
        arr[i] = null;
      }
    }
    int data = Integer.parseInt(br.readLine());
    int k = Integer.parseInt(br.readLine());
    Node root = construct(arr);
    printKNodesFar(root, data, k);
  }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Path To Leaf From Root In Range</span>
import java.io.*;

import java.util.*;

public class Main {
  public static class Node {
    int data;
    Node left;
    Node right;

    Node(int data, Node left, Node right) {
      this.data = data;
      this.left = left;
      this.right = right;
    }
  }

  public static class Pair {
    Node node;
    int state;

    Pair(Node node, int state) {
      this.node = node;
      this.state = state;
    }
  }

  public static Node construct(Integer[] arr) {
    Node root = new Node(arr[0], null, null);
    Pair rtp = new Pair(root, 1);

    Stack< Pair> st = new Stack< >();
    st.push(rtp);

    int idx = 0;
    while (st.size() > 0) {
      Pair top = st.peek();
      if (top.state == 1) {
        idx++;
        if (arr[idx] != null) {
          top.node.left = new Node(arr[idx], null, null);
          Pair lp = new Pair(top.node.left, 1);
          st.push(lp);
        } else {
          top.node.left = null;
        }
        top.state++;
      } else if (top.state == 2) {
        idx++;
        if (arr[idx] != null) {
          top.node.right = new Node(arr[idx], null, null);
          Pair rp = new Pair(top.node.right, 1);
          st.push(rp);
        } else {
          top.node.right = null;
        }
        top.state++;
      } else {
        st.pop();
      }
    }
    return root;
  }
  public static void display(Node node) {
    if (node == null) {
      return;
    }

    String str = "";
    str += node.left == null ? "." : node.left.data + "";
    str += " <- " + node.data + " -> ";
    str += node.right == null ? "." : node.right.data + "";
    System.out.println(str);
    display(node.left);
    display(node.right);
  }
  public static void pathToLeafFromRoot(Node node, String path, int sum, int lo, int hi) {
    if (node == null) { //1
      return;
    }
    if (node.left == null && node.right == null) { //2
      sum += node.data; //3
      if (sum >= lo && sum <= hi) { //4
        System.out.println(path + node.data);
      }
      return;
    }
    pathToLeafFromRoot(node.left, path + node.data + " ", sum + node.data, lo, hi); //5
    pathToLeafFromRoot(node.right, path + node.data + " ", sum + node.data, lo, hi);

  }
  public static void main(String[] args) throws Exception {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    int n = Integer.parseInt(br.readLine());
    Integer[] arr = new Integer[n];
    String[] values = br.readLine().split(" ");
    for (int i = 0; i < n; i++) {
      if (values[i].equals("n") == false) {
        arr[i] = Integer.parseInt(values[i]);
      } else {
        arr[i] = null;
      }
    }

    int lo = Integer.parseInt(br.readLine());
    int hi = Integer.parseInt(br.readLine());
    Node root = construct(arr);
    pathToLeafFromRoot(root, "", 0, lo, hi);
  }
}

<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">rm to Left Cloned Tree</span>
import java.io.*;

import java.util.*;

public class Main {
  public static class Node {
    int data;
    Node left;
    Node right;

    Node(int data, Node left, Node right) {
      this.data = data;
      this.left = left;
      this.right = right;
    }
  }

  public static class Pair {
    Node node;
    int state;

    Pair(Node node, int state) {
      this.node = node;
      this.state = state;
    }
  }

  public static Node construct(Integer[] arr) {
    Node root = new Node(arr[0], null, null);
    Pair rtp = new Pair(root, 1);

    Stack< Pair> st = new Stack< >();
    st.push(rtp);

    int idx = 0;
    while (st.size() > 0) {
      Pair top = st.peek();
      if (top.state == 1) {
        idx++;
        if (arr[idx] != null) {
          top.node.left = new Node(arr[idx], null, null);
          Pair lp = new Pair(top.node.left, 1);
          st.push(lp);
        } else {
          top.node.left = null;
        }

        top.state++;
      } else if (top.state == 2) {
        idx++;
        if (arr[idx] != null) {
          top.node.right = new Node(arr[idx], null, null);
          Pair rp = new Pair(top.node.right, 1);
          st.push(rp);
        } else {
          top.node.right = null;
        }

        top.state++;
      } else {
        st.pop();
      }
    }

    return root;
  }

  public static void display(Node node) {
    if (node == null) {
      return;
    }

    String str = "";
    str += node.left == null ? "." : node.left.data + "";
    str += " <- " + node.data + " -> ";
    str += node.right == null ? "." : node.right.data + "";
    System.out.println(str);

    display(node.left);
    display(node.right);
  }

  public static Node createLeftCloneTree(Node node) {
    if (node == null) {
      return null;
    }

    Node leftcloned = createLeftCloneTree(node.left);
    Node rightcloned = createLeftCloneTree(node.right);

    node.left = new Node(node.data, leftcloned, null);
    node.right = rightcloned;

    return node;
  }

  public static void main(String[] args) throws Exception {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    int n = Integer.parseInt(br.readLine());
    Integer[] arr = new Integer[n];
    String[] values = br.readLine().split(" ");
    for (int i = 0; i < n; i++) {
      if (values[i].equals("n") == false) {
        arr[i] = Integer.parseInt(values[i]);
      } else {
        arr[i] = null;
      }
    }

    Node root = construct(arr);
    root = createLeftCloneTree(root);
    display(root);
  }

}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Transform to Normal from Left Cloned Tree</span>
import java.io.*;

import java.util.*;

public class Main {
  public static class Node {
    int data;
    Node left;
    Node right;

    Node(int data, Node left, Node right) {
      this.data = data;
      this.left = left;
      this.right = right;
    }
  }

  public static class Pair {
    Node node;
    int state;
    Pair(Node node, int state) {
      this.node = node;
      this.state = state;
    }
  }

  public static Node construct(Integer[] arr) {
    Node root = new Node(arr[0], null, null);
    Pair rtp = new Pair(root, 1);

    Stack< Pair> st = new Stack< >();
    st.push(rtp);

    int idx = 0;
    while (st.size() > 0) {
      Pair top = st.peek();
      if (top.state == 1) {
        idx++;
        if (arr[idx] != null) {
          top.node.left = new Node(arr[idx], null, null);
          Pair lp = new Pair(top.node.left, 1);
          st.push(lp);
        } else {
          top.node.left = null;
        }

        top.state++;
      } else if (top.state == 2) {
        idx++;
        if (arr[idx] != null) {
          top.node.right = new Node(arr[idx], null, null);
          Pair rp = new Pair(top.node.right, 1);
          st.push(rp);
        } else {
          top.node.right = null;
        }

        top.state++;
      } else {
        st.pop();
      }
    }

    return root;
  }

  public static void display(Node node) {
    if (node == null) {
      return;
    }

    String str = "";
    str += node.left == null ? "." : node.left.data + "";
    str += " <- " + node.data + " -> ";
    str += node.right == null ? "." : node.right.data + "";
    System.out.println(str);

    display(node.left);
    display(node.right);
  }

  public static Node transBackFromLeftClonedTree(Node node) {
    if (node == null) {
      return null;
    }

    node.left = transBackFromLeftClonedTree(node.left.left);
    node.right = transBackFromLeftClonedTree(node.right);

    return node;
  }

  public static void main(String[] args) throws Exception {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    int n = Integer.parseInt(br.readLine());
    Integer[] arr = new Integer[n];
    String[] values = br.readLine().split(" ");
    for (int i = 0; i < n; i++) {
      if (values[i].equals("n") == false) {
        arr[i] = Integer.parseInt(values[i]);
      } else {
        arr[i] = null;
      }
    }

    Node root = construct(arr);
    root = transBackFromLeftClonedTree(root);
    display(root);
  }

}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Print Single Child Nodes</span>
import java.io.*;

import java.util.*;

public class Main {
  public static class Node {
    int data;
    Node left;
    Node right;

    Node(int data, Node left, Node right) {
      this.data = data;
      this.left = left;
      this.right = right;
    }
  }

  public static class Pair {
    Node node;
    int state;

    Pair(Node node, int state) {
      this.node = node;
      this.state = state;
    }
  }

  public static Node construct(Integer[] arr) {
    Node root = new Node(arr[0], null, null);
    Pair rtp = new Pair(root, 1);

    Stack< Pair> st = new Stack< >();
    st.push(rtp);

    int idx = 0;
    while (st.size() > 0) {
      Pair top = st.peek();
      if (top.state == 1) {
        idx++;
        if (arr[idx] != null) {
          top.node.left = new Node(arr[idx], null, null);
          Pair lp = new Pair(top.node.left, 1);
          st.push(lp);
        } else {
          top.node.left = null;
        }

        top.state++;
      } else if (top.state == 2) {
        idx++;
        if (arr[idx] != null) {
          top.node.right = new Node(arr[idx], null, null);
          Pair rp = new Pair(top.node.right, 1);
          st.push(rp);
        } else {
          top.node.right = null;
        }

        top.state++;
      } else {
        st.pop();
      }
    }

    return root;
  }

  public static void display(Node node) {
    if (node == null) {
      return;
    }

    String str = "";
    str += node.left == null ? "." : node.left.data + "";
    str += " <- " + node.data + " -> ";
    str += node.right == null ? "." : node.right.data + "";
    System.out.println(str);

    display(node.left);
    display(node.right);
  }

  public static void printSingleChildNodes(Node node, Node parent) {
    if (node == null) {
      return;
    }

    if (parent != null && parent.left == null && parent.right == node) {
      System.out.println(node.data);
    } else if (parent != null && parent.right == null && parent.left == node) {
      System.out.println(node.data);
    }

    printSingleChildNodes(node.left, node);
    printSingleChildNodes(node.right, node);
  }

  public static void main(String[] args) throws Exception {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    int n = Integer.parseInt(br.readLine());
    Integer[] arr = new Integer[n];
    String[] values = br.readLine().split(" ");
    for (int i = 0; i < n; i++) {
      if (values[i].equals("n") == false) {
        arr[i] = Integer.parseInt(values[i]);
      } else {
        arr[i] = null;
      }
    }

    Node root = construct(arr);
    printSingleChildNodes(root, null);
  }

}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Remove Leaves In Binary Tree</span>
import java.io.*;

import java.util.*;

public class Main {
  public static class Node {
    int data;
    Node left;
    Node right;

    Node(int data, Node left, Node right) {
      this.data = data;
      this.left = left;
      this.right = right;
    }
  }

  public static class Pair {
    Node node;
    int state;

    Pair(Node node, int state) {
      this.node = node;
      this.state = state;
    }
  }

  public static Node construct(Integer[] arr) {
    Node root = new Node(arr[0], null, null);
    Pair rtp = new Pair(root, 1);

    Stack< Pair> st = new Stack< >();
    st.push(rtp);

    int idx = 0;
    while (st.size() > 0) {
      Pair top = st.peek();
      if (top.state == 1) {
        idx++;
        if (arr[idx] != null) {
          top.node.left = new Node(arr[idx], null, null);
          Pair lp = new Pair(top.node.left, 1);
          st.push(lp);
        } else {
          top.node.left = null;
        }

        top.state++;
      } else if (top.state == 2) {
        idx++;
        if (arr[idx] != null) {
          top.node.right = new Node(arr[idx], null, null);
          Pair rp = new Pair(top.node.right, 1);
          st.push(rp);
        } else {
          top.node.right = null;
        }

        top.state++;
      } else {
        st.pop();
      }
    }

    return root;
  }

  public static void display(Node node) {
    if (node == null) {
      return;
    }

    String str = "";
    str += node.left == null ? "." : node.left.data + "";
    str += " <- " + node.data + " -> ";
    str += node.right == null ? "." : node.right.data + "";
    System.out.println(str);

    display(node.left);
    display(node.right);
  }

  public static Node removeLeaves(Node node) {
    if (node == null) {
      return null;
    }

    if (node.left == null && node.right == null) {
      return null;
    }

    node.left = removeLeaves(node.left);
    node.right = removeLeaves(node.right);

    return node;
  }

  public static void main(String[] args) throws Exception {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    int n = Integer.parseInt(br.readLine());
    Integer[] arr = new Integer[n];
    String[] values = br.readLine().split(" ");
    for (int i = 0; i < n; i++) {
      if (values[i].equals("n") == false) {
        arr[i] = Integer.parseInt(values[i]);
      } else {
        arr[i] = null;
      }
    }

    Node root = construct(arr);
    root = removeLeaves(root);
    display(root);
  }

}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Diameter of a Binary Tree</span>
import java.io.*;

import java.util.*;

public class Main {
  public static class Node {
    int data;
    Node left;
    Node right;

    Node(int data, Node left, Node right) {
      this.data = data;
      this.left = left;
      this.right = right;
    }
  }

  public static class Pair {
    Node node;
    int state;

    Pair(Node node, int state) {
      this.node = node;
      this.state = state;
    }
  }

  public static Node construct(Integer[] arr) {
    Node root = new Node(arr[0], null, null);
    Pair rtp = new Pair(root, 1);

    Stack< Pair> st = new Stack< >();
    st.push(rtp);

    int idx = 0;
    while (st.size() > 0) {
      Pair top = st.peek();
      if (top.state == 1) {
        idx++;
        if (arr[idx] != null) {
          top.node.left = new Node(arr[idx], null, null);
          Pair lp = new Pair(top.node.left, 1);
          st.push(lp);
        } else {
          top.node.left = null;
        }

        top.state++;
      } else if (top.state == 2) {
        idx++;
        if (arr[idx] != null) {
          top.node.right = new Node(arr[idx], null, null);
          Pair rp = new Pair(top.node.right, 1);
          st.push(rp);
        } else {
          top.node.right = null;
        }

        top.state++;
      } else {
        st.pop();
      }
    }

    return root;
  }

  public static int height(Node node) {
    if (node == null) {
      return -1;
    }

    int lh = height(node.left);
    int rh = height(node.right);

    int th = Math.max(lh, rh) + 1;
    return th;
  }

  public static int diameter0(Node node) {
    if (node == null) {
      return 0;
    }

    int lh = height(node.left);
    int rh = height(node.right);
    int ld = diameter1(node.left);
    int rd = diameter1(node.right);

    int td = Math.max(lh + rh + 2, Math.max(ld, rd));
    return td;
  }

  static class DPair {
    int ht;
    int dia;
  }

  public static DPair diameter(Node node) {
    if (node == null) {
      DPair bp = new DPair();
      bp.ht = -1;
      bp.dia = 0;
      return bp;
    }

    DPair lp = diameter3(node.left);
    DPair rp = diameter3(node.right);

    DPair mp = new DPair();
    mp.ht = Math.max(lp.ht, rp.ht) + 1;
    mp.dia = Math.max(lp.ht + rp.ht + 2, Math.max(lp.dia, rp.dia));
    return mp;
  }

  public static void main(String[] args) throws Exception {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    int n = Integer.parseInt(br.readLine());
    Integer[] arr = new Integer[n];
    String[] values = br.readLine().split(" ");
    for (int i = 0; i < n; i++) {
      if (values[i].equals("n") == false) {
        arr[i] = Integer.parseInt(values[i]);
      } else {
        arr[i] = null;
      }
    }
    Node root = construct(arr);

    Dpair result = diameter1(root);
    System.out.println(result.dia);
  }

}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Tilt of a Binary Tree</span>
import java.io.*;

import java.util.*;

public class Main {
  public static class Node {
    int data;
    Node left;
    Node right;

    Node(int data, Node left, Node right) {
      this.data = data;
      this.left = left;
      this.right = right;
    }
  }

  public static class Pair {
    Node node;
    int state;

    Pair(Node node, int state) {
      this.node = node;
      this.state = state;
    }
  }

  public static Node construct(Integer[] arr) {
    Node root = new Node(arr[0], null, null);
    Pair rtp = new Pair(root, 1);

    Stack< Pair> st = new Stack< >();
    st.push(rtp);

    int idx = 0;
    while (st.size() > 0) {
      Pair top = st.peek();
      if (top.state == 1) {
        idx++;
        if (arr[idx] != null) {
          top.node.left = new Node(arr[idx], null, null);
          Pair lp = new Pair(top.node.left, 1);
          st.push(lp);
        } else {
          top.node.left = null;
        }

        top.state++;
      } else if (top.state == 2) {
        idx++;
        if (arr[idx] != null) {
          top.node.right = new Node(arr[idx], null, null);
          Pair rp = new Pair(top.node.right, 1);
          st.push(rp);
        } else {
          top.node.right = null;
        }

        top.state++;
      } else {
        st.pop();
      }
    }

    return root;
  }

  public static void display(Node node) {
    if (node == null) {
      return;
    }

    String str = "";
    str += node.left == null ? "." : node.left.data + "";
    str += " <- " + node.data + " -> ";
    str += node.right == null ? "." : node.right.data + "";
    System.out.println(str);

    display(node.left);
    display(node.right);
  }

  public static int height(Node node) {
    if (node == null) {
      return -1;
    }

    int lh = height(node.left);
    int rh = height(node.right);

    int th = Math.max(lh, rh) + 1;
    return th;
  }

  static int tilt = 0;
  public static int tilt(Node node) {
    if (node == null) {
      return 0;
    }

    int ls = tilt(node.left);
    int rs = tilt(node.right);
    int ts = ls + rs + node.data;

    tilt += Math.abs(ls - rs);

    return ts;
  }

  public static void main(String[] args) throws Exception {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    int n = Integer.parseInt(br.readLine());
    Integer[] arr = new Integer[n];
    String[] values = br.readLine().split(" ");
    for (int i = 0; i < n; i++) {
      if (values[i].equals("n") == false) {
        arr[i] = Integer.parseInt(values[i]);
      } else {
        arr[i] = null;
      }
    }

    Node root = construct(arr);

    tilt(root);
    System.out.println(tilt);
  }

}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Is a Binary Search Tree</span>
import java.io.*;

import java.util.*;

public class Main {
  public static class Node {
    int data;
    Node left;
    Node right;

    Node(int data, Node left, Node right) {
      this.data = data;
      this.left = left;
      this.right = right;
    }
  }

  public static class Pair {
    Node node;
    int state;

    Pair(Node node, int state) {
      this.node = node;
      this.state = state;
    }
  }

  public static Node construct(Integer[] arr) {
    Node root = new Node(arr[0], null, null);
    Pair rtp = new Pair(root, 1);

    Stack< Pair> st = new Stack< >();
    st.push(rtp);

    int idx = 0;
    while (st.size() > 0) {
      Pair top = st.peek();
      if (top.state == 1) {
        idx++;
        if (arr[idx] != null) {
          top.node.left = new Node(arr[idx], null, null);
          Pair lp = new Pair(top.node.left, 1);
          st.push(lp);
        } else {
          top.node.left = null;
        }

        top.state++;
      } else if (top.state == 2) {
        idx++;
        if (arr[idx] != null) {
          top.node.right = new Node(arr[idx], null, null);
          Pair rp = new Pair(top.node.right, 1);
          st.push(rp);
        } else {
          top.node.right = null;
        }

        top.state++;
      } else {
        st.pop();
      }
    }

    return root;
  }

  public static void display(Node node) {
    if (node == null) {
      return;
    }

    String str = "";
    str += node.left == null ? "." : node.left.data + "";
    str += " <- " + node.data + " -> ";
    str += node.right == null ? "." : node.right.data + "";
    System.out.println(str);

    display(node.left);
    display(node.right);
  }

  public static int height(Node node) {
    if (node == null) {
      return -1;
    }

    int lh = height(node.left);
    int rh = height(node.right);

    int th = Math.max(lh, rh) + 1;
    return th;
  }

  public static class BSTPair {
    int min;
    int max;
    boolean isBST;
  }

  public static BSTPair isBST(Node node) {
    if (node == null) {
      BSTPair bp = new BSTPair();
      bp.min = Integer.MAX_VALUE;
      bp.max = Integer.MIN_VALUE;
      bp.isBST = true;
      return bp;
    }

    BSTPair lp = isBST(node.left);
    BSTPair rp = isBST(node.right);

    BSTPair mp = new BSTPair();
    mp.min = Math.min(node.data, Math.min(lp.min, rp.min));
    mp.max = Math.max(node.data, Math.max(lp.max, rp.max));
    mp.isBST = lp.isBST && rp.isBST && node.data >= lp.max && node.data <= rp.min;

    return mp;
  }


  public static void main(String[] args) throws Exception {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    int n = Integer.parseInt(br.readLine());
    Integer[] arr = new Integer[n];
    String[] values = br.readLine().split(" ");
    for (int i = 0; i < n; i++) {
      if (values[i].equals("n") == false) {
        arr[i] = Integer.parseInt(values[i]);
      } else {
        arr[i] = null;
      }
    }

    Node root = construct(arr);
    BSTPair p = isBST(root);
    System.out.println(p.isBST);
  }

}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Balanced Tree</span>
import java.io.*;

import java.io.*;
import java.util.*;

public class Main {
  public static class Node {
    int data;
    Node left;
    Node right;

    Node(int data, Node left, Node right) {
      this.data = data;
      this.left = left;
      this.right = right;
    }
  }

  public static class Pair {
    Node node;
    int state;

    Pair(Node node, int state) {
      this.node = node;
      this.state = state;
    }
  }

  public static Node construct(Integer[] arr) {
    Node root = new Node(arr[0], null, null);
    Pair rtp = new Pair(root, 1);

    Stack< Pair> st = new Stack< >();
    st.push(rtp);

    int idx = 0;
    while (st.size() > 0) {
      Pair top = st.peek();
      if (top.state == 1) {
        idx++;
        if (arr[idx] != null) {
          top.node.left = new Node(arr[idx], null, null);
          Pair lp = new Pair(top.node.left, 1);
          st.push(lp);
        } else {
          top.node.left = null;
        }

        top.state++;
      } else if (top.state == 2) {
        idx++;
        if (arr[idx] != null) {
          top.node.right = new Node(arr[idx], null, null);
          Pair rp = new Pair(top.node.right, 1);
          st.push(rp);
        } else {
          top.node.right = null;
        }

        top.state++;
      } else {
        st.pop();
      }
    }

    return root;
  }

  public static void display(Node node) {
    if (node == null) {
      return;
    }

    String str = "";
    str += node.left == null ? "." : node.left.data + "";
    str += " <- " + node.data + " -> ";
    str += node.right == null ? "." : node.right.data + "";
    System.out.println(str);

    display(node.left);
    display(node.right);
  }

  public static class BalPair {
    int ht;
    boolean isBal;
  }

  public static int isBalanced(Node node) {

    if (node == null)
    {
      return 0;
    }

    int lh = isBalanced(node.left);
    int rh = isBalanced(node.right);

    int gap = Math.abs(lh - rh);

    if (gap > 1)
    {
      isBal = false;
    }
    int th = Math.max(lh, rh) + 1;
    return th;
  }

  public static void main(String[] args) throws Exception {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    int n = Integer.parseInt(br.readLine());
    Integer[] arr = new Integer[n];
    String[] values = br.readLine().split(" ");
    for (int i = 0; i < n; i++) {
      if (values[i].equals("n") == false) {
        arr[i] = Integer.parseInt(values[i]);
      } else {
        arr[i] = null;
      }
    }

    Node root = construct(arr);
    BalPair bp = isBalanced(root);
    System.out.println(bp.isBal);
  }
}
<span class="textStyle">or</span>
import java.io.*;

import java.util.*;

public class Main {
  public static class Node {
    int data;
    Node left;
    Node right;

    Node(int data, Node left, Node right) {
      this.data = data;
      this.left = left;
      this.right = right;
    }
  }

  public static class Pair {
    Node node;
    int state;

    Pair(Node node, int state) {
      this.node = node;
      this.state = state;
    }
  }

  public static Node construct(Integer[] arr) {
    Node root = new Node(arr[0], null, null);
    Pair rtp = new Pair(root, 1);

    Stack< Pair> st = new Stack<>();
    st.push(rtp);

    int idx = 0;
    while (st.size() > 0) {
      Pair top = st.peek();
      if (top.state == 1) {
        idx++;
        if (arr[idx] != null) {
          top.node.left = new Node(arr[idx], null, null);
          Pair lp = new Pair(top.node.left, 1);
          st.push(lp);
        } else {
          top.node.left = null;
        }

        top.state++;
      } else if (top.state == 2) {
        idx++;
        if (arr[idx] != null) {
          top.node.right = new Node(arr[idx], null, null);
          Pair rp = new Pair(top.node.right, 1);
          st.push(rp);
        } else {
          top.node.right = null;
        }

        top.state++;
      } else {
        st.pop();
      }
    }

    return root;
  }

  public static void display(Node node) {
    if (node == null) {
      return;
    }

    String str = "";
    str += node.left == null ? "." : node.left.data + "";
    str += " <- " + node.data + " -> ";
    str += node.right == null ? "." : node.right.data + "";
    System.out.println(str);

    display(node.left);
    display(node.right);
  }

  public static class BalPair {
    int ht;
    boolean isBal;
  }

  public static BalPair isBalanced(Node node) {
    if (node == null) {
      BalPair bp = new BalPair();
      bp.ht = -1;
      bp.isBal = true;
      return bp;
    }

    BalPair lp = isBalanced(node.left);
    BalPair rp = isBalanced(node.right);

    BalPair mp = new BalPair();
    mp.ht = Math.max(lp.ht, rp.ht) + 1;
    mp.isBal = lp.isBal && rp.isBal && Math.abs(lp.ht - rp.ht) <= 1;

    return mp;
  }

  public static void main(String[] args) throws Exception {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    int n = Integer.parseInt(br.readLine());
    Integer[] arr = new Integer[n];
    String[] values = br.readLine().split(" ");
    for (int i = 0; i < n; i++) {
      if (values[i].equals("n") == false) {
        arr[i] = Integer.parseInt(values[i]);
      } else {
        arr[i] = null;
      }
    }

    Node root = construct(arr);
    BalPair bp = isBalanced(root);
    System.out.println(bp.isBal);
  }

}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle"> Bst Subtree</span>
public static class bstpair {
  boolean isBST;

  int min;
  int max;
  Node root;     //1
  int size;

}

//****************IS BST*****************

public static bstpair isBST(Node node) {

  if (node == null) {
    bstpair bp = new bstpair();
    bp.isBST = true;
    bp.min = Integer.MAX_VALUE;
    bp.max = Integer.MIN_VALUE;
    bp.root = null;
    bp.size = 0;
    return bp;
  }

  bstpair lp = isBST(node.left);
  bstpair rp = isBST(node.right);

  bstpair mp = new bstpair();

  mp.isBST = lp.isBST && rp.isBST && (node.data >= lp.max && node.data <= rp.min);
  mp.min = Math.min(node.data, Math.min(lp.min, rp.min));
  mp.max = Math.max(node.data, Math.max(lp.max, rp.max));

  if (mp.isBST) {         //2
    mp.root = node;
    mp.size = lp.size + rp.size + 1;
  } else if (lp.size > rp.size) {  //3
    mp.root = lp.root;
    mp.size = lp.size;
  } else {  //4
    mp.root = rp.root;
    mp.size = rp.size;
  }

  return mp;
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">INTRODUCTION TO BINARY SEARCH TREE</span>
<span class="textStyle">Binary Search Tree Constructor</span>
import java.io.*;

import java.util.*;

public class Main {
  public static class Node {
    int data;
    Node left;
    Node right;

    Node(int data, Node left, Node right) {
      this.data = data;
      this.left = left;
      this.right = right;
    }
  }

  public static Node construct(int[] arr, int lo, int hi) {

    int mid = (lo + hi) / 2;

    Node lchild = construct(arr, lo, mid - 1);
    Node rchild = construct(arr, mid + 1, hi);
    Node node = new Node(arr[mid], lchild, rchild);

    return node;
  }

  public static void display(Node node) {
    if (node == null) {
      return;
    }

    String str = "";
    str += node.left == null ? "." : node.left.data + "";
    str += " <- " + node.data + " -> ";
    str += node.right == null ? "." : node.right.data + "";
    System.out.println(str);

    display(node.left);
    display(node.right);
  }

  public static void main(String[] args) throws Exception {
    int[] arr = {12, 25, 37, 50, 62, 75, 87};
    Node root = construct(arr, 0, arr.length - 1);
    display(root);
  }

}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Size, Sum, Max, Min & Find in BST</span>
import java.io.*;

import java.util.*;

public class Main {
  public static class Node {
    int data;
    Node left;
    Node right;

    Node(int data, Node left, Node right) {
      this.data = data;
      this.left = left;
      this.right = right;
    }
  }

  public static class Pair {
    Node node;
    int state;

    Pair(Node node, int state) {
      this.node = node;
      this.state = state;
    }
  }

  public static Node construct(Integer[] arr) {
    Node root = new Node(arr[0], null, null);
    Pair rtp = new Pair(root, 1);

    Stack< Pair> st = new Stack<>();
    st.push(rtp);

    int idx = 0;
    while (st.size() > 0) {
      Pair top = st.peek();
      if (top.state == 1) {
        idx++;
        if (arr[idx] != null) {
          top.node.left = new Node(arr[idx], null, null);
          Pair lp = new Pair(top.node.left, 1);
          st.push(lp);
        } else {
          top.node.left = null;
        }

        top.state++;
      } else if (top.state == 2) {
        idx++;
        if (arr[idx] != null) {
          top.node.right = new Node(arr[idx], null, null);
          Pair rp = new Pair(top.node.right, 1);
          st.push(rp);
        } else {
          top.node.right = null;
        }

        top.state++;
      } else {
        st.pop();
      }
    }

    return root;
  }

  public static void display(Node node) {
    if (node == null) {
      return;
    }

    String str = "";
    str += node.left == null ? "." : node.left.data + "";
    str += " <- " + node.data + " -> ";
    str += node.right == null ? "." : node.right.data + "";
    System.out.println(str);

    display(node.left);
    display(node.right);
  }

  public static int size(Node node) {
    if (node == null) {
      return 0;
    }

    int ls = size(node.left);
    int rs = size(node.right);
    int ts = ls + rs + 1;
    return ts;
  }

  public static int sum(Node node) {
    if (node == null) {
      return 0;
    }

    int ls = sum(node.left);
    int rs = sum(node.right);
    int ts = ls + rs + node.data;
    return ts;
  }

  public static int max(Node node) {
    if (node.right == null) {
      return node.data;
    } else {
      return max(node.right);
    }
  }

  public static int min(Node node) {
    if (node.left == null) {
      return node.data;
    } else {
      return min(node.left);
    }
  }

  public static boolean find(Node node, int data) {
    if (node == null) {
      return false;
    }

    if (data > node.data) {
      return find(node.right, data);
    } else if (data < node.data) {
      return find(node.left, data);
    } else {
      return true;
    }
  }

  public static void main(String[] args) throws Exception {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    int n = Integer.parseInt(br.readLine());
    Integer[] arr = new Integer[n];
    String[] values = br.readLine().split(" ");
    for (int i = 0; i < n; i++) {
      if (values[i].equals("n") == false) {
        arr[i] = Integer.parseInt(values[i]);
      } else {
        arr[i] = null;
      }
    }

    int data = Integer.parseInt(br.readLine());

    Node root = construct(arr);

    int size = size(root);
    int sum = sum(root);
    int max = max(root);
    int min = min(root);
    boolean found = find(root, data);

    System.out.println(size);
    System.out.println(sum);
    System.out.println(max);
    System.out.println(min);
    System.out.println(found);
  }

}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Add Node to BST</span>
import java.io.*;

import java.util.*;

public class Main {
  public static class Node {
    int data;
    Node left;
    Node right;

    Node(int data, Node left, Node right) {
      this.data = data;
      this.left = left;
      this.right = right;
    }
  }

  public static class Pair {
    Node node;
    int state;

    Pair(Node node, int state) {
      this.node = node;
      this.state = state;
    }
  }

  public static Node construct(Integer[] arr) {
    Node root = new Node(arr[0], null, null);
    Pair rtp = new Pair(root, 1);

    Stack< Pair> st = new Stack<>();
    st.push(rtp);

    int idx = 0;
    while (st.size() > 0) {
      Pair top = st.peek();
      if (top.state == 1) {
        idx++;
        if (arr[idx] != null) {
          top.node.left = new Node(arr[idx], null, null);
          Pair lp = new Pair(top.node.left, 1);
          st.push(lp);
        } else {
          top.node.left = null;
        }

        top.state++;
      } else if (top.state == 2) {
        idx++;
        if (arr[idx] != null) {
          top.node.right = new Node(arr[idx], null, null);
          Pair rp = new Pair(top.node.right, 1);
          st.push(rp);
        } else {
          top.node.right = null;
        }

        top.state++;
      } else {
        st.pop();
      }
    }

    return root;
  }

  public static void display(Node node) {
    if (node == null) {
      return;
    }

    String str = "";
    str += node.left == null ? "." : node.left.data + "";
    str += " <- " + node.data + " -> ";
    str += node.right == null ? "." : node.right.data + "";
    System.out.println(str);

    display(node.left);
    display(node.right);
  }

  public static Node add(Node node, int data) {
    if (node == null) {
      return new Node(data, null, null);
    }

    if (data > node.data) {
      node.right = add(node.right, data);
      return node;
    } else if (data < node.data) {
      node.left = add(node.left, data);
      return node;
    } else {
      return node;
    }
  }

  public static void main(String[] args) throws Exception {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    int n = Integer.parseInt(br.readLine());
    Integer[] arr = new Integer[n];
    String[] values = br.readLine().split(" ");
    for (int i = 0; i < n; i++) {
      if (values[i].equals("n") == false) {
        arr[i] = Integer.parseInt(values[i]);
      } else {
        arr[i] = null;
      }
    }

    int data = Integer.parseInt(br.readLine());

    Node root = construct(arr);
    root = add(root, data);

    display(root);
  }

}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Remove Node from BST</span>
import java.io.*;

import java.util.*;

public class Main {
  public static class Node {
    int data;
    Node left;
    Node right;

    Node(int data, Node left, Node right) {
      this.data = data;
      this.left = left;
      this.right = right;
    }
  }

  public static class Pair {
    Node node;
    int state;

    Pair(Node node, int state) {
      this.node = node;
      this.state = state;
    }
  }

  public static Node construct(Integer[] arr) {
    Node root = new Node(arr[0], null, null);
    Pair rtp = new Pair(root, 1);

    Stack< Pair> st = new Stack< >();
    st.push(rtp);

    int idx = 0;
    while (st.size() > 0) {
      Pair top = st.peek();
      if (top.state == 1) {
        idx++;
        if (arr[idx] != null) {
          top.node.left = new Node(arr[idx], null, null);
          Pair lp = new Pair(top.node.left, 1);
          st.push(lp);
        } else {
          top.node.left = null;
        }

        top.state++;
      } else if (top.state == 2) {
        idx++;
        if (arr[idx] != null) {
          top.node.right = new Node(arr[idx], null, null);
          Pair rp = new Pair(top.node.right, 1);
          st.push(rp);
        } else {
          top.node.right = null;
        }

        top.state++;
      } else {
        st.pop();
      }
    }

    return root;
  }

  public static void display(Node node) {
    if (node == null) {
      return;
    }

    String str = "";
    str += node.left == null ? "." : node.left.data + "";
    str += " <- " + node.data + " -> ";
    str += node.right == null ? "." : node.right.data + "";
    System.out.println(str);

    display(node.left);
    display(node.right);
  }

  public static int max(Node node) {
    if (node.right == null) {
      return node.data;
    } else {
      return max(node.right);
    }
  }

  public static Node remove(Node node, int data) {
    if (node == null) {
      return null;
    }

    if (data > node.data) {
      node.right = remove(node.right, data);
      return node;
    } else if (data < node.data) {
      node.left = remove(node.left, data);
      return node;
    } else {
      if (node.left == null && node.right == null) {
        return null;
      } else if (node.left == null) {
        return node.right;
      } else if (node.right == null) {
        return node.left;
      } else {
        int max = max(node.left);
        node.data = max;
        node.left = remove(node.left, max);
        return node;
      }
    }
  }

  public static void main(String[] args) throws Exception {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    int n = Integer.parseInt(br.readLine());
    Integer[] arr = new Integer[n];
    String[] values = br.readLine().split(" ");
    for (int i = 0; i < n; i++) {
      if (values[i].equals("n") == false) {
        arr[i] = Integer.parseInt(values[i]);
      } else {
        arr[i] = null;
      }
    }

    int data = Integer.parseInt(br.readLine());

    Node root = construct(arr);
    root = remove(root, data);

    display(root);
  }

}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Replace With Sum Of Larger</span>
import java.io.*;

import java.util.*;

public class Main {
  public static class Node {
    int data;
    Node left;
    Node right;

    Node(int data, Node left, Node right) {
      this.data = data;
      this.left = left;
      this.right = right;
    }
  }

  public static class Pair {
    Node node;
    int state;

    Pair(Node node, int state) {
      this.node = node;
      this.state = state;
    }
  }

  public static Node construct(Integer[] arr) {
    Node root = new Node(arr[0], null, null);
    Pair rtp = new Pair(root, 1);
    Stack< Pair> st = new Stack< >();
    st.push(rtp);
    int idx = 0;
    while (st.size() > 0) {
      Pair top = st.peek();
      if (top.state == 1) {
        idx++;
        if (arr[idx] != null) {
          top.node.left = new Node(arr[idx], null, null);
          Pair lp = new Pair(top.node.left, 1);
          st.push(lp);
        } else {
          top.node.left = null;
        }

        top.state++;
      } else if (top.state == 2) {
        idx++;
        if (arr[idx] != null) {
          top.node.right = new Node(arr[idx], null, null);
          Pair rp = new Pair(top.node.right, 1);
          st.push(rp);
        } else {
          top.node.right = null;
        }

        top.state++;
      } else {
        st.pop();
      }
    }

    return root;
  }

  public static void display(Node node) {
    if (node == null) {
      return;
    }

    String str = "";
    str += node.left == null ? "." : node.left.data + "";
    str += " <- " + node.data + " -> ";
    str += node.right == null ? "." : node.right.data + "";
    System.out.println(str);

    display(node.left);
    display(node.right);
  }
  static int sum = 0;
  public static void rwsol(Node node) {
    if (node == null) {
      return;
    }
    rwsol(node.right);   // visit the right node

    int od = node.data;  // inorder process
    node.data = sum;
    sum += od;

    rwsol(node.left);    //visit left node

  }

  public static void main(String[] args) throws Exception {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    int n = Integer.parseInt(br.readLine());
    Integer[] arr = new Integer[n];
    String[] values = br.readLine().split(" ");
    for (int i = 0; i < n; i++) {
      if (values[i].equals("n") == false) {
        arr[i] = Integer.parseInt(values[i]);
      } else {
        arr[i] = null;
      }
    }

    Node root = construct(arr);
    rwsol(root);
    display(root);
  }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Lca Of Bst</span>
import java.io.*;

import java.util.*;

public class Main {
  public static class Node {
    int data;
    Node left;
    Node right;

    Node(int data, Node left, Node right) {
      this.data = data;
      this.left = left;
      this.right = right;
    }
  }

  public static class Pair {
    Node node;
    int state;

    Pair(Node node, int state) {
      this.node = node;
      this.state = state;
    }
  }

  public static Node construct(Integer[] arr) {
    Node root = new Node(arr[0], null, null);
    Pair rtp = new Pair(root, 1);

    Stack< Pair> st = new Stack< >();
    st.push(rtp);

    int idx = 0;
    while (st.size() > 0) {
      Pair top = st.peek();
      if (top.state == 1) {
        idx++;
        if (arr[idx] != null) {
          top.node.left = new Node(arr[idx], null, null);
          Pair lp = new Pair(top.node.left, 1);
          st.push(lp);
        } else {
          top.node.left = null;
        }
        top.state++;
      } else if (top.state == 2) {
        idx++;
        if (arr[idx] != null) {
          top.node.right = new Node(arr[idx], null, null);
          Pair rp = new Pair(top.node.right, 1);
          st.push(rp);
        } else {
          top.node.right = null;
        }
        top.state++;
      } else {
        st.pop();
      }
    }
    return root;
  }

  public static void display(Node node) {
    if (node == null) {
      return;
    }
    String str = "";
    str += node.left == null ? "." : node.left.data + "";
    str += " <- " + node.data + " -> ";
    str += node.right == null ? "." : node.right.data + "";
    System.out.println(str);
    display(node.left);
    display(node.right);
  }

  public static int lca(Node node, int d1, int d2) {
    if (node == null) { //1
      return 0;
    }
    if (d1 < node.data && d2 < node.data) { //2
      return lca(node.left, d1, d2);
    }
    else if (d1 > node.data && d2 > node.data) { //3
      return lca(node.right, d1, d2);
    }
    else {      //4
      return node.data;
    }
  }
  public static void main(String[] args) throws Exception {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    int n = Integer.parseInt(br.readLine());
    Integer[] arr = new Integer[n];
    String[] values = br.readLine().split(" ");
    for (int i = 0; i < n; i++) {
      if (values[i].equals("n") == false) {
        arr[i] = Integer.parseInt(values[i]);
      } else {
        arr[i] = null;
      }
    }

    int d1 = Integer.parseInt(br.readLine());
    int d2 = Integer.parseInt(br.readLine());

    Node root = construct(arr);
    int lca = lca(root, d1, d2);
    System.out.println(lca);
  }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Print In Range</span>
import java.io.*;

import java.util.*;

public class Main {
  public static class Node {
    int data;
    Node left;
    Node right;

    Node(int data, Node left, Node right) {
      this.data = data;
      this.left = left;
      this.right = right;
    }
  }

  public static class Pair {
    Node node;
    int state;

    Pair(Node node, int state) {
      this.node = node;
      this.state = state;
    }
  }

  public static Node construct(Integer[] arr) {
    Node root = new Node(arr[0], null, null);
    Pair rtp = new Pair(root, 1);

    Stack< Pair> st = new Stack< >();
    st.push(rtp);

    int idx = 0;
    while (st.size() > 0) {
      Pair top = st.peek();
      if (top.state == 1) {
        idx++;
        if (arr[idx] != null) {
          top.node.left = new Node(arr[idx], null, null);
          Pair lp = new Pair(top.node.left, 1);
          st.push(lp);
        } else {
          top.node.left = null;
        }

        top.state++;
      } else if (top.state == 2) {
        idx++;
        if (arr[idx] != null) {
          top.node.right = new Node(arr[idx], null, null);
          Pair rp = new Pair(top.node.right, 1);
          st.push(rp);
        } else {
          top.node.right = null;
        }

        top.state++;
      } else {
        st.pop();
      }
    }

    return root;
  }

  public static void display(Node node) {
    if (node == null) {
      return;
    }

    String str = "";
    str += node.left == null ? "." : node.left.data + "";
    str += " <- " + node.data + " -> ";
    str += node.right == null ? "." : node.right.data + "";
    System.out.println(str);

    display(node.left);
    display(node.right);
  }

  public static void pir(Node node, int d1, int d2) {
    if (node == null) {
      return;

    }
    if (node.data > d1 && node.data > d2) {
      pir(node.left, d1, d2);
    } else if (node.data < d1 && node.data < d2) {
      pir(node.right, d1, d2);
    } else {
      pir(node.left, d1, d2);
      System.out.println(node.data);
      pir(node.right, d1, d2);
    }
  }

  public static void main(String[] args) throws Exception {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    int n = Integer.parseInt(br.readLine());
    Integer[] arr = new Integer[n];
    String[] values = br.readLine().split(" ");
    for (int i = 0; i < n; i++) {
      if (values[i].equals("n") == false) {
        arr[i] = Integer.parseInt(values[i]);
      } else {
        arr[i] = null;
      }
    }

    int d1 = Integer.parseInt(br.readLine());
    int d2 = Integer.parseInt(br.readLine());

    Node root = construct(arr);
    pir(root, d1, d2);
  }

}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Target Sum Pair In Bst</span>
import java.io.*;

import java.util.*;

public class Main {
  public static class Node {
    int data;
    Node left;
    Node right;

    Node(int data, Node left, Node right) {
      this.data = data;
      this.left = left;
      this.right = right;
    }
  }

  public static class Pair {
    Node node;
    int state;

    Pair(Node node, int state) {
      this.node = node;
      this.state = state;
    }
  }

  public static Node construct(Integer[] arr) {
    Node root = new Node(arr[0], null, null);
    Pair rtp = new Pair(root, 1);

    Stack< Pair> st = new Stack< >();
    st.push(rtp);

    int idx = 0;
    while (st.size() > 0) {
      Pair top = st.peek();
      if (top.state == 1) {
        idx++;
        if (arr[idx] != null) {
          top.node.left = new Node(arr[idx], null, null);
          Pair lp = new Pair(top.node.left, 1);
          st.push(lp);
        } else {
          top.node.left = null;
        }

        top.state++;
      } else if (top.state == 2) {
        idx++;
        if (arr[idx] != null) {
          top.node.right = new Node(arr[idx], null, null);
          Pair rp = new Pair(top.node.right, 1);
          st.push(rp);
        } else {
          top.node.right = null;
        }

        top.state++;
      } else {
        st.pop();
      }
    }

    return root;
  }

  public static void display(Node node) {
    if (node == null) {
      return;
    }

    String str = "";
    str += node.left == null ? "." : node.left.data + "";
    str += " <- " + node.data + " -> ";
    str += node.right == null ? "." : node.right.data + "";
    System.out.println(str);

    display(node.left);
    display(node.right);
  }

  public static boolean find(Node node, int data) {
    if (node == null) {
      return false;
    }

    if (data > node.data) {
      return find(node.right, data);
    } else if (data < node.data) {
      return find(node.left, data);
    } else {
      return true;
    }
  }

  public static void targetSumPair(Node root, Node node, int tar) {
    if (node == null) {
      return;
    }

    targetSumPair(root, node.left, tar);

    int comp = tar - node.data;
    if (comp > node.data) {
      if (find(root, comp)) {
        System.out.println(node.data + " " + comp);
      }
    }

    targetSumPair(root, node.right, tar);
  }

  public static void main(String[] args) throws Exception {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    int n = Integer.parseInt(br.readLine());
    Integer[] arr = new Integer[n];
    String[] values = br.readLine().split(" ");
    for (int i = 0; i < n; i++) {
      if (values[i].equals("n") == false) {
        arr[i] = Integer.parseInt(values[i]);
      } else {
        arr[i] = null;
      }
    }

    int data = Integer.parseInt(br.readLine());

    Node root = construct(arr);
    targetSumPair(root, root, data);
  }

}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Target Sum Pair in BST-Alternate Approaches</span>
import java.io.*;

import java.util.*;

public class Main {
  public static class Node {
    int data;
    Node left;
    Node right;

    Node(int data, Node left, Node right) {
      this.data = data;
      this.left = left;
      this.right = right;
    }
  }

  public static class Pair {
    Node node;
    int state;

    Pair(Node node, int state) {
      this.node = node;
      this.state = state;
    }
  }

  public static Node construct(Integer[] arr) {
    Node root = new Node(arr[0], null, null);
    Pair rtp = new Pair(root, 1);

    Stack< Pair> st = new Stack< >();
    st.push(rtp);

    int idx = 0;
    while (st.size() > 0) {
      Pair top = st.peek();
      if (top.state == 1) {
        idx++;
        if (arr[idx] != null) {
          top.node.left = new Node(arr[idx], null, null);
          Pair lp = new Pair(top.node.left, 1);
          st.push(lp);
        } else {
          top.node.left = null;
        }

        top.state++;
      } else if (top.state == 2) {
        idx++;
        if (arr[idx] != null) {
          top.node.right = new Node(arr[idx], null, null);
          Pair rp = new Pair(top.node.right, 1);
          st.push(rp);
        } else {
          top.node.right = null;
        }

        top.state++;
      } else {
        st.pop();
      }
    }

    return root;
  }

  public static void display(Node node) {
    if (node == null) {
      return;
    }

    String str = "";
    str += node.left == null ? "." : node.left.data + "";
    str += " <- " + node.data + " -> ";
    str += node.right == null ? "." : node.right.data + "";
    System.out.println(str);

    display(node.left);
    display(node.right);
  }

  public static void tnf(Node node, ArrayList< Integer> list )
  {
    if (node == null)
    {
      return;
    }

    tnf(node.left, list);
    list.add(node.data);
    tnf(node.right, list);
  }

  public static void main(String[] args) throws Exception {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    int n = Integer.parseInt(br.readLine());
    Integer[] arr = new Integer[n];
    String[] values = br.readLine().split(" ");
    for (int i = 0; i < n; i++) {
      if (values[i].equals("n") == false) {
        arr[i] = Integer.parseInt(values[i]);
      } else {
        arr[i] = null;
      }
    }

    int data = Integer.parseInt(br.readLine());

    Node root = construct(arr);
    // write your code here
    ArrayList< Integer> list = new ArrayList< >();
    tnf(root, list);
    int li = 0;
    int ri = list.size() - 1;
    while (li < ri)
    {
      if (list.get(li) + list.get(ri) > data)
      {
        ri--;
      }
      else if (list.get(li) + list.get(ri) < data)
      {
        li++;
      }
      else
      {
        System.out.println(list.get(li) + " " + list.get(ri));
        li++;
        ri--;
      }
    }
  }

}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Introduction to Hashmaps</span>
import java.io.*;

import java.util.*;

public class Main {

  public static void main(String[] args)
  {
    HashMap< String, Integer> hm = new HashMap< >();
    System.out.println(hm);
  }
}
import java.io.*;

import java.util.*;

public class Main {

  public static void main(String[] args)
  {
    HashMap< String, Integer> hm = new HashMap< >();
    hm.put("India", 1391);
    hm.put("China", 1398);
    hm.put("USA", 329);
    hm.put("Indonesia", 268);

    //Printing the get(key) when key exists
    System.out.println("Value for India " + hm.get("India"));

    //Printing the get(key) when kkey doesn't exist
    System.out.println("Value for Utopia " + hm.get("Utopia"));

  }
}
import java.io.*;

import java.util.*;

public class Main {

  public static void main(String[] args)
  {
    HashMap< String, Integer> hm = new HashMap< >();
    hm.put("India", 1391);
    hm.put("China", 1398);
    hm.put("USA", 329);
    hm.put("Indonesia", 268);

    Set< String> keys = hm.keySet();
    System.out.println(keys);
  }
}
import java.io.*;

import java.util.*;

public class Main {

  public static void main(String[] args)
  {
    HashMap< String, Integer> hm = new HashMap< >();
    hm.put("India", 1391);
    hm.put("China", 1398);
    hm.put("USA", 329);
    hm.put("Indonesia", 268);

    //Using keySet() to iterate through the hashmap
    for (String key : hm.keySet())
    {
      Integer val = hm.get(key);
      System.out.print(key + ":" + val + "  ");
    }
  }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Highest Frequency Character</span>
import java.io.*;

import java.util.*;

public class Main {

  public static void main(String[] args) throws Exception {

    Scanner scn = new Scanner(System.in);
    String str = scn.next();
    HashMap < Character, Integer> hm = new HashMap(); //1
    for (int i = 0; i < str.length(); i++)
    {
      char ch = str.charAt(i);
      if (hm.containsKey(ch)) //2
      {
        int old = hm.get(ch);
        int now = old + 1;
        hm.put(ch, now);
      }
      else {  //3
        hm.put(ch, 1);
      }

    }

    char max = str.charAt(0); //4
    for (Character key : hm.keySet()) //5
    {
      if (hm.get(key) > hm.get(max))
        max = key;

    }
    System.out.println(max);  //6
  }

}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Get Common Elements-1</span>
<span class="textStyle">CODE</span>

import java.io.*;

import java.util.*;

public class Main {

  public static void main(String[] args) throws Exception {
    Scanner scn = new Scanner(System.in);
    int n1 = scn.nextInt();
    int[]a1 = new int[n1];
    for (int i = 0; i hm = new HashMap();
    for (int val : a1)
    {
      if (hm.containsKey(val)) {
          int old = hm.get(val);
          int now = old + 1;
          hm.put(val, now);
        }
        else
        {
          hm.put(val, 1);
        }
      }

    for (int val : a2) {
    if (hm.containsKey(val))
      {
        System.out.println(val);
        hm.remove(val);
      }
    }

  }

}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Get Common Elements-2</span>
import java.io.*;

import java.util.*;

public class Main {

  public static void main(String[] args) throws Exception {

    Scanner scn = new Scanner(System.in);
    int n1 = scn.nextInt();
    int[]a1 = new int[n1];
    for (int i = 0; i < n1; i++)
    {
      a1[i] = scn.nextInt();
    }
    int n2 = scn.nextInt();
    int[]a2 = new int[n2];
    for (int i = 0; i < n2; i++)
    {
      a2[i] = scn.nextInt();
    }

    HashMap< Integer, Integer> hm = new HashMap();
    for (int val : a1)
    {
      if (hm.containsKey(val)) {
        int old = hm.get(val);
        int now = old + 1;
        hm.put(val, now);
      }
      else {
        hm.put(val, 1);
      }
    }
    for (int val : a2) {
      if (hm.containsKey(val)) {
        System.out.println(val);
        int old = hm.get(val);
        if (old > 1)
          hm.put(val, old - 1);
        else
          hm.remove(val);
      }
    }

  }

}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Longest consecutive sequence</span>
import java.io.*;

import java.util.*;

public class Main {

  public static void main(String[] args) throws Exception {

    Scanner scn = new Scanner(System.in);
    int n = scn.nextInt();
    int[]a = new int[n];
    for (int i = 0; i < n; i++) {
      a[i] = scn.nextInt();
    }
    HashMap < Integer, Boolean> hm = new HashMap();
    for (int val : a) {
      hm.put(val, true);
    }
    for (int val : a) {
      if (hm.containsKey(val - 1)) {
        hm.put(val, false);
      }
    }
    int mh = 0;
    int mval = 0;
    for (int val : a) {
      if (hm.get(val) == true)
      {
        int lh = 1;
        int lval = val;
        while (hm.containsKey(lval + lh)) {
          lh++;
        }
        if (lh > mh) {
          mh = lh;
          mval = val;
        }
      }
    }
    for (int i = 0; i < mh; i++)
    {
      System.out.println(mval + i);

    }
  }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">K Largest Elements</span>
import java.io.*;

import java.util.*;

public class Main {

  public static void main(String[] args) throws Exception {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    int n = Integer.parseInt(br.readLine());
    int[] arr = new int[n];

    for (int i = 0; i < n; i++) {
      arr[i] = Integer.parseInt(br.readLine());
    }

    int k = Integer.parseInt(br.readLine());

    PriorityQueue pq = new PriorityQueue <>();
    for (int i = 0; i < arr.length; i++) {
      if (i < k) {
        pq.add(arr[i]);
      } else {
        if (arr[i] > pq.peek()) {
          pq.remove();
          pq.add(arr[i]);
        }
      }
    }

    while (pq.size() > 0) {
      System.out.println(pq.remove());
    }
  }

}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Sort a K Sorted Array</span>
import java.io.*;

import java.util.*;

public class Main {

  public static void main(String[] args) throws Exception {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    int n = Integer.parseInt(br.readLine());
    int[] arr = new int[n];

    for (int i = 0; i < n; i++) {
      arr[i] = Integer.parseInt(br.readLine());
    }

    int k = Integer.parseInt(br.readLine());

    // Add first k+1 elements to the Priority Queue
    PriorityQueue< Integer> pq = new PriorityQueue<>();
    for (int i = 0; i <= k; i++) {
      pq.add(arr[i]);
    }

    //Filter out the smallest element and move funnel to the next positions
    for (int i = k + 1; i < arr.length; i++) {
      System.out.println(pq.remove());
      pq.add(arr[i]);
    }

    //Array is completely traversed, empty the funnel now
    while (pq.size() > 0) {
      System.out.println(pq.remove());
    }
  }

}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Median Priority Queue</span>
import java.io.*;

import java.util.*;

public class Main {

  public static class MedianPriorityQueue {
    PriorityQueue< Integer> left;
    PriorityQueue< Integer> right;

    public MedianPriorityQueue() {
      left = new PriorityQueue<>(Collections.reverseOrder());
      right = new PriorityQueue<>();
    }

    public void add(int val) {
      if (right.size() > 0 && val > right.peek()) {
        right.add(val);
      } else {
        left.add(val);
      }

      handleBalance();
    }

    private void handleBalance() {
      if (left.size() - right.size() == 2) {
        right.add(left.remove());
      } else if (right.size() - left.size() == 2) {
        left.add(right.remove());
      }
    }

    public int remove() {
      if (this.size() == 0) {
        System.out.println("Underflow");
        return -1;
      } else if (left.size() >= right.size()) {
        return left.remove();
      } else {
        return right.remove();
      }
    }

    public int peek() {
      if (this.size() == 0) {
        System.out.println("Underflow");
        return -1;
      } else if (left.size() >= right.size()) {
        return left.peek();
      } else {
        return right.peek();
      }
    }

    public int size() {
      return left.size() + right.size();
    }
  }

  public static void main(String[] args) throws Exception {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    MedianPriorityQueue qu = new MedianPriorityQueue();

    String str = br.readLine();
    while (str.equals("quit") == false) {
      if (str.startsWith("add")) {
        int val = Integer.parseInt(str.split(" ")[1]);
        qu.add(val);
      } else if (str.startsWith("remove")) {
        int val = qu.remove();
        if (val != -1) {
          System.out.println(val);
        }
      } else if (str.startsWith("peek")) {
        int val = qu.peek();
        if (val != -1) {
          System.out.println(val);
        }
      } else if (str.startsWith("size")) {
        System.out.println(qu.size());
      }
      str = br.readLine();
    }
  }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Merge K sorted lists</span>
import java.io.*;

import java.util.*;

public class Main {

  public static class Pair implements Comparable< Pair> {
    int li;
    int di;
    int data;

    Pair(int li, int di, int data) {
      this.li = li;
      this.di = di;
      this.data = data;
    }

    public int compareTo(Pair o) {
      return this.data - o.data;
    }
  }

  public static ArrayList< Integer> mergeKSortedLists(ArrayList< ArrayList< Integer>> lists) {
    ArrayList< Integer> rv = new ArrayList<>();

    PriorityQueue< Pair> pq = new PriorityQueue<>();
    for (int i = 0; i < lists.size(); i++) {
      Pair p = new Pair(i, 0, lists.get(i).get(0));
      pq.add(p);
    }

    while (pq.size() > 0) {
      Pair p = pq.remove();
      rv.add(p.data);
      p.di++;

      if (p.di < lists.get(p.li).size()) {
        p.data = lists.get(p.li).get(p.di);
        pq.add(p);
      }
    }

    return rv;
  }

  public static void main(String[] args) throws Exception {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    int k = Integer.parseInt(br.readLine());
    ArrayList< ArrayList< Integer>> lists = new ArrayList<>();
    for (int i = 0; i < k; i++) {
      ArrayList< Integer> list = new ArrayList<>();

      int n = Integer.parseInt(br.readLine());
      String[] elements = br.readLine().split(" ");
      for (int j = 0; j < n; j++) {
        list.add(Integer.parseInt(elements[j]));
      }

      lists.add(list);
    }

    ArrayList< Integer> mlist = mergeKSortedLists(lists);
    for (int val : mlist) {
      System.out.print(val + " ");
    }
    System.out.println();
  }

}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Priority Queue Using Heap</span>
import java.io.*;

import java.util.*;

public class Main {

  public static class PriorityQueue {
    ArrayList< Integer> data;

    public PriorityQueue() {
      data = new ArrayList<>();
    }

    public void add(int val) {
      data.add(val);
      upheapify(data.size() - 1);
    }

    private void upheapify(int i) {
      if (i == 0) {
        return;
      }

      int pi = (i - 1) / 2;
      if (data.get(pi) > data.get(i)) {
        swap(i, pi);
        upheapify(pi);
      }
    }

    private void swap(int i, int j) {
      int ith = data.get(i);
      int jth = data.get(j);
      data.set(i, jth);
      data.set(j, ith);
    }

    public int remove() {
      if (this.size() == 0) {
        System.out.println("Underflow");
        return -1;
      }
      swap(0, data.size() - 1);
      int val = data.remove(data.size() - 1);
      downheapify(0);
      return val;
    }

    private void downheapify(int i) {
      int mini = i;

      int li = 2 * i + 1;
      if (li < data.size() && data.get(li) < data.get(mini)) {
        mini = li;
      }
      int ri = 2 * i + 2;
      if (ri < data.size() && data.get(ri) < data.get(mini)) {
        mini = ri;
      }
      if (mini != i) {
        swap(i, mini);
        downheapify(mini);
      }
    }

    public int peek() {
      if (this.size() == 0) {
        System.out.println("Underflow");
        return -1;
      }

      return data.get(0);
    }

    public int size() {
      return data.size();
    }
  }
  public static void main(String[] args) throws Exception {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    PriorityQueue qu = new PriorityQueue();

    String str = br.readLine();
    while (str.equals("quit") == false) {
      if (str.startsWith("add")) {
        int val = Integer.parseInt(str.split(" ")[1]);
        qu.add(val);
      } else if (str.startsWith("remove")) {
        int val = qu.remove();
        if (val != -1) {
          System.out.println(val);
        }
      } else if (str.startsWith("peek")) {
        int val = qu.peek();
        if (val != -1) {
          System.out.println(val);
        }
      } else if (str.startsWith("size")) {
        System.out.println(qu.size());
      }
      str = br.readLine();
    }
  }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Write Hashmap</span>
import java.io.*;

import java.util.*;

public class Main {


  public static class HashMap< K, V> {        //1
    private class HMNode {
      K key;
      V value;

      HMNode(K key, V value) {
        this.key = key;
        this.value = value;
      }
    }

    private int size; // n
    private LinkedList< HMNode>[] buckets; // N = buckets.length

    public HashMap() {  //2
      initbuckets(4);
      size = 0;
    }

    private void initbuckets(int N) {  //3
      buckets = new LinkedList[N];
      for (int bi = 0; bi < buckets.length; bi++) {
        buckets[bi] = new LinkedList<>();
      }
    }
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Efficient Heap construction</span>

<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Introduction To Graphs and its Representation</span>
<span class="textStyle">Introduction To Graphs and its Representation</span>
import java.io.*;

import java.util.*;

public class Main {
  static class Edge {
    int src;
    int nbr;
    int wt;

    Edge(int src, int nbr, int wt) {
      this.src = src;
      this.nbr = nbr;
      this.wt = wt;
    }
  }
  public static void main(String[] args) throws Exception {
    int vertices = 7; //0 1 2 3 4 5 6
    ArrayList[] graph = new ArrayList[7];

    //This is as per the diagram (fig-13)

    graph[0].add(new Edge(0, 1, 10));
    graph[0].add(new Edge(0, 2, 20));

    graph[0].add(new Edge(1, 0, 10));
    graph[0].add(new Edge(1, 2, 30));
    graph[0].add(new Edge(1, 3, 50));
    graph[0].add(new Edge(1, 4, 40));

    graph[0].add(new Edge(2, 0, 20));
    graph[0].add(new Edge(2, 1, 30));
    graph[0].add(new Edge(2, 5, 80));

    graph[0].add(new Edge(3, 1, 50));
    graph[0].add(new Edge(3, 5, 70));

    graph[0].add(new Edge(4, 1, 40));
    graph[0].add(new Edge(4, 2, 80));
    graph[0].add(new Edge(4, 5, 60));

    graph[0].add(new Edge(5, 3, 70));
    graph[0].add(new Edge(5, 4, 60));

  }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Has Path</span>
import java.io.*;

import java.util.*;

public class Main {
  static class Edge {
    int src;
    int nbr;
    int wt;

    Edge(int src, int nbr, int wt) {
      this.src = src;
      this.nbr = nbr;
      this.wt = wt;
    }
  }

  public static void main(String[] args) throws Exception {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

    int vtces = Integer.parseInt(br.readLine());
    ArrayList< Edge>[] graph = new ArrayList[vtces];
    for (int i = 0; i < vtces; i++) {
      graph[i] = new ArrayList<>();
    }

    int edges = Integer.parseInt(br.readLine());
    for (int i = 0; i < edges; i++) {
      String[] parts = br.readLine().split(" ");
      int v1 = Integer.parseInt(parts[0]);
      int v2 = Integer.parseInt(parts[1]);
      int wt = Integer.parseInt(parts[2]);
      graph[v1].add(new Edge(v1, v2, wt));
      graph[v2].add(new Edge(v2, v1, wt));
    }

    int src = Integer.parseInt(br.readLine());
    int dest = Integer.parseInt(br.readLine());

    boolean[] visited = new boolean[vtces];
    boolean flag = hasPath(graph, src, dest, visited);
    System.out.println(flag);
  }

  public static boolean hasPath(ArrayList< Edge>[] graph, int src, int dest, boolean[] visited) {
    if (src == dest)
      return true;

    visited[src] = true;
    for (Edge e : graph[src]) {
      if (!visited[e.nbr]) {
        boolean nbrHasPath = hasPath(graph, e.nbr, dest, visited);
        if (nbrHasPath)
          return true;
      }
    }
    return false;
  }

}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Print All Path</span>
import java.io.*;

import java.util.*;

public class Main {
  static class Edge {
    int src;
    int nbr;
    int wt;

    Edge(int src, int nbr, int wt) {
      this.src = src;
      this.nbr = nbr;
      this.wt = wt;
    }
  }

  public static void main(String[] args) throws Exception {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

    int vtces = Integer.parseInt(br.readLine());
    ArrayList< Edge>[] graph = new ArrayList[vtces];
    for (int i = 0; i < vtces; i++) {
      graph[i] = new ArrayList<>();
    }

    int edges = Integer.parseInt(br.readLine());
    for (int i = 0; i < edges; i++) {
      String[] parts = br.readLine().split(" ");
      int v1 = Integer.parseInt(parts[0]);
      int v2 = Integer.parseInt(parts[1]);
      int wt = Integer.parseInt(parts[2]);
      graph[v1].add(new Edge(v1, v2, wt));
      graph[v2].add(new Edge(v2, v1, wt));
    }

    int src = Integer.parseInt(br.readLine());
    int dest = Integer.parseInt(br.readLine());

    boolean[] visited = new boolean[vtces];
    printAllPaths(graph, src, dest, visited, src + "");
  }

  public static void printAllPaths(ArrayList< Edge>[] graph, int src, int dest, boolean[] visited, String psf) {
    if (src == dest) {
      System.out.println(psf);
      return;
    }

    visited[src] = true;
    for (Edge e : graph[src]) {
      if (!visited[e.nbr]) {
        printAllPaths(graph, e.nbr, dest, visited, psf + e.nbr);
      }
    }
    visited[src] = false;
  }

}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Multisolver</span>
import java.io.*;

import java.util.*;

public class Main {
  static class Edge {
    int src;
    int nbr;
    int wt;

    Edge(int src, int nbr, int wt) {
      this.src = src;
      this.nbr = nbr;
      this.wt = wt;
    }
  }

  static class Pair implements Comparable< Pair> {
    int wsf;
    String psf;

    Pair(int wsf, String psf) {
      this.wsf = wsf;
      this.psf = psf;
    }

    public int compareTo(Pair o) {
      return this.wsf - o.wsf;
    }
  }

  public static void main(String[] args) throws Exception {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

    int vtces = Integer.parseInt(br.readLine());
    ArrayList< Edge>[] graph = new ArrayList[vtces];
    for (int i = 0; i < vtces; i++) {
      graph[i] = new ArrayList<>();
    }

    int edges = Integer.parseInt(br.readLine());
    for (int i = 0; i < edges; i++) {
      String[] parts = br.readLine().split(" ");
      int v1 = Integer.parseInt(parts[0]);
      int v2 = Integer.parseInt(parts[1]);
      int wt = Integer.parseInt(parts[2]);
      graph[v1].add(new Edge(v1, v2, wt));
      graph[v2].add(new Edge(v2, v1, wt));
    }

    int src = Integer.parseInt(br.readLine());
    int dest = Integer.parseInt(br.readLine());

    int criteria = Integer.parseInt(br.readLine());
    int k = Integer.parseInt(br.readLine());

    boolean[] visited = new boolean[vtces];
    multisolver(graph, src, dest, visited, criteria, k, src + "", 0);

    System.out.println("Smallest Path = " + spath + "@" + spathwt);
    System.out.println("Largest Path = " + lpath + "@" + lpathwt);
    System.out.println("Just Larger Path than " + criteria + " = " + cpath + "@" + cpathwt);
    System.out.println("Just Smaller Path than " + criteria + " = " + fpath + "@" + fpathwt);
    System.out.println(k + "th largest path = " + pq.peek().psf + "@" + pq.peek().wsf);
  }



  static String spath;  //spath=smallest path weight
  static Integer spathwt = Integer.MAX_VALUE; //spathwt= smallest path weight
  static String lpath;  //lpath= largest path
  static Integer lpathwt = Integer.MIN_VALUE; //lpathwt=largest path weight
  static String cpath;  //cpath=ceil path
  static Integer cpathwt = Integer.MAX_VALUE; //cpathwt=ceil path weight
  static String fpath; //fpath=floor path
  static Integer fpathwt = Integer.MIN_VALUE; //fpathwt= floor path weight
  static PriorityQueue< Pair> pq = new PriorityQueue<>();
  public static void multisolver(ArrayList< Edge>[] graph, 
                                int src, int dest, boolean[] visited, int criteria, 
                                int k, String psf, int wsf) {

    if (src == dest) {
      if (wsf < spathwt) {
        spathwt = wsf;
        spath = psf;
      }
      if (wsf > lpathwt) {
        lpathwt = wsf;
        lpath = psf;
      }
      if (wsf > criteria && wsf < cpathwt) {
        cpathwt = wsf;
        cpath = psf;
      }
      if (wsf < criteria && wsf > fpathwt) {
        fpathwt = wsf;
        fpath = psf;
      }
      if (pq.size() < k) {
        pq.add(new Pair(wsf, psf));
      } else {
        if (wsf > pq.peek().wsf) {
          pq.remove();
          pq.add(new Pair(wsf, psf));
        }
      }
      return;
    }

    visited[src] = true;
    for (Edge edge : graph[src]) {
      if (visited[edge.nbr] == false) {
        multisolver(graph, edge.nbr, dest, visited, criteria, k, psf + edge.nbr, wsf + edge.wt);
      }
    }
    visited[src] = false;
  }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Get Connected Components</span>
import java.io.*;

import java.util.*;

public class Main {
  static class Edge {
    int src;
    int nbr;
    int wt;

    Edge(int src, int nbr, int wt) {
      this.src = src;
      this.nbr = nbr;
      this.wt = wt;
    }
  }

  public static void main(String[] args) throws Exception {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

    int vtces = Integer.parseInt(br.readLine());
    ArrayList< Edge>[] graph = new ArrayList[vtces];
    for (int i = 0; i < vtces; i++) {
      graph[i] = new ArrayList< >();
    }

    int edges = Integer.parseInt(br.readLine());
    for (int i = 0; i < edges; i++) {
      String[] parts = br.readLine().split(" ");
      int v1 = Integer.parseInt(parts[0]);
      int v2 = Integer.parseInt(parts[1]);
      int wt = Integer.parseInt(parts[2]);
      graph[v1].add(new Edge(v1, v2, wt));
      graph[v2].add(new Edge(v2, v1, wt));
    }

    int src = Integer.parseInt(br.readLine());
    int dest = Integer.parseInt(br.readLine());

    boolean[] visited = new boolean[vtces];
    printAllPaths(graph, src, dest, visited, src + "");
  }

  public static void printAllPaths(ArrayList< Edge>[] graph, int src, int dest, boolean[] visited, String psf) {
    if (src == dest) {
      System.out.println(psf);
      return;
    }

    visited[src] = true;
    for (Edge e : graph[src]) {
      if (!visited[e.nbr]) {
        printAllPaths(graph, e.nbr, dest, visited, psf + e.nbr);
      }
    }
    visited[src] = false;
  }

} import java.io.*;
import java.util.*;

public class Main {
  static class Edge {
    int src;
    int nbr;
    int wt;

    Edge(int src, int nbr, int wt) {
      this.src = src;
      this.nbr = nbr;
      this.wt = wt;
    }
  }

  public static void main(String[] args) throws Exception {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

    int vtces = Integer.parseInt(br.readLine());
    ArrayList< Edge>[] graph = new ArrayList[vtces];
    for (int i = 0; i < vtces; i++) {
      graph[i] = new ArrayList< >();
    }

    int edges = Integer.parseInt(br.readLine());
    for (int i = 0; i < edges; i++) {
      String[] parts = br.readLine().split(" ");
      int v1 = Integer.parseInt(parts[0]);
      int v2 = Integer.parseInt(parts[1]);
      int wt = Integer.parseInt(parts[2]);
      graph[v1].add(new Edge(v1, v2, wt));
      graph[v2].add(new Edge(v2, v1, wt));
    }

    ArrayList< ArrayList< Integer>> comps = new ArrayList< >();

    // write your code here

    boolean[] visited = new boolean[vtces];

    for (int i = 0; i < vtces; i++) {

      if (visited[i] == false) {

        ArrayList< Integer> comp = new ArrayList< >();
        dfs(graph, i, visited, comp);
        comps.add(comp);
      }
    }

    System.out.println(comps);
  }

  public static void dfs(ArrayList<Edge>[] graph, int src, boolean[] visited,ArrayList<Integer> comp){

    visited[src] = true;
    comp.add(src);

    for (Edge e : graph[src]) {

      if (visited[e.nbr] == false) {

        dfs(graph, e.nbr, visited, comp);
      }
    }
  }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">IS GRAPH CONNECTED</span>
import java.io.*;

import java.util.*;

public class Main {
  static class Edge {
    int src;
    int nbr;
    int wt;

    Edge(int src, int nbr, int wt) {
      this.src = src;
      this.nbr = nbr;
      this.wt = wt;
    }
  }

  public static void main(String[] args) throws Exception {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

    int vtces = Integer.parseInt(br.readLine());
    ArrayList< Edge>[] graph = new ArrayList[vtces];
    for (int i = 0; i < vtces; i++) {
      graph[i] = new ArrayList< >();
    }

    int edges = Integer.parseInt(br.readLine());
    for (int i = 0; i < edges; i++) {
      String[] parts = br.readLine().split(" ");
      int v1 = Integer.parseInt(parts[0]);
      int v2 = Integer.parseInt(parts[1]);
      int wt = Integer.parseInt(parts[2]);
      graph[v1].add(new Edge(v1, v2, wt));
      graph[v2].add(new Edge(v2, v1, wt));
    }

    ArrayList< ArrayList< Integer>> comps = new ArrayList< >();


    boolean[]visited = new boolean[vtces];
    for (int v = 0; v < vtces; v++) {
      if (visited[v] == false) {
        ArrayList<Integer> comp = new ArrayList<>();
        drawTree(graph, v, comp, visited);
        comps.add(comp);
      }
    }

    System.out.println(comps.size() == 1); //1

  }
  public static void drawTree(ArrayList<Edge>[]graph, int src, ArrayList<Integer> comp, boolean[]visited){
    visited[src] = true;
    comp.add(src);
    for (Edge e : graph[src]) {
      if (visited[e.nbr] == false) {
        drawTree(graph, e.nbr, comp, visited);
      }
    }
  }

}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">NUMBER OF ISLANDS</span>
import java.io.*;

import java.util.*;

public class Main {
  public static void main(String[] args) throws Exception {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

    int m = Integer.parseInt(br.readLine());
    int n = Integer.parseInt(br.readLine());
    int[][] arr = new int[m][n];

    for (int i = 0; i < arr.length; i++) {
      String parts = br.readLine();
      for (int j = 0; j < arr[0].length; j++) {
        arr[i][j] = Integer.parseInt(parts.split(" ")[j]);
      }
    }

    boolean[][]visited = new boolean[arr.length][arr[0].length]; //1
    int count = 0;
    for (int i = 0; i < arr.length; i++) {    //2
      for (int j = 0; j < arr[0].length; j++) {
        if (arr[i][j] == 0 && visited[i][j] == false) {
          drawTreeforComponent(arr, i, j, visited);
          count++;
        }
      }
    }
    System.out.println(count); //3
  }

  public static void drawTreeforComponent(int[][]arr, int i, int j, boolean[][]visited) {
    if (i < 0 || j < 0 || i >= arr.length || j >= arr[0].length || arr[i][j] == 1 || visited[i][j] == true){ //4
      return;
    }
    visited[i][j] = true; //5
    drawTreeforComponent(arr, i - 1, j, visited); //6
    drawTreeforComponent(arr, i, j + 1, visited);
    drawTreeforComponent(arr, i, j - 1, visited);
    drawTreeforComponent(arr, i + 1, j, visited);
  }

}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Perfect Friends</span>
import java.io.*;

import java.util.*;

public class Main {
  static class Edge {
    int src;
    int nbr;

    Edge(int src, int nbr) {
      this.src = src;
      this.nbr = nbr;
    }
  }

  public static void main(String[] args) throws Exception {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

    int n = Integer.parseInt(br.readLine());
    int k = Integer.parseInt(br.readLine());

    int vtces = n;
    ArrayList< Edge>[] graph = new ArrayList[vtces];
    for (int i = 0; i < vtces; i++) {
      graph[i] = new ArrayList< >();
    }

    int edges = k;
    for (int i = 0; i < edges; i++) {
      String[] parts = br.readLine().split(" ");
      int v1 = Integer.parseInt(parts[0]);
      int v2 = Integer.parseInt(parts[1]);
      graph[v1].add(new Edge(v1, v2));
      graph[v2].add(new Edge(v2, v1));
    }

    boolean[] visited = new boolean[vtces];
    ArrayList< ArrayList< Integer>> comps = new ArrayList< >();
    for (int v = 0; v < vtces; v++) {
      if (visited[v] == false) {
        ArrayList< Integer> comp = new ArrayList< >();
        gcc(graph, v, visited, comp);
        comps.add(comp);
      }
    }

    int count = 0;
    for (int i = 0; i < comps.size(); i++) {
      for (int j = i + 1; j < comps.size(); j++) {
        count += comps.get(i).size() * comps.get(j).size();
      }
    }
    System.out.println(count);
  }

  public static void gcc(ArrayList< Edge>[] graph, int src, boolean[] visited, ArrayList< Integer>
                         comp) {
    comp.add(src);
    visited[src] = true;
    for (Edge e : graph[src]) {
      if (!visited[e.nbr]) {
        gcc(graph, e.nbr, visited, comp);
      }
    }
  }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Hamiltonian Path and Cycle</span>
import java.io.*;

import java.util.*;

public class Main {
  static class Edge {
    int src;
    int nbr;
    int wt;

    Edge(int src, int nbr, int wt) {
      this.src = src;
      this.nbr = nbr;
      this.wt = wt;
    }
  }

  public static void main(String[] args) throws Exception {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

    int vtces = Integer.parseInt(br.readLine());
    ArrayList< Edge>[] graph = new ArrayList[vtces];
    for (int i = 0; i < vtces; i++) {
      graph[i] = new ArrayList< >();
    }

    int edges = Integer.parseInt(br.readLine());
    for (int i = 0; i < edges; i++) {
      String[] parts = br.readLine().split(" ");
      int v1 = Integer.parseInt(parts[0]);
      int v2 = Integer.parseInt(parts[1]);
      int wt = Integer.parseInt(parts[2]);
      graph[v1].add(new Edge(v1, v2, wt));
      graph[v2].add(new Edge(v2, v1, wt));
    }

    int src = Integer.parseInt(br.readLine());

    HashSet< Integer> visited = new HashSet< >();
    hamiltonianPathAndCycle(graph, src, src, visited, src + "");
  }

  public static void hamiltonianPathAndCycle(ArrayList< Edge>[] graph, int osrc, int src, HashSet< Integer> visited, String psf) {
    if (visited.size() == graph.length - 1) {
      System.out.print(psf);

      boolean closingEdge = false;
      for (Edge e : graph[osrc]) {
        if (e.nbr == src) {
          closingEdge = true;
          break;
        }
      }

      if (closingEdge) {
        System.out.println("*");
      } else {
        System.out.println(".");
      }
      return;
    }

    visited.add(src);
    for (Edge e : graph[src]) {
      if (!visited.contains(e.nbr)) {
        hamiltonianPathAndCycle(graph, osrc, e.nbr, visited, psf + e.nbr);
      }
    }
    visited.remove(src);
  }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Knights Tour</span>
import java.io.*;

import java.util.*;

public class Main {

  public static void main(String[] args) throws Exception {

  }

  public static void printKnightsTour(int[][] chess, int r, int c, int move) {

    //Code based on High Level Thinking

    chess[r][c] = move; //Fill the chess[r][c] will the move number

    //Apply recursive calls on the basis of faith
    printKnightsTour(chess, r - 2, c + 1, move + 1);
    printKnightsTour(chess, r - 1, c + 2, move + 1);
    printKnightsTour(chess, r + 1, c + 2, move + 1);
    printKnightsTour(chess, r + 2, c + 1, move + 1);
    printKnightsTour(chess, r + 2, c - 1, move + 1);
    printKnightsTour(chess, r + 1, c - 2, move + 1);
    printKnightsTour(chess, r - 1, c - 2, move + 1);
    printKnightsTour(chess, r - 2, c - 1, move + 1);

    //Follow the Backtracking principle
    chess[r][c] = 0;
  }

  public static void displayBoard(int[][] chess) {
    for (int i = 0; i < chess.length; i++) {
      for (int j = 0; j < chess[0].length; j++) {
        System.out.print(chess[i][j] + " ");
      }
      System.out.println();
    }

    System.out.println();
  }
}
<span class="textStyle">or</span>
import java.io.*;

import java.util.*;

public class Main {

  public static void main(String[] args) throws Exception {

    Scanner scn = new Scanner(System.in);
    int n = scn.nextInt();
    int r = scn.nextInt();
    int c = scn.nextInt();
    int[][] chess = new int[n][n];
    printKnightsTour(chess, r, c, 1);
  }

  public static void printKnightsTour(int[][] chess, int r, int c, int move) {

    //if we reach out of the baord or we reach an already visited block
    if (r < 0 || c < 0 || r >= chess.langth || c >= chess.length || chess[r][c] > 0)
    {
      return;
    }
    //if we have reached the last move
    else if (move == chess.length * chess.length)
    {
      chess[r][c] = move;
      displayBoard(chess);
      chess[r][c] = 0;
      return;
    }

    chess[r][c] = move; //Fill the chess[r][c] will the move number

    //Apply recursive calls on the basis of faith
    printKnightsTour(chess, r - 2, c + 1, move + 1);
    printKnightsTour(chess, r - 1, c + 2, move + 1);
    printKnightsTour(chess, r + 1, c + 2, move + 1);
    printKnightsTour(chess, r + 2, c + 1, move + 1);
    printKnightsTour(chess, r + 2, c - 1, move + 1);
    printKnightsTour(chess, r + 1, c - 2, move + 1);
    printKnightsTour(chess, r - 1, c - 2, move + 1);
    printKnightsTour(chess, r - 2, c - 1, move + 1);

    //Follow the Backtracking principle
    chess[r][c] = 0;
  }

  public static void displayBoard(int[][] chess) {
    for (int i = 0; i < chess.length; i++) {
      for (int j = 0; j < chess[0].length; j++) {
        System.out.print(chess[i][j] + " ");
      }
      System.out.println();
    }

    System.out.println();
  }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Breadth First Traversal</span>
import java.io.*;

import java.util.*;

public class Main {
  static class Edge {
    int src;
    int nbr;

    Edge(int src, int nbr) {
      this.src = src;
      this.nbr = nbr;
    }
  }

  public static void main(String[] args) throws Exception {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

    int vtces = Integer.parseInt(br.readLine());
    ArrayList< Edge>[] graph = new ArrayList[vtces];
    for (int i = 0; i < vtces; i++) {
      graph[i] = new ArrayList< >();
    }

    int edges = Integer.parseInt(br.readLine());
    for (int i = 0; i < edges; i++) {
      String[] parts = br.readLine().split(" ");
      int v1 = Integer.parseInt(parts[0]);
      int v2 = Integer.parseInt(parts[1]);
      graph[v1].add(new Edge(v1, v2));
      graph[v2].add(new Edge(v2, v1));
    }

    int src = Integer.parseInt(br.readLine());

    ArrayDeque< Pair> queue = new ArrayDeque< >();
    queue.add(new Pair(src, src + ""));
    boolean[] visited = new boolean[vtces];
    while (queue.size() > 0) {
      Pair rem = queue.remove();

      if (visited[rem.v] == true) {
        continue;
      }
      visited[rem.v] = true;
      System.out.println(rem.v + "@" + rem.psf);

      for (Edge e : graph[rem.v]) {
        if (visited[e.nbr] == false) {
          queue.add(new Pair(e.nbr, rem.psf + e.nbr));
        }
      }
    }
  }

  static class Pair {
    int v;
    String psf;

    Pair(int v, String psf) {
      this.v = v;
      this.psf = psf;
    }
  }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Is Graph Cyclic</span>
import java.io.*;

import java.util.*;

public class Main {
  static class Edge {
    int src;
    int nbr;
    int wt;

    Edge(int src, int nbr, int wt) {
      this.src = src;
      this.nbr = nbr;
      this.wt = wt;
    }
  }

  public static void main(String[] args) throws Exception {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

    int vtces = Integer.parseInt(br.readLine());
    ArrayList< Edge>[] graph = new ArrayList[vtces];
    for (int i = 0; i < vtces; i++) {
      graph[i] = new ArrayList<>();
    }

    int edges = Integer.parseInt(br.readLine());
    for (int i = 0; i < edges; i++) {
      String[] parts = br.readLine().split(" ");
      int v1 = Integer.parseInt(parts[0]);
      int v2 = Integer.parseInt(parts[1]);
      int wt = Integer.parseInt(parts[2]);
      graph[v1].add(new Edge(v1, v2, wt));
      graph[v2].add(new Edge(v2, v1, wt));
    }

    boolean[] visited = new boolean[vtces];
    int[] parent = new int[vtces];
    Arrays.fill(parent, -1); // Initially, all nodes will have parent -1.

    for (int v = 0; v < vtces; v++) {
      if (visited[v] == false) {
        boolean cyclic = IsCyclic(graph, v, visited, parent);
        if (cyclic) {
          System.out.println(true);
          return;
        }
      }
    }

    System.out.println(false);
  }

  public static boolean IsCyclic(ArrayList< Edge>[] graph, int src,
                                 boolean[] visited, int[] parent) {
    ArrayDeque< Integer> queue = new ArrayDeque<>();

    queue.add(src);
    visited[src] = true;

    while (queue.size() > 0) {
      int rem = queue.remove();

      for (Edge e : graph[rem]) {

        if (visited[e.nbr] && parent[rem] != e.nbr) {
          // e.nbr is visited already & it is not the parent of rem.
          // Hence, there exists a cycle
          return true;
        }

        if (!visited[e.nbr]) {
          queue.add(e.nbr);
          visited[e.nbr] = true;
          parent[e.nbr] = rem;
        }
      }
    }

    return false;
  }

}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Is Graph Bipartite</span>
import java.io.*;

import java.util.*;

public class Main {
  static class Edge {
    int src;
    int nbr;
    int wt;

    Edge(int src, int nbr, int wt) {
      this.src = src;
      this.nbr = nbr;
      this.wt = wt;
    }
  }

  public static void main(String[] args) throws Exception {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

    int vtces = Integer.parseInt(br.readLine());
    ArrayList< Edge>[] graph = new ArrayList[vtces];
    for (int i = 0; i < vtces; i++) {
      graph[i] = new ArrayList<>();
    }

    int edges = Integer.parseInt(br.readLine());
    for (int i = 0; i < edges; i++) {
      String[] parts = br.readLine().split(" ");
      int v1 = Integer.parseInt(parts[0]);
      int v2 = Integer.parseInt(parts[1]);
      int wt = Integer.parseInt(parts[2]);
      graph[v1].add(new Edge(v1, v2, wt));
      graph[v2].add(new Edge(v2, v1, wt));
    }

    HashMap< Integer, Integer> visited = new HashMap<>();
    for (int v = 0; v < vtces; v++) {
      if (!visited.containsKey(v)) {
        boolean bip = IsBipartite(graph, v, visited);
        if (!bip) {
          System.out.println(false);
          return;
        }
      }
    }

    System.out.println(true);
  }

  static class Pair {
    int vtx;
    int level;

    Pair(int vtx, int level) {
      this.vtx = vtx;
      this.level = level;
    }
  }

  public static boolean IsBipartite(ArrayList< Edge>[] graph,
                                    int src, HashMap< Integer, Integer> visited) {
    ArrayDeque< Pair> queue = new ArrayDeque<>();
    queue.add(new Pair(src, 0));
    while (queue.size() > 0) {
      Pair rem = queue.remove();

      if (visited.containsKey(rem.vtx)) {
        if (visited.get(rem.vtx) % 2 != rem.level % 2) {
          return false;
        }
      } else {
        visited.put(rem.vtx, rem.level);
      }

      for (Edge e : graph[rem.vtx]) {
        if (!visited.containsKey(e.nbr)) {
          queue.add(new Pair(e.nbr, rem.level + 1));
        }
      }
    }

    return true;
  }

}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Spread of Infection</span>
import java.io.*;

import java.util.*;

public class Main {
  static class Edge {
    int src;
    int nbr;

    Edge(int src, int nbr) {
      this.src = src;
      this.nbr = nbr;
    }
  }

  public static void main(String[] args) throws Exception {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

    int vtces = Integer.parseInt(br.readLine());
    ArrayList[] graph = new ArrayList[vtces];
    for (int i = 0; i < vtces; i++) {
      graph[i] = new ArrayList<>();
    }

    int edges = Integer.parseInt(br.readLine());
    for (int i = 0; i < edges; i++) {
      String[] parts = br.readLine().split(" ");
      int v1 = Integer.parseInt(parts[0]);
      int v2 = Integer.parseInt(parts[1]);
      graph[v1].add(new Edge(v1, v2));
      graph[v2].add(new Edge(v2, v1));
    }

    int src = Integer.parseInt(br.readLine());
    int t = Integer.parseInt(br.readLine());
    int count = 0;

    ArrayDeque queue = new ArrayDeque<>();
    queue.add(new Pair(src, 1));
    int[] visited = new int[vtces];
    while (queue.size() > 0) {
      Pair rem = queue.remove();

      if (visited[rem.v] > 0) {
        continue;
      }
      visited[rem.v] = rem.time;
      if (rem.time > t) {
        break;
      } else {
        count++;
      }

      for (Edge e : graph[rem.v]) {
        if (visited[e.nbr] == 0) {
          queue.add(new Pair(e.nbr, rem.time + 1));
        }
      }
    }

    System.out.println(count);
  }

  static class Pair {
    int v;
    int time;

    Pair(int v, int time) {
      this.v = v;
      this.time = time;
    }
  }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Shortest path in weights</span>
import java.io.*;

import java.util.*;

public class Main {
  static class Edge {
    int src;
    int nbr;
    int wt;

    Edge(int src, int nbr, int wt) {
      this.src = src;
      this.nbr = nbr;
      this.wt = wt;
    }
  }

  public static void main(String[] args) throws Exception {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

    int vtces = Integer.parseInt(br.readLine());
    ArrayList< Edge>[] graph = new ArrayList[vtces];
    for (int i = 0; i < vtces; i++) {
      graph[i] = new ArrayList<>();
    }

    int edges = Integer.parseInt(br.readLine());
    for (int i = 0; i < edges; i++) {
      String[] parts = br.readLine().split(" ");
      int v1 = Integer.parseInt(parts[0]);
      int v2 = Integer.parseInt(parts[1]);
      int wt = Integer.parseInt(parts[2]);
      graph[v1].add(new Edge(v1, v2, wt));
      graph[v2].add(new Edge(v2, v1, wt));
    }

    int src = Integer.parseInt(br.readLine());
    boolean[] visited = new boolean[vtces];

    PriorityQueue< Pair> queue = new PriorityQueue<>();
    queue.add(new Pair(src, src + "", 0));

    while (queue.size() > 0) {
      Pair rem = queue.remove();

      if (visited[rem.v] == true) {
        continue;
      }
      visited[rem.v] = true;
      System.out.println(rem.v + " via " + rem.psf
                         + " @ " + rem.wsf);

      for (Edge e : graph[rem.v]) {
        if (visited[e.nbr] == false) {
          queue.add(new Pair(e.nbr,
                             rem.psf + e.nbr, rem.wsf + e.wt));
        }
      }
    }
  }

  static class Pair implements Comparable< Pair> {
    int v;
    String psf;
    int wsf;

    Pair(int v, String psf, int wsf) {
      this.v = v;
      this.psf = psf;
      this.wsf = wsf;
    }

    public int compareTo(Pair o) {
      return this.wsf - o.wsf;
    }
  }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Min. wire required to connect all pcs</span>
import java.io.*;

import java.util.*;

public class Main {
  static class Edge {
    int src;
    int nbr;
    int wt;

    Edge(int src, int nbr, int wt) {
      this.src = src;
      this.nbr = nbr;
      this.wt = wt;
    }
  }

  public static void main(String[] args) throws Exception {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

    int vtces = Integer.parseInt(br.readLine());
    ArrayList< Edge>[] graph = new ArrayList[vtces];
    for (int i = 0; i < vtces; i++) {
      graph[i] = new ArrayList<>();
    }

    int edges = Integer.parseInt(br.readLine());
    for (int i = 0; i < edges; i++) {
      String[] parts = br.readLine().split(" ");
      int v1 = Integer.parseInt(parts[0]);
      int v2 = Integer.parseInt(parts[1]);
      int wt = Integer.parseInt(parts[2]);
      graph[v1].add(new Edge(v1, v2, wt));
      graph[v2].add(new Edge(v2, v1, wt));
    }

    int src = 0;
    PriorityQueue< Pair> queue = new PriorityQueue<>();
    queue.add(new Pair(src, -1, 0));
    Integer[] visited = new Integer[vtces];
    while (queue.size() > 0) {
      Pair rem = queue.remove();

      if (visited[rem.v] != null) {
        continue;
      }
      visited[rem.v] = rem.p;
      if (rem.p != -1) {
        System.out.println("[" + rem.v + "-" +
                           rem.p + "@" + rem.wt + "]");
      }

      for (Edge e : graph[rem.v]) {
        if (visited[e.nbr] == null) {
          queue.add(new Pair(e.nbr, rem.v, e.wt));
        }
      }
    }
  }

  static class Pair implements Comparable< Pair> {
    Integer v;
    Integer p;
    int wt;

    Pair(Integer v, Integer p, int wt) {
      this.v = v;
      this.p = p;
      this.wt = wt;
    }

    public int compareTo(Pair o) {
      return this.wt - o.wt;
    }
  }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Order of Compilation</span>
import java.io.*;

import java.util.*;

public class Main {
  static class Edge {
    int src;
    int nbr;

    Edge(int src, int nbr) {
      this.src = src;
      this.nbr = nbr;
    }
  }

  public static void main(String[] args) throws Exception {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

    int vtces = Integer.parseInt(br.readLine());
    ArrayList< Edge>[] graph = new ArrayList[vtces];
    for (int i = 0; i < vtces; i++) {
      graph[i] = new ArrayList<>();
    }

    int edges = Integer.parseInt(br.readLine());
    for (int i = 0; i < edges; i++) {
      String[] parts = br.readLine().split(" ");
      int v1 = Integer.parseInt(parts[0]);
      int v2 = Integer.parseInt(parts[1]);
      graph[v1].add(new Edge(v1, v2));
    }

    boolean[] visited = new boolean[vtces];
    Stack< Integer> st = new Stack<>();
    for (int v = 0; v < vtces; v++) {
      if (visited[v] == false) {
        topological(graph, v, visited, st);
      }
    }

    while (st.size() > 0) {
      System.out.println(st.pop());
    }
  }

  public static void topological(ArrayList< Edge>[] graph,
                                 int src, boolean[] visited, Stack< Integer> st) {
    visited[src] = true;
    for (Edge e : graph[src]) {
      if (!visited[e.nbr]) {
        topological(graph, e.nbr, visited, st);
      }
    }
    st.push(src);
  }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Iterative Depth First Traversal</span>
import java.io.*;

import java.util.*;

public class Main {
  static class Edge {
    int src;
    int nbr;

    Edge(int src, int nbr) {
      this.src = src;
      this.nbr = nbr;
    }
  }

  public static void main(String[] args) throws Exception {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

    int vtces = Integer.parseInt(br.readLine());
    ArrayList< Edge>[] graph = new ArrayList[vtces];
    for (int i = 0; i < vtces; i++) {
      graph[i] = new ArrayList<>();
    }

    int edges = Integer.parseInt(br.readLine());
    for (int i = 0; i < edges; i++) {
      String[] parts = br.readLine().split(" ");
      int v1 = Integer.parseInt(parts[0]);
      int v2 = Integer.parseInt(parts[1]);
      graph[v1].add(new Edge(v1, v2));
      graph[v2].add(new Edge(v2, v1));
    }

    int src = Integer.parseInt(br.readLine());

    Stack< Pair> stack = new Stack<>();
    stack.push(new Pair(src, src + ""));
    boolean[] visited = new boolean[vtces];
    while (stack.size() > 0) {
      Pair rem = stack.pop();

      if (visited[rem.v] == true) {
        continue;
      }
      visited[rem.v] = true;
      System.out.println(rem.v + "@" + rem.psf);

      for (Edge e : graph[rem.v]) {
        if (visited[e.nbr] == false) {
          stack.push(new Pair(e.nbr, rem.psf + e.nbr));
        }
      }
    }
  }

  static class Pair {
    int v;
    String psf;

    Pair(int v, String psf) {
      this.v = v;
      this.psf = psf;
    }
  }
}
</div>
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">PEPCODE----LEVEL--1----END</span>								
<span class="textStyle">PEPCODE----LEVEL--1----END</span>								
<span class="textStyle">PEPCODE----LEVEL--1----END</span>								
<span class="textStyle">PEPCODE----LEVEL--1----END</span>								
<span class="textStyle">PEPCODE----LEVEL--1----END</span>								
<span class="textStyle">PEPCODE----LEVEL--2---------Hard level start</span>
<span class="textStyle">PEPCODE----LEVEL--2---------HARD LEVEL START</span>
<span class="textStyle">PEPCODE----LEVEL--2---------hard level start</span>
<span class="textStyle">PEPCODE----LEVEL--2---------Hard level start</span>
<span class="textStyle">PEPCODE----LEVEL--2---------HARD LEVEL START</span>
<span class="textStyle">PEPCODE----LEVEL--2---------hard level start</span> 
<span class="textStyle">PEPCODE----LEVEL--2---------Hard level start</span>
<span class="textStyle">PEPCODE----LEVEL--2---------HARD LEVEL START</span>
<span class="textStyle">PEPCODE----LEVEL--2---------hard level start</span> 
<span class="textStyle">PEPCODE----LEVEL--2---------Hard level start</span>
<span class="textStyle">PEPCODE----LEVEL--2---------HARD LEVEL START</span>
<span class="textStyle">PEPCODE----LEVEL--2---------hard level start</span> 											
<span id="line">-----------------------------------------------------------------------------------------------------</span>

<div id="hh"> 
<span class="textStyle">Permutations - 1</span>
import java.util.*;


public class Main {

  public static void permutations(int[] boxes, int ci, int ti) {
    if (ci > ti) {
      for (int i = 0; i < boxes.length; i++) {
        System.out.print(boxes[i]);
      }
      System.out.println();
      return;
    }
    for (int i = 0; i < boxes.length; i++) {
      if (boxes[i] == 0) {
        boxes[i] = ci;
        permutations(boxes, ci + 1, ti);
        boxes[i] = 0;
      }
    }
  }

  public static void main(String[] args) throws Exception {
    BufferedReader br = new
    BufferedReader(new InputStreamReader(System.in));
    int nboxes = Integer.parseInt(br.readLine());
    int ritems = Integer.parseInt(br.readLine());
    permutations(new int[nboxes], 1, ritems);
  }

}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">permutations - 2</span>
import java.io.*;

import java.util.*;

public class Main {

  public static void permutations(int cb, int tb, int[] items, int ssf, int ts, String asf) {
    if (cb > tb) {
      if (ssf == ts) {
        System.out.println(asf);
      }
      return;
    }


    for (int i = 0; i < items.length; i++) {
      if (items[i] == 0) {
        items[i] = cb;
        permutations(cb + 1, tb, items, ssf + 1, ts, asf + (i + 1));
        items[i] = 0;
      }
    }
    permutations(cb + 1, tb, items, ssf, ts, asf + 0);
  }

  public static void main(String[] args) throws Exception {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    int nboxes = Integer.parseInt(br.readLine());
    int ritems = Integer.parseInt(br.readLine());
    permutations(1, nboxes, new int[ritems], 0, ritems, "");
  }

}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Combinations - 1</span>
import java.io.*;

import java.util.*;

public class Main {

  public static void combinations(int cb, int tb, int ssf, int ts, String asf) {
    if (cb > tb) {
      if (ssf == ts) {
        System.out.println(asf);
      }
      return;
    }

    combinations(cb + 1, tb, ssf + 1, ts, asf + "i");
    combinations(cb + 1, tb, ssf + 0, ts, asf + "-");
  }

  public static void main(String[] args) throws Exception {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    int nboxes = Integer.parseInt(br.readLine());
    int ritems = Integer.parseInt(br.readLine());
    combinations(1, nboxes, 0, ritems, "");
  }

}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Combinations - 2</span>
import java.io.*;

import java.util.*;

public class Main {

  public static void combinations(int[] boxes, int ci, int ti, int lb) {
    if (ci > ti) {
      for (int i = 0; i < boxes.length; i++) {
        System.out.print(boxes[i] == 0 ? "-" : "i");
      }
      System.out.println();
      return;
    }
    for (int b = lb + 1; b < boxes.length; b++) {
      if (boxes[b] == 0) {
        boxes[b] = ci;
        combinations(boxes, ci + 1, ti, b);
        boxes[b] = 0;
      }
    }
  }

  public static void main(String[] args) throws Exception {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    int nboxes = Integer.parseInt(br.readLine());
    int ritems = Integer.parseInt(br.readLine());
    combinations(new int[nboxes], 1, ritems, -1);
  }

}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Queens Permutations - 2d As 2d - Queen Chooses</span>
import java.io.*;

import java.util.*;

public class Main {

  public static void queensPermutations(int qpsf, int tq, int[][] chess) {
    if (qpsf == tq) {
      for (int row = 0; row < chess.length; row++) {
        for (int col = 0; col < chess.length; col++) {
          System.out.print(chess[row][col] != 0
                           ? "q" + chess[row][col] + "	" : "-	");
        }
        System.out.println();
      }
      System.out.println();
      return;
    }

    for (int row = 0; row < chess.length; row++) {
      for (int col = 0; col < chess.length; col++) {
        if (chess[row][col] == 0) {
          chess[row][col] = qpsf + 1;
          queensPermutations(qpsf + 1, tq, chess);
          chess[row][col] = 0;
        }
      }
    }
  }
  public static void main(String[] args) throws Exception {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    int n = Integer.parseInt(br.readLine());
    int[][] chess = new int[n][n];

    queensPermutations(0, n, chess);
  }
}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Queens Combinations - 2d As 2d - Queen Chooses</span>
import java.io.*;

import java.util.*;

public class Main {

  public static void queensCombinations(int qpsf, int tq, boolean[][] chess, int i, int j) {
    if (qpsf == tq) {
      for (int row = 0; row < chess.length; row++) {
        for (int col = 0; col < chess.length; col++) {
          System.out.print(chess[row][col] ? "q	" : "-	");
        }
        System.out.println();
      }
      System.out.println();
      return;
    }

    for (int row = i; row < chess.length; row++) {
      for (int col = (row == i ? j + 1 : 0);
           col < chess.length; col++) {
        if (chess[row][col] == false) {
          chess[row][col] = true;
          queensCombinations(qpsf + 1, tq, chess, row, col);
          chess[row][col] = false;
        }
      }
    }
  }
  public static void main(String[] args) throws Exception {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    int n = Integer.parseInt(br.readLine());
    boolean[][] chess = new boolean[n][n];

    queensCombinations(0, n, chess, 0, -1);
  }
}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Queens Permutations - 2d As 2d - Queen Chooses</span>
import java.io.*;

import java.util.*;

public class Main {

  public static void queensPermutations(int qpsf, int tq, int[][] chess) {
    if (qpsf == tq) {
      for (int row = 0; row < chess.length; row++) {
        for (int col = 0; col < chess.length; col++) {
          System.out.print(chess[row][col] != 0
                           ? "q" + chess[row][col] + "	" : "-	");
        }
        System.out.println();
      }
      System.out.println();
      return;
    }

    for (int row = 0; row < chess.length; row++) {
      for (int col = 0; col < chess.length; col++) {
        if (chess[row][col] == 0) {
          chess[row][col] = qpsf + 1;
          queensPermutations(qpsf + 1, tq, chess);
          chess[row][col] = 0;
        }
      }
    }
  }
  public static void main(String[] args) throws Exception {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    int n = Integer.parseInt(br.readLine());
    int[][] chess = new int[n][n];

    queensPermutations(0, n, chess);
  }
}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Queens Combinations - 2d As 2d - Box Chooses</span>
import java.io.*;

import java.util.*;

public class Main {

  public static void queensCombinations(int qpsf,
                                        int tq, int row, int col, String asf) {
    if (row == tq) {
      if (qpsf == tq) {
        System.out.println(asf);
      }
      return;
    }
    queensCombinations(qpsf + 1, tq,
                       col == tq - 1 ? row + 1 : row,
                       col == tq - 1 ? 0 : col + 1,
                       col == tq - 1 ? asf + "q
                       ": asf + "q");
                       queensCombinations(qpsf + 0, tq,
                                          col == tq - 1 ? row + 1 : row,
                                          col == tq - 1 ? 0 : col + 1,
                                          col == tq - 1 ? asf + "-
                                          ": asf + " - ");
  }
  public static void main(String[] args) throws Exception {
    BufferedReader br = new
    BufferedReader(new InputStreamReader(System.in));
    int n = Integer.parseInt(br.readLine());

    queensCombinations(0, n, 0, 0, "");
  }
}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Queens Combinations - 2d As 1d - Queen Chooses</span>
import java.io.*;

import java.util.*;

public class Main {

  public static void queensCombinations(int qpsf, int tq, boolean[][] chess, int lcno) {
    if (qpsf == tq) {
      for (int row = 0; row < chess.length; row++) {
        for (int col = 0; col < chess.length; col++) {
          System.out.print(chess[row][col] ? "q	" : "-	");
        }
        System.out.println();
      }
      System.out.println();
      return;
    }

    for (int i = lcno + 1; i < chess.length * chess.length; i++) {
      int row = i / chess.length;
      int col = i % chess.length;

      if (chess[row][col] == false) {
        chess[row][col] = true;
        queensCombinations(qpsf + 1, tq,
                           chess, row * chess.length + col);
        chess[row][col] = false;
      }
    }
  }

  public static void main(String[] args) throws Exception {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    int n = Integer.parseInt(br.readLine());
    boolean[][] chess = new boolean[n][n];

    queensCombinations(0, n, chess, -1);
  }
}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">NQueens Permutations - 2d As 1d - Queen Chooses</span>
import java.io.*;

import java.util.*;

public class Main {

  public static boolean IsQueenSafe(int[][] chess, int row, int col) {
    // vertical
    for (int i = row, j = col; i >= 0; i--) {
      if (chess[i][j] > 0) {
        return false;
      }
    }

    for (int i = row, j = col; i < chess.length; i++) {
      if (chess[i][j] > 0) {
        return false;
      }
    }

    // horizontal
    for (int i = row, j = col; j >= 0; j--) {
      if (chess[i][j] > 0) {
        return false;
      }
    }

    for (int i = row, j = col; j < chess.length; j++) {
      if (chess[i][j] > 0) {
        return false;
      }
    }

    // diagonal
    for (int i = row, j = col; i >= 0 && j >= 0; i--, j--) {
      if (chess[i][j] > 0) {
        return false;
      }
    }

    for (int i = row, j = col; i < chess.length && j < chess.length; i++, j++) {
      if (chess[i][j] > 0) {
        return false;
      }
    }

    // anti-diagonal
    for (int i = row, j = col; i >= 0 && j < chess.length; i--, j++) {
      if (chess[i][j] > 0) {
        return false;
      }
    }

    for (int i = row, j = col; i < chess.length && j >= 0; i++, j--) {
      if (chess[i][j] > 0) {
        return false;
      }
    }

    return true;
  }

  public static void nqueens(int qpsf, int tq, int[][] chess) {
    if (qpsf == tq) {
      for (int row = 0; row < chess.length; row++) {
        for (int col = 0; col < chess.length; col++) {
          System.out.print(chess[row][col] > 0
                           ? "q" + chess[row][col] + "	" : "-	");
        }
        System.out.println();
      }
      System.out.println();
      return;
    }

    for (int i = 0; i < chess.length * chess.length; i++) {
      int row = i / chess.length;
      int col = i % chess.length;

      if (chess[row][col] == 0 && IsQueenSafe(chess, row, col)) {
        chess[row][col] = qpsf + 1;
        nqueens(qpsf + 1, tq, chess);
        chess[row][col] = 0;
      }
    }
  }

  public static void main(String[] args) throws Exception {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    int n = Integer.parseInt(br.readLine());
    int[][] chess = new int[n][n];

    nqueens(0, n, chess);
  }
}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">NQueens Combinations - 2d As 1d - Queen Chooses</span>
import java.io.*;

import java.util.*;

public class Main {

  public static boolean IsQueenSafe(boolean[][] chess, int row, int col) {
    // vertical
    for (int i = row, j = col; i >= 0; i--) {
      if (chess[i][j]) {
        return false;
      }
    }
    // horizontal
    for (int i = row, j = col; j >= 0; j--) {
      if (chess[i][j]) {
        return false;
      }
    }
    // diagonal
    for (int i = row, j = col; i >= 0 && j >= 0; i--, j--) {
      if (chess[i][j]) {
        return false;
      }
    }
    // anti-diagonal
    for (int i = row, j = col; i >= 0 && j < chess.length; i--, j++) {
      if (chess[i][j]) {
        return false;
      }
    }

    return true;
  }

  public static void nqueens(int qpsf, int tq, boolean[][] chess, int lcno) {
    if (qpsf == tq) {
      for (int row = 0; row < chess.length; row++) {
        for (int col = 0; col < chess.length; col++) {
          System.out.print(chess[row][col] ? "q	" : "-	");
        }
        System.out.println();
      }
      System.out.println();
      return;
    }

    for (int i = lcno + 1; i < chess.length * chess.length; i++) {
      int row = i / chess.length;
      int col = i % chess.length;

      if (chess[row][col] == false
          && IsQueenSafe(chess, row, col)) {
        chess[row][col] = true;
        nqueens(qpsf + 1, tq, chess, row * chess.length + col);
        chess[row][col] = false;
      }
    }
  }

  public static void main(String[] args) throws Exception {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    int n = Integer.parseInt(br.readLine());
    boolean[][] chess = new boolean[n][n];

    nqueens(0, n, chess, -1);
  }
}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">N Queens - Branch and Bound</span>
import java.util.*;

import java.io.*;

import java.util.*;

public class Main {

  public static void solution(boolean[][] board, int row, boolean[] cols, boolean[] ndiag, boolean[] rdiag, String asf) {
    if (row == board.length) {
      System.out.println(asf + ".");
      return;
    }

    for (int col = 0; col < board.length; col++) {
      if (!cols[col] && !ndiag[row + col] && !rdiag[row - col + board.length - 1]) {
        board[row][col] = true;
        cols[col] = true;
        ndiag[row + col] = true;
        rdiag[row - col + board.length - 1] = true;
        solution(board, row + 1, cols, ndiag, rdiag, asf + row + "-" + col + ", ");
        board[row][col] = false;
        cols[col] = false;
        ndiag[row + col] = false;
        rdiag[row - col + board.length - 1] = false;
      }
    }
  }

  public static void main(String[] args) throws Exception {
    Scanner scn = new Scanner(System.in);
    int n = scn.nextInt();
    boolean[][] board = new boolean[n][n];
    boolean[] cols = new boolean[n];
    boolean[] ndiag = new boolean[2 * n - 1];
    boolean[] rdiag = new boolean[2 * n - 1];
    solution(board, 0, cols, ndiag, rdiag, "");
  }

}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">NKnight Combinations - 2d As 1d - Knight Chooses</span>
import java.io.*;

import java.util.*;

public class Main {

  public static boolean IsKnightSafe(boolean[][] chess, int i, int j) {
    if (i - 1 >= 0 && j - 2 >= 0 && chess[i - 1][j - 2]) {
      return false;
    }

    if (i - 2 >= 0 && j - 1 >= 0 && chess[i - 2][j - 1]) {
      return false;
    }

    if (i - 2 >= 0 && j + 1 < chess.length && chess[i - 2][j + 1]) {
      return false;
    }

    if (i - 1 >= 0 && j + 2 < chess.length && chess[i - 1][j + 2]) {
      return false;
    }

    return true;
  }

  public static void nknights(int kpsf, int tk,
                              boolean[][] chess, int lcno) {
    if (kpsf == tk) {
      for (int row = 0; row < chess.length; row++) {
        for (int col = 0; col < chess.length; col++) {
          System.out.print(chess[row][col] ? "k	" : "-	");
        }
        System.out.println();
      }
      System.out.println();
      return;
    }

    for (int i = lcno + 1; i < chess.length * chess.length; i++) {
      int row = i / chess.length;
      int col = i % chess.length;

      if (chess[row][col] == false
          && IsKnightSafe(chess, row, col)) {
        chess[row][col] = true;
        nknights(kpsf + 1, tk, chess, row * chess.length + col);
        chess[row][col] = false;
      }
    }
  }

  public static void main(String[] args) throws Exception {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    int n = Integer.parseInt(br.readLine());
    boolean[][] chess = new boolean[n][n];

    nknights(0, n, chess, -1);
  }
}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Permutations Words-1</span>
import java.io.*;

import java.util.*;

public class Main {

  public static void generateWords(int cs, int ts, HashMap< Character, Integer> fmap, String asf) {  //cs=current spot, ts=total spots, asf= answer so far

    if (cs > ts) { //1
      System.out.println(asf);
      return;
    }
    for (char ch : fmap.keySet()) { //2
      if (fmap.get(ch) > 0) { //3
        fmap.put(ch, fmap.get(ch) - 1);
        generateWords(cs + 1, ts, fmap, asf + ch); //4
        fmap.put(ch, fmap.get(ch) + 1); //5
      }
    }

  }

  public static void main(String[] args) throws Exception {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    String str = br.readLine();

    HashMap< Character, Integer> fmap = new HashMap< >();
    for (char ch : str.toCharArray()) {
      if (fmap.containsKey(ch)) {
        fmap.put(ch, fmap.get(ch) + 1);
      } else {
        fmap.put(ch, 1);
      }
    }

    generateWords(1, str.length(), fmap, "");
  }

}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Permutations-Words 2</span>
import java.io.*;

import java.util.*;

public class Main {

  public static void generateWords(int cc, String str, Character[] spots, HashMap< Character, Integer> lastOccurence) { //cc=current character

    if (cc == str.length()) { //1
      for (int i = 0; i < spots.length; i++) {
        System.out.print(spots[i]);
      }
      System.out.println();
      return;
    }
    char ch = str.charAt(cc); //2
    int lo = lastOccurence.get(ch);

    for (int i = lo + 1; i < spots.length; i++) { //3
      if (spots[i] == null) {
        spots[i] = ch; //4
        lastOccurence.put(ch, i);
        generateWords(cc + 1, str, spots, lastOccurence); //5
        lastOccurence.put(ch, -1); //6
        spots[i] = null;
      }
    }

  }

  public static void main(String[] args) throws Exception {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    String str = br.readLine();

    Character[] spots = new Character[str.length()];
    HashMap< Character, Integer> lastOccurence = new HashMap< >();
    for (char ch : str.toCharArray()) {
      lastOccurence.put(ch, -1);
    }

    generateWords(0, str, spots, lastOccurence);
  }

}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Words - K Selection - 1</span>
import java.io.*;

import java.util.*;

public class Main {

  public static void generateSelection(int i, String ustr, int ssf, int ts, String asf) {
    if (i == ustr.length()) {
      if (ssf == ts) {
        System.out.println(asf);
      }
      return;
    }

    char ch = ustr.charAt(i);
    generateSelection(i + 1, ustr, ssf + 1, ts, asf + ch);
    generateSelection(i + 1, ustr, ssf + 0, ts, asf + "");
  }

  public static void main(String[] args) throws Exception {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    String str = br.readLine();
    int k = Integer.parseInt(br.readLine());

    HashSet< Character> unique = new HashSet< >();
    String ustr = "";
    for (char ch : str.toCharArray()) {
      if (unique.contains(ch) == false) {
        unique.add(ch);
        ustr += ch;
      }
    }

    generateSelection(0, ustr, 0, k, "");
  }

}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Words - K Selection - 2</span>
import java.io.*;

import java.util.*;

public class Main {

  public static void generateSelection(String ustr, int cs, int ts, int lc, String asf) {
    if (cs > ts) {
      System.out.println(asf);
      return;
    }

    for (int i = lc + 1; i < ustr.length(); i++) {
      generateSelection(ustr, cs + 1, ts, i, asf +
                        ustr.charAt(i));
    }
  } public static void main(String[] args) throws Exception { BufferedReader
    br = new BufferedReader(new InputStreamReader(System.in));
    String str = br.readLine();
    int
    k = Integer.parseInt(br.readLine());
    HashSet unique = new HashSet<>();
    String ustr = "";
    for (char ch : str.toCharArray()) {
      if (unique.contains(ch) == false) {
        unique.add(ch);
        ustr += ch;
      }
    }

    generateSelection(ustr, 1, k, -1, "");
  }
}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Words - K Selection - 3</span>
import java.io.*;

import java.util.*;

public class Main {

  public static void generateSelection(int cc, String ustr, int ssf, int ts, HashMap< Character, Integer> unique, String asf) {
    if (cc == ustr.length()) {
      if (ssf == ts) {
        System.out.println(asf);
      }
      return;
    }

    char ch = ustr.charAt(cc);
    for (int i = unique.get(ch); i > 0; i--) {
      char[] fasf = new char[i];
      Arrays.fill(fasf, ch);
      generateSelection(cc + 1, ustr, ssf + i, ts, unique, asf + new String(fasf));
    }
    generateSelection(cc + 1, ustr, ssf + 0, ts, unique, asf);
  }

  public static void main(String[] args) throws Exception {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    String str = br.readLine();
    int k = Integer.parseInt(br.readLine());

    HashMap< Character, Integer> unique = new HashMap< >();
    String ustr = "";
    for (char ch : str.toCharArray()) {
      if (unique.containsKey(ch) == false) {
        unique.put(ch, 1);
        ustr += ch;
      } else {
        unique.put(ch, unique.get(ch) + 1);
      }
    }

    generateSelection(0, ustr, 0, k, unique, "");
  }

}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Words - K Selection - 4</span>
import java.io.*;

import java.util.*;

public class Main {

  public static void generateSelection(int cs, int ts, String ustr, HashMap< Character, Integer> unique, int ls, String asf) {
    if (cs > ts) {
      System.out.println(asf);
      return;
    }

    for (int i = ls; i < ustr.length(); i++) {
      char ch = ustr.charAt(i);

      if (unique.get(ch) > 0) {
        unique.put(ch, unique.get(ch) - 1);
        generateSelection(cs + 1, ts, ustr, unique, i, asf + ch);
        unique.put(ch, unique.get(ch) + 1);
      }
    }
  }

  public static void main(String[] args) throws Exception {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    String str = br.readLine();
    int k = Integer.parseInt(br.readLine());

    HashMap< Character, Integer> unique = new HashMap< >();
    String ustr = "";
    for (char ch : str.toCharArray()) {
      if (unique.containsKey(ch) == false) {
        unique.put(ch, 1);
        ustr += ch;
      } else {
        unique.put(ch, unique.get(ch) + 1);
      }
    }

    generateSelection(1, k, ustr, unique, 0, "");
  }

}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Words-K Length Words-1</span>
import java.io.*;

import java.util.*;

public class Main {

  public static void generateWords(int cc, String ustr, int ssf, int ts, Character[] spots) {
    if (cc == ustr.length()) {
      if (ssf == ts) {
        for (int i = 0; i < spots.length; i++) {
          System.out.print(spots[i]);
        }
        System.out.println();
      }
      return;
    }

    char ch = ustr.charAt(cc);
    for (int i = 0; i < spots.length; i++) {
      if (spots[i] == null) {
        spots[i] = ch;
        generateWords(cc + 1, ustr, ssf + 1, ts, spots);
        spots[i] = null;
      }
    }
    generateWords(cc + 1, ustr, ssf + 0, ts, spots);
  }

  public static void main(String[] args) throws Exception {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    String str = br.readLine();
    int k = Integer.parseInt(br.readLine());

    HashSet< Character> unique = new HashSet< >();
    String ustr = "";
    for (char ch : str.toCharArray()) {
      if (unique.contains(ch) == false) {
        unique.add(ch);
        ustr += ch;
      }
    }

    Character[] spots = new Character[k];
    generateWords(0, ustr, 0, k, spots);
  }

}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Words-K Length Words-2</span>
import java.io.*;

import java.util.*;

public class Main {

  public static void generateWords(int cs, int ts, String ustr, HashSet< Character> used, String asf) {
    if (cs > ts) {
      System.out.println(asf);
      return;
    }

    for (int i = 0; i < ustr.length(); i++) {
      char ch = ustr.charAt(i);

      if (used.contains(ch) == false) {
        used.add(ch);
        generateWords(cs + 1, ts, ustr, used, asf + ustr.charAt(i));
        used.remove(ch);
      }
    }
  }

  public static void main(String[] args) throws Exception {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    String str = br.readLine();
    int k = Integer.parseInt(br.readLine());

    HashSet< Character> unique = new HashSet< >();
    String ustr = "";
    for (char ch : str.toCharArray()) {
      if (unique.contains(ch) == false) {
        unique.add(ch);
        ustr += ch;
      }
    }

    generateWords(1, k, ustr, new HashSet< >(), "");
  }

}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">K Length Words-3</span>
import java.io.*;

import java.util.*;

public class Main {

  public static void generateWords(int cc, String str, int ssf, int ts, Character[] spots,
                                   HashMap< Character, Integer> lastOccurence) {
    if (cc == str.length()) {
      if (ssf == ts) {
        for (char ch : spots) {
          System.out.print(ch);
        }
        System.out.println();
      }
      return;
    }

    char ch = str.charAt(cc);
    int lo = lastOccurence.get(ch);
    for (int i = lo + 1; i < spots.length; i++) {
      if (spots[i] == null) {
        spots[i] = ch;
        lastOccurence.put(ch, i);
        generateWords(cc + 1, str, ssf + 1, ts, spots, lastOccurence);
        lastOccurence.put(ch, lo);
        spots[i] = null;
      }
    }
    if (lastOccurence.get(ch) == -1) {
      generateWords(cc + 1, str, ssf + 0, ts, spots, lastOccurence);
    }
  }

  public static void main(String[] args) throws Exception {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    String str = br.readLine();
    int k = Integer.parseInt(br.readLine());

    Character[] spots = new Character[k];
    HashMap< Character, Integer> lastOccurence = new HashMap<>();
    for (char ch : str.toCharArray()) {
      lastOccurence.put(ch, -1);
    }

    generateWords(0, str, 0, k, spots, lastOccurence);
  }

}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">K-Length Words-4</span>
import java.io.*;

import java.util.*;

public class Main {

  public static void generateWords(int cs, int ts, String ustr, HashMap< Character, Integer> unique, String asf) {
    if (cs > ts) {
      System.out.println(asf);
      return;
    }

    for (int i = 0; i < ustr.length(); i++) {
      char ch = ustr.charAt(i);

      if (unique.get(ch) > 0) {
        unique.put(ch, unique.get(ch) - 1);
        generateWords(cs + 1, ts, ustr, unique, asf + ch);
        unique.put(ch, unique.get(ch) + 1);
      }
    }
  }

  public static void main(String[] args) throws Exception {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    String str = br.readLine();
    int k = Integer.parseInt(br.readLine());

    HashMap< Character, Integer> unique = new HashMap< >();
    String ustr = "";
    for (char ch : str.toCharArray()) {
      if (unique.containsKey(ch) == false) {
        unique.put(ch, 1);
        ustr += ch;
      } else {
        unique.put(ch, unique.get(ch) + 1);
      }
    }

    generateWords(1, k, ustr, unique, "");
  }

}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Coin Change Combinations-1</span>
import java.io.*;

import java.util.*;
public class Main {
  public static void coinChange(int i, int[] coins, int amtsf, int tamt, String
                                asf) { //amtsf=amount so far, tamt=total amount, asf=answer so far

    if (i == coins.length) { //1
      if (amtsf == tamt) {
        System.out.println(asf + ".");
      }
      return;
    }

    coinChange(i + 1, coins, amtsf + coins[i], tamt, asf + coins[i] + "-"); //2
    coinChange(i + 1, coins, amtsf + 0, tamt, asf); //3
  }
  public static void main(String[] args) throws Exception {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    int n = Integer.parseInt(br.readLine());
    int[] coins = new int[n];
    for (int i = 0; i < n; i++) {
      coins[i] = Integer.parseInt(br.readLine());
    }
    int amt = Integer.parseInt(br.readLine());

    coinChange(0, coins, 0, amt, "");
  }
}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">COIN CHANGE COMBINATIONS-2</span>
import java.io.*;

import java.util.*;
public class Main {
  public static void coinChange(int i, int[] coins, int amtsf, int tamt, String
                                asf) {
    if (i == coins.length) { //1
      if (amtsf == tamt) {
        System.out.println(asf + ".");
      }
      return;
    }

    for (int j = tamt / coins[i]; j > = 1; j--) { //2
      String part = "";
      for (int k = 0; k < j; k++) { //3                 part+=coins[i]+"-";             }
        coinChange(i + 1, coins, amtsf + coins[i]*j, tamt, asf + part); //4         }
        coinChange(i + 1, coins, amtsf, tamt, asf); //5     }
        public static void main(String[] args) throws Exception {
          BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
          int n = Integer.parseInt(br.readLine());
          int[] coins = new int[n];
          for (int i = 0; i < n; i++) {
            coins[i] = Integer.parseInt(br.readLine());
          }
          int amt = Integer.parseInt(br.readLine());
          coinChange(0, coins, 0, amt, "");
        }
      }
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Coin Change Permutations-1</span>
import java.io.*;

import java.util.*;

public class Main {

  public static void coinChange(int[] coins, int amtsf, int tamt, String asf, boolean[] used) {  //amtsf= amount so far,tamt= total amount,asf=answer so far
    if (amtsf > tamt) { //1
      return;
    } else if (amtsf == tamt) {
      System.out.println(asf + ".");
      return;
    }
    for (int i = 0; i < coins.length; i++) { //2
      if (used[i] == false) {
        used[i] = true;
        coinChange(coins, amtsf + coins[i], tamt, asf + coins[i] + "-", used); //3
        used[i] = false; //4
      }
    }
  }
  public static void main(String[] args) throws Exception {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    int n = Integer.parseInt(br.readLine());
    int[] coins = new int[n];
    for (int i = 0; i < n; i++) {
      coins[i] = Integer.parseInt(br.readLine());
    }
    int amt = Integer.parseInt(br.readLine());
    boolean[] used = new boolean[coins.length];
    coinChange(coins, 0, amt, "", used);
  }
}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Coin Change Permutations-2</span>
import java.io.*;

import java.util.*;

public class Main {

  public static void coinChange(int[] coins, int amtsf, int tamt, String asf) {
    if (amtsf > tamt) { //1
      return;
    } else if (amtsf == tamt) {
      System.out.println(asf + ".");
      return;
    }
    for (int i = 0; i < coins.length; i++) { //2
      coinChange(coins, amtsf + coins[i], tamt, asf + coins[i] + "-");
    }
  }

  public static void main(String[] args) throws Exception {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    int n = Integer.parseInt(br.readLine());
    int[] coins = new int[n];
    for (int i = 0; i < div n; i++) {
      coins[i] = Integer.parseInt(br.readLine());
    }
    int amt = Integer.parseInt(br.readLine());
    coinChange(coins, 0, amt, "");
  }
}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Sudoku Solver</span>
import java.io.*;

import java.util.*;

public class Main {
  public static void display(int[][] board) {
    for (int i = 0; i < board.length; i++) {
      for (int j = 0; j < board[0].length; j++) {
        System.out.print(board[i][j] + " " );
      }
      System.out.println();
    }
  } public static void solveSudoku(int[][]
                                   board, int i, int j) {
    if (i == board.length) {
      display(board);
      return;
    }
    int ni = 0;
    int nj = 0;
    if (j == board[0].length - 1) {
      ni = i + 1;
      nj = 0;
    }
    else {
      ni = i;
      nj = j + 1;
    }
    if (board[i][j] != 0) {
      solveSudoku(board, ni, nj);
    }
    else {
      for (int val = 1; val <= 9; val++) {
        if (isValid(board, i, j, val)) {
          board[i][j] = val;
          solveSudoku(board, ni, nj);
          board[i][j] = 0;
        }
      }
    }
  } public static boolean
  isValid(int[][] board, int x, int y, int val) {
    int n = board.length;
    for (int i = 0; i < n; i++) {
      if
      (board[x][i] == val) {
        return false;
      }
    }
    for (int i = 0; i < n; i++) {
      if (board[i][y] == val) {
        return false;
      }
    }
    x = x / 3 * 3;
    y = y / 3 * 3;
    for (int i = 0; i < 3; i++) {
      for (int j = 0; j < 3; j++) {
        if (board[x + i][y
                         + j] == val) {
          return false;
        }
      }
    }
    return true;
  } public static void main(String[] args) throws Exception
  { Scanner scn = new Scanner(System.in);
    int[][] arr = new int[9][9];
    for (int i = 0; i < 9; i++) {
      for (int
           j = 0; j < 9; j++) {
        arr[i][j] = scn.nextInt();
      }
    }
    solveSudoku(arr, 0, 0);
  }
}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Crossword Puzzle</span>
import java.io.*;
import java.util.*;

public class Main {
	public static void main(String[] args) {
		Scanner scn = new Scanner(System.in);
		char[][] arr = new char[10][10];
		for(int i = 0 ; i < arr.length; i++){
			String str = scn.next();
			arr[i] = str.toCharArray();
		}
		int n = scn.nextInt();
		String[] words = new String[n];
		for(int i = 0 ; i  < words.length; i++){
			words[i] = scn.next();
		}
		solution(arr,words,0);

	}

	public static void solution(char[][] arr, String[] words, int vidx){
		if(vidx == words.length){
			print(arr);
			return;
		}
		for (int i = 0; i < 10; i++) {
			for (int j = 0; j < 10; j++) {
				String word = words[vidx];
				if(arr[i][j] == '-' || arr[i][j] == word.charAt(0)){
					if(canPlaceVertical(arr,word,i,j) == true){
						boolean[] visited = new boolean[word.length()];
						placeVertical(arr,word,i,j,visited);
						//call
						solution(arr,words,vidx + 1);
						unplaceVertical(arr,word,i,j,visited);
					}

					if(canPlaceHorizontal(arr,word,i,j) == true){
						boolean[] visited = new boolean[word.length()];
						placeHorizontal(arr,word,i,j,visited);
						//call
						solution(arr,words,vidx + 1);
						unplaceHorizontal(arr,word,i,j,visited);
					}
				}
			}
		}
	}

	public static boolean canPlaceVertical(char[][] arr, String word, int r, int c){
		int i = 0 ;
		for(; i < word.length(); i++){
			if(r + i >= arr.length){
				return false;
			}
			if(arr[r + i][c] == '-' || arr[r + i][c] == word.charAt(i)){
				continue;
			}else{
				return false;
			}
		}
		
		if(r + i == arr.length || arr[r + i][c] == '+') {
			return true;
		}else {
			return false;
		}
	}

	public static boolean canPlaceHorizontal(char[][] arr, String word, int r, int c){
		int i = 0;
		for(; i < word.length(); i++){
			if(c + i >= arr.length){
				return false;
			}
			if(arr[r][c + i] == '-' || arr[r][c + i] == word.charAt(i)){
				continue;
			}else{
				return false;
			}
		}
		if(c + i == arr.length || arr[r][c + i] == '+') {
			return true;
		}else {
			return false;
		}
	}

	public static void placeVertical(char[][] arr, String word, int r, int c,boolean[] visited){
		for(int i = 0 ; i < word.length(); i++){
			if(arr[r + i][c] == '-'){
				visited[i] = true;
			}
			arr[r + i][c] = word.charAt(i);
		}
	}

	public static void unplaceVertical(char[][] arr, String word, int r, int c, boolean[] visited){
		for(int i = 0 ; i < word.length(); i++){
			if(visited[i] == true){
				arr[r + i][c] = '-';	
			}
		}
	}

	public static void placeHorizontal(char[][] arr, String word, int r, int c,boolean[] visited){
		for(int i = 0 ; i < word.length(); i++){
			if (arr[r][c + i] == '-') {
				visited[i] = true;
			}
			arr[r][c + i] = word.charAt(i);
		}
	}

	public static void unplaceHorizontal(char[][] arr, String word, int r, int c, boolean[] visited){
		for(int i = 0 ; i < word.length(); i++){
			if(visited[i] == true){
				arr[r][c + i] = '-';	
			}
		}
	}
	
	public static void print(char[][] arr){
		for(int i = 0 ; i < arr.length; i++){
			for(int j = 0 ; j < arr.length; j++){
				System.out.print(arr[i][j] +  "");
			}
			System.out.println();
		}
		
	}
}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Cryptarithmetic</span>
import java.io.*;
import java.util.*;

public class Main {

  public static void main(String[] args) {
    Scanner scn = new Scanner(System.in);
    String s1 = scn.nextLine();
    String s2 = scn.nextLine();
    String s3 = scn.nextLine();

    HashMap< Character, Integer> charIntMap = new HashMap<>();
    String unique = "";
    for (int i = 0; i < s1.length(); i++) {
      if (!charIntMap.containsKey(s1.charAt(i))) {
        charIntMap.put(s1.charAt(i), -1);
        unique += s1.charAt(i);
      }
    }

    for (int i = 0; i < s2.length(); i++) {
      if (!charIntMap.containsKey(s2.charAt(i))) {
        charIntMap.put(s2.charAt(i), -1);
        unique += s2.charAt(i);
      }
    }

    for (int i = 0; i < s3.length(); i++) {
      if (!charIntMap.containsKey(s3.charAt(i))) {
        charIntMap.put(s3.charAt(i), -1);
        unique += s3.charAt(i);
      }
    }

    boolean[] usedNumbers = new boolean[10];
    solution(unique, 0, charIntMap, usedNumbers, s1, s2, s3);
  }

  public static int getNum(String s, HashMap< Character, Integer> charIntMap){
	  String num = "";

	  for(int i = 0; i < s.length(); i++){
		  char ch = s.charAt(i);
		  num += charIntMap.get(ch);
	  }

	  return Integer.parseInt(num);
  }

  public static void solution(String unique, int idx, 
							  HashMap< Character, Integer> charIntMap, boolean[] usedNumbers, 
							  String s1, String s2, String s3) {
	    if(idx == unique.length()){
			int num1 = getNum(s1, charIntMap);
			int num2 = getNum(s2, charIntMap);
			int num3 = getNum(s3, charIntMap);

			if(num1 + num2 == num3){
				for(int i = 0; i < 26; i++){
					char ch = (char)('a' + i);
					if(charIntMap.containsKey(ch)){
						System.out.print(ch + "-" + charIntMap.get(ch) + " ");
					}
				}
				System.out.println();
			}

			return;
		}

		char ch = unique.charAt(idx);
		for(int num = 0; num <= 9; num++){
			if(usedNumbers[num] == false){
				usedNumbers[num] = true;
				charIntMap.put(ch, num);
				solution(unique, idx + 1, charIntMap, usedNumbers, s1, s2, s3);
				charIntMap.put(ch, -1);
				usedNumbers[num] = false;
			}
		}
  }

}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Gold Mine - 2</span>
import java.io.*;
import java.util.*;

public class Main {
  public static int getMaximumGold_(int[][] grid, int sr, int sc, int n, int m, int[][] dir) {

    grid[sr][sc] = -grid[sr][sc];

    int maxGold = 0;
    for (int d = 0; d < 4; d++) {
      int r = sr + dir[d][0];
      int c = sc + dir[d][1];

      if (r >= 0 && c >= 0 && r < n && c < m && grid[r][c] > 0) {
        maxGold = Math.max(maxGold, getMaximumGold_(grid, r, c, n, m, dir));
      }
    }

    grid[sr][sc] = -grid[sr][sc];
    return maxGold + grid[sr][sc];

  }


  public static int getMaxGold(int[][] grid) {
    if (grid.length == 0 || grid[0].length == 0) return 0;
    int n = grid.length;
    int m = grid[0].length;
    int[][] dir = {{1, 0}, {0, -1}, {0, 1}, {-1, 0}};

    int maxGold = 0;
    for (int i = 0; i < n; i++) {
      for (int j = 0; j < m; j++) {
        if (grid[i][j] != 0) maxGold = Math.max(maxGold, getMaximumGold_(grid, i, j, n, m, dir));
      }
    }
    return maxGold;
  }


  public static void main(String[] args) {
    Scanner scn = new Scanner(System.in);
    int n = scn.nextInt();
    int m = scn.nextInt();
    int[][] arr = new int[m][n];
    for (int i = 0; i < arr.length; i++) {
      for (int j = 0 ; j  < arr[0].length; j++) {
        arr[i][j] = scn.nextInt();
      }
    }
    int max = getMaxGold(arr);
    System.out.println(max);
  }

}

<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Josephus Problem</span>
import java.io.*;
import java.util.*;

public class Main {

  public static void main(String[] args){
    Scanner scn = new Scanner(System.in);
    int n = scn.nextInt();
    int k = scn.nextInt();
    System.out.println(solution(n,k));
  }

  public static int solution(int n, int k){
    if(n == 1){
      return 0;
    }else{
      return (solution(n - 1, k) + k) % n;
    }
  }
  

}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Lexicographical Numbers</span>
import java.io.*;
import java.util.*;

public class Main {
	public static void main(String[] args) {
		Scanner scn = new Scanner(System.in);
		int n = scn.nextInt();
		for(int i = 1; i < 10;i++){
			dfs(i,n);
		}
	}
	
	public static void dfs(int cur, int n){
		if(cur > n){
			return;
		}
        else{
            System.out.println(cur);
            for(int i = 0;i < 10;i++){
                dfs(10 * cur + i, n);
            }
        }
    }
}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Friends Pairing - 2</span>
import java.io.*;
import java.util.*;

public class Main {
  static int counter = 1;

  public static void solution(int i, int n, boolean[] used, String asf) {
    if (i > n) {
      System.out.println(counter + "." + asf);
      counter++;
      return;
    }

    if (used[i]) {
      solution(i + 1, n, used, asf);
    } else {
      used[i] = true;
      solution(i + 1, n, used, asf + "(" + i + ") ");

      for (int j = i + 1; j <= n; j++) {
        if (used[j] == false) {
          used[j] = true;
          solution(i + 1, n, used, asf + "(" + i + "," + j + ") ");
          used[j] = false;
        }
	  }
	  
      used[i] = false;
    }
  }

  public static void main(String[] args) throws Exception {
    Scanner sc = new Scanner(System.in);
    int n = sc.nextInt();
    boolean[] used = new boolean[n + 1];
    solution(1, n, used, "");
  }
}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">K-partitions</span>
import java.io.*;
import java.util.*;

public class Main {

	public static void main(String[] args) {
		Scanner scn = new Scanner(System.in);
		int n = scn.nextInt();
		int k = scn.nextInt();
		ArrayList< ArrayList< Integer>> ans = new ArrayList<>();
		for(int i  = 0; i < k; i++) {
			ans.add(new ArrayList<>());
		}
		solution(1, n, k, 0, ans);

	}

	static int counter = 1;
	public static void solution(int i, int n, int k, int rssf, ArrayList< ArrayList< Integer>> ans) {
		if (i == n + 1) {
			if (rssf == k) {
				System.out.print(counter + ". ");
				counter++;
				for(ArrayList< Integer> a : ans) {
					System.out.print(a + " ");
				}
				System.out.println();
			}
			return;
		}

		for(int j = 0 ; j < ans.size(); j++) {
			if(ans.get(j).size() == 0) {
				ans.get(j).add(i);
				solution(i + 1,n,k,rssf + 1,ans);
				ans.get(j).remove(ans.get(j).size() - 1);
				break;
			}else {
				ans.get(j).add(i);
				solution(i + 1, n, k, rssf, ans);
				ans.get(j).remove(ans.get(j).size() - 1);
			}
		}
		
	}

}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">K Subsets With Equal Sum</span>
import java.io.*;
import java.util.*;

public class Main {

	public static void main(String[] args) {
		Scanner scn = new Scanner(System.in);
		int n = scn.nextInt();
		int[] arr = new int[n];
		int sum = 0;
		for(int i =  0 ; i < arr.length; i++) {
			arr[i] = scn.nextInt();
			sum += arr[i];
		}
		int k = scn.nextInt();
		// if k is equal to 1, then whole array is your answer 
		if(k == 0) {
			System.out.print("[");
			for(int i = 0 ; i  < arr.length; i++) {
				System.out.print(arr[i] + ", ");
			}
			System.out.println("]");
			return;
		}
		//if there are more subsets than no. of elements in array or sum of all elements is not divisible by k
		if(k > n || sum % k != 0) {
			System.out.println("-1");
			return;
		}
		int[] subsetSum = new int[k];
		ArrayList< ArrayList< Integer>> ans = new ArrayList<>();
		for(int i = 0; i < k; i++) {
			ans.add(new ArrayList<>());
		}
		solution(arr,0,n,k,subsetSum,0,ans);
	}
	
	public static void solution(int[] arr, int vidx,int n , int k,int[] subsetSum,int ssssf, ArrayList<ArrayList<Integer>> ans) {
		if(vidx == arr.length) {
			if(ssssf == k) {
				int isum = subsetSum[0];
				boolean flag = true;
				for(int i = 1  ;i  < subsetSum.length; i++) {
					if(subsetSum[i] == isum) {
						continue;
					}else {
						flag = false;
						break;
					}
				}
				if(flag == true) {
					for(ArrayList< Integer> a : ans) {
						System.out.print(a + " ");
					}
					System.out.println();
				}
			}
			return;
		}
		
		for(int j = 0 ; j < ans.size(); j++) {
			if(ans.get(j).size() == 0) {
				ans.get(j).add(arr[vidx]);
				subsetSum[j] += arr[vidx];
				solution(arr,vidx + 1,n,k,subsetSum,ssssf + 1,ans);
				ans.get(j).remove(ans.get(j).size() - 1);
				subsetSum[j] -= arr[vidx];
				break;
			}else {
				ans.get(j).add(arr[vidx]);
				subsetSum[j] += arr[vidx];
				solution(arr,vidx + 1,n,k,subsetSum,ssssf,ans);
				ans.get(j).remove(ans.get(j).size() - 1);
				subsetSum[j] -= arr[vidx];
			}
		}
	}

}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Abbreviations using Backtracking</span>
import java.io.*;

import java.util.*;

public class Main
{
  public static void solution(String str, String asf, int count, int pos) {
    if (pos == str.length()) {
      if (count > 0) {
        asf += count;
      }
      System.out.println(asf);
      return;
    }
    solution(str, asf + (count > 0 ? count : "" ) + str.charAt(pos), 0, pos + 1);
    solution(str, asf, count + 1, pos + 1);
  }

  public static void main(String[] args) {
    Scanner scn = new Scanner(System.in);
    String str = scn.nextLine();
    solution(str, "", 0, 0);
  }
}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Max Score</span>
import java.io.*;

import java.util.*;

public class Main {

  public static int solution(String[] words, int[] farr, int[] score, int idx) {

    if (idx == words.length)
    {
      return 0;
    }

    int sno = 0 + solution(words, farr, score, idx + 1); //score of the subset when the word is not included

    int sword = 0;
    String word = words[idx];
    boolean flag = true;

    for (int i = 0; i < word.length(); i++)
    {
      char ch = word.charAt(i);
      if (farr[ch - 'a'] == 0)
      {
        flag = false;
      }
      farr[ch - 'a']--;
      sword += score[ch - 'a'];
    }

    int syes = 0; //score of the subset when the word is included
    if (flag)
    {
      syes = sword + solution(words, farr, score, idx + 1);
    }

    for (int i = 0; i < word.length(); i++)
    {
      char ch = word.charAt(i);
      farr[ch - 'a']++;
    }

    return Math.max(syes, sno);
  }

  public static void main(String[] args) {

    Scanner scn = new Scanner(System.in);
    int nofWords = scn.nextInt();
    String[] words = new String[nofWords];
    for (int i = 0 ; i < words.length; i++) {
      words[i] = scn.next();
    }
    int nofLetters = scn.nextInt();
    char[] letters = new char[nofLetters];
    for (int i = 0; i < letters.length; i++) {
      letters[i] = scn.next().charAt(0);
    }
    int[] score = new int[26];
    for (int i = 0; i < score.length; i++) {
      score[i] = scn.nextInt();
    }
    if (words == null || words.length == 0 || letters == null || letters.length == 0 || score == null
        || score.length == 0) {
      System.out.println(0);
      return;
    }
    int[] farr = new int[score.length];
    for (char ch : letters) {
      farr[ch - 'a']++;
    }
    System.out.println(solution(words, farr, score, 0));

  }
}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Palindromic Partitions</span>
import java.io.*;

import java.util.*;

public class Main {

  public static void main(String[] args) {
    Scanner scn = new Scanner(System.in);
    String str = scn.nextLine();
    solution(str, "");
  }

  public static void solution(String str, String asf) {
    if (str.length() == 0) {
      System.out.println(asf);
      return;
    }
    for (int i = 0; i < str.length() ; i++) {
      String fh = str.substring(0, i + 1);
      String ros = str.substring(i + 1);
      if (isPalindrome(fh)) {
        solution(ros, asf + "(" + fh + ") ");
      }
    }
  }

  public static boolean isPalindrome(String str) {
    int i =  0, j = str.length() - 1;
    while (i < j) {
      char ith = str.charAt(i);
      char jth = str.charAt(j);
      if (ith != jth) {
        return false;
      }
      i++;
      j--;
    }
    return true;
  }

}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">All Palindromic Permutations</span>
import java.io.*;
import java.util.*;

public class Main {

	public static void main(String[] args) {
		Scanner scn = new Scanner(System.in);
		String str = scn.nextLine();
		HashMap< Character, Integer> fmap = new HashMap<>();
		for (int i = 0; i < str.length(); i++) {
			char ch = str.charAt(i);
			fmap.put(ch, fmap.getOrDefault(ch, 0) + 1);
		}
		int ofc = 0;
		Character oddchar = null;
		int length = 0;
		for (int i = 0; i < 26; i++) {
			char ch = (char) ('a' + i);
			if (fmap.containsKey(ch)) {
				int freq = fmap.get(ch);
				if (freq % 2 != 0) {
					oddchar = ch;
					ofc++;
				}
				if (ofc > 1) {
					System.out.println("-1");
					return;
				}
				fmap.put(ch, freq / 2);
				length += (freq / 2);
			}
		}
		generatepw(1, length, fmap, oddchar, "");

	}

	public static void generatepw(int cs, int ts, HashMap< Character, Integer> fmap, Character oddc, String asf) {
		if (cs == ts + 1) {
			System.out.println(asf + (oddc == null ? "" : oddc) + reverse(asf));
			return;
		}

		for (char ch : fmap.keySet()) {
			if (fmap.get(ch) > 0) {
				fmap.put(ch, fmap.get(ch) - 1);
				generatepw(cs + 1, ts, fmap,oddc, asf + ch);
				fmap.put(ch, fmap.get(ch) + 1);
			}
		}
	}
	
	public static String reverse(String str) {
		StringBuilder ans = new StringBuilder();
		for(int i = str.length() - 1; i >= 0 ; i--) {
			ans.append(str.charAt(i));
		}
		return ans.toString();
	}

}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Pattern Matching</span>
import java.io.*;
import java.util.*;

public class Main {

	public static void main(String[] args) {
		Scanner scn = new Scanner(System.in);
		String str = scn.next();
		String pattern = scn.next();
		HashMap< Character,String> map = new HashMap<>();
		solution(str,pattern,map,pattern);
	}

	public static void solution(String str, String pattern, HashMap< Character,String> map, String op){
		if(pattern.length() == 0){
			if(str.length() == 0){
				boolean[] arr = new boolean[26];
				for(int i = 0 ; i < op.length(); i++) {
					char ch = op.charAt(i);
					if(arr[ch - 'a'] == false) {
						arr[ch - 'a'] = true;
						System.out.print(ch + " -> " + map.get(ch) + ", ");
					}
				}
				System.out.println(".");
			}
			return;
		}

		char chp = pattern.charAt(0);
		String rop = pattern.substring(1);
		
		if(!map.containsKey(chp)){
			//if character is coming for the first time
			for(int i = 0 ; i < str.length(); i++){
				String fh = str.substring(0, i + 1);
				String ros = str.substring(i + 1);

				map.put(chp, fh);
				solution(ros,rop,map,op);
				map.remove(chp);
			}
		}else{
			//if character has already appeared 
			String prevmatching = map.get(chp);
			String nextsubstring = str.length() >= prevmatching.length() ? str.substring(0, prevmatching.length()) : "-1";
			if(prevmatching.equals(nextsubstring)){
				String ros = str.substring(prevmatching.length());
				solution(ros, rop, map,op);
			}
		}
	}

}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Word break-1</span>
import java.io.*;

import java.util.*;
public class Main {
  public static void main(String[] args) {
    Scanner scn = new Scanner(System.in);
    int n = scn.nextInt();
    HashSet< String> dict = new HashSet<>();
    for (int i = 0  ; i  < n; i++) {
      dict.add(scn.next());
    }
    String sentence = scn.next();
    wordBreak(sentence, "", dict);
  }
  public static void wordBreak(String str, String ans, HashSet< String>
                               dict) {
    if (str.length() == 0) {
      System.out.println(ans);
      return;
    }
    for (int i = 0; i < str.length(); i++) {
      String left = str.substring(0, i + 1);
      if (dict.contains(left)) {
        String right = str.substring(i + 1);
        wordBreak(right, ans + left + " ", dict);
      }
    }
  }

}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Remove Invalid Parentheses</span>
import java.io.*;

import java.util.*;
public class Main {

  public static void main(String[] args) {
    Scanner scn = new Scanner(System.in);
    String str = scn.next();
    solution(str, getMin(str), new HashSet<>());
  }

  public static void solution(String str, int minRemoval, HashSet ans) {
    if (IsValid(str) == true) {
      if (!ans.contains(str)) {
        System.out.println(str);
        ans.add(str);
      }
      return;
    }

    if (minRemoval == 0) {
      return;
    }

    for (int i = 0; i < str.length(); i++) {
      String left = str.substring(0, i);
      String
      right = str.substring(i + 1);
      solution(left + right, minRemoval - 1, ans);
    }
  }
  public static int getMin(String str) {
    Stack st = new Stack<>();
    for (int i = 0; i < str.length(); i++) {
      char ch = str.charAt(i);
      if (ch == '(' )
      {
        st.push(ch);
      }
      else {
        if (st.size() == 0 || st.peek() == ')' ) {
          st.push(ch);
        }
        else if (st.peek() == '(' ) {
          st.pop();
        }
      }
    }
    return
      st.size();
  } private static boolean IsValid(String str) {
    int count = 0;
    for (int i = 0 ; i < str.length(); i++) {
      char ch = str.charAt(i);
      if (ch == '('
         ) {
        count++;
      }
      else if (ch == ')' ) {
        count--;
        if (count < 0) {
          return false;
        }
      }
    }
    return count == 0;
  }
}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Tug Of War</span>
import java.io.*;

import java.util.*;
public class Main {
  public static void main(String[] args) {
    Scanner scn = new Scanner(System.in);
    int[] arr = new int[scn.nextInt()];
    for (int i = 0; i < arr.length; i++) {
      arr[i] = scn.nextInt();
    }
    solve(arr, 0, new ArrayList<>(), new ArrayList<>(), 0, 0);
    System.out.println(ans);
  }
  static int mindiff = Integer.MAX_VALUE; //mindiff= minimum difference
  static String ans = "";
  public static void solve(int[] arr, int vidx, ArrayList< Integer> set1, ArrayL
                           ist< Integer> set2, int soset1, int soset2) {

    if (vidx == arr.length) { //1
      int delta = Math.abs(soset1 - soset2);
      if (delta < mindiff) {
        mindiff = delta;
        ans = set1 + " " + set2;
      }
      return;
    }


    if (set1.size() < (arr.length + 1) / 2) { //2
      set1.add(arr[vidx]);
      solve(arr, vidx + 1, set1, set2, soset1 + arr[vidx], soset2);
      set1.remove(set1.size() - 1);
    }
    if (set2.size() < (arr.length + 1) / 2) { //3
      set2.add(arr[vidx]);
      solve(arr, vidx + 1, set1, set2, soset1, soset2 + arr[vidx]);
      set2.remove(set2.size() - 1);
    }

  }
}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Largest Number Possible After At Most K Swaps</span>
import java.io.*;
import java.util.*;

public class Main {

	static String max;
	public static void main(String[] args) {
		Scanner scn = new Scanner(System.in);
		String str = scn.next();
		int k = scn.nextInt();
		 max = str;
		findMaximum(str, k);
		System.out.println(max);
	}

	
	public static void findMaximum(String str, int k) {
		if (k == 0) {
			return;
		}

		for (int i = 0; i < str.length() - 1; i++) {
			for (int j = i + 1; j < str.length(); j++) {
				if (str.charAt(i) < str.charAt(j)) {
					str = swap(str, i, j);

					if (Integer.parseInt(str) > Integer.parseInt(max)) {
						max = str;
					}

					findMaximum(str, k - 1);
					str = swap(str, i, j);
				}
			}
		}
	}

	public static String swap(String str, int i, int j) {
		char ith = str.charAt(i);
		char jth = str.charAt(j);

		String left = str.substring(0, i);
		String middle = str.substring(i + 1, j);
		String right = str.substring(j + 1);

		return left + jth + middle + ith + right;
	}
		
}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Magnets</span>
import java.io.*;
import java.util.*;

public class Main {

	public static void print(char[][] arr) {
		for (int i = 0; i < arr.length; i++) {
			for (int j = 0; j < arr[0].length; j++) {
				System.out.print(arr[i][j] + " ");
			}
			System.out.println();
		}
	}

	private static int countInColumn(char ans[][], char ch, int j) {
		int count = 0;
		for (int i = 0; i < ans.length; i++)
			if (ans[i][j] == ch)
				count++;

		return count;
	}

	private static int countInRow(char ans[][], char ch, int i) {
		int count = 0;
		for (int j = 0; j < ans[0].length; j++)
			if (ans[i][j] == ch)
				count++;

		return count;
	}

	public static void main(String[] args) {
		Scanner scn = new Scanner(System.in);
		int m = scn.nextInt();
		int n = scn.nextInt();
		char[][] arr = new char[m][n];
		for (int i = 0; i < arr.length; i++) {
			String str = scn.next();
			arr[i] = str.toCharArray();
		}
		int[] top = new int[n];
		for (int i = 0; i < n; i++) {
			top[i] = scn.nextInt();
		}
		int[] left = new int[m];
		for (int i = 0; i < m; i++) {
			left[i] = scn.nextInt();
		}
		int[] right = new int[m];
		for (int i = 0; i < m; i++) {
			right[i] = scn.nextInt();
		}
		int[] bottom = new int[n];
		for (int i = 0; i < n; i++) {
			bottom[i] = scn.nextInt();
		}

		char ans[][] = new char[m][n];

		for (int i = 0; i < m; i++)
			Arrays.fill(ans[i], 'X');

		if (!solution(arr, top, left, right, bottom, ans, 0, 0)) {
			System.out.println("No Solution");
			return;
		}

		print(ans);
	}

	public static boolean solution(char[][] arr, int[] top, int[] left, int[] right, int[] bottom, char[][] ans,
			int row, int col) {

		if (col >= arr[0].length) {
			col = 0;
			row++;
		}
		if (row >= arr.length) {
//			print(ans);
//			System.out.println("--------------------------");
			if (isValid(ans, top, left, right, bottom)) {
				return true;
			}else {
				return false;
			}
			
		}

		if(ans[row][col] == 'X') {
			if (col < arr[0].length - 1 && arr[row][col] == 'L' && arr[row][col + 1] == 'R') {
				// check if it is safe to place
				if (isSafe(ans, row, col, '+', top, left, right, bottom)
						&& isSafe(ans, row, col + 1, '-', top, left, right, bottom)) {
					// place it
					ans[row][col] = '+';
					ans[row][col + 1] = '-';
					// recursive call
					if (solution(arr, top, left, right, bottom, ans, row, col + 2)) {
						return true;
					}
					// unplace it
					ans[row][col] = 'X';
					ans[row][col + 1] = 'X';
				}
				if (isSafe(ans, row, col, '-', top, left, right, bottom)
						&& isSafe(ans, row, col + 1, '+', top, left, right, bottom)) {
					// place it
					ans[row][col] = '-';
					ans[row][col + 1] = '+';
					// recursive call
					if (solution(arr, top, left, right, bottom, ans, row, col + 2)) {
						return true;
					}
					// unplace it
					ans[row][col] = 'X';
					ans[row][col + 1] = 'X';
				}	
			}
	
			if (row < arr.length - 1 && arr[row][col] == 'T' && arr[row + 1][col] == 'B') {
				if (isSafe(ans, row, col, '+', top, left, right, bottom)
						&& isSafe(ans, row + 1, col, '-', top, left, right, bottom)) {
					// place it
					ans[row][col] = '+';
					ans[row + 1][col] = '-';
					// recursive call
					if (solution(arr, top, left, right, bottom, ans, row, col + 1)) {
						return true;
					}
					// unplace it
					ans[row][col] = 'X';
					ans[row + 1][col] = 'X';
				}
				if (isSafe(ans, row, col, '-', top, left, right, bottom)
						&& isSafe(ans, row + 1, col, '+', top, left, right, bottom)) {
					// place it
					ans[row][col] = '-';
					ans[row + 1][col] = '+';
					// recursive call
					if (solution(arr, top, left, right, bottom, ans, row, col + 1)) {
						return true;
					}
					// unplace it
					ans[row][col] = 'X';
					ans[row + 1][col] = 'X';
				}
			}
		}
		if (solution(arr, top, left, right, bottom, ans, row, col + 1))
			return true;

		return false;
	}

	public static boolean isSafe(char[][] ans, int row, int col, char ch, int[] top, int[] left, int[] right,
			int[] bottom) {
		if ((ans[row][col] != 'X') || (row - 1 >= 0 && ans[row - 1][col] == ch) || (row + 1 < ans.length && ans[row + 1][col] == ch)
				|| (col - 1 >= 0 && ans[row][col - 1] == ch) || (col + 1 < ans[0].length && ans[row][col + 1] == ch)) {
			return false;
		}
		int rowCount = countInRow(ans, ch, row);
		int colCount = countInColumn(ans, ch, col);

		// if given character is '+', check top[] & left[]
		if (ch == '+') {
			if (top[col] != -1 && colCount >= top[col])
				return false;

			if (left[row] != -1 && rowCount >= left[row])
				return false;
		}

		// if given character is '-', check bottom[] & right[]
		if (ch == '-') {
			if (bottom[col] != -1 && colCount >= bottom[col])
				return false;

			if (right[row] != -1 && rowCount >= right[row])
				return false;
		}
		return true;
	}

	public static boolean isValid(char[][] ans, int[] top, int[] left, int[] right, int[] bottom) {

		for (int i = 0; i < top.length; i++) {
			if (top[i] != -1 && countInColumn(ans, '+', i) != top[i]) {
				return false;
			}
		}

		for (int i = 0; i < left.length; i++) {
			if (left[i] != -1 && countInRow(ans, '+', i) != left[i]) {
				return false;
			}
		}

		for (int i = 0; i < bottom.length; i++) {
			if (bottom[i] != -1 && countInColumn(ans, '-', i) != bottom[i]) {
				return false;
			}
		}

		for (int i = 0; i < right.length; i++) {
			if (right[i] != -1 && countInRow(ans, '-', i) != right[i]) {
				return false;
			}
		}

		return true;
	}
	
}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">bit-manipulation</span>
<span class="textStyle">bit-manipulation</span>
<span class="textStyle">bit-manipulation</span>
<span class="textStyle">bit-manipulation</span>
<span class="textStyle">Bit Manipulation</span>
import java.io.*;

import java.util.*;

public class Main {

  public static void main(String[] args) {
    Scanner sc = new Scanner(System.in);
    int n = scn.nextInt();
    int i = scn.nextInt();
    int j = scn.nextInt();
    int k = scn.nextInt();
    int m = scn.nextInt();

    int mask1 = 1 << i;
    int mask2 = 1 << j;
    int mask3 = 1 << k;
    int mask4 = 1 << m;

    System.out.println(n | mask1);
    System.out.println(n & (~mask2));
    System.out.println(n ^ mask3);
    System.out.println((n & mask4) == 0 ?  false : true);
  }

}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Print Value Of Rsb Mask</span>
import java.io.*;
import java.util.*;

public class Main {

  public static void main(String[] args){
    Scanner scn = new Scanner(System.in);
    int n = scn.nextInt();
    System.out.println(Integer.toBinaryString(n & ((~n) + 1)));
  }

}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Kernighans Algorithm</span>
import java.io.*;
import java.util.*;

public class Main {

  public static void main(String[] args){
    Scanner scn = new Scanner(System.in);
    int n = scn.nextInt();
    int ans = 0;

    while(n != 0){
      n &= (n - 1);
      ans++;
    }
    System.out.println(ans);
  }

}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Josephus Special</span>
import java.io.*;
import java.util.*;

public class Main {

  public static void main(String[] args){
    Scanner scn = new Scanner(System.in);
    int n = scn.nextInt();
    System.out.println(solution(n));
  }

  public static int solution(int n){
    int x = nearestPowerOf2(n);
    int l = n - x;
    return (2*l) + 1;
  }

  public static int nearestPowerOf2(int n){
    int ans = 0;
    while((1 << ans) <= n){
      ans++;
    }
    return 1 << (ans - 1);
  }
  

}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Gray Code</span>
import java.util.*;
 
 public class Main {
 
     public static List< Integer> grayCode(int n) {
         List< Integer> ans = new ArrayList<>();
         if (n == 0) {
             ans.add(0);
             return ans;
         }
         backtrack(ans, n);
         return ans;
     }
 
     static int temp;
 
     private static void backtrack(List< Integer> ans, int n) {
         if (n == 0) {
             ans.add(temp);
             return;
         }
 
         backtrack(ans, n - 1);
 
         temp = temp ^ (1 << (n - 1));
         backtrack(ans, n - 1);
     }
 
     public static void main(String[] args) {
         Scanner scn = new Scanner(System.in);
         List< Integer> ans=grayCode(scn.nextInt());
         Collections.sort(ans);
         System.out.println(ans);
     }
 }
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Minimum Number Of Software Developers</span>
import java.io.*;
import java.util.*;

public class Main {

	static ArrayList< Integer> sol = new ArrayList<>();

	public static void solution(int[] people, int nskills, int cp, ArrayList< Integer> onesol, int skills) {
		if(cp == people.length){
		    if(skills == ((1 << nskills) - 1)){
		        if(onesol.size() < sol.size() || sol.size() == 0){
		            sol = new ArrayList<>(onesol);
		        }
		    }
		    return;
		}
		solution(people, nskills, cp + 1, onesol, skills);
		onesol.add(cp);
		solution(people, nskills, cp + 1, onesol, (skills | people[cp]));
		onesol.remove(onesol.size() - 1);
	}
	public static void main(String[] args) {
		Scanner scn = new Scanner(System.in);
		int n = scn.nextInt();
		HashMap< String, Integer> smap = new HashMap<>();
		for (int i = 0; i < n; i++) {
			smap.put(scn.next(), i);
		}
		
		int np = scn.nextInt();
		int[] people = new int[np];
		for (int i = 0; i < np; i++) {
			int personSkills = scn.nextInt();
			for (int j = 0; j < personSkills; j++) {
				String skill = scn.next();
				int snum = smap.get(skill);
				people[i] = people[i] | (1 << snum);
			}
		}

		solution(people, n, 0, new ArrayList<>(), 0);
		System.out.println(sol);
		
	}
}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Number Of Valid Words</span>
import java.io.*;
import java.util.*;

public class Main {

	public static void main(String[] args) {
		Scanner scn = new Scanner(System.in);
		int n = scn.nextInt();
		String[] words = new String[n];
		for(int i = 0 ; i < words.length; i++) {
			words[i] = scn.next();
		}
		int m = scn.nextInt();
		String[] puzzles = new String[m];
		for(int i = 0 ; i < m ;i++) {
			puzzles[i] = scn.next();
		}
		ArrayList< Integer> ans = findNumOfValidWords(words,puzzles);
		for(int i = 0 ; i < m; i++){
            System.out.println(puzzles[i] + " -> " + ans.get(i));
        }
	}
	
	public static ArrayList< Integer> findNumOfValidWords(String[] words, String[] puzzles) {
        HashMap< Integer , List< Integer>> map = new HashMap<>();
        for (int i = 0; i < 26; i++) {
            map.put(i, new ArrayList<>());
        }
        for (String word : words) {
            int temp = 0;
            //make bit mask of every word
            for (char c : word.toCharArray()) {
                temp = temp | (1 << (c - 'a'));
            }
            //jo jo bit on hai uske saamne word rkh diya
            for (int i = 0; i < 26; i++) {
                if ((temp & (1 << i)) != 0) {
                    map.get(i).add(temp);
                }
            }
        }
        ArrayList< Integer> res = new ArrayList<>();
        for (String p : puzzles) {
            int temp = 0;
            //make bit mask of a puzzle
            for (char c : p.toCharArray()) {
                temp = temp | (1 << (c - 'a'));
            }
            //bring out the first character
            int c = p.charAt(0) - 'a';
            int count = 0;
            for (int key : map.get(c)) {
                if ((key & temp) == key) {
                    count++;
                }
            }
            res.add(count);
        }
        return res;
    }
}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">All Repeating Except One</span>
import java.io.*;
import java.util.*;

public class Main {

  public static void main(String[] args){
    Scanner scn = new Scanner(System.in);
    int n = scn.nextInt();
    int[] arr = new int[n];
    for(int i = 0 ; i < n; i++){
      arr[i] = scn.nextInt();
    }
    int ans = 0;
    for(int i = 0 ; i < n; i++){
      ans ^= arr[i];
    }
    System.out.println(ans);
  }

}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">All Repeating Except Two</span>
import java.io.*;
import java.util.*;

public class Main {

  public static void main(String[] args){
    Scanner scn = new Scanner(System.in);
    int n = scn.nextInt();
    int[] arr = new int[n];
    for(int i = 0 ; i < n; i++){
      arr[i] = scn.nextInt();
    }
    solution(arr);
  }

  public static void solution(int[] arr){
    int xor = 0;
    for(int i = 0 ; i < arr.length; i++){
      xor ^= arr[i];
    }
    int rsb = xor & ~(xor - 1);
    int x = 0;
    int y = 0;
    for(int i = 0 ; i < arr.length; i++){
      if((arr[i] & rsb) == 0){
        x ^= arr[i];
      }else{
        y ^= arr[i];
      }
    }
    if(x < y){
      System.out.println(x);
      System.out.println(y);
    }else{
      System.out.println(y);
      System.out.println(x);
    }
  }

}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">One Repeating And One Missing</span>
import java.io.*;
import java.util.*;

public class Main {

  public static void main(String[] args){
    Scanner scn = new Scanner(System.in);
    int n = scn.nextInt();
    int[] arr = new int[n];
    for(int i = 0 ; i < n; i++){
      arr[i] = scn.nextInt();
    }
    solution(arr);
  }

  public static void solution(int[] arr){
   int xor = 0;
   for(int i = 0 ; i < arr.length; i++){
       xor ^= arr[i];
       xor ^= (i + 1);
   }
   int rsbmask = xor & (-xor);
   int x = 0;
   int y  = 0;
   for(int i = 0 ; i < arr.length; i++){
       if((rsbmask & arr[i]) == 0){
           x ^= arr[i];
       }else{
           y ^= arr[i];
       }
   }
   
   for(int i = 1 ; i <= arr.length; i++){
       if((rsbmask & i) == 0){
           x ^= i;
       }else{
           y ^= i;
       }
   }
   
   for(int i = 0 ; i < arr.length; i++){
       if(arr[i] == x){
           System.out.println("Missing Number -> " + y);
           System.out.println("Repeating Number -> " + x);
           break;
       }
       
       if(arr[i] == y){
           System.out.println("Missing Number -> " + x);
           System.out.println("Repeating Number -> " + y);
           break;
       }
   }
   
   
   
  }

}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">All Repeating Three Times Except One</span>
import java.io.*;
import java.util.*;

public class Main {

  public static void main(String[] args){
    Scanner scn = new Scanner(System.in);
    int n = scn.nextInt();
    int[] arr = new int[n];
    for(int i = 0 ; i < n; i++){
      arr[i] = scn.nextInt();
    }
    System.out.println(solution(arr));
  }

  public static int solution(int[] arr){
    int ones = 0, twos = 0, threes = Integer.MAX_VALUE;
    for(int i = 0 ; i < arr.length; i++){
      int mask1 = (ones & arr[i]);
      int mask2 = (twos & arr[i]);
      int mask3 = (threes & arr[i]);

      int nones = (ones & (~mask1));
      nones |= mask3;

      int ntwos = (twos & (~mask2));
      ntwos |= mask1;

      int nthrees = (threes & (~mask3));
      nthrees |= mask2;

      ones = nones;
      twos = ntwos;
      threes = nthrees;
    }
    return ones;
  } 

}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Triplets - 1</span>
import java.io.*;
import java.util.*;

public class Main {

	public static void main(String[] args) {
		Scanner scn = new Scanner(System.in);
		int n = scn.nextInt();
        int[] arr = new int[n];
        for(int i = 0 ; i < arr.length; i++){
            arr[i] = scn.nextInt();
        }
        solution(arr);
    }
    
    public static void solution(int[] arr){
        int ans = 0;
        for (int i = 0; i < arr.length; i++) {
            int xor = arr[i];
            for (int j = i + 1; j < arr.length; j++) {
                xor ^= arr[j];
                if (xor == 0) {
                    ans += (j - i);
                }
            }
        }
        System.out.println(ans);
    }
	
	
}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Reduce N To 1</span>
import java.io.*;
import java.util.*;

public class Main {

	public static void main(String[] args) {
		Scanner scn = new Scanner(System.in);
		int n = scn.nextInt();
        System.out.println(solution(n));
    }
    
    public static int solution(int n) {
        long N = n;
        int count = 0;
        while(N != 1) {
            if(N % 2 == 0) {
                N = N >> 1;
            }
            else {
                if(N == 3) {
                    count += 2;
                    break;
                }
                N = (N & 2) == 2 ? N + 1 : N - 1;
            }
            count ++;
        }
        return count;
    }
	
	
}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Pepcoder And Bits</span>
import java.io.*;
import java.util.*;

public class Main {
    public static long ncr(long n, long r){
        if(n < r){
            return 0L;    
        }
        
        long res = 1L;
        
        for(long i = 0L; i < r; i++){
            res = res * (n - i);
            res = res / (i + 1);
        }
        
        return res;
    }
    
    public static long solution(long n, int k, int i) {
        if(i == 0){
            return 0;    
        }
        
        long mask = 1L << i;
        
        long res = 0;
        
        if((n & mask) == 0){
            res = solution(n, k, i - 1);
        } else {
            long res1 = solution(n, k - 1, i - 1);
            long res0 = ncr(i, k);
            res = res1 + res0;
        }
        
        return res;
    }
    
    public static int csb(long n){
        int res = 0;
        
        while(n > 0){
            long rsb = n & -n;
            n -= rsb;
            res++;
        }
        
        return res;
    }
    
	public static void main(String[] args) {
		Scanner scn = new Scanner(System.in);
        long n = scn.nextLong();
        int k = csb(n);
        System.out.println(solution(n, k, 63));
    }
	
	
}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Xor Of Sum Of All Pairs</span>
import java.io.*;
import java.util.*;

public class Main {

    public static int solution(int[] arr){
        int ans = 0;
        for(int i = 0 ; i < arr.length; i++){
            ans ^= (2 * arr[i]);
        }
        return ans;
    }
	public static void main(String[] args) {
		Scanner scn = new Scanner(System.in);
        int n = scn.nextInt();
        int[] arr = new int[n];
        for(int i = 0 ; i < n; i++){
            arr[i] = scn.nextInt();
        }
        System.out.println(solution(arr));
    }
    
    
}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Abbreviation 1 - Using Bits</span>
import java.io.*;
import java.util.*;

public class Main {

    public static void solve(String str){
        for(int i = 0; i < (1 << str.length()); i++){
            StringBuilder sb = new StringBuilder();
            int count = 0;
            
            for(int j = 0; j < str.length(); j++){
                char ch = str.charAt(j);
                int b = str.length() - 1 - j;
                
                if((i & (1 << b)) == 0){
                    if(count == 0){
                        sb.append(ch);
                    } else {
                        sb.append(count);
                        sb.append(ch);
                        count = 0;
                    }
                } else {
                    count++;
                }
            }
            
            if(count > 0){
                sb.append(count);
            }
            
            System.out.println(sb);
        }
    }
    
	public static void main(String[] args) {
        Scanner scn = new Scanner(System.in);
        String str = scn.nextLine();
        solve(str);
    }
}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Utf - 8 Encoding</span>
import java.io.*;
import java.util.*;

public class Main {

    public static boolean solution(int[] arr) {
        int count = 0;
        for (int val : arr) {
            if (count > 0) {
                if ((val >> 6) == 0b10) {
                    count--;
                } else {
                    return false;
                }
            } else {
                if ((val >> 7) == 0b0) {
                    count = 0;
                } else if ((val >> 5) == 0b110) {
                    count = 1;
                } else if ((val >> 4) == 0b1110) {
                    count = 2;
                } else if ((val >> 3) == 0b11110) {
                    count = 3;
                } else {
                    return false;
                }
            }
        }

        if (count > 0) {
            return false;
        } else {
            return true;
        }
    }

    public static void main(String[] args) {
        Scanner scn = new Scanner(System.in);
        int n = scn.nextInt();
        int[] arr = new int[n];
        for (int i = 0; i < n; i++) {
            arr[i] = scn.nextInt();
        }
        System.out.println(solution(arr));
    }

}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Sudoku Using Bit Manipulation</span>
// import java.io.*;
import java.util.*;

public class Main {

  public static void display(int[][] arr){
    for (int ii = 0; ii < arr.length; ii++) {
      for (int jj = 0; jj < arr.length; jj++) {
        System.out.print(arr[ii][jj] + " ");
      }
      System.out.println();
    }
    System.out.println();
  }

  public static void solveSudoku(int[][] arr, int[] rows, int[] cols, int[][] grid, int i, int j) {
    if (i == arr.length) {
      display(arr);
      return;
    }

    if (arr[i][j] != 0) {
      solveSudoku(arr, rows, cols, grid, j < 8 ? i : i + 1, j < 8 ? j + 1 : 0);
    } else {
      for (int num = 1; num <= 9; num++) {
        if (((rows[i] & (1 << num)) == 0) && ((cols[j] & (1 << num)) == 0)
            && ((grid[i / 3][j / 3] & (1 << num)) == 0)) {
          rows[i] ^= (1 << num);
          cols[j] ^= (1 << num);
          grid[i / 3][j / 3] ^= (1 << num);
          arr[i][j] = num;
          solveSudoku(arr, rows, cols, grid, j < 8 ? i : i + 1, j < 8 ? j + 1 : 0);
          arr[i][j] = 0;
          grid[i / 3][j / 3] ^= (1 << num);
          cols[j] ^= (1 << num);
          rows[i] ^= (1 << num);
        }
      }
    }
  }

  public static void main(String[] args) throws Exception {
    Scanner scn = new Scanner(System.in);
    int[][] arr = new int[9][9];
    int[] rows = new int[9];
    int[] cols = new int[9];
    int[][] grid = new int[3][3];

    for (int i = 0; i < 9; i++) {
      for (int j = 0; j < 9; j++) {
        int digit = scn.nextInt();
        arr[i][j] = digit;
        rows[i] |= (1 << digit);
        cols[j] |= (1 << digit);
        grid[i / 3][j / 3] |= (1 << digit);
      }
    }

    solveSudoku(arr, rows, cols, grid, 0, 0);
  }

}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">N Queens Using Bit</span>
import java.io.*;
import java.util.*;

public class Main {

  public static void solution(boolean[][] board, int row, int cols, int ndiag, int rdiag, String asf) {
    if (row == board.length) {
      System.out.println(asf + ".");
      return;
    }

    for (int col = 0; col < board.length; col++) {
      if ((cols & (1 << col)) == 0 && (ndiag & (1 << (row + col))) == 0 && (rdiag & (1 << (row - col + board.length - 1))) == 0) {
        board[row][col] = true;
        cols ^= (1 << col);
        ndiag ^= (1 << (row + col));
        rdiag ^= (1 << (row - col + board.length - 1));
        solution(board, row + 1, cols, ndiag, rdiag, asf + row + "-" + col + ", ");
        board[row][col] = false;
        cols ^= (1 << col);
        ndiag ^= (1 << (row + col));
        rdiag ^= (1 << (row - col + board.length - 1));
      }
    }
  }

  public static void main(String[] args) throws Exception {
    Scanner scn = new Scanner(System.in);
    int n = scn.nextInt();
    boolean[][] board = new boolean[n][n];
    int cols = 0;
    int ndiag = 0;
    int rdiag = 0;
    solution(board, 0, cols, ndiag, rdiag, "");
  }

}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Flip Bits To Convert A To B</span>
import java.io.*;
import java.util.*;

public class Main {

  public static void main(String[] args){
    Scanner scn = new Scanner(System.in);
    int a = scn.nextInt();
    int b = scn.nextInt();
    int xor = a ^ b;

    int ans = 0;

    while(xor != 0){
      xor &= (xor - 1);
      ans++;
    }
    System.out.println(ans);
  }

}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Flip Bits To Convert A To B</span>
import java.io.*;
import java.util.*;

public class Main {

  public static void main(String[] args){
    Scanner scn = new Scanner(System.in);
    int a = scn.nextInt();
    int b = scn.nextInt();
    int xor = a ^ b;

    int ans = 0;

    while(xor != 0){
      xor &= (xor - 1);
      ans++;
    }
    System.out.println(ans);
  }

}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Copy Set Bits In A Range</span>
import java.io.*;
import java.util.*;

public class Main {

  public static void main(String[] args){
    Scanner scn = new Scanner(System.in);
    int a = scn.nextInt();
    int b = scn.nextInt();
    int left = scn.nextInt();
    int right = scn.nextInt();

    int mask = (1 << (right - left + 1)) - 1;
    mask = ((mask << (left - 1)) & a);
    b |= mask;
    System.out.println(b);
    
  }

}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Is A Power Of 2</span>
import java.io.*;
import java.util.*;

public class Main {

  public static void main(String[] args){
    Scanner scn = new Scanner(System.in);
    int n = scn.nextInt();
    System.out.println((n & (n - 1)) == 0);
  }


}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Is A Power Of 4</span>
class Solution {
  public boolean isPowerOfFour(int n) {
    int fac = 0b01010101010101010101010101010101;
    return n > 0 && (n & (n - 1)) == 0 && (fac & n) > 0;
  }
}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Solve 7n By 8</span>
import java.io.*;
import java.util.*;

public class Main {

  public static void main(String[] args){
    Scanner scn = new Scanner(System.in);
    int n = scn.nextInt();
    System.out.println(((n << 3) - n) >> 3);
  }


}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Swap All Odd And Even Bits</span>
import java.io.*;
import java.util.*;

public class Main {

  public static void main(String[] args){
    Scanner scn = new Scanner(System.in);
    int n = scn.nextInt();

    int even = n & 0xAAAAAAAA;  
    int odd = n & 0x55555555;  

    even >>= 1;   
    odd <<= 1;  
    System.out.println(even | odd);  
  }


}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Sum Of Bit Differences Of All Pairs</span>
import java.io.*;
import java.util.*;

public class Main {

  public static void main(String[] args){
    Scanner scn = new Scanner(System.in);
    int n = scn.nextInt();
    int[] arr = new int[n];
    for(int i = 0 ; i < arr.length; i++){
      arr[i] = scn.nextInt();
    }
    System.out.println(solution(arr));
  }

  public static long solution(int[] arr){
    int n = arr.length;
    long ans = 0;
    for (int i = 0; i < 32; i++) { 
      long count = 0; 
      for (int j = 0; j < n; j++){ 
        if ((arr[j] & (1 << i)) == 0){ 
            count++;
        }
      }   
      ans += (count * (n - count) * 2);
    }  
    return ans; 
  }

}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Check Divisibility By 3</span>
import java.io.*;
import java.util.*;

public class Main {

  public static void main(String[] args){
    Scanner scn = new Scanner(System.in);
    String str = scn.nextLine();

    int even = 0, odd = 0;
    for(int i = 0 ; i < str.length(); i++){
      if(str.charAt(i) == '1'){
        if(i % 2 == 0){
          even++;
        }else{
          odd++;
        }
      }
    }
    System.out.println(Math.abs(even - odd) % 3 == 0);
  }

}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Count Set Bits In First N Natural Numbers</span>
import java.util.*;
import java.io.*;

    public class Main {

        public static void main(String[] args) {
            Scanner scn = new Scanner(System.in);
            int n = scn.nextInt();
            System.out.println(solution(n));

        }

        public static int solution(int n) {
            if (n == 0) {
                return 0;
            }

            int x = largestPowerOf2inrange(n);
            int btill2x = x * (1 << (x - 1));
            int msb2xton = n - (1 << x) + 1;
            int rest = n - (1 << x);
            int ans = btill2x + msb2xton + solution(rest);
            return ans;

        }

        public static int largestPowerOf2inrange(int n) {
            int x = 0;

            while ((1 << x) <= n) {
                x++;
            }

            return x - 1;
        }
    }
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Print Binary And Reverse Bits</span>
import java.io.*;
import java.util.*;

public class Main {

  public static void main(String[] args){
    Scanner scn = new Scanner(System.in);
    int n = scn.nextInt();
    boolean flag = false;
    for(int i = (1 << 30); i > 0; i = i >> 1){
      if((n & i) != 0){
        System.out.print(1);
        flag = true;
      }else if(((n & i) == 0) && flag){
        System.out.print(0);
      }
    }
    System.out.println();
    int rev = 0;
    while(n > 0){
       int m = (n & 1);
       rev |= m;
       n = n >> 1;
       rev = rev << 1;
    }
    System.out.println(rev >> 1);
  }

}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Min Xor Pairs</span>
import java.io.*;
import java.util.*;

public class Main {

    public static void solution(int[] arr) {
        Arrays.sort(arr);
        ArrayList< Integer> ans = new ArrayList<>();
        int min = arr[0] ^ arr[1];
        ans.add(arr[0]);
        ans.add(arr[1]);
        for(int i = 1; i < arr.length - 1; i++){
            if((arr[i] ^ arr[i + 1]) < min){
                min = (arr[i] ^ arr[i + 1]);
                ans = new ArrayList<>();
                ans.add(arr[i]);
                ans.add(arr[i + 1]);
            }else if((arr[i] ^ arr[i + 1]) == min){
                ans.add(arr[i]);
                ans.add(arr[i + 1]);
            }
        }
        
        for(int i = 0 ; i < ans.size() - 1; i+= 2){
            System.out.println(ans.get(i) + ", " + ans.get(i + 1));
        }
    }
	public static void main(String[] args) {
        Scanner scn = new Scanner(System.in);
        int n = scn.nextInt();
        int[] arr = new int[n];
        for(int i = 0 ; i < n; i++){
            arr[i] = scn.nextInt();
        }
        solution(arr);
    }
    
    
}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Nth Palindromic Binary</span>
import java.io.*;
import java.util.*;

public class Main {

    public static int revBin(int n) {
        int rev = 0;
        while (n > 0) {
            int m = (n & 1);
            rev |= m;
            n = n >> 1;
            rev = rev << 1;
        }
        return (rev >> 1);
    }

    public static int NthPalindromicBinary(int n) {
        int grpNo = 1;
        int count = 1;
        while (count < n) {
            grpNo++;
            count += (1 << ((grpNo - 1) / 2));
        }
        count -= (1 << (grpNo - 1) / 2);
        int offset = n - count - 1;

        int ans = 1;

        ans |= (1 << (grpNo - 1));
        ans |= (offset << (grpNo / 2));
        int val = ans >> (grpNo / 2);
        int rev = revBin(val);

        ans |= rev;
        return ans;
    }

    public static void main(String[] args) {
        Scanner scn = new Scanner(System.in);
        int n = scn.nextInt();
        System.out.println(NthPalindromicBinary(n));
    }

}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Xor Queries Of A Subarray</span>
import java.util.*;

public class Main {
  class Solution {
    public int[] xorQueries(int[] arr, int[][] q) {
      int[] ans = new int[q.length];
      int[] prefXor = new int[arr.length];
      prefXor[0] = arr[0];
      for (int i = 1; i < arr.length; i++) {
        prefXor[i] = arr[i] ^ prefXor[i - 1];
      }

      for (int i = 0; i < q.length; i++) {
        int l = q[i][0];
        int r = q[i][1];
        if (l == 0) ans[i] =  prefXor[r];
        else ans[i] = prefXor[r] ^ prefXor[l - 1];
      }
      return ans;
    }
  }
  public static void main(String[] args) {
    Scanner scn = new Scanner(System.in);

  }
}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Minimum Flips To Make A Or B Equal To C</span>
public int minFlips(int a, int b, int c) {
  int res = 0;

  for (int i = 0; i < 32; i++) {
    boolean aa = false;
    boolean bb = false;
    boolean cc = false;

    if ( (a & (1 << i)) != 0) aa = true;
    if ( (b & (1 << i)) != 0) bb = true;
    if ( (c & (1 << i)) != 0) cc = true;
    if (cc) {
      if (!aa && !bb ) res++;
    } else {
      if (aa && bb) res += 2;
      else if (aa || bb) res++;
    }
  }
  return res;
}
                                
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Find Longest Awesome Substring</span>
class Solution {
  public int longestAwesome(String s) {

    Integer map[] = new Integer[1 << (10)];
    //HashMap< Integer, Integer> map = new HashMap<>();
    // map.put(0, -1);
    map[0] = -1;

    int ans = 0;
    int state = 0;
    int n = s.length();
    for (int i = 0; i < n; i++) {
      char ch = s.charAt(i);

      int mask = (1 << (ch - '0'));
      state = state ^ mask;

      Integer j = map[state];
      if (j != null) {
        ans = Math.max(ans, i - j);
      }

      for (int odd = 0; odd < 10; odd++) {
        mask = 1 << odd;
        j = map[state ^ mask];
        if (j != null) {
          ans = Math.max(ans, i - j);
        }
      }

      if (map[state] == null) {
        map[state] = i;
      }
    }

    return ans;
  }
}
                                
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Dynamic Programming</span>	
<span class="textStyle">Dynamic Programming</span>	
<span class="textStyle">Dynamic Programming</span>	
<span class="textStyle">Dynamic Programming</span>										
<span class="textStyle">Largest Square Sub-matrix With All 1's</span>
import java.io.*;
import java.util.*;

public class Main {
	
	public static void main(String[] args) {
		Scanner scn = new Scanner(System.in);
		int n = scn.nextInt();
		int m =scn.nextInt();
		int[][] arr = new int[n][m];
		for(int i = 0 ; i < n; i++){
			for(int j = 0 ; j < m; j++){
				arr[i][j] = scn.nextInt();
			}
		}
		System.out.println(solution(arr));
	}

	public static int solution(int[][] arr) {
		int[][] dp = new int[arr.length][arr[0].length];
		int ans = 0;
		for(int i = arr.length - 1; i >= 0; i--){
			for(int j = arr[0].length - 1; j >= 0; j--){
				if(arr[i][j] == 0){
					dp[i][j] = 0;
				}else{
					if(i == arr.length - 1 || j == arr[0].length - 1){
						dp[i][j] = 1;
					}else{
						dp[i][j] = Math.min(dp[i + 1][j + 1], Math.min(dp[i + 1][j], dp[i][j + 1])) + 1;
					}
				}
				ans = Math.max(ans,dp[i][j]);
			}
		}
		return ans;
	}

}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Print All Paths With Minimum Jumps</span>
import java.util.ArrayDeque;
import java.util.Queue;
import java.util.Scanner;

public class Main{
    public static class Pair{
        int idx;
        String asf;
        int jmps;
        Pair(int idx,String asf,int jmps){
            this.idx = idx;
            this.asf = asf;
            this.jmps = jmps;
        }
    }
    
    public static void minJumpRE(int []arr,int []dp){
        
        Queue<Pair> queue = new ArrayDeque<>();
        queue.add(new Pair(0 , ""+ 0 , dp[0]));

        while(queue.size() > 0){
            Pair tmp = queue.remove();

            if(tmp.jmps == 0){
                System.out.println(tmp.asf+" .");
                continue;
            }
    
            for(int step = 1 ; step <= arr[tmp.idx] ; step++){
                if(tmp.idx+step < arr.length && tmp.jmps-1 == dp[tmp.idx+step]){
                    queue.add(new Pair(tmp.idx+step, tmp.asf +" -> " + (tmp.idx+step), tmp.jmps-1));
                }
            }
        }
    }
    public static int[] minJumps(int []arr){
        int dp[] = new int[arr.length];

        // dp[arr.length-1] = ;

        for(int idx = arr.length-2 ; idx >=0 ; idx--){
            int steps = arr[idx];
        
            int min = Integer.MAX_VALUE;
            if(steps > 0){
                for(int i = 1 ; i <= steps ;i++){
                    if(idx + i < arr.length)
                        min = Math.min(min,dp[idx+i]);
                }
            }
            dp[idx] = min == Integer.MAX_VALUE ? min : min+1;
            // System.out.print(dp[idx]+" ");
        }
        return dp;
        
    }

    public static void Solution(int arr[]){
        int dp[] = minJumps(arr);
        System.out.println(dp[0]);
        minJumpRE(arr, dp);
    }
    public static void main(String []args){
        Scanner scn = new Scanner(System.in);
        int n = scn.nextInt();

        int arr[] = new int[n];
        for(int i = 0 ; i < n ; i++)
            arr[i] = scn.nextInt();

        Solution(arr);
        scn.close();
    }
}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Print All Paths With Minimum Cost</span>
import java.io.*;
import java.util.*;

public class Main {

   private static class Pair {
      String psf;
      int i;
      int j;

      public Pair(String psf, int i, int j) {
         this.psf = psf;
         this.i = i;
         this.j = j;
      }
   }

   public static void main(String[] args) throws Exception {
      BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
      int n = Integer.parseInt(br.readLine());
      int m = Integer.parseInt(br.readLine());
      int[][] arr = new int[n][m];

      for (int i = 0; i < n; i++) {
         String str = br.readLine();
         for (int j = 0; j < m; j++) {
            arr[i][j] = Integer.parseInt(str.split(" ")[j]);
         }
      }

      //write your code here
      int[][] dp = new int[arr.length][arr[0].length];
      
      for(int i = dp.length - 1; i >= 0; i--){
          for(int j = dp[0].length - 1; j >= 0; j--){
              if(i == dp.length - 1 && j == dp[0].length - 1){
                  dp[i][j] = arr[i][j];
              } else if(i == dp.length - 1){
                  dp[i][j] = arr[i][j] + dp[i][j + 1];
              } else if(j == dp[0].length - 1){
                  dp[i][j] = arr[i][j] + dp[i + 1][j];
              } else {
                  dp[i][j] = arr[i][j] + Math.min(dp[i][j + 1], dp[i + 1][j]);
              }
          }
      }
      
      System.out.println(dp[0][0]);
      ArrayDeque<Pair> queue = new ArrayDeque<>();
      queue.add(new Pair("", 0, 0));
      while(queue.size() > 0){
          Pair rem = queue.removeFirst();
          
          if(rem.i == dp.length - 1 && rem.j == dp[0].length - 1){
              System.out.println(rem.psf);
          } else if(rem.i == dp.length - 1){
                  queue.add(new Pair(rem.psf + "H", rem.i, rem.j + 1));              
          } else if(rem.j == dp[0].length - 1){
                  queue.add(new Pair(rem.psf + "V", rem.i + 1, rem.j));              
          } else {
              if(dp[rem.i][rem.j + 1] < dp[rem.i + 1][rem.j]){
                  queue.add(new Pair(rem.psf + "H", rem.i, rem.j + 1));
              } else if(dp[rem.i][rem.j + 1] > dp[rem.i + 1][rem.j]){
                  queue.add(new Pair(rem.psf + "V", rem.i + 1, rem.j));
              } else {
                  queue.add(new Pair(rem.psf + "V", rem.i + 1, rem.j));
                  queue.add(new Pair(rem.psf + "H", rem.i, rem.j + 1));
              }
          }
      }
      
   }

}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Print All Paths With Maximum Gold</span>
import java.io.*;
import java.util.*;

public class Main {

   private static class Pair {
      String psf;
      int i;
      int j;

      public Pair(String psf, int i, int j) {
         this.psf = psf;
         this.i = i;
         this.j = j;
      }
   }
   public static void main(String[] args) throws Exception {
      BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
      int n = Integer.parseInt(br.readLine());
      int m = Integer.parseInt(br.readLine());
      int[][] arr = new int[n][m];

      for (int i = 0; i < n; i++) {
         String str = br.readLine();
         for (int j = 0; j < m; j++) {
            arr[i][j] = Integer.parseInt(str.split(" ")[j]);
         }
      }

      int[][] dp = new int[arr.length][arr[0].length];
      
      for(int j = arr[0].length - 1; j >= 0; j--){
          for(int i = 0; i < arr.length; i++){
              if(j == arr[0].length - 1){
                  dp[i][j] = arr[i][j];
              } else if(i == 0){
                  dp[i][j] = arr[i][j] + Math.max(dp[i][j + 1], dp[i + 1][j + 1]);
              } else if(i == arr.length - 1){
                  dp[i][j] = arr[i][j] + Math.max(dp[i][j + 1], dp[i - 1][j + 1]);
              } else {
                  dp[i][j] = arr[i][j] + Math.max(dp[i][j + 1], Math.max(dp[i - 1][j + 1], dp[i + 1][j + 1]));
              }
          }
      }
      
      int max = Integer.MIN_VALUE;
      for(int i = 0; i < dp.length; i++){
          if(dp[i][0] > max){
              max = dp[i][0];
          }
      }
      
      System.out.println(max);
      
      ArrayDeque<Pair> que = new ArrayDeque<>();
      
      for(int i = 0; i < dp.length; i++){
          if(dp[i][0] == max){
              que.add(new Pair(i + " ", i, 0));
          }
      }
      
      while(que.size() > 0){
          Pair rem = que.removeFirst();
          
          if(rem.j == arr[0].length - 1){
              System.out.println(rem.psf);
          } else if(rem.i == 0){
              int g = Math.max(dp[rem.i][rem.j + 1], dp[rem.i + 1][rem.j + 1]);
              
              
              if(g == dp[rem.i][rem.j + 1]){
                  que.add(new Pair(rem.psf + "d2 ", rem.i, rem.j + 1));
              }
              
              if(g == dp[rem.i + 1][rem.j + 1]){
                  que.add(new Pair(rem.psf + "d3 ", rem.i + 1, rem.j + 1));
              }
          } else if(rem.i == arr.length - 1){
              int g = Math.max(dp[rem.i][rem.j + 1], dp[rem.i - 1][rem.j + 1]);
              
              
              if(g == dp[rem.i - 1][rem.j + 1]){
                  que.add(new Pair(rem.psf + "d1 ", rem.i - 1, rem.j + 1));
              }
              
              if(g == dp[rem.i][rem.j + 1]){
                  que.add(new Pair(rem.psf + "d2 ", rem.i, rem.j + 1));
              }
          } else {
              int g = Math.max(dp[rem.i][rem.j + 1], Math.max(dp[rem.i - 1][rem.j + 1], dp[rem.i + 1][rem.j + 1]));
              
              if(g == dp[rem.i - 1][rem.j + 1]){
                  que.add(new Pair(rem.psf + "d1 ", rem.i - 1, rem.j + 1));
              }
              
              if(g == dp[rem.i][rem.j + 1]){
                  que.add(new Pair(rem.psf + "d2 ", rem.i, rem.j + 1));
              }
              
              if(g == dp[rem.i + 1][rem.j + 1]){
                  que.add(new Pair(rem.psf + "d3 ", rem.i + 1, rem.j + 1));
              }
          }
          
          
      }
   }


}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Print All Paths With Target Sum Subset</span>
import java.io.*;
import java.util.*;

public class Main {

    public static class Pair{
        int i;
        int j;
        String psf;

        public Pair(int i, int j, String psf){
            this.i = i;
            this.j = j;
            this.psf = psf;
        }
    }
    public static void main(String[] args) throws Exception {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int n = Integer.parseInt(br.readLine());
        int[] arr = new int[n];

        for (int i = 0; i < n; i++) {
            arr[i] = Integer.parseInt(br.readLine());
        }

        int tar = Integer.parseInt(br.readLine());

        boolean[][] dp = new boolean[arr.length + 1][tar + 1];
        for (int i = 0; i < dp.length; i++) {
            for (int j = 0; j < dp[0].length; j++) {
                if (i == 0 && j == 0) {
                    dp[i][j] = true;
                } else if (i == 0) {
                    dp[i][j] = false;
                } else if (j == 0) {
                    dp[i][j] = true;
                } else {
                    if(dp[i - 1][j] == true){
                        dp[i][j] = true;
                    } else {
                        int val = arr[i - 1];
                        if (j >= val && dp[i - 1][j - val] == true) {
                            dp[i][j] = true;
                        }
                    }
                }
            }
        }

        System.out.println(dp[dp.length - 1][tar]);
        Queue<Pair> q = new ArrayDeque<>();
        q.add(new Pair(n,tar,""));
      

        while (q.size() > 0) {
			Pair rp = q.remove();
			if (rp.i == 0 || rp.j == 0) {
				System.out.println(rp.psf);
			} else {
				boolean exc = dp[rp.i - 1][rp.j];
				boolean inc = rp.j - arr[rp.i - 1] >= 0 ? dp[rp.i - 1][rp.j - arr[rp.i - 1]] : false;
				
				if (inc == true) {
					q.add(new Pair(rp.i - 1, rp.j - arr[rp.i - 1], (rp.i - 1) + " " + rp.psf));
				}
				if (exc == true) {
					q.add(new Pair(rp.i - 1, rp.j, rp.psf));
				}
			}
		}
    }
}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Print All Results In 0-1 Knapsack</span>
import java.io.*;
import java.util.*;

public class Main {

   public static class Pair{
      int i;
      int j;
      String psf;

      public Pair(int i, int j, String psf){
         this.i = i;
         this.j = j;
         this.psf = psf;
      }
   }
    public static void main(String[] args) throws Exception {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int n = Integer.parseInt(br.readLine());

        int[] values = new int[n];
        String str1 = br.readLine();
        for (int i = 0; i < n; i++) {
            values[i] = Integer.parseInt(str1.split(" ")[i]);
        }

        int[] wts = new int[n];
        String str2 = br.readLine();
        for (int i = 0; i < n; i++) {
            wts[i] = Integer.parseInt(str2.split(" ")[i]);
        }

        int cap = Integer.parseInt(br.readLine());

        int[][] dp = new int[n + 1][cap + 1];
        for (int i = 1; i < dp.length; i++) {
            for(int j = 1; j < dp[0].length; j++){
                int val = values[i - 1];
                int wt = wts[i - 1];

                if(j >= wt){
                    dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - wt] + val);
                } else {
                    dp[i][j] = dp[i - 1][j];
                }
            }
        }

        System.out.println(dp[n][cap]);
        Queue<Pair> q = new ArrayDeque<>();
        q.add(new Pair(n,cap,""));
      

        while (q.size() > 0) {
			Pair rp = q.remove();
			if (rp.i == 0 || rp.j == 0) {
				System.out.println(rp.psf);
			} else {
				int exc = dp[rp.i - 1][rp.j];
				int inc = rp.j - wts[rp.i - 1] >= 0 ? (dp[rp.i - 1][rp.j - wts[rp.i - 1]] + values[rp.i - 1]) : Integer.MIN_VALUE;
				
				if (dp[rp.i][rp.j] == inc) {
					q.add(new Pair(rp.i - 1, rp.j - wts[rp.i - 1], (rp.i - 1) + " " + rp.psf));
				}
				if (dp[rp.i][rp.j] == exc) {
					q.add(new Pair(rp.i - 1, rp.j, rp.psf));
				}
			}
		}
    }
}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">2 Key Keyboard</span>
import java.io.*;
import java.util.*;

public class Main {

	public static void main(String[] args) {
		Scanner scn = new Scanner(System.in);
		int n = scn.nextInt();
		System.out.println(solution(n));
	}

	public static int solution(int n) {
		int res = 0;
		for (int d = 2; d <= n; d++) {
			while (n % d == 0) {
				res += d;
				n /= d;
			}
		}
		return res > 0 || n == 1 ? res : n;
	}

}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">4 Key Keyboard</span>
import java.io.*;
import java.util.*;

public class Main {

	public static void main(String[] args) {
		Scanner scn = new Scanner(System.in);
		int n = scn.nextInt();
		System.out.println(solution(n));
	}

	public static int solution(int n) {
		int[] best = new int[n + 1];
        for (int k = 1; k <= n; ++k) {
            best[k] = best[k - 1] + 1;
            for (int x = 0; x < k - 1; x++)
                best[k] = Math.max(best[k], best[x] * (k-x-1));
        }
        return best[n];
	}

}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Longest Increasing Subsequence</span>
import java.io.*;
import java.util.*;

public class Main {

   public static void main(String[] args) throws Exception {
      BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
      int n = Integer.parseInt(br.readLine());
      int[] arr = new int[n];
      for (int i = 0; i < arr.length; i++) {
         arr[i] = Integer.parseInt(br.readLine());
      }

      int omax = 0;
      int[] dp = new int[arr.length];
      for(int i = 0; i < arr.length; i++){
         Integer max = null;

         for(int j = 0; j < i; j++){
            if(arr[j] <= arr[i]){
               if(max == null || dp[j] > max){
                  max = dp[j];
               }
            }
         }

         if(max != null){
            dp[i] = max + 1;
         } else {
            dp[i] = 1;
         }
         
         if(dp[i] > omax){
            omax = dp[i];
         }
      }

      System.out.println(omax);
   }

}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Print All Longest Increasing Subsequences</span>
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Queue;
import java.util.Scanner;

public class Main{
    
    public static class Pair {
        int l;
        int i;
        int v;
        String psf;
        
        Pair(int l, int i, int v, String psf){
            this.l = l;
            this.i = i;
            this.v = v;
            this.psf = psf;
        }
    }
        
    public static void solution(int []arr){
        int[] dp = new int[arr.length];
        int omax = 0;
        
        for(int i = 0; i < dp.length; i++){
            int max = 0;
            
            for(int j = 0; j < i; j++){
                if(arr[j] <= arr[i]){
                    if(dp[j] > max){
                        max = dp[j];
                    }
                }
            }
            
            dp[i] = max + 1;
            if(dp[i] > omax){
                omax = dp[i];
            }
        }
        
        System.out.println(omax);
        
        ArrayDeque<Pair> queue = new ArrayDeque<>();
        
        for(int i = 0; i < dp.length; i++){
            if(omax == dp[i]){
                queue.add(new Pair(omax, i, arr[i], arr[i] + ""));
            }
        }
        
        while(queue.size() > 0){
            Pair rem = queue.removeFirst();
            
            if(rem.l == 1){
                System.out.println(rem.psf);
            }
            
            for(int j = rem.i - 1; j >= 0; j--){
                if(dp[j] == rem.l - 1 && arr[j] <= rem.v){
                    queue.add(new Pair(dp[j], j, arr[j], arr[j] + " -> " + rem.psf));
                }
            }
        }
    }
    
    
    
    public static void main(String []args){
        Scanner scn = new Scanner(System.in);

        int n = scn.nextInt();

        int arr[] = new int[n];
        for(int i = 0 ; i < n ; i++){
            arr[i] = scn.nextInt();
        }

        solution(arr);

        scn.close();
    }
}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Maximum Sum Increasing Subsequence</span>
import java.io.*;
import java.util.*;

public class Main {

   public static void main(String[] args) throws Exception {
      BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
      int n = Integer.parseInt(br.readLine());
      int[] arr = new int[n];
      for (int i = 0; i < arr.length; i++) {
         arr[i] = Integer.parseInt(br.readLine());
      }

      int omax = Integer.MIN_VALUE;
      int[] dp = new int[arr.length];
      for(int i = 0; i < arr.length; i++){
         Integer max = null;

         for(int j = 0; j < i; j++){
            if(arr[j] <= arr[i]){
               if(max == null || dp[j] > max){
                  max = dp[j];
               }
            }
         }

         if(max != null){
            dp[i] = max + arr[i];
         } else {
            dp[i] = arr[i];
         }
         
         if(dp[i] > omax){
            omax = dp[i];
         }
      }

      System.out.println(omax);
   }

}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Longest Bitonic Subsequence</span>
import java.io.*;
import java.util.*;

public class Main {

   public static void main(String[] args) throws Exception {
      BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
      int n = Integer.parseInt(br.readLine());
      int[] arr = new int[n];
      for (int i = 0; i < arr.length; i++) {
         arr[i] = Integer.parseInt(br.readLine());
      }

      int[] lis = new int[arr.length];
      for(int i = 0; i < arr.length; i++){
         Integer max = null;

         for(int j = 0; j < i; j++){
            if(arr[j] <= arr[i]){
               if(max == null || lis[j] > max){
                  max = lis[j];
               }
            }
         }

         if(max != null){
            lis[i] = max + 1;
         } else {
            lis[i] = 1;
         }
      }

      int[] lds = new int[arr.length];
      for(int i = arr.length - 1; i >= 0; i--){
         Integer max = null;

         for(int j = arr.length - 1; j > i; j--){
            if(arr[j] <= arr[i]){
               if(max == null || lds[j] > max){
                  max = lds[j];
               }
            }
         }

         if(max != null){
            lds[i] = max + 1;
         } else {
            lds[i] = 1;
         }
      }

      int omax = 0;
      for(int i = 0; i < arr.length; i++){
         if(lis[i] + lds[i] - 1> omax){
            omax = lis[i] + lds[i] - 1;
         }
      }
      System.out.println(omax);
   }

}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Maximum Non-overlapping Bridges</span>
import java.io.*;
import java.util.*;

public class Main {
   public static class Bridge implements Comparable<Bridge> {
      int n;
      int s;

      public int compareTo(Bridge o){
         if(this.n != o.n){
            return this.n - o.n;
         } else {
            return this.s - o.s;
         }
      }
   }
   public static void main(String[] args) throws Exception {
      BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
      int n = Integer.parseInt(br.readLine());
      Bridge[] brdgs = new Bridge[n];
      for (int i = 0; i < brdgs.length; i++) {
         String str = br.readLine();
         brdgs[i] = new Bridge();
         brdgs[i].n = Integer.parseInt(str.split(" ")[0]);
         brdgs[i].s = Integer.parseInt(str.split(" ")[1]);
      }

      Arrays.sort(brdgs);
      int[] lis = new int[brdgs.length];
      for(int i = 0; i < brdgs.length; i++){
         Integer max = null;

         for(int j = 0; j < i; j++){
            if(brdgs[j].s <= brdgs[i].s){
               if(max == null || lis[j] > max){
                  max = lis[j];
               }
            }
         }

         if(max != null){
            lis[i] = max + 1;
         } else {
            lis[i] = 1;
         }
      }

      int omax = 0;
      for(int i = 0; i < brdgs.length; i++){
         if(lis[i] > omax){
            omax = lis[i];
         }
      }
      System.out.println(omax);
   }

}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Russian Doll Envelopes</span>
import java.io.*;
import java.util.*;

public class Main {
   public static class Envelope implements Comparable<Envelope> {
      int w;
      int h;

      public int compareTo(Envelope o){
         return this.w - o.w;
      }
   }

   public static void main(String[] args) throws Exception {
      BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
      int n = Integer.parseInt(br.readLine());
      Envelope[] envlps = new Envelope[n];
      for (int i = 0; i < envlps.length; i++) {
         String str = br.readLine();
         envlps[i] = new Envelope();
         envlps[i].w = Integer.parseInt(str.split(" ")[0]);
         envlps[i].h = Integer.parseInt(str.split(" ")[1]);
      }

      Arrays.sort(envlps);
      int[] lis = new int[envlps.length];
      for(int i = 0; i < envlps.length; i++){
         Integer max = null;

         for(int j = 0; j < i; j++){
            if(envlps[j].h < envlps[i].h && envlps[j].w < envlps[i].w){
               if(max == null || lis[j] > max){
                  max = lis[j];
               }
            }
         }

         if(max != null){
            lis[i] = max + 1;
         } else {
            lis[i] = 1;
         }
      }

      int omax = 0;
      for(int i = 0; i < envlps.length; i++){
         if(lis[i] > omax){
            omax = lis[i];
         }
      }
      System.out.println(omax);
   }

}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Min Squares</span>
import java.io.*;
import java.util.*;

public class Main {

	public static int solution(int n){
		int[] dp = new int[n + 1];
		dp[1] = 1;
		for(int i = 2; i <= n; i++){
			dp[i] = i; //As every number can be expressed as (1*1)+(1*1)....
			for(int j = 1; j * j <= i; j++){
				int squareVal = j*j;
				if(squareVal > i){
					break;
				}else{
					dp[i] = Math.min(dp[i], 1 + dp[i - squareVal]);
				}
			}
		}
		return dp[n];
	}

	public static void main(String[] args) {
		Scanner scn = new Scanner(System.in);
		int n = scn.nextInt();
		System.out.println(solution(n));
	}


	
}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Catalan Number</span>
import java.io.*;
import java.util.*;

public class Main {

   public static void main(String[] args) throws Exception {
      BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
      int n = Integer.parseInt(br.readLine());
      long[] dp = new long[n + 1];
      dp[0] = 1;

      for(int i = 1; i < dp.length; i++){
         for(int j = 0; j < i; j++){
            dp[i] += dp[j] * dp[i - 1 - j];
         }
      }

      System.out.println(dp[n]);
   }

}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Number Of Bsts</span>
import java.io.*;
import java.util.*;

public class Main {

   public static void main(String[] args) throws Exception {
      BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
      int n = Integer.parseInt(br.readLine());
      long[] dp = new long[n + 1];
      dp[0] = 1;

      for(int i = 1; i < dp.length; i++){
         for(int j = 0; j < i; j++){
            dp[i] += dp[j] * dp[i - 1 - j];
         }
      }

      System.out.println(dp[n]);
   }

}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Count Of Valleys And Mountains</span>
import java.io.*;
import java.util.*;

public class Main {

   public static void main(String[] args) throws Exception {
      BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
      int n = Integer.parseInt(br.readLine());
      long[] dp = new long[n + 1];
      dp[0] = 1;

      for(int i = 1; i < dp.length; i++){
         for(int j = 0; j < i; j++){
            dp[i] += dp[j] * dp[i - 1 - j];
         }
      }

      System.out.println(dp[n]);
   }

}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Count Brackets</span>
import java.io.*;
import java.util.*;

public class Main {

   public static void main(String[] args) throws Exception {
      BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
      int n = Integer.parseInt(br.readLine());
      long[] dp = new long[n + 1];
      dp[0] = 1;

      for(int i = 1; i < dp.length; i++){
         for(int j = 0; j < i; j++){
            dp[i] += dp[j] * dp[i - 1 - j];
         }
      }

      System.out.println(dp[n]);
   }

}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Circle And Chords</span>
import java.io.*;
import java.util.*;

public class Main {

    public static long NumberOfChords(int n){
        long[] dp = new long[2*n + 1];
        dp[0] = dp[2] = 1;
        for(int i = 4 ; i < dp.length; i += 2){
            for(int j = 0 ; j < i - 1; j += 2){
                dp[i] += dp[j] * dp[i - 2 - j];
            }
        }
        return dp[dp.length - 1];
    }
  public static void main(String[] args) {
		Scanner scn = new Scanner(System.in);
        int n = scn.nextInt();
        System.out.println(NumberOfChords(n));
	}
}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Number Of Ways Of Triangulation</span>
import java.io.*;
import java.util.*;

public class Main {

	public static void main(String[] args) {
		Scanner scn = new Scanner(System.in);
		int n = scn.nextInt();
		System.out.println(solution(n));
	}

    public static int solution(int n){
        if(n < 3){
            return 0;
        }
        int[] dp = new int[n - 1];
        dp[0] = dp[1] = 1;

        for(int i = 2; i < dp.length; i++){
            for(int j = 0 ; j < i; j++){
                dp[i] += dp[j] * dp[i - j - 1];
            }
        }
        return dp[dp.length - 1];
    }

}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Matrix Chain Multiplication</span>
import java.io.*;
import java.util.*;

public class Main {

	public static int mcm(int[] arr){
		int n = arr.length;
		int[][] dp  =new int[n][n];
		for(int gap = 2; gap < n; gap++){
			int si = 0, ei = gap;
			while(ei < n){
				dp[si][ei] = Integer.MAX_VALUE;
				for(int i = si + 1; i < ei; i++){
					dp[si][ei] = Math.min(dp[si][ei], dp[si][i] + dp[i][ei] + (arr[si] * arr[i] * arr[ei]));
				}
				si++;
				ei++;
			}
		}
		return dp[0][n - 1];
	}
	public static void main(String[] args) {
		Scanner scn = new Scanner(System.in);
		int n = scn.nextInt();
		int[] arr = new int[n];
		for(int i = 0 ; i < n; i++){
			arr[i] = scn.nextInt();
		}
		System.out.println(mcm(arr));
	}

	
}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Burst Balloons</span>
import java.io.*;
import java.util.*;

public class Main {

    public static void main(String[] args) {
        Scanner scn = new Scanner(System.in);
        int n = scn.nextInt();
        int[] arr = new int[n];
        for (int i = 0; i < arr.length; i++) {
            arr[i] = scn.nextInt();
        }
        System.out.println(solution1(arr));
    }

    public static int solution1(int[] arr) {
        if (arr.length == 0) {
            return 0;
        }
        int[][] dp = new int[arr.length][arr.length];
        for (int gap = 0; gap < arr.length; gap++) {
            int si = 0, ei = gap;
            while (ei < arr.length) {
                for (int k = si; k <= ei; k++) {
                    int leftVal = 1;
                    int rightVal = 1;
                    if (si != 0) {
                        leftVal = arr[si - 1];
                    }
                    if (ei != arr.length - 1) {
                        rightVal = arr[ei + 1];
                    }

                    int before = 0;
                    int after = 0;
                    if (si != k) {
                        before = dp[si][k - 1];
                    }
                    if (ei != k) {
                        after = dp[k + 1][ei];
                    }

                    dp[si][ei] = Math.max(dp[si][ei], before + after + (leftVal * rightVal * arr[k]));
                }
                si++;
                ei++;
            }

        }
        return dp[0][arr.length - 1];
    }
}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Minimum Score Of Triangulation</span>
import java.io.*;
import java.util.*;

public class Main {

	public static int minScoreTriangulation(int[] arr) {
        int n = arr.length;
        int[][] dp = new int[n][n];
        for (int d = 2; d < n; ++d) {
            for (int i = 0; i + d < n; ++i) {
                int j = i + d;
                dp[i][j] = Integer.MAX_VALUE;
                for (int k = i + 1; k < j; ++k)
                    dp[i][j] = Math.min(dp[i][j], dp[i][k] + dp[k][j] + arr[i] * arr[j] * arr[k]);
            }
        }
        return dp[0][n - 1];
    }
  public static void main(String[] args) {
		Scanner scn = new Scanner(System.in);
        int n = scn.nextInt();
        int[] arr = new int[n];
		for(int i = 0 ; i  < n; i++){
            arr[i] = scn.nextInt();
        }
        System.out.println(minScoreTriangulation(arr));
	}
}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Boolean Parenthesization</span>
import java.io.*;
import java.util.*;

public class Main {

	public static int solution(String str1, String str2) {
		int n = str1.length();
		int[][] t = new int[n][n];
		int[][] f = new int[n][n];
		for (int gap = 0; gap < n; gap++) {
			int si = 0, ei = gap;
			while (ei < n) {
				if (gap == 0) {
					t[si][ei] = str1.charAt(si) == 'T' ? 1 : 0;
					f[si][ei] = str1.charAt(si) == 'F' ? 1 : 0;
				} else {
					for (int cp = si; cp < ei; cp++) {
						char sign = str2.charAt(cp);
						if (sign == '&') {
							t[si][ei] += t[si][cp] * t[cp + 1][ei];
							f[si][ei] += ((t[si][cp] * f[cp + 1][ei]) + (f[si][cp] * t[cp + 1][ei])
									+ (f[si][cp] * f[cp + 1][ei]));
						}
						if (sign == '|') {
							t[si][ei] += ((t[si][cp] * t[cp + 1][ei]) + (t[si][cp] * f[cp + 1][ei])
									+ (f[si][cp] * t[cp + 1][ei]));
							f[si][ei] += ((f[si][cp]) * (f[cp + 1][ei]));
						}
						if (sign == '^') {
							t[si][ei] += ((t[si][cp] * f[cp + 1][ei]) + (f[si][cp] * t[cp + 1][ei]));
							f[si][ei] += ((t[si][cp] * t[cp + 1][ei]) + (f[si][cp] * f[cp + 1][ei]));
						}
					}
				}
				si++;
				ei++;
			}
		}
		return (t[0][t[0].length - 1]);
	}

	public static void main(String[] args) {
		Scanner scn = new Scanner(System.in);
		String s1 = scn.next();
		String s2 = scn.next();
		System.out.println(solution(s1, s2));
	}

}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Optimal Binary Search Tree</span>
import java.io.*;
import java.util.*;

public class Main {

	public static void main(String[] args) {
		Scanner scn = new Scanner(System.in);
		int n = scn.nextInt();
		int[] keys = new int[n];
		for (int i = 0; i < n; i++) {
			keys[i] = scn.nextInt();
		}
		int[] frequency = new int[n];
		for (int i = 0; i < n; i++) {
			frequency[i] = scn.nextInt();
		}

		optimalbst(keys, frequency, n);
	}

	private static void optimalbst(int[] keys, int[] frequency, int n) {
		// make prefix sum of frequencies
		int[] fsum = new int[n];
		for (int i = 0; i < n; i++) {
			if (i == 0) {
				fsum[i] = frequency[i];
			} else {
				fsum[i] = frequency[i] + fsum[i - 1];
			}
		}

		int[][] cost = new int[n][n];
		for (int gap = 0; gap < n; gap++) {
			int si = 0;
			int ei = gap;
			while (ei < n) {
				if (gap == 0) {
					// diagonal
					cost[si][ei] = frequency[si];
				} else if (gap == 1) {
					int sum = fsum[ei];
					if (si - 1 >= 0) {
						sum -= fsum[si - 1];
					}
					cost[si][ei] = Math.min(cost[si][ei - 1], cost[si + 1][ei]) + sum;
				} else {
					cost[si][ei] = Integer.MAX_VALUE;
					int sum = fsum[ei];
					if (si - 1 >= 0) {
						sum -= fsum[si - 1];
					}
					for (int i = si; i < ei - 1; i++) {
						cost[si][ei] = Math.min(cost[si][i] + cost[i + 2][ei] + sum, cost[si][ei]);
					}
					cost[si][ei] = Math.min(Math.min(cost[si][ei - 1], cost[si + 1][ei]) + sum, cost[si][ei]);
				}
				si++;
				ei++;
			}
		}
		System.out.println(cost[0][n - 1]);
	}
}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Rod Cutting</span>
import java.io.*;
import java.util.*;

public class Main {

    public static int solution(int[] prices){
        int[] dp = new int[prices.length + 1];
        for(int i = 1; i < dp.length; i++){
            int max = Integer.MIN_VALUE;
            for(int j = 0; j < i; j++){
                max = Math.max(max, dp[i - j - 1] + prices[j]);
            }
            dp[i] = max;
        }
        return dp[dp.length - 1];
    }

    public static void main(String[] args) {
        Scanner scn = new Scanner(System.in);
        int n = scn.nextInt();
        int[] prices = new int[n];
        for(int i = 0 ; i < n ; i++){
            prices[i] = scn.nextInt();
        }
        System.out.println(solution(prices));
    }

}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Minimum Palindromic Cut</span>
import java.io.*;
import java.util.*;

public class Main {

	public static int minPalindromicCut(String s) {
		int n = s.length();
		boolean[][] dp = new boolean[s.length()][s.length()];
		for (int gap = 0; gap < s.length(); gap++) {
			int si = 0, ei = gap;
			while (ei < s.length()) {
				if (gap == 0) {
					dp[si][ei] = true;
				} else if (gap == 1) {
					dp[si][ei] = s.charAt(si) == s.charAt(ei);
				} else {
					if (s.charAt(si) == s.charAt(ei)) {
						dp[si][ei] = dp[si + 1][ei - 1];
					} else {
						dp[si][ei] = false;
					}
				}
				si++;
				ei++;
			}
		}

		int[] cuts = new int[n];
		for (int i = 0; i < n; i++) {
			if (dp[0][i] == true) {
				cuts[i] = 0;
			} else {
				cuts[i] = Integer.MAX_VALUE;
				for (int j = 0; j < i; j++) {
					if(dp[j + 1][i] == true && 1 + cuts[j] < cuts[i]){
						cuts[i] = 1 + cuts[j];
					}
				}
			}
		}
		return cuts[n - 1];
	}

	public static void main(String[] args) {
		Scanner scn = new Scanner(System.in);
		String str = scn.nextLine();
		System.out.println(minPalindromicCut(str));
	}
}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Longest Common Subsequence</span>
import java.io.*;
import java.util.*;

public class Main {

    public static void main(String[] args) throws Exception {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String str1 = br.readLine();
        String str2 = br.readLine();
        
        int[][] dp = new int[str1.length() + 1][str2.length() + 1];
        for(int i = dp.length - 2; i >= 0; i--){
            for(int j = dp[0].length - 2; j >= 0; j--){
                if(str1.charAt(i) == str2.charAt(j)){
                    dp[i][j] = 1 + dp[i + 1][j + 1];
                } else {
                    dp[i][j] = Math.max(dp[i + 1][j], dp[i][j + 1]);
                }
            }
        }

        System.out.println(dp[0][0]);
    }
}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Longest Palindromic Subsequences</span>
import java.io.*;
import java.util.*;

public class Main {

    public static void main(String[] args) throws Exception {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String str = br.readLine();
        
        int[][] dp = new int[str.length()][str.length()];
        for(int g = 0; g < dp.length; g++){
            for(int i = 0, j = g; j < dp[0].length; i++, j++){
                if(g == 0){
                    dp[i][j] = 1;
                } else if(g == 1){
                    dp[i][j] = str.charAt(i) == str.charAt(j)? 2: 1;
                } else {
                    if(str.charAt(i) == str.charAt(j)){
                        dp[i][j] = 2 + dp[i + 1][j - 1];
                    } else {
                        dp[i][j] = Math.max(dp[i + 1][j], dp[i][j - 1]);
                    }
                }
            }
        }

        System.out.println(dp[0][dp[0].length - 1]);
    }
}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Count Palindromic Subsequences</span>
import java.io.*;
import java.util.*;

public class Main {

    public static void main(String[] args) throws Exception {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String str = br.readLine();
        
        int[][] dp = new int[str.length()][str.length()];
        for(int g = 0; g < dp.length; g++){
            for(int i = 0, j = g; j < dp[0].length; i++, j++){
                if(g == 0){
                    dp[i][j] = 1;
                } else if(g == 1){
                    dp[i][j] = str.charAt(i) == str.charAt(j)? 3: 2;
                } else {
                    if(str.charAt(i) == str.charAt(j)){
                        dp[i][j] = dp[i + 1][j] + dp[i][j - 1] + 1;
                    } else {
                        dp[i][j] = dp[i + 1][j] + dp[i][j - 1] - dp[i + 1][j - 1];
                    }
                }
            }
        }

        System.out.println(dp[0][dp[0].length - 1]);
    }
}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Count Palindromic Substrings</span>
import java.io.*;
import java.util.*;

public class Main {

    public static void main(String[] args) throws Exception {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String str = br.readLine();
        
        boolean[][] dp = new boolean[str.length()][str.length()];
        int count = 0;
        for(int g = 0; g < dp.length; g++){
            for(int i = 0, j = g; j < dp[0].length; i++, j++){
                if(g == 0){
                    dp[i][j] = true;
                } else if(g == 1){
                    if(str.charAt(i) == str.charAt(j)){
                        dp[i][j] = true;
                    } else {
                        dp[i][j] = false;
                    }
                } else {
                    if(str.charAt(i) == str.charAt(j)){
                        dp[i][j] = dp[i + 1][j - 1];
                    } else {
                        dp[i][j] = false;
                    }
                }

                if(dp[i][j]){
                    count++;
                }
            }
        }

        System.out.println(count);
    }
}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Longest Palindromic Substring</span>
import java.io.*;
import java.util.*;

public class Main {

    public static void main(String[] args) throws Exception {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String str = br.readLine();
        
        boolean[][] dp = new boolean[str.length()][str.length()];
        int len = 0;
        for(int g = 0; g < dp.length; g++){
            for(int i = 0, j = g; j < dp[0].length; i++, j++){
                if(g == 0){
                    dp[i][j] = true;
                } else if(g == 1){
                    if(str.charAt(i) == str.charAt(j)){
                        dp[i][j] = true;
                    } else {
                        dp[i][j] = false;
                    }
                } else {
                    if(str.charAt(i) == str.charAt(j)){
                        dp[i][j] = dp[i + 1][j - 1];
                    } else {
                        dp[i][j] = false;
                    }
                }

                if(dp[i][j] && (g + 1) > len){
                    len = g + 1;
                }
            }
        }

        System.out.println(len);
    }
}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Count Distinct Subsequences</span>
import java.util.*;

public class Main{
    public static void main(String[] args){
        Scanner scn = new Scanner(System.in);
        String str = scn.next();
        int[] lastOccurence = new int[26];
        Arrays.fill(lastOccurence, -1);
        long[] dp = new long[str.length() + 1];
        dp[0] = 1;

        for(int i = 1; i <= str.length(); i++){
                dp[i] = 2 * dp[i - 1];
            if(lastOccurence[str.charAt(i - 1) - 'a'] != -1){
                dp[i] -= dp[lastOccurence[str.charAt(i - 1) - 'a']];
            }
            lastOccurence[str.charAt(i - 1) - 'a'] = (i - 1);
        }
        System.out.println((dp[str.length()] - 1));
    }
}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Count Of Distinct Palindromic Subsequences</span>
import java.io.*;
import java.util.*;

public class Main {

	public static void main(String[] args) {
		Scanner scn = new Scanner(System.in);
		String str = scn.next();
		System.out.println(solution(str));
	}

	public static int solution(String str) {
		int n = str.length();
		int[] low = new int[n];
		int[] high = new int[n];
		HashMap< Character, Integer> map = new HashMap<>();
		high[0] = -1;
		map.put(str.charAt(0), -1);
		for (int i = 1; i < str.length(); i++) {
			char ch = str.charAt(i);
			if (map.containsKey(ch)) {
				high[i] = map.get(ch);
				map.put(ch, i);
			} else {
				high[i] = -1;
				map.put(ch, i);
			}
		}
		map.clear();
		map.put(str.charAt(n - 1), n);
		low[n - 1] = n;
		for (int i = n - 2; i >= 0; i--) {
			char ch = str.charAt(i);
			if (map.containsKey(ch)) {
				low[i] = map.get(ch);
				map.put(ch, i);
			} else {
				low[i] = n;
				map.put(ch, i);
			}
		}
		int[][] dp = new int[n][n];
		char[] arr = str.toCharArray();
		for (int gap = 0; gap < n; gap++) {
			int si = 0;
			int ei = gap;
			while (ei < n) {
				if (gap == 0) {
					dp[si][ei] = 1;
				} else if (arr[si] != arr[ei]) {
					dp[si][ei] += dp[si + 1][ei] + dp[si][ei - 1] - dp[si + 1][ei - 1];
				} else {
					int lo = low[si];
					int hi = high[ei];
					if (lo == hi) {
						dp[si][ei] = (2 * dp[si + 1][ei - 1]) + 1;
					} else if (lo > hi) {

						// character not found!!
						// test case -> a (b-z) a
						// +2 -> 'a' and 'aa'
						dp[si][ei] = dp[si + 1][ei - 1] * 2 + 2;
					} else {
						dp[si][ei] = (2 * dp[si + 1][ei - 1]) - dp[lo + 1][hi - 1];
					}
				}
				si++;
				ei++;

			}
		}

		return (dp[0][n - 1]);
	}

}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Wildcard Pattern Matching</span>
import java.io.*;
import java.util.*;

public class Main {

	public static void main(String[] args) {
		Scanner scn = new Scanner(System.in);
		String s1 = scn.next();
		String s2 = scn.next();
		System.out.println(solution(s1,s2));
	}

	public static boolean solution(String str, String pattern) {
		boolean[][] dp = new boolean[pattern.length() + 1][str.length() + 1];
		for(int i = dp.length - 1; i >= 0 ;i--) {
			for(int j = dp[0].length - 1; j >= 0; j--) {
				if(i == dp.length - 1 && j == dp[0].length - 1) {
					dp[i][j] = true;
				}else if(i == dp.length - 1) {
					dp[i][j] = false;
				}else if(j == dp[0].length - 1) {
					if(pattern.charAt(i) == '*') {
						dp[i][j] = dp[i + 1][j];
					}
				}else {
					if(pattern.charAt(i) == '?') {
						dp[i][j] = dp[i + 1][j + 1];
					}else if(pattern.charAt(i) == '*') {
						dp[i][j] = dp[i][j + 1] || dp[i + 1][j];
					}else if(pattern.charAt(i) == str.charAt(j)) {
						dp[i][j] = dp[i + 1][j + 1];
					}else {
						dp[i][j] = false;
					}
				}
			}
		}
		
		return (dp[0][0]);
	}

}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Regular Expression Matching</span>
import java.io.*;
import java.util.*;

public class Main {

	public static void main(String[] args) {
		Scanner scn = new Scanner(System.in);
		String s1 = scn.next();
		String s2 = scn.next();
		System.out.println(solution(s1,s2));
	}

	public static boolean solution(String s, String p) {
		boolean[][] dp = new boolean[p.length() + 1][s.length() + 1];
        dp[0][0] = true;
        for(int i = 1 ; i < dp.length; i++){
            for(int j = 0 ; j < dp[0].length; j++){
                if(j == 0 ){
                    if(p.charAt(i - 1) == '*')
                        dp[i][j] = dp[i - 2][j];
                }else{
                    if(p.charAt(i - 1) == '.' || p.charAt(i - 1) == s.charAt(j - 1)){
                        dp[i][j] = dp[i - 1][j - 1];
                    }else if(p.charAt(i - 1) == '*'){
                        dp[i][j] = dp[i - 2][j];
                        if(p.charAt(i - 2) == s.charAt(j - 1) || p.charAt(i - 2) == '.')
                            dp[i][j] = dp[i][j - 1] || dp[i - 2][j];
                    }
                }
                
            }
        }
        return dp[dp.length - 1][dp[0].length - 1];
	}

}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Longest Common Substring</span>
import java.io.*;
import java.util.*;

public class Main {

	public static void main(String[] args) {
		Scanner scn = new Scanner(System.in);
		String s1 = scn.next();
		String s2 = scn.next();
		System.out.println(solution(s1,s2));
	}

	public static int solution(String s1, String s2){
		int[][] dp = new int[s1.length() + 1][s2.length() + 1];
		int ans = 0 ;
		for(int i = 1 ; i <= s1.length(); i++) {
			for(int j = 1 ; j <= s2.length() ;j++) {
				if(s1.charAt(i - 1) == s2.charAt(j - 1)) {
					dp[i][j] = dp[i - 1][j - 1] + 1;
				}
				ans = Math.max(ans, dp[i][j]);
			}
		}
		return ans;
	}

}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Longest Repeating Subsequence</span>
import java.io.*;
import java.util.*;

public class Main {

	public static void main(String[] args) {
		Scanner scn = new Scanner(System.in);
		String str = scn.next();
		System.out.println(solution(str));
	}

	public static int solution(String str){
		int n = str.length();
		int[][] dp = new int[n + 1][n + 1];
		for(int i = 1 ; i <= n; i++) {
			for(int j = 1; j <= n; j++) {
				if(str.charAt(i - 1) == str.charAt(j - 1) && i != j) {
					dp[i][j] = dp[i - 1][j - 1] + 1;
				}else {
					dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
				}
			}
		}
		return dp[n][n];
	}

}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Edit Distance</span>
import java.io.*;
import java.util.*;

public class Main {
	
	public static void main(String[] args) {
		Scanner scn = new Scanner(System.in);
		String s1 = scn.next();
		String s2 = scn.next();
		System.out.println(solution(s1,s2));
	}

	public static int solution(String str1, String str2) {
		int n1 = str1.length();
		int n2 = str2.length();
		int[][] dp = new int[n1 + 1][n2 + 1];
		for (int i = 0; i <= n1; i++) {
			dp[i][0] = i;
		}
		for (int i = 0; i <= n2; i++) {
			dp[0][i] = i;
		}
		
		for(int i = 1; i <= n1; i++) {
			for(int j = 1; j <= n2; j++) {
				if(str1.charAt(i - 1) == str2.charAt(j - 1)) {
					dp[i][j] = dp[i - 1][j - 1];
				}else {
					dp[i][j] = Math.min(dp[i - 1][j - 1], Math.min(dp[i - 1][j], dp[i][ j - 1])) + 1;
				}
			}
		}
		return (dp[n1][n2]);
	}

}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Scramble String</span>
import java.io.*;
import java.util.*;

public class Main {

	public static void main(String[] args) {
		Scanner scn = new Scanner(System.in);
		String s1 = scn.next();
		String s2 = scn.next();
		System.out.println(isScrambleTab(s1,s2));
	}

	public static boolean isScrambleTab(String s1, String s2) {
		if (s1.equals(s2))
			return true;

		int[] letters = new int[26];
		for (int i = 0; i < s1.length(); i++) {
			letters[s1.charAt(i) - 'a']++;
			letters[s2.charAt(i) - 'a']--;
		}
		for (int i = 0; i < 26; i++)
			if (letters[i] != 0)
				return false;

		int len = s1.length();

		boolean[][][] dp = new boolean[len][len][len + 1];
		for (int k = 1; k <= len; ++k)
			for (int i = 0; i + k <= len; ++i)
				for (int j = 0; j + k <= len; ++j)
					if (k == 1)
						dp[i][j][k] = s1.charAt(i) == s2.charAt(j);
					else
						for (int q = 1; q < k && !dp[i][j][k]; ++q) {
							dp[i][j][k] = (dp[i][j][q] && dp[i + q][j + q][k - q])
									|| (dp[i][j + k - q][q] && dp[i + q][j][k - q]);
						}
		return dp[0][0][len];
	}

}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Minimum Ascii Delete Sum For Two Strings</span>
import java.io.*;
import java.util.*;

public class Main {

	public static void main(String[] args) {
		Scanner scn = new Scanner(System.in);
		String s1 = scn.next();
		String s2 = scn.next();
		System.out.println(solution(s1, s2));
	}

	public static int solution(String s1, String s2) {
		int[][] dp = new int[s1.length() + 1][s2.length() + 1];

		for (int i = 1; i <= s1.length(); i++) {
			dp[i][0] = dp[i - 1][0] + (int) s1.charAt(i - 1);
		}
		for (int j = 1; j <= s2.length(); j++) {
			dp[0][j] = dp[0][j - 1] + (int) s2.charAt(j - 1);
		}

		for (int i = 1; i <= s1.length(); i++) {
			for (int j = 1; j <= s2.length(); j++) {
				if (s1.charAt(i - 1) == s2.charAt(j - 1)) {
					dp[i][j] = dp[i - 1][j - 1];
				} else {
					dp[i][j] = Math.min(dp[i - 1][j] + (int) (s1.charAt(i - 1)),
							dp[i][j - 1] + (int) (s2.charAt(j - 1)));
				}
			}
		}
		return dp[s1.length()][s2.length()];

	}

}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Minimum Cost To Make Two Strings Identical</span>
import java.io.*;
import java.util.*;

public class Main {

	public static void main(String[] args) {
		Scanner scn = new Scanner(System.in);
		String s1 = scn.next();
		String s2 = scn.next();
		int x = scn.nextInt();
		int y = scn.nextInt();
		System.out.println(solution(s1, s2,x, y));
	}

	public static int solution(String s1, String s2, int c1, int c2) {
		int[][] dp = new int[s1.length() + 1][s2.length() + 1];
		for(int i = 1; i <= s1.length(); i++) {
			for(int j = 1; j <= s2.length() ; j++) {
				if(s1.charAt(i - 1) == s2.charAt(j - 1)) {
					dp[i][j] = dp[i - 1][j - 1] + 1;
				}else {
					dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
				}
			}
		}
		int lcs = dp[s1.length()][s2.length()];
		int l1 = s1.length() - lcs;
		int l2 = s2.length() - lcs;
		return l1 * c1 + l2 * c2;
	}

}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Kadane's Algorithm</span>
import java.io.*;
import java.util.*;

public class Main {

    public static void main(String[] args) {
        Scanner scn = new Scanner(System.in);
        int n = scn.nextInt();
        int[] arr = new int[n];
        for (int i = 0; i < arr.length; i++) {
            arr[i] = scn.nextInt();
        }
        System.out.println(solution(arr));
    }

    public static int solution(int[] arr) {
        int finalans = arr[0];
        int curr = arr[0];
        for(int i = 1 ; i < arr.length; i++){
            curr = Math.max(arr[i], arr[i] + curr);
            finalans = Math.max(finalans, curr);
        }
        return finalans; 
    }
}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">K Concatenation</span>
import java.io.*;
import java.util.*;

public class Main {

    public static void main(String[] args) {
        Scanner scn = new Scanner(System.in);
        int n = scn.nextInt();
        int[] arr = new int[n];
        long sum = 0;
        for (int i = 0; i < arr.length; i++) {
            arr[i] = scn.nextInt();
            sum += arr[i];
        }
        int k = scn.nextInt();
        System.out.println(solution(arr, k, sum));
    }

    public static long solution(int[] arr, int k, long sum){
        if(k == 1){
            return kadanesForOne(arr);
        }
        if(sum > 0){
            return  kadanesForTwo(arr) + ((k - 2) * (sum));
        }else{
            return kadanesForTwo(arr);
        }
    }

    public static long kadanesForOne(int[] arr) {
        long finalans = arr[0];
        long curr = arr[0];
        for(int i = 1 ; i < arr.length; i++){
            curr = Math.max(arr[i], arr[i] + curr);
            finalans = Math.max(finalans, curr);
        }
        return finalans; 
    }

    public static long kadanesForTwo(int[] arr) {
        long finalans = arr[0];
        long curr = arr[0];
        for(int i = 1 ; i < 2 * arr.length; i++){
            curr = Math.max(arr[i % arr.length], arr[i % arr.length] + curr);
            finalans = Math.max(finalans, curr);
        }
        return finalans; 
    }
}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Maximum Sum Subarray With At Least K Elements</span>
import java.io.*;
import java.util.*;

public class Main {

    public static void main(String[] args) {
        Scanner scn = new Scanner(System.in);
        int n = scn.nextInt();
        int[] arr = new int[n];
        for (int i = 0; i < arr.length; i++) {
            arr[i] = scn.nextInt();
        }
        int k = scn.nextInt();
        System.out.println(solution(arr, k));
    }

    public static int solution(int[] arr, int k) {
		int[] maxSum = new int[arr.length];
		// use kadane's
		maxSum[0] = arr[0];
		for(int i = 1 ; i < arr.length; i++) {
			maxSum[i] = Math.max(arr[i], maxSum[i - 1] + arr[i]);
		}
		
		int sum = 0 ;
		for(int i = 0 ; i < k; i++) {
			sum += arr[i];
		}
		
		int ans = sum;;
		for(int i = k ; i < arr.length; i++) {
			sum = sum + arr[i] - arr[i - k];
			ans = Math.max(ans, sum);
			ans = Math.max(ans, sum + maxSum[i - k]);
		}
		
		return ans;
	}
}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Egg Drop</span>
import java.io.*;
import java.util.*;

public class Main {

	public static int eggDrop(int n, int k){
		int[][] dp = new int[n + 1][k + 1];
		//if number of floors == 1 ans number of eggs >= 1, then we need only one attempt
		for(int i = 1; i <= n; i++){
			dp[i][1] = 1;
		}
		//if number of eggs == 1
		for(int i = 1 ; i <= k; i++){
			dp[1][i] = i;
		}

		for(int i = 2; i <= n; i++){
			for(int j = 2; j <= k; j++){
				dp[i][j] = Integer.MAX_VALUE;
				int max = Integer.MIN_VALUE;
				for(int f = 1; f <= j; f++){
					max = 1 + Math.max(dp[i - 1][f - 1], dp[i][j - f]);
					if(max < dp[i][j]){
						dp[i][j] = max;
					}
				}
			}
		}
		return dp[n][k];
	} 

	public static void main(String[] args) {
		Scanner scn = new Scanner(System.in);
		//n -> number of eggs and k -> number of floors
		int n = scn.nextInt();
		int k = scn.nextInt();
		System.out.println(eggDrop(n,k));
	}	
}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Optimal Strategy For A Game</span>
import java.io.*;
import java.util.*;

public class Main {

	public static void main(String[] args) {
		Scanner scn = new Scanner(System.in);
		int n = scn.nextInt();
		int a[] = new int[n];
		for (int i = 0; i < a.length; i++) {
			a[i] = scn.nextInt();
		}
		optimalStrategy(a);
	}

	public static void optimalStrategy(int[] arr) {
		int[][] dp = new int[arr.length][arr.length];
		for (int gap = 0; gap < arr.length; gap++) {
			int i = 0, j = gap;
			while (j < arr.length) {
				int x = ((i + 2) <= j) ? dp[i + 2][j] : 0;
				int y = ((i + 1) <= (j - 1)) ? dp[i + 1][j - 1] : 0;
				int z = (i <= (j - 2)) ? dp[i][j - 2] : 0;
				dp[i][j] = Math.max(arr[i] + Math.min(x, y), arr[j] + Math.min(y, z));
				i++;
				j++;
			}
		}
		System.out.println(dp[0][dp[0].length - 1]);
	}

}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Cherry Pickup</span>
import java.io.*;
import java.util.*;

public class Main {

	public static void main(String[] args) {
		Scanner scn = new Scanner(System.in);
		int n = scn.nextInt();
		int[][] arr = new int[n][n];
		for(int i = 0; i < n; i++){
			for(int j = 0 ; j < n; j++){
				arr[i][j] = scn.nextInt();
			}
		}
		int ans = Math.max(0,Solution(0, 0, 0, arr, new int[n][n][n]));
		System.out.println(ans);
	}

	public static int Solution(int r1, int c1, int r2, int[][] arr, int[][][] dp) {
		int c2 = r1 + c1 - r2;
		// negative base case
		if (r1 >= arr.length || c1 >= arr.length || r2 >= arr.length || c2 >= arr.length)
			return 0;

		if(arr[r1][c1] == -1 || arr[r2][c2] == -1) {
			return Integer.MIN_VALUE;
		}
		//using dp
		if (dp[r1][c1][r2] != 0)
			return dp[r1][c1][r2];

		// if person 1 reached the bottom right
		if (r1 == arr.length - 1 && c1 == arr.length - 1)
			return arr[r1][c1];

		// if person 2 reached the bottom right
		if (r2 == arr.length - 1 && c2 == arr.length - 1)
			return arr[r2][c2];

		int cherries = 0;

		if (r1 == r2 && c1 == c2)
			cherries = arr[r1][c1];
		else
			cherries = arr[r1][c1] + arr[r2][c2];

		int f1 = Solution(r1 + 1, c1, r2 + 1, arr, dp);
		int f2 = Solution(r1, c1 + 1, r2, arr, dp);
		int f3 = Solution(r1 + 1, c1, r2, arr, dp);
		int f4 = Solution(r1, c1 + 1, r2 + 1, arr, dp);

		cherries += Math.max(Math.max(f1, f2), Math.max(f3, f4));
		dp[r1][c1][r2] = cherries;
		return cherries;
	}

}
                                
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Probability Of Knight In The Chessboard</span>
import java.io.*;
import java.util.*;

public class Main {

	public static void main(String[] args) {
		Scanner scn = new Scanner(System.in);
		int n = scn.nextInt();
		int k = scn.nextInt();
		int r = scn.nextInt();
		int c = scn.nextInt();
		solution(r, c, n, k);
	}

	public static void solution(int r, int c, int n, int k) {
		double[][] dp1 = new double[n][n];
		double[][] dp2 = new double[n][n];
		int[][] moves = { { 1, 2 }, { 2, 1 }, { -1, 2 }, { 1, -2 }, { -2, 1 }, { 2, -1 }, { -1, -2 }, { -2, -1 } };
		dp1[r][c] = 1;
		double factor = 8.0;
		for (int i = 0; i < k; i++) {
			for (int row = 0; row < n; row++) {
				for (int col = 0; col < n; col++) {
					if (dp1[row][col] > 0.0) {
						for (int move = 0; move < moves.length; move++) {
							int nr = row + moves[move][0];
							int nc = col + moves[move][1];
							if (nr >= 0 && nr < n && nc >= 0 && nc < n) {
								dp2[nr][nc] += dp1[row][col] / factor;
								;
							}
						}
					}
				}
			}
			dp1 = dp2;
			dp2 = new double[n][n];
		}

		double ans = 0.0;
		for (int i = 0; i < n; i++) {
			for (int j = 0; j < n; j++) {
				ans += dp1[i][j];
			}
		}
		System.out.println(ans);
	}

}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Highway Billboard</span>
import java.util.Scanner;
public class Main{
    public static int solution(int m , int[] x, int[] rev, int t) {
		int[] dp = new int[m + 1];
		int j = 0;
		for(int i = 1; i <= m; i++) {
            // System.out.println(i+"  "+j);
			if( j < x.length && x[j] == i) {
				dp[i] = Math.max(dp[i - 1],(i - t - 1 >= 0 ? dp[i - t - 1] : 0) + rev[j]);
				j++;
			}else {
				dp[i] = dp[ i - 1];
			}
        }
        return dp[m];
    }
    public static void input(int []arr,Scanner scn){
        for(int i = 0;i< arr.length;i++){
            arr[i] = scn.nextInt();
        }
    }
    public static void main(String []args){
        Scanner scn = new Scanner(System.in);   
        int m = scn.nextInt();
        int n = scn.nextInt();
        
        int x[] = new int[n];
        input(x, scn);

        int revenue[] = new int[n];
        input(revenue,scn);

        int t = scn.nextInt();

        System.out.println(solution(m, x, revenue, t));
        scn.close();
    }
}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Distinct Transformations</span>
import java.io.*;
import java.util.*;

public class Main {

	public static void main(String[] args) {
		Scanner scn = new Scanner(System.in);
		String s1 = scn.next();
		String s2 = scn.next();
		System.out.println(solution(s1, s2));
	}

	public static int solution(String s, String t) {
		int m = t.length();
		int n = s.length();
		int[][] dp = new int[m + 1][n + 1];
		for(int i = 0 ; i < dp.length ; i++) {
			dp[i][0] = 0;
		}
		
		for(int i = 0 ; i < dp[0].length; i++){
			dp[0][i] = 1;
		}
		
		for(int i = 1; i < dp.length; i++) {
			for(int j = 1; j  < dp[0].length ;j++) {
				if(s.charAt(j - 1) != t.charAt(i - 1)) {
					dp[i][j] = dp[i][j - 1];
				}else {
					dp[i][j] = dp[i - 1][j - 1] + dp[i][ j - 1];
				}
			}
		}
		return (dp[dp.length - 1][dp[0].length - 1]);
	}

}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Numeric Keypad</span>
import java.io.*;
import java.util.*;

public class Main {

	public static int solution(int n) {
		ArrayList<Integer>[] nextkeys = new ArrayList[10];
		for(int i = 0; i < 10; i++){
		    nextkeys[i] = new ArrayList<>();
		}
		
		nextkeys[0].add(0);
		nextkeys[0].add(8);
		nextkeys[1].add(1);
		nextkeys[1].add(2);
		nextkeys[1].add(4);
		nextkeys[2].add(1);
		nextkeys[2].add(2);
		nextkeys[2].add(3);
		nextkeys[2].add(5);
		nextkeys[3].add(2);
		nextkeys[3].add(3);
		nextkeys[3].add(6);
		nextkeys[4].add(1);
		nextkeys[4].add(4);
		nextkeys[4].add(5);
		nextkeys[4].add(7);
		nextkeys[5].add(2);
		nextkeys[5].add(4);
		nextkeys[5].add(5);
		nextkeys[5].add(6);
		nextkeys[5].add(8);
		nextkeys[6].add(3);
		nextkeys[6].add(5);
		nextkeys[6].add(6);
		nextkeys[6].add(9);
		nextkeys[7].add(4);
		nextkeys[7].add(7);
		nextkeys[7].add(8);
		nextkeys[8].add(0);
		nextkeys[8].add(5);
		nextkeys[8].add(7);
		nextkeys[8].add(8);
		nextkeys[8].add(9);
		nextkeys[9].add(6);
		nextkeys[9].add(8);
		nextkeys[9].add(9);
		
		int[][] dp = new int[n + 1][10];
		for(int i = 0 ; i < 10; i++){
		    dp[1][i] = 1;
		}
		
		for(int i = 2; i <= n; i++){
		    for(int j = 0; j < 10; j++){
		        for(int key = 0 ; key < nextkeys[j].size();key++){
		            dp[i][j] += dp[i - 1][nextkeys[j].get(key)]; 
		        }
		    }
		}
		
		int ans = 0;
		for(int j = 0 ; j < 10; j++){
		    ans += dp[n][j];
		}
		return ans;
	}
	public static void main(String[] args) {
		Scanner scn = new Scanner(System.in);
		System.out.println(solution(scn.nextInt()));
	}

}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Maximum Difference Of Zeros And Ones In Binary String</span>
import java.io.*;
import java.util.*;

public class Main {

	public static void main(String[] args) {
		Scanner scn = new Scanner(System.in);
		String str = scn.next();
		System.out.println(solution(str));
	}

	public static int solution(String str) {
		int ans = 0;
		int currSum = 0;
		for (int i = 0; i < str.length(); i++) {
			currSum += str.charAt(i) == '0' ? 1 : -1;
			if (currSum < 0) {
				currSum = 0;
			}
			ans = Math.max(ans, currSum);
		}
		return ans == 0 ? -1 : ans;
	}

}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Maximum Sum Of Two Non-overlapping Subarrays</span>
import java.io.*;
import java.util.*;

public class Main {

	public static void main(String[] args) {
		Scanner scn = new Scanner(System.in);
		int n = scn.nextInt();
		int[] arr = new int[n];
		for(int i = 0 ; i < arr.length; i++){
			arr[i] = scn.nextInt();
		}
		int x = scn.nextInt();
		int y = scn.nextInt();
		System.out.println(solution(arr,x,y));
	}

	public static int solution(int[] arr, int x, int y){
		int n = arr.length;
		int[] prefixSum = new int[n + 1];
		for(int i = 1; i <= n; i++){
			prefixSum[i] = prefixSum[i - 1] + arr[i - 1];
		}
		int xmax = prefixSum[x];
		int ymax = prefixSum[y];
		int ans = prefixSum[x + y];
		for(int i = x + y; i<= n; i++){
			xmax = Math.max(xmax, prefixSum[i - y] - prefixSum[i - (x + y)]);
			ymax = Math.max(ymax, prefixSum[i - x] - prefixSum[i - (x + y)]);
			ans = Math.max(ans, Math.max(xmax + prefixSum[i] - prefixSum[i - y], ymax + prefixSum[i] - prefixSum[i - x]));
		}
		return ans;
	}

}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Maximum Sum Of Three Non-overlapping Subarrays</span>
import java.io.*;
import java.util.*;

public class Main {

	public static void main(String[] args) {
		Scanner scn = new Scanner(System.in);
		int n = scn.nextInt();
		int[] arr = new int[n];
		for(int i = 0 ; i < arr.length; i++){
			arr[i] = scn.nextInt();
		}
		int k = scn.nextInt();
		solution(arr,k);
	}

	public static void solution(int[] arr, int k){
		if(arr == null || arr.length < 3){
            return;
        }
        int n = arr.length;
        int[] left = new int[n];
        int[] right = new int[n];
        int[] third = new int[n];
        
        int lsum = 0;
        for(int i = 0; i < k; i++){
            lsum += arr[i];
            if(i == k - 1){
                left[i] = lsum;
            }
        }
        int prev = arr[0];
        for(int i = k; i < n; i++){
            lsum += arr[i];
            left[i] = Math.max(left[i - 1], lsum - prev);
            prev += arr[i - k + 1];
        }
        
       int rsum = 0;
        for(int i = n - 1; i >= n - k; i--){
            rsum += arr[i];
            if(i == n - k){
                right[i] = rsum;
            }
        }
        prev = arr[n - 1];
        for(int i = n - k - 1; i >= 0; i--){
            rsum += arr[i];
            right[i] = Math.max(right[i + 1], rsum - prev);
            prev += arr[i + k - 1];
        }
        
        rsum = 0;
        for(int i = n - 1; i >= n - k; i--){
            rsum += arr[i];
            if(i == n - k){
                third[i] = rsum;
            }
        }
        prev = arr[n - 1];
        for(int i = n - k - 1; i >= 0; i--){
            rsum += arr[i];
            third[i] = rsum - prev;
            prev += arr[i + k - 1];
        }
        
        int ans = 0;
        int[] res = new int[3];
        
        for(int i = k, j = 1; i <= n - (2*k); i++){
            if(left[i - 1] + third[i] + right[i + k] > ans){
                ans = left[i - 1] + third[i] + right[i + k];
                 res[0] = i - k;
                 res[1] = i;
                 res[2] = i + k;
            }
        }
        
        int val = left[res[0] + k - 1];
        for(int i = 0; i <= res[0] + k - 1; i++){
            if(left[i] == val){
                res[0] = i - k + 1;
                break;
            }
        }
        
         val = right[res[2]];
        for(int i = res[2]; i <= n; i++){
            if(third[i] == val){
                res[2] = i;
                break;
            }
        }
        
		System.out.print(ans + " ");
		for(int a : res){
			System.out.print(a + " ");
		}
    }

}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Maximum Sum Of M Non-overlapping Subarrays</span>
import java.io.*;
import java.util.*;

public class Main {

	public static void main(String[] args) {
		Scanner scn = new Scanner(System.in);
		int n = scn.nextInt();
		int[] arr = new int[n];
		for(int i = 0 ; i < arr.length; i++){
			arr[i] = scn.nextInt();
		}
        int m = scn.nextInt();
        int k = scn.nextInt();
        // System.out.println(solution(arr, m , k));
        System.out.println(maxSumTab(arr,m,k));
	}

	public static int solution(int[] arr, int m, int k){
        int n = arr.length;
        int[] prefixSum = new int[n];
        for(int i = 0 ; i < k; i++){
            prefixSum[0] += arr[i];
        }
        for(int i = 1; i <= n - k; i++){
            prefixSum[i] = prefixSum[i - 1] + arr[i + k - 1] - arr[i - 1];
        }
        return maxSum(prefixSum, arr, m, k, 0);
    }

    public static int maxSum(int[] prefixSum, int[] arr, int m , int k, int vidx){
        if(m == 0){
            return 0;
        }
        if(vidx >= arr.length){
            return 0;
        }
        //include-exclude call
        int include = prefixSum[vidx] + maxSum(prefixSum, arr, m - 1, k, vidx + k);
        int exclude = 0 + maxSum(prefixSum, arr, m, k, vidx + 1);
        return Math.max(include, exclude);
    }

    public static int maxSumTab(int[] arr, int m, int k){
        int[] ssum = new int[arr.length];
        for(int i = arr.length - 1; i >= arr.length - k; i--){
            ssum[arr.length - 1] += arr[i];
        }
        for(int i = arr.length - 2; i >= k - 1; i--){
            ssum[i] = ssum[i + 1] + arr[i - k + 1] - arr[i + 1];
        }

        int[][] dp = new int[arr.length + 1][m + 1];
        for(int i = 1; i < dp.length; i++){
            for(int j = 1; j < dp[0].length; j++){
                dp[i][j] = Math.max(dp[i - 1][j],i - k >= 0 ? dp[i - k][j - 1] + ssum[i - 1] : 0);
            }
        }
        
        return dp[dp.length - 1][dp[0].length - 1];
    }

}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Arithmetic Slices 1</span>
import java.io.*;
import java.util.*;

public class Main {

	public static void main(String[] args) {
		Scanner scn = new Scanner(System.in);
		int n = scn.nextInt();
		int[] arr = new int[n];
		for(int i = 0 ; i < n; i++){
			arr[i] = scn.nextInt();
		}
		System.out.println(solution(arr));
	}

	public static int solution(int[] A) {
        int ans=0;
 	 	 
 	 	 // to store the count of slices including the element i in the last
 	 	 int[] dp=new int[A.length];
 	 	 for (int i = 2; i < A.length; i++) {
 	 	 	 if (A[i] - A[i - 1] == A[i - 1] - A[i - 2]) {
 	 	 	 	 // new count will be 1 more due to A[i-2],A[i-1],A[i]
 	 	 	 	 dp[i]=dp[i-1]+1;
 	 	 	 	 ans+=dp[i];
 	 	 	 }
 	 	 }
 	 	 return ans;
    }

}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Arithmetic Slices 2</span>
import java.io.*;
import java.util.*;

public class Main {

	public static void main(String[] args) {
		Scanner scn = new Scanner(System.in);
		int n = scn.nextInt();
		int[] arr = new int[n];
		for (int i = 0; i < n; i++) {
			arr[i] = scn.nextInt();
		}
		System.out.println(solution(arr));
	}

	public static int solution(int[] A) {
		if (A.length < 3) {
			return 0;
		}
		int res = 0;
		HashMap< Integer, Integer>[] map = new HashMap[A.length];

		for (int i = 0; i < A.length; i++) {
			map[i] = new HashMap<>(i);

			for (int j = 0; j < i; j++) {
				long diff = (long) A[i] - A[j];
				if (diff <= Integer.MIN_VALUE || diff > Integer.MAX_VALUE)
					continue;

				int d = (int) diff;
				int c1 = map[i].getOrDefault(d, 0);
				int c2 = map[j].getOrDefault(d, 0);
				res += c2;
				map[i].put(d, c1 + c2 + 1);
			}
		}

		return res;
	}

}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Word Break</span>
import java.io.*;
import java.util.*;

public class Main {

	public static void main(String[] args) {
		Scanner scn = new Scanner(System.in);
		int n = scn.nextInt();
		HashSet< String> dictionary = new HashSet< String>();
		for (int i = 0; i < n; i++) {
			dictionary.add(scn.next());
		}
		String sentence = scn.next();
		System.out.println(solution(sentence, dictionary));
	}

	public static boolean solution(String sentence, HashSet< String> dictionary) {
		boolean[] dp = new boolean[sentence.length() + 1];
		dp[0] = true;
		for (int i = 1; i < dp.length; i++) {
			char ch = sentence.charAt(i - 1);
			if (i == 1 && dictionary.contains(ch + "")) {
				dp[i] = true;
				continue;
			}
			for (int j = i - 1; j >= 0; j--) {
				if (dp[j] == true) {
					String strtobechecked = sentence.substring(j, i);
					if (dictionary.contains(strtobechecked)) {
						dp[i] = true;
					}
				}
			}
		}

		return dp[dp.length - 1];
	}

}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Temple Offerings</span>
import java.io.*;
import java.util.*;

public class Main {
	
	public static void main(String[] args) {
		Scanner scn = new Scanner(System.in);
		int n = scn.nextInt();
		int height[] = new int[n];
		for (int i = 0; i < n; i++) {
			height[i] = scn.nextInt();
		}

		int offering = totaloffering(height);
		System.out.println(offering);
	}

	private static int totaloffering(int[] height) {
		int[] larr = new int[height.length];
		larr[0] = 1;
		int[] rarr = new int[height.length];
		rarr[rarr.length - 1] = 1;
		int ans = 0;
		for (int i = 1; i < height.length; i++) {
			if (height[i] > height[i - 1]) {
				larr[i] = larr[i - 1] + 1;
			} else {
				larr[i] = 1;
			}
		}

		for (int i = height.length - 2; i >= 0; i--) {
			if (height[i] > height[i + 1]) {
				rarr[i] = rarr[i + 1] + 1;
			} else {
				rarr[i] = 1;
			}
		}
		
		for(int i = 0 ; i < height.length ;i++) {
			ans += Math.max(larr[i] , rarr[i]);
		}
		return ans;
		
	}

}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Minimum Insertions To Make Palindrome</span>
import java.io.*;
import java.util.*;

public class Main {
	
	public static void main(String[] args) {
		Scanner scn = new Scanner(System.in);
		String str = scn.next();
		System.out.println(str.length() - solution(str));
	}

	public static int solution(String str) {
		int n = str.length();
		int[][] dp = new int[n][n];
		for(int gap = 0; gap < n; gap++){
			int si = 0, ei = gap;
			while(ei < n){
				if(gap == 0){
					dp[si][ei] = 1;
				}else if(gap == 1){
					dp[si][ei] = str.charAt(si) == str.charAt(ei) ? 2 : 1;
				}else{
					dp[si][ei] = (str.charAt(si) == str.charAt(ei)) ? (dp[si + 1][ei - 1] + 2) : Math.max(dp[si + 1][ei],dp[si][ei - 1]);
				}
				si++;
				ei++;
			}
		}
		return dp[0][n - 1];
	}

}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Ugly Number</span>
import java.io.*;
import java.util.*;

public class Main {

  public static void main(String[] args) {
    Scanner scn = new Scanner(System.in);
    int n = scn.nextInt();
    System.out.println(solution(n));
  }

  public static int solution(int n) {
    int[] dp = new int[n + 1];
    int p2 = 1, p3 = 1, p5 = 1;
    dp[1] = 1;
    for (int i = 2; i <= n; i++) {
      int min = Math.min(2 * dp[p2], Math.min(3 * dp[p3], 5 * dp[p5]));
      dp[i] = min;
      if (min == 2 * dp[p2]) {
        p2++;
      }
      if (min == 3 * dp[p3]) {
        p3++;
      }
      if (min ==  5 * dp[p5]) {
        p5++;
      }
    }
    return dp[n];
  }

}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Super Ugly Number</span>
import java.io.*;
import java.util.*;

public class Main {

  public static void main(String[] args) {
    Scanner scn = new Scanner(System.in);
    int k = scn.nextInt();
    int[] primes = new int[k];
    for (int i = 0 ; i < k; i++) {
      primes[i] = scn.nextInt();
    }
    int n = scn.nextInt();
    System.out.println(solution(primes, n));
  }

  public static int solution(int[] primes, int n) {
    int[] dp = new int[n + 1];
    dp[1] = 1;
    int[] pointers = new int[primes.length];
    Arrays.fill(pointers, 1);

    for (int i = 2; i <= n; i++) {
      int min = Integer.MAX_VALUE;
      for (int j = 0; j < primes.length; j++) {
        min = Math.min(min, primes[j] * dp[pointers[j]]);
      }
      dp[i] = min;
      for (int j = 0; j < primes.length; j++) {
        if (min ==  (primes[j] * dp[pointers[j]])) {
          pointers[j]++;
        }
      }
    }
    return dp[n];
  }

}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Find Water In Glass</span>
import java.io.*;
import java.util.*;

public class Main {

  public static void main(String[] args) {
    Scanner scn = new Scanner(System.in);
    int k = scn.nextInt();
    int r = scn.nextInt();
    int c = scn.nextInt();
    System.out.println(solution(k, r, c));
  }

  public static double solution(int k, int r, int c) {
    double[][] dp = new double[k + 1][k + 1];
    dp[0][0] = k;
    for (int i = 0 ; i <= r; i++) {
      for (int j = 0 ; j <= i; j++) {

        if (dp[i][j] > 1.0) {
          double spare = dp[i][j] - (double)1;
          dp[i][j] = 1.0;
          dp[i + 1][j] += spare / (double)2;
          dp[i + 1][j + 1] += spare / (double)2;
        }

      }
    }
    return dp[r][c];
  }

}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Frog Jump</span>
import java.io.*;
import java.util.*;

public class Main {

  public static void main(String[] args) {
    Scanner scn = new Scanner(System.in);
    int n = scn.nextInt();
    int[] arr = new int[n];
    for (int i = 0 ; i < n; i++) {
      arr[i] = scn.nextInt();
    }

    System.out.println(solution(arr));
  }

  public static boolean solution(int[] stones) {
    HashMap< Integer, HashSet< Integer>> map = new HashMap< Integer, HashSet< Integer>>();
    map.put(0, new HashSet< Integer>());
    HashSet< Integer> s = map.get(0);
    s.add(1);
    map.put(0, s);
    for (int i = 1; i < stones.length ; i++) {
      map.put(stones[i], new HashSet< Integer>());
    }

    for (int i = 0 ;  i < stones.length - 1; i++) {
      int currstone = stones[i];
      for (int step : map.get(currstone)) {
        int reachedStone = currstone + step;
        if (reachedStone == stones[stones.length - 1]) {
          return true;
        }
        HashSet< Integer> set = new HashSet< Integer>();
        if (map.containsKey(reachedStone)) {
          set = map.get(reachedStone);
          if (step > 1) {
            set.add(step - 1);
          }
          set.add(step);
          set.add(step + 1);
        }
        map.put(reachedStone, set);
      }
    }
    return false;
  }

}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Interleaving Of Two Strings</span>
import java.io.*;
import java.util.*;

public class Main {

  public static void main(String[] args) {
    Scanner scn = new Scanner(System.in);
    String s1 = scn.nextLine();
    String s2 = scn.nextLine();
    String s3 = scn.nextLine();
    System.out.println(solution2(s1, s2, s3));
  }

  public static boolean solution2(String s1, String s2, String s3) {
    if (s1.length() + s2.length() != s3.length()) {
      return false;
    }

    boolean[][] dp = new boolean[s1.length() + 1][s2.length() + 1];

    for (int i = 0 ; i < dp.length; i++) {
      for (int j = 0 ; j < dp[0].length; j++) {
        if (i == 0 && j == 0) {
          dp[i][j] = true;
        } else if (i == 0) {
          dp[i][j] = s2.charAt(j - 1) == s3.charAt(i + j - 1) ? dp[i][j - 1] : false;
        } else if (j == 0) {
          dp[i][j] = s1.charAt(i - 1) == s3.charAt(i + j - 1) ? dp[i - 1][j] : false;
        } else {
          if (s1.charAt(i - 1) == s3.charAt(i + j - 1)) {
            dp[i][j] = dp[i - 1][j];
          }
          if (!dp[i][j] && s2.charAt(j - 1) == s3.charAt(i + j - 1)) {
            dp[i][j] = dp[i][j - 1];
          }
        }
      }
    }
    return dp[dp.length - 1][dp[0].length - 1];
  }

  public static boolean solution(String s1, String s2, String s3, int i, int j) {
    if (i == s1.length() && j == s2.length()) {
      return true;
    }


    if (i < s1.length() && s1.charAt(i) == s3.charAt(i + j)) {
      if (solution(s1, s2, s3, i + 1, j)) {
        return true;
      }
    }

    if (j < s2.length() && s2.charAt(j) == s3.charAt(i + j)) {
      if (solution(s1, s2, s3, i, j + 1)) {
        return true;
      }
    }
    return false;
  }

}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Maximum Length Of Repeated Subarray</span>
import java.io.*;
import java.util.*;

public class Main {

  public static void main(String[] args) {
    Scanner scn = new Scanner(System.in);
    int n = scn.nextInt();
    int[] arr1 = new int[n];
    for (int i = 0 ; i < n; i++) {
      arr1[i] = scn.nextInt();
    }

    int m = scn.nextInt();
    int[] arr2 = new int[m];
    for (int i = 0 ; i < m; i++) {
      arr2[i] = scn.nextInt();
    }
    System.out.println(solution(arr1, arr2));
  }

  public static int solution(int[] nums1, int[] nums2) {
    int[][] dp = new int[nums1.length + 1][nums2.length + 1];
    int ans = 0;
    for (int i = 1; i < dp.length; i++) {
      for (int j = 1; j < dp[0].length; j++) {
        if (nums1[i - 1] == nums2[j - 1]) {
          dp[i][j] = dp[i - 1][j - 1] + 1;
        }
        ans = Math.max(ans, dp[i][j]);
      }
    }

    return ans;
  }

}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Distinct Echo Substrings    </span>
                                                    
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Minimum Cost To Cut A Stick </span>
                                                    
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Delete And Earn             </span>
                                                    
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Minimum Cost For Tickets    </span>
import java.util.*;

  public class Main {
      public static void main(String[] args) {
 	 	  // TODO Auto-generated method stub
          Scanner scn= new Scanner(System.in);
          int n=scn.nextInt();
          int[] days= new int[n];
          for(int i=0;i< n;i++){
              days[i]=scn.nextInt();
          }
          int[] costs = new int[3];
          for(int i=0;i< 3;i++){
              costs[i]=scn.nextInt();
 	 	      }
 	 	      Arrays.sort(days);
          System.out.println(mincostTickets(days, costs));
 	 }
 
 	 public static int mincostTickets(int[] days, int[] costs) {
 	 	 
 	 	 int n = days[days.length - 1];
 	 	 // the dag is dp[i] = min{ dp[i-1] + cost[0], dp[i-7] + cost[1], dp[i-30] +
 	 	 // cost[2] }
 	 	 int[] dp = new int[n + 1];
 	 	 boolean[] travelDay = new boolean[n + 1];
 
 	 	 for (int i = 0; i < days.length; i++) {
 	 	 	 int day = days[i];
 	 	 	 travelDay[day] = true;
 	 	 }
 
 	 	 for (int i = 1; i < dp.length; i++) {
 	 	 	 if (travelDay[i] == false) {
 	 	 	 	  dp[i] = dp[i - 1];
 	 	 	 	  continue;
 	 	 	 }
 	 	 	 int one = dp[i - 1] + costs[0];
 	 	 	 int sev = dp[Math.max(0, i - 7)] + costs[1];
 	 	 	 int thir = dp[Math.max(0, i - 30)] + costs[2];
 
 	 	 	 dp[i] = Math.min(one, Math.min(sev, thir));
 	 	 }
 	 	 return dp[n];
 	 } 
}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Minimum Ascii Delete Sum For Two Strings</span>

<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Largest Multiple Of Three</span>

<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Graph</span>	
<span class="textStyle">Graph</span>	
<span class="textStyle">Graph</span>	
<span class="textStyle">Graph</span>	
<span class="textStyle">Graph</span>	

<span id="line">-----------------------------------------------------------------------------------------------------</span>

<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Number Of Enclaves</span>
import java.util.*;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.lang.*;

class Main {

  public static void main(String[] args) throws NumberFormatException, IOException {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

    String[] st = br.readLine().split(" ");
    int m = Integer.parseInt(st[0]);
    int n = Integer.parseInt(st[1]);

    int[][] arr = new int[m][n];

    for (int i = 0; i < m; i++) {
      st = br.readLine().split(" ");
      for (int j = 0; j < n; j++) {
        arr[i][j] = Integer.parseInt(st[j]);
      }
    }

    System.out.println(numEnclaves(arr));

  }

  public static int numEnclaves(int[][] A) {
    int result = 0;
    for (int i = 0; i < A.length; i++) {
      for (int j = 0; j < A[i].length; j++) {
        if (i == 0 || j == 0 || i == A.length - 1 || j == A[i].length - 1)
          dfs(A, i, j);
      }
    }

    for (int i = 0; i < A.length; i++) {
      for (int j = 0; j < A[i].length; j++) {
        if (A[i][j] == 1)
          result++;
      }
    }

    return result;
  }

  public static void dfs(int a[][], int i, int j) {
    if (i >= 0 && i <= a.length - 1 && j >= 0 && j <= a[i].length - 1 && a[i][j] == 1) {
      a[i][j] = 0;
      dfs(a, i + 1, j);
      dfs(a, i - 1, j);
      dfs(a, i, j + 1);
      dfs(a, i, j - 1);
    }
  }
}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Number Of Distinct Island</span>
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.*;

class Main {

  public static void main(String[] args) throws NumberFormatException, IOException {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

    String[] st = br.readLine().split(" ");
    int n = Integer.parseInt(st[0]);
    int m = Integer.parseInt(st[1]);

    int[][] arr = new int[n][m];

    for (int i = 0; i < n; i++) {
      st = br.readLine().split(" ");
      for (int j = 0; j < m; j++) {
        arr[i][j] = Integer.parseInt(st[j]);
      }
    }

    System.out.println(numDistinctIslands(arr));

  }

  public static StringBuilder psf = new StringBuilder();

  public static int numDistinctIslands(int[][] arr) {
    if (arr == null || arr.length < 1 || arr[0].length < 1)
      return 0;

    HashSet< String> set = new HashSet< String>();

    for (int i = 0; i < arr.length; i++) {
      for (int j = 0; j < arr[0].length; j++) {
        psf = new StringBuilder();
        if (arr[i][j] == 1) {
          psf.append("o");
          funcall(arr, i, j);
          set.add(psf.toString());
        }
      }
    }

    return set.size();
  }

  private static void funcall(int[][] arr, int i, int j) {

    arr[i][j] = 0;
    if (i + 1 < arr.length && arr[i + 1][j] == 1) {
      psf.append("d");
      funcall(arr, i + 1, j);

    }
    if (i - 1 >= 0 && arr[i - 1][j] == 1) {
      psf.append("u");
      funcall(arr, i - 1, j);

    }
    if (j + 1 < arr[0].length && arr[i][j + 1] == 1) {
      psf.append("r");
      funcall(arr, i, j + 1);

    }
    if (j - 1 >= 0 && arr[i][j - 1] == 1) {
      psf.append("l");
      funcall(arr, i, j - 1);

    }
    psf.append("b");

  }

}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">sZero One Matrix</span>
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.*;

class Main {
  private static class Pair {
    int x;
    int y;

    Pair(int x, int y) {
      this.x = x;
      this.y = y;
    }
  }

  private static int[][] dirs = new int[][] { { 1, 0 }, { -1, 0 }, { 0, 1 }, { 0, -1 } };

  public static void main(String[] args) throws NumberFormatException, IOException {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

    String[] st = br.readLine().split(" ");
    int n = Integer.parseInt(st[0]);
    int m = Integer.parseInt(st[1]);

    int[][] arr = new int[n][m];

    for (int i = 0; i < n; i++) {
      st = br.readLine().split(" ");
      for (int j = 0; j < m; j++) {
        arr[i][j] = Integer.parseInt(st[j]);
      }
    }

    int[][] ans = updateMatrix(arr);

    for (int i = 0; i < n; i++) {
      for (int j = 0; j < m; j++) {
        System.out.print(ans[i][j] + " ");
      }
      System.out.println();
    }

  }

  public static int[][] updateMatrix(int[][] matrix) {
    LinkedList< Pair> queue = new LinkedList<>();

    for (int i = 0; i < matrix.length; i++) {
      for (int j = 0; j < matrix[0].length; j++) {
        if (matrix[i][j] == 1) {
          matrix[i][j] = -1;
        } else {
          queue.addLast(new Pair(i, j));
        }
      }
    }
    int length = 0;
    while (!queue.isEmpty()) {
      int size = queue.size();
      length++;
      for (int i = 0; i < size; i++) {
        Pair rem = queue.removeFirst();
        for (int[] dir : dirs) {
          int idash = rem.x + dir[0];
          int jdash = rem.y + dir[1];

          if (idash >= 0 && jdash >= 0 && idash < matrix.length && jdash < matrix[0].length) {
            if (matrix[idash][jdash] == -1) {
              matrix[idash][jdash] = length;
              queue.addLast(new Pair(idash, jdash));
            }
          }
        }
      }
    }
    return matrix;
  }
}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Rotting Oranges</span>
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.*;

class Main {

  public static void main(String[] args) throws NumberFormatException, IOException {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

    String[] st = br.readLine().split(" ");
    int n = Integer.parseInt(st[0]);
    int m = Integer.parseInt(st[1]);

    int[][] arr = new int[n][m];

    for (int i = 0; i < n; i++) {
      st = br.readLine().split(" ");
      for (int j = 0; j < m; j++) {
        arr[i][j] = Integer.parseInt(st[j]);
      }
    }

    System.out.println(orangesRotting(arr));

  }

  public static class Pair {
    int row;
    int col;

    Pair(int row, int col) {
      this.row = row;
      this.col = col;
    }

  }

  public static int orangesRotting(int[][] grid) {
    if (grid == null || grid.length == 0)
      return 0;
    int rows = grid.length;
    int cols = grid[0].length;
    LinkedList< Pair> queue = new LinkedList<>();
    int fresh = 0;
    for (int i = 0; i < rows; i++) {
      for (int j = 0; j < cols; j++) {
        if (grid[i][j] == 2) {
          queue.addLast(new Pair(i, j));
        } else if (grid[i][j] == 1) {
          fresh++;
        }
      }
    }
    if (fresh == 0)
      return 0;

    int count = -1;
    int[][] dirs = { { 1, 0 }, { -1, 0 }, { 0, 1 }, { 0, -1 } };
    while (!queue.isEmpty()) {
      ++count;
      int size = queue.size();
      for (int i = 0; i < size; i++) {
        Pair point = queue.removeFirst();
        for (int dir[] : dirs) {
          int x = point.row + dir[0];
          int y = point.col + dir[1];
          if (x < 0 || y < 0 || x >= rows || y >= cols || grid[x][y] == 0 || grid[x][y] == 2)
            continue;
          grid[x][y] = 2;
          queue.addLast(new Pair(x, y));
          fresh--;
        }
      }
    }
    return fresh == 0 ? count : -1;
  }
}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">As Far From Land As Possible</span>
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.*;

public class Main {

  public static void main(String[] args) throws NumberFormatException, IOException {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

    int n = Integer.parseInt(br.readLine());
    int[][] arr = new int[n][n];

    for (int i = 0; i < n; i++) {
      String[] st = br.readLine().split(" ");
      for (int j = 0; j < n; j++) {
        arr[i][j] = Integer.parseInt(st[j]);
      }
    }

    System.out.println(maxDistance(arr));

  }

  public static int maxDistance(int[][] grid) {
    int m = grid.length, n = grid[0].length;
    Queue< int[]> queue = new LinkedList<>();
    for (int i = 0; i < m; i++) {
      for (int j = 0; j < n; j++) {
        if (grid[i][j] == 1) {
          queue.offer(new int[] { i, j });
        }
      }
    }

    if (queue.size() == 0 || queue.size() == m * n) {
      return -1;
    }

    int[][] dirs = { { 0, 1 }, { 0, -1 }, { 1, 0 }, { -1, 0 } };
    int max = 0;
    while (!queue.isEmpty()) {
      int size = queue.size();
      for (int i = 0; i < size; i++) {
        int[] point = queue.poll();
        for (int[] dir : dirs) {
          int x = point[0] + dir[0];
          int y = point[1] + dir[1];
          if (x >= 0 && y >= 0 && x < m && y < n && grid[x][y] == 0) {
            grid[x][y] = 1;
            queue.offer(new int[] { x, y });
          }
        }
      }
      max++;
    }
    return max - 1;
  }
}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Shortest Bridge</span>
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.*;

public class Main {

  public static void main(String[] args) throws NumberFormatException, IOException {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

    int n = Integer.parseInt(br.readLine());
    int[][] arr = new int[n][n];

    for (int i = 0; i < n; i++) {
      String[] st = br.readLine().split(" ");
      for (int j = 0; j < n; j++) {
        arr[i][j] = Integer.parseInt(st[j]);
      }
    }

    System.out.println(shortestBridge(arr));

  }

  private static int[][] dirs = new int[][] { { 1, 0 }, { -1, 0 }, { 0, 1 }, { 0, -1 } };
  private static Queue< int[]> queue = new LinkedList<>();
  private static int[][] grid;
  private static int row, col;

  public static int shortestBridge(int[][] A) {
    grid = A;
    row = A.length;
    col = A[0].length;
    boolean[][] visited = new boolean[row][col];
    boolean found = false;

    for (int i = 0; i < row && !found; i++) {
      for (int j = 0; j < col && !found; j++) {
        if (A[i][j] == 1) {
          dfs(visited, i, j);
          found = true;
        }
      }
    }

    int step = 0;
    while (!queue.isEmpty()) {
      int size = queue.size();
      while (size-- > 0) {
        int[] cell = queue.poll();
        for (int[] d : dirs) {
          int x = cell[0] + d[0];
          int y = cell[1] + d[1];
          if (x >= 0 && y >= 0 && x < row && y < col && !visited[x][y]) {
            if (A[x][y] == 1) {
              return step;
            }
            queue.offer(new int[] { x, y });
            visited[x][y] = true;
          }
        }
      }
      step++;
    }
    return -1;
  }

  private static void dfs(boolean[][] visited, int x, int y) {
    if (x < 0 || y < 0 || x >= row || y >= col || visited[x][y] || grid[x][y] == 0) {
      return;
    }
    visited[x][y] = true;
    queue.offer(new int[] { x, y });
    for (int[] d : dirs) {
      dfs(visited, x + d[0], y + d[1]);
    }
  }
}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Bus Routes</span>
import java.io.*;
import java.util.*;

class Main {
  public static void main(String[] args) throws NumberFormatException, IOException {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

    int n = Integer.parseInt(br.readLine());
    int m = Integer.parseInt(br.readLine());

    int[][] arr = new int[n][m];

    for (int i = 0; i < n; i++) {
      String[] st = br.readLine().split(" ");
      for (int j = 0; j < m; j++) {
        arr[i][j] = Integer.parseInt(st[j]);
      }
    }

    String[] st1 = br.readLine().split(" ");
    int src = Integer.parseInt(st1[0]);
    int dest = Integer.parseInt(st1[1]);
    System.out.println(numBusesToDestination(arr, src, dest));

  }

  public static int numBusesToDestination(int[][] routes, int S, int T) {
    int n = routes.length;
    HashMap< Integer, ArrayList< Integer>> stopmap = new HashMap<>();

    for (int i = 0; i < n; i++) {
      for (int j = 0; j < routes[i].length; j++) {
        int busstop = routes[i][j];

        ArrayList< Integer> busno = stopmap.getOrDefault(busstop, new ArrayList<>());
        busno.add(i);
        stopmap.put(busstop, busno);
      }
    }

    LinkedList< Integer> queue = new LinkedList<>();
    HashSet< Integer> stopvis = new HashSet<>();
    HashSet< Integer> busnovis = new HashSet<>();

    queue.addLast(S);
    stopvis.add(S);
    int level = 0;
    while (queue.size() > 0) {
      int size = queue.size();
      while (size-- > 0) {
        Integer rem = queue.removeFirst();
        if (rem == T) {
          return level;
        }

        ArrayList< Integer> buses = stopmap.get(rem);
        for (int bus : buses) {
          if (busnovis.contains(bus) == true) {
            continue;
          }

          int[] arr = routes[bus];
          for (int stop : arr) {
            if (stopvis.contains(stop) == true) {
              continue;
            }
            queue.addLast(stop);
            stopvis.add(stop);
          }
          busnovis.add(bus);
        }
      }
      level++;
    }
    return -1;
  }
}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Sliding Puzzle</span>

import java.io.*;
import java.util.*;

class Main {
  public static void main(String[] args) throws NumberFormatException, IOException {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

    int[][] arr = new int[2][3];

    for (int i = 0; i < 2; i++) {
      String[] st = br.readLine().split(" ");
      for (int j = 0; j < 3; j++) {
        arr[i][j] = Integer.parseInt(st[j]);
      }
    }

    System.out.println(slidingPuzzle(arr));
  }

  public static int slidingPuzzle(int[][] board) {
    String target = "123450";
    String start = "";
    for (int i = 0; i < board.length; i++) {
      for (int j = 0; j < board[0].length; j++) {
        start += board[i][j];
      }
    }
    HashSet< String> visited = new HashSet<>();
    int[][] dirs = new int[][] { { 1, 3 }, { 0, 2, 4 }, { 1, 5 }, { 0, 4 }, { 1, 3, 5 }, { 2, 4 } };
    Queue< String> queue = new LinkedList<>();
    queue.offer(start);
    visited.add(start);
    int res = 0;
    while (!queue.isEmpty()) {
      int size = queue.size();
      for (int i = 0; i < size; i++) {
        String cur = queue.poll();
        if (cur.equals(target)) {
          return res;
        }
        int zero = cur.indexOf('0');
        for (int dir : dirs[zero]) {
          String next = swap(cur, zero, dir);
          if (visited.contains(next)) {
            continue;
          }
          visited.add(next);
          queue.offer(next);

        }
      }
      res++;
    }
    return -1;
  }

  private static String swap(String str, int i, int j) {
    StringBuilder sb = new StringBuilder(str);
    sb.setCharAt(i, str.charAt(j));
    sb.setCharAt(j, str.charAt(i));
    return sb.toString();
  }
}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Minimum Number Of Swaps Required To Sort An Array</span>
import java.io.*;
import java.util.*;

public class Main {
  public static void main(String[] args) throws Exception {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    int n = Integer.parseInt(br.readLine());
    int[] arr = new int[n];

    String[] st = br.readLine().split(" ");
    for (int i = 0; i < n; i++) {
      arr[i] = Integer.parseInt(st[i]);
    }

    System.out.println(minSwaps(arr));
  }

  public static int minSwaps(int[] arr1) {
    int N = arr1.length;
    Pair[] arr = new Pair[N];
    for (int i = 0; i < arr.length; i++) {
      arr[i] = new Pair(arr1[i], i);
    }

    int ans = 0;
    Arrays.sort(arr);
    boolean[] visited = new boolean[N];
    for (int i = 0; i < arr.length; i++) {
      if (visited[i] == true || arr[i].idx == i) {
        continue;
      } else {
        int cycle = 0;
        int j = i;
        while (!visited[j]) {
          visited[j] = true;
          cycle++;
          j = arr[j].idx;
        }
        ans += (cycle - 1);
      }
    }
    return ans;
  }

  private static class Pair implements Comparable<Pair> {
    int val;
    int idx;

    Pair(int val, int idx) {
      this.val = val;
      this.idx = idx;
    }

    @Override
    public int compareTo(Pair o) {
      return this.val - o.val;
    }
  }
}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Pepcoder And Reversing</span>
import java.io.*;
import java.util.*;

public class Main {

	public static void main(String[] args) throws NumberFormatException, IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		String[] st = br.readLine().split(" ");
		int n = Integer.parseInt(st[0]);
		int m = Integer.parseInt(st[1]);

		ArrayList< ArrayList< Pair>> graph = new ArrayList<>();

		for (int i = 0; i < n; i++) {
			graph.add(new ArrayList<>());
		}

		for (int i = 0; i < m; i++) {
			st = br.readLine().split(" ");
			int u = Integer.parseInt(st[0]) - 1;
			int v = Integer.parseInt(st[1]) - 1;
			graph.get(u).add(new Pair(v, 0));
			graph.get(v).add(new Pair(u, 1));
		}

		LinkedList< Pair> queue = new LinkedList<>();
		boolean[] vis = new boolean[n];
		queue.addLast(new Pair(0, 0));

		while (queue.size() > 0) {
			Pair rem = queue.removeFirst();

			if (rem.vtx == n - 1) {
				System.out.println(rem.wt);
				return;
			}

			vis[rem.vtx] = true;

			for (Pair nbrs : graph.get(rem.vtx)) {
				if (vis[nbrs.vtx] == true) {
					continue;
				}

				if (nbrs.wt == 0) {
					queue.addFirst(new Pair(nbrs.vtx, rem.wt));
				} else {
					queue.addLast(new Pair(nbrs.vtx, rem.wt + 1));
				}
			}
		}
		System.out.println(-1);
	}
}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Pepcoding Course Schedule</span>
                        
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.LinkedList;
import java.util.PriorityQueue;
import java.util.Queue;

public class Main {

	public static void main(String[] args) throws NumberFormatException, IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		String[] st = br.readLine().split(" ");
		int n = Integer.parseInt(st[0]);
		int m = Integer.parseInt(st[1]);

		int[][] prerequisites = new int[m][2];
		for (int i = 0; i < m; i++) {
			st = br.readLine().split(" ");
			prerequisites[i][0] = Integer.parseInt(st[0]);
			prerequisites[i][1] = Integer.parseInt(st[1]);
		}
		ArrayList< ArrayList< Integer>> graph = new ArrayList<>();
		for (int i = 0; i < n; i++) {
			graph.add(new ArrayList<>());
		}

		for (int i = 0; i < prerequisites.length; i++) {
			int u = prerequisites[i][0];
			int v = prerequisites[i][1];

			graph.get(v).add(u);
		}

		int[] ans = findOrder(n, graph);

		for (int val : ans) {
			System.out.print(val + " ");
		}
	}

	public static int[] findOrder(int numCourses, ArrayList<ArrayList<Integer>> graph) {

		int[] ans = new int[numCourses];
		int[] indegree = new int[numCourses];

		for (int i = 0; i < numCourses; i++) {
			for (int nbrs : graph.get(i)) {
				indegree[nbrs]++;
			}
		}

		LinkedList<Integer> queue = new LinkedList<>();
		for (int i = 0; i < indegree.length; i++) {
			if (indegree[i] == 0) {
				queue.addLast(i);
			}
		}

		int idx = 0;
		while (queue.size() > 0) {
			int rem = queue.removeFirst();
			ans[idx] = rem;
			idx++;

			for (int nbrs : graph.get(rem)) {
				indegree[nbrs]--;
				if (indegree[nbrs] == 0) {
					queue.addLast(nbrs);
				}
			}
		}

		if (idx == numCourses) {
			return ans;
		} else {
			return new int[] { -1 };
		}
	}
}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Alien Dictionary</span>
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.*;

public class Main {

  public static void main(String[] args) throws NumberFormatException, IOException {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

    int n = Integer.parseInt(br.readLine());

    String[] words = br.readLine().split(" ");

    System.out.println(alienOrder(words));
  }

  public static String alienOrder(String[] words) {
    Map< Character, Set< Character>> map = new HashMap< Character, Set< Character>>();
    Map< Character, Integer> degree = new HashMap< Character, Integer>();
    String result = "";
    if (words == null || words.length == 0)
      return result;
    for (String s : words) {
      for (char c : s.toCharArray()) {
        degree.put(c, 0);
      }
    }
    for (int i = 0; i < words.length - 1; i++) {
      boolean flag = false;
      String cur = words[i];
      String next = words[i + 1];
      int length = Math.min(cur.length(), next.length());
      for (int j = 0; j < length; j++) {
        char c1 = cur.charAt(j);
        char c2 = next.charAt(j);
        if (c1 != c2) {
          Set< Character> set = new HashSet< Character>();
          if (map.containsKey(c1))
            set = map.get(c1);
          if (!set.contains(c2)) {
            set.add(c2);
            map.put(c1, set);
            degree.put(c2, degree.get(c2) + 1);
          }
          flag = true;
          break;
        }
      }

      if (flag == false && next.length() < cur.length()) {
        return "";
      }
    }
    Queue< Character> q = new LinkedList< Character>();
    for (char c : degree.keySet()) {
      if (degree.get(c) == 0)
        q.add(c);
    }
    while (!q.isEmpty()) {
      char c = q.remove();
      result += c;
      if (map.containsKey(c)) {
        for (char c2 : map.get(c)) {
          degree.put(c2, degree.get(c2) - 1);
          if (degree.get(c2) == 0)
            q.add(c2);
        }
      }
    }

    if (result.length() != degree.size()) {
      return "";
    }

    return result;
  }
}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Kruskal Algorithm</span>

import java.util.*;
import java.io.*;

public class Main {

  public static void main(String[] args) throws Exception {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    int v = Integer.parseInt(br.readLine());
    int e = Integer.parseInt(br.readLine());

    int[][] edges = new int[e][3];
    for (int i = 0; i < e; i++) {
      String[] st = br.readLine().split(" ");
      edges[i][0] = Integer.parseInt(st[0]);
      edges[i][1] = Integer.parseInt(st[1]);
      edges[i][2] = Integer.parseInt(st[2]);
    }

    System.out.println(minCostToSupplyWater(v, edges));
  }

  static int[] parent;
  static int[] rank;

  public static class Pair implements Comparable<Pair> {
    int u;
    int v;
    int wt;

    Pair(int u, int v, int wt) {
      this.u = u;
      this.v = v;
      this.wt = wt;
    }

    @Override
    public int compareTo(Pair o) {
      return this.wt - o.wt;
    }
  }

  public static int minCostToSupplyWater(int n, int[][] pipes) {
    Pair[] edges = new Pair[pipes.length];

    for (int i = 0; i < pipes.length; i++) {
      int u = pipes[i][0];
      int v = pipes[i][1];
      int wt = pipes[i][2];
      edges[i] = new Pair(u, v, wt);
    }

    int ans = 0;
    Arrays.sort(edges);
    parent = new int[n + 1];
    rank = new int[n + 1];

    for (int i = 0; i < parent.length; i++) {
      parent[i] = i;
      rank[i] = 1;
    }

    for (int i = 0; i < edges.length; i++) {
      int u = edges[i].u;
      int v = edges[i].v;
      int wt = edges[i].wt;

      boolean flag = union(u, v);
      if (flag == false) {
        ans += wt;
      }
    }

    return ans;

  }

  public static int find(int x) {
    if (parent[x] == x) {
      return x;
    }
    int temp = find(parent[x]);
    parent[x] = temp;
    return temp;
  }

  public static boolean union(int x, int y) {
    int lx = find(x);
    int ly = find(y);

    if (lx == ly) {
      return true;
    }

    if (rank[lx] > rank[ly]) {
      parent[ly] = lx;
    } else if (rank[lx] < rank[ly]) {
      parent[lx] = ly;
    } else {
      parent[lx] = ly;
      rank[ly]++;
    }

    return false;
  }
}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Optimize Water Distribution</span>
import java.io.*;
import java.util.*;

class Main {
  public static void main(String[] args) throws NumberFormatException, IOException {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

    String[] st = br.readLine().split(" ");
    int v = Integer.parseInt(st[0]);
    int e = Integer.parseInt(st[1]);

    int[] wells = new int[v];
    String[] words = br.readLine().split(" ");

    for (int i = 0; i < wells.length; i++) {
      wells[i] = Integer.parseInt(words[i]);
    }

    int[][] pipes = new int[e][3];
    for (int i = 0; i < e; i++) {
      String[] st1 = br.readLine().split(" ");
      pipes[i][0] = Integer.parseInt(st1[0]);
      pipes[i][1] = Integer.parseInt(st1[1]);
      pipes[i][2] = Integer.parseInt(st1[2]);

    }

    System.out.println(minCostToSupplyWater(v, wells, pipes));

  }

  public static class Pair implements Comparable<Pair> {
    int u;
    int v;
    int wt;

    Pair(int u, int v, int wt) {
      this.u = u;
      this.v = v;
      this.wt = wt;
    }

    @Override
    public int compareTo(Pair o) {
      return this.wt - o.wt;
    }
  }

  public static  int minCostToSupplyWater(int n, int[] wells, int[][] pipes) {
    Pair[] edges = new Pair[pipes.length + n];

    int idx = 0;
    for (int i = 0; i < pipes.length; i++) {
      int u = pipes[i][0];
      int v = pipes[i][1];
      int wt = pipes[i][2];
      edges[idx] = new Pair(u, v, wt);
      idx++;
    }

    for (int i = 0; i < wells.length; i++) {
      int u = 0;
      int v = i + 1;
      int wt = wells[i];
      edges[idx] = new Pair(u, v, wt);
      idx++;
    }

    ArrayList< ArrayList< Pair>> graph = new ArrayList<>();
    for (int i = 0; i <= n; i++) {
      graph.add(new ArrayList<>());
    }
    for (int i = 0; i < edges.length; i++) {
      int u = edges[i].u;
      int v = edges[i].v;
      int wt = edges[i].wt;
      graph.get(u).add(new Pair(0, v, wt));
      graph.get(v).add(new Pair(0, u, wt));
    }
    int ans = 0;
    PriorityQueue< Pair> pq = new PriorityQueue<>();
    pq.add(new Pair(0, 0, 0));
    boolean[] vis = new boolean[n + 1];
    while (pq.size() > 0) {
      Pair rem = pq.remove();
      if (vis[rem.v] == true) {
        continue;
      }
      vis[rem.v] = true;
      ans += rem.wt;
      ArrayList< Pair> nbrs = graph.get(rem.v);

      for (Pair nbr : nbrs) {
        if (vis[nbr.v] == false) {
          pq.add(new Pair(0, nbr.v, nbr.wt));
        }
      }
    }
    return ans;
  }


}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Swim In Rising Water</span>

<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Minimum Cost To Connect All Cities</span>
import java.io.*;
import java.util.*;

public class Main {
  static class Edge implements Comparable< Edge> {
    int v;
    int wt;

    Edge(int nbr, int wt) {
      this.v = nbr;
      this.wt = wt;
    }

    @Override
    public int compareTo(Edge o) {
      return this.wt - o.wt;
    }
  }

  public static void main(String[] args) throws Exception {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

    int vtces = Integer.parseInt(br.readLine());
    ArrayList< ArrayList< Edge>> graph = new ArrayList<>();
    for (int i = 0; i < vtces; i++) {
      graph.add(new ArrayList<>());
    }

    int edges = Integer.parseInt(br.readLine());
    for (int i = 0; i < edges; i++) {
      String[] parts = br.readLine().split(" ");
      int v1 = Integer.parseInt(parts[0]);
      int v2 = Integer.parseInt(parts[1]);
      int wt = Integer.parseInt(parts[2]);
      graph.get(v1).add(new Edge(v2, wt));
      graph.get(v2).add(new Edge(v1, wt));
    }

    int src = 0;
    int ans = 0;
    PriorityQueue< Edge> queue = new PriorityQueue<>();
    queue.add(new Edge(src, 0));
    boolean[] visited = new boolean[vtces];
    while (queue.size() > 0) {
      Edge rem = queue.remove();

      if (visited[rem.v] != false) {
        continue;
      }
      visited[rem.v] = true;
      ans += rem.wt;

      for (Edge e : graph.get(rem.v)) {
        if (visited[e.v] == false) {
          queue.add(new Edge(e.v, e.wt));
        }
      }
    }

    System.out.println(ans);
  }

}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Bellman Ford</span>
You are given 2 integers N and M , N is the number of vertices, M is the number of edges. You'll also
 be given ai, bi and wi where ai and bi represents an edge from a vertex ai to a vertex bi and wi 
 respresents the weight of that edge.
Your task is to find the shortest path from source vertex (vertex number 1) to all other vertices.

Note : use bellman ford algo.
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Negative Weight Cycle Detection</span>
                        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		String[] st = br.readLine().split(" ");
		int n = Integer.parseInt(st[0]);
		int m = Integer.parseInt(st[1]);

		int[][] edges = new int[m][3];
		for (int i = 0; i < m; i++) {
			st = br.readLine().split(" ");
			edges[i][0] = Integer.parseInt(st[0]);
			edges[i][1] = Integer.parseInt(st[1]);
			edges[i][2] = Integer.parseInt(st[2]);
		}
		System.out.println(isNegativeWeightCycle(n, edges));
	}

	public static int isNegativeWeightCycle(int n, int[][] edges) {
		int[] path = new int[n];
		Arrays.fill(path, Integer.MAX_VALUE);
		path[0] = 0;
		for (int i = 0; i < n - 1; i++) {
			for (int j = 0; j < edges.length; j++) {
				int u = edges[j][0];
				int v = edges[j][1];
				int wt = edges[j][2];

				if (path[u] == Integer.MAX_VALUE) {
					continue;
				}

				if (path[v] > path[u] + wt) {
					path[v] = path[u] + wt;
				}
			}
		}

		for (int i = 0; i < edges.length; i++) {
			int u = edges[i][0];
			int v = edges[i][1];
			int wt = edges[i][2];

			if (path[u] == Integer.MAX_VALUE) {
				continue;
			}

			if (path[v] > path[u] + wt) {
				return 1;
			}
		}
		return 0;
                        
                        
                                
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Kosaraju Algorithm</span>
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		String[] st = br.readLine().split(" ");
		int n = Integer.parseInt(st[0]);
		int m = Integer.parseInt(st[1]);

		ArrayList< ArrayList< Integer>> graph = new ArrayList<>();
		for (int i = 0; i < n; i++) {
			graph.add(new ArrayList<>());
		}

		for (int i = 0; i < m; i++) {
			st = br.readLine().split(" ");
			int u = Integer.parseInt(st[0]) - 1;
			int v = Integer.parseInt(st[1]) - 1;
			graph.get(u).add(v);
		}

		System.out.println(kosaraju(graph, n));
	}

	public static int kosaraju(ArrayList< ArrayList< Integer>> list, int N) {
		int count = 0;
		Stack< Integer> stack = new Stack<>();
		boolean[] visited = new boolean[N];
		for (int i = 0; i < N; i++) {
			if (!visited[i]) {
				dfs(list, visited, i, stack);
			}
		}
		ArrayList< ArrayList< Integer>> tanspose = transpose(list, N);
		visited = new boolean[N];
		while (!stack.isEmpty()) {
			int cur = stack.pop();
			if (!visited[cur]) {

				dfs(tanspose, visited, cur);
				count++;
			}
		}

		return count;
	}

	public static void dfs(ArrayList< ArrayList< Integer>> graph, boolean[] visited, int cur) {
		visited[cur] = true;
		for (Integer neighbour : graph.get(cur)) {
			if (!visited[neighbour]) {
				dfs(graph, visited, neighbour);
			}
		}
	}

	public static void dfs(ArrayList< ArrayList< Integer>> graph, boolean[] visited, int cur, Stack<Integer> stack) {
		visited[cur] = true;
		for (Integer neighbour : graph.get(cur)) {
			if (!visited[neighbour]) {
				dfs(graph, visited, neighbour, stack);
			}
		}
		stack.push(cur);
	}

	public static ArrayList< ArrayList< Integer>> transpose(ArrayList< ArrayList< Integer>> graph, int N) {
		ArrayList< ArrayList< Integer>> result = new ArrayList<>();
		for (int i = 0; i < N; i++) {
			result.add(new ArrayList< Integer>());
		}
		for (int i = 0; i < N; i++) {
			for (Integer target : graph.get(i)) {
				result.get(target).add(i);
			}
		}
		return result;

                                
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Mother Vertex</span>
import java.io.*;
import java.util.*;


public class Main{
    	public static void main(String args[]) throws Exception {

		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		String[] st = br.readLine().split(" ");
		int n = Integer.parseInt(st[0]);
		int m = Integer.parseInt(st[1]);

		ArrayList< ArrayList< Integer>> graph = new ArrayList<>();
		for (int i = 0; i < n; i++) {
			graph.add(new ArrayList<>());
		}

		for (int i = 0; i < m; i++) {
			st = br.readLine().split(" ");
			int u = Integer.parseInt(st[0]) - 1;
			int v = Integer.parseInt(st[1]) - 1;
			graph.get(u).add(v);
		}

		System.out.println(findMotherVertex(n, graph));
	}
    public static int findMotherVertex(int N, ArrayList< ArrayList< Integer>>adj){
        Stack< Integer> stack = new Stack<>();
		boolean[] visited = new boolean[N];
		for (int i = 0; i < N; i++) {
			if (!visited[i]) {
				dfs(adj, visited, i, stack);
			}
		}
		count=0;
		visited = new boolean[N];
		int ans = stack.pop();
		dfs(adj,visited,ans);
		if(count == N){
		 return ans+1;
		}else{
		   return -1;
		}
		
    }
   static int count;

   public static void dfs(ArrayList<ArrayList<Integer>> graph, boolean[] visited, int cur) {
		visited[cur] = true;
		count++;
		for (Integer neighbour : graph.get(cur)) {
			if (!visited[neighbour]) {
				dfs(graph, visited, neighbour);
			}
		}
	}
    public static void dfs(ArrayList<ArrayList<Integer>> graph, boolean[] visited, int cur, Stack<Integer> stack) {
		visited[cur] = true;
		for (Integer neighbour : graph.get(cur)) {
			if (!visited[neighbour]) {
				dfs(graph, visited, neighbour, stack);
			}
		}
		stack.push(cur);
	}
}
                                
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Articulation Point'</span>
import java.util.*;
import java.io.*;

class Main {
  static int time = 0;

  private static void AP_Bridges(ArrayList<ArrayList<Integer>> graph, int[] disc, int[] low, int[] parent,
                                 boolean[] Apoint, boolean[] visited, int src) {
    disc[src] = low[src] = ++time;
    int counter = 0;
    visited[src] = true;
    for (int e = 0; e < graph.get(src).size(); e++) {
      int nbr = graph.get(src).get(e);
      if (parent[src] == nbr) {
        continue;
      } else if (visited[nbr] == true) {
        low[src] = Math.min(low[src], disc[nbr]);
      } else {
        parent[nbr] = src;
        AP_Bridges(graph, disc, low, parent, Apoint, visited, nbr);
        low[src] = Math.min(low[src], low[nbr]);
        if (parent[src] == -1) {
          counter++;
          if (counter >= 2) {
            Apoint[src] = true;
          }
        } else {
          if (low[nbr] >= disc[src]) {
            Apoint[src] = true;
          }
        }

      }
    }
  }

  public static void main(String[] args) {
    // TODO Auto-generated method stub
    Scanner scn = new Scanner(System.in);


    int v = scn.nextInt();
    int e = scn.nextInt();
    ArrayList<ArrayList<Integer>> g = new ArrayList<>();
    for (int i = 0; i < v; i++) {
      g.add(new ArrayList<>());
    }
    for (int i = 0; i < e; i++) {
      int v1 = scn.nextInt();
      int v2 = scn.nextInt();
      g.get(v1 - 1).add(v2 - 1);
      g.get(v2 - 1).add(v1 - 1);
    }

    boolean A_point[] = new boolean[v];
    int[] parent = new int[v];
    parent[0] = -1;
    AP_Bridges(g, new int[v], new int[v], parent, A_point, new boolean[v], 0);
    int count = 0;
    for (int i = 0; i < v; i++) {
      if (A_point[i]) {
        count++;
      }
    }
    System.out.println(count);



  }

}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Critical Connection</span>
import java.util.*;
import java.io.*;

class Main {
  static int time;

  private static void AP_Bridges(ArrayList<ArrayList<Integer>> graph, int[] disc, int[] low, int[] parent,
                                 List<List<Integer>> ans, boolean[] visited, int src) {
    disc[src] = low[src] = ++time;
    visited[src] = true;
    for (int e = 0; e < graph.get(src).size(); e++) {
      int nbr = graph.get(src).get(e);
      if (parent[src] == nbr) {
        continue;
      } else if (visited[nbr] == true) {
        low[src] = Math.min(low[src], disc[nbr]);
      } else {
        parent[nbr] = src;
        AP_Bridges(graph, disc, low, parent, ans, visited, nbr);
        low[src] = Math.min(low[src], low[nbr]);
        if (low[nbr] > disc[src]) {
          List<Integer> temp = new ArrayList<>();
          temp.add(src);
          temp.add(nbr);
          ans.add(temp);
        }

      }
    }
  }

  public static List<List<Integer>> criticalConnections(int n, List<List<Integer>> Edges) {
    ArrayList<ArrayList<Integer>> graph = new ArrayList<>();
    for (int i = 0; i < n; i++) {
      graph.add(new ArrayList<>());
    }
    for (List<Integer> list : Edges) {
      int u = list.get(0);
      int v = list.get(1);
      graph.get(u).add(v);
      graph.get(v).add(u);
    }
    time = 0;
    int[] parent = new int[n];
    parent[0] = -1;
    List<List<Integer>> ans = new ArrayList<>();
    AP_Bridges(graph, new int[n], new int[n], parent, ans, new boolean[n], 0);
    return ans;

  }

  public static void main(String[] args) throws Exception {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    String[] st = br.readLine().split(" ");
    int n = Integer.parseInt(st[0]);
    int e = Integer.parseInt(st[1]);
    List<List<Integer>> edges = new ArrayList<>();


    for (int i = 0; i < e; i++) {
      edges.add(new ArrayList<>());
      st = br.readLine().split(" ");
      edges.get(i).add(Integer.parseInt(st[0]));
      edges.get(i).add(Integer.parseInt(st[1]));
    }

    System.out.println(criticalConnections(n, edges));

  }

}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Remove Max Number Of Edges To Keep Graph Fully Traversable</span>
import java.io.*;
import java.util.*;

public class Main {
  public static void main(String[] args) throws Exception {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    String[] st = br.readLine().split(" ");
    int n = Integer.parseInt(st[0]);
    int m = Integer.parseInt(st[1]);

    int[][] edges = new int[m][3];
    for (int i = 0; i < m; i++) {
      st = br.readLine().split(" ");
      edges[i][0] = Integer.parseInt(st[0]);
      edges[i][1] = Integer.parseInt(st[1]);
      edges[i][2] = Integer.parseInt(st[2]);
    }
    Main obj = new Main();
    System.out.println(obj.maxNumEdgesToRemove(n, edges));
  }

  public int maxNumEdgesToRemove(int n, int[][] edges) {
    Arrays.sort(edges, (a, b) -> Integer.compare(b[0], a[0]));
    int[] parenta = new int[n + 1];
    int[] parentb = new int[n + 1];
    int[] ranka = new int[n + 1];
    int[] rankb = new int[n + 1];
    int counta = 1;
    int countb = 1;

    for (int i = 0; i <= n; i++) {
      parenta[i] = i;
      parentb[i] = i;
    }

    int removedEdges = 0;

    for (int[] e : edges) {
      if (e[0] == 3) {
        boolean mergeda = union(e[1], e[2], parenta, ranka);
        boolean mergedb = union(e[1], e[2], parentb, rankb);
        if (mergeda == true) {
          counta++;
        }
        if (mergedb == true) {
          countb++;
        }

        if (!mergeda && !mergedb) {
          removedEdges++;
        }
      } else if (e[0] == 1) {
        boolean mergeda = union(e[1], e[2], parenta, ranka);
        if (mergeda == true) {
          counta++;
        }

        if (!mergeda) {
          removedEdges++;
        }
      } else {
        boolean mergedb = union(e[1], e[2], parentb, rankb);
        if (mergedb == true) {
          countb++;
        }
        if (!mergedb) {
          removedEdges++;
        }
      }
    }

    if (countb != n || counta != n) {
      return -1;
    }

    return removedEdges;
  }

  public int find(int x, int[] parent) {
    if (parent[x] == x) {
      return x;
    }
    int temp = find(parent[x], parent);
    parent[x] = temp;
    return temp;
  }

  public boolean union(int x, int y, int[] parent, int[] rank) {
    int lx = find(x, parent);
    int ly = find(y, parent);

    if (lx == ly)
      return false;

    if (rank[lx] > rank[ly]) {
      parent[ly] = lx;
    } else if (rank[lx] < rank[ly]) {
      parent[lx] = ly;
    } else {
      parent[lx] = ly;
      rank[ly]++;
    }
    return true;
  }
}
                                
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Number Of Island 2</span>
import java.util.*;
import java.io.*;

public class Main {
  public static void main(String[] args) throws NumberFormatException, IOException {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    String[] st = br.readLine().split(" ");
    int m = Integer.parseInt(st[0]);
    int n = Integer.parseInt(st[1]);
    int q = Integer.parseInt(st[2]);

    int[][] pos = new int[q][2];
    for (int i = 0; i < q; i++) {
      st = br.readLine().split(" ");
      pos[i][0] = Integer.parseInt(st[0]);
      pos[i][1] = Integer.parseInt(st[1]);
    }

    System.out.println(numIslands2(m, n, pos));
  }

  public static List<Integer> numIslands2(int m, int n, int[][] positions) {
    List<Integer> res = new LinkedList<>();
    if (m <= 0 || n <= 0) {
      return res;
    }

    int count = 0;
    int[] roots = new int[m * n];
    int[] size = new int[m * n];
    Arrays.fill(roots, -1);
    int[][] directions = new int[][] { { -1, 0 }, { 1, 0 }, { 0, -1 }, { 0, 1 } };

    for (int[] p : positions) {
      int island = p[0] * n + p[1];
      roots[island] = island;
      size[island]++;
      count++;

      for (int[] dir : directions) {
        int x = p[0] + dir[0], y = p[1] + dir[1];
        int neighbor = x * n + y;

        if (x < 0 || x >= m || y < 0 || y >= n || roots[neighbor] == -1) {
          continue;
        }
        int neighborRoot = find(neighbor, roots);
        int islandRoot = find(island, roots);
        if (islandRoot != neighborRoot) {

          if (size[islandRoot] >= size[neighborRoot]) {
            size[islandRoot] += size[neighborRoot];
            roots[neighborRoot] = islandRoot;
          } else {
            size[neighborRoot] += size[islandRoot];
            roots[islandRoot] = neighborRoot;
          }
          count--;
        }
      }

      res.add(count);
    }

    return res;
  }

  private static int find(int id, int[] roots) {
    if (roots[id] == id) {
      return id;
    } else {
      roots[id] = find(roots[id], roots);
      return roots[id];
    }
  }
}
                                
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Regions Cut By Slashes    </span>
                                                  
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Reconstruct Itinerary     </span>
                                                  
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Rank Transform Of A Matrix</span>
                                                  
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Accounts Merge            </span>
                                                  
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Minimize Malware Spread   </span>
                                                  
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Minimize Malware Spread 2 </span>

<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Redundant Connection</span>
import java.util.*;
import java.io.*;

public class Main {
  public static void main(String[] args) throws NumberFormatException, IOException {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    String[] st = br.readLine().split(" ");
    int n = Integer.parseInt(st[0]);

    int[][] pos = new int[n][2];
    for (int i = 0; i < n; i++) {
      st = br.readLine().split(" ");
      pos[i][0] = Integer.parseInt(st[0]);
      pos[i][1] = Integer.parseInt(st[1]);
    }

    int[] ans = findRedundantConnection(pos);
    System.out.println(ans[0] + " " + ans[1]);
  }

  public static int[] findRedundantConnection(int[][] edges) {
    int[] parent = new int[2001];
    for (int i = 0; i < parent.length; i++)
      parent[i] = i;

    for (int[] edge : edges) {
      int f = edge[0], t = edge[1];
      if (find(parent, f) == find(parent, t))
        return edge;
      else
        parent[find(parent, f)] = find(parent, t);
    }

    return new int[2];
  }

  private static int find(int[] parent, int f) {
    if (f != parent[f]) {
      parent[f] = find(parent, parent[f]);
    }
    return parent[f];
  }
}
                                
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Minimize Hamming Distance After Swap Operations</span>

<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Redundant Connection 2</span>
import java.util.*;
import java.io.*;

public class Main {
  public static void main(String[] args) throws NumberFormatException, IOException {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    String[] st = br.readLine().split(" ");
    int n = Integer.parseInt(st[0]);

    int[][] pos = new int[n][2];
    for (int i = 0; i < n; i++) {
      st = br.readLine().split(" ");
      pos[i][0] = Integer.parseInt(st[0]);
      pos[i][1] = Integer.parseInt(st[1]);
    }

    int[] ans = findRedundantDirectedConnection(pos);
    System.out.println(ans[0] + " " + ans[1]);
  }

  static int[] parent;
  static int[] rank;

  public static int[] findRedundantDirectedConnection(int[][] edges) {
    int n = edges.length;
    int[] indegree = new int[n + 1];
    Arrays.fill(indegree, -1);
    int bl1 = -1;
    int bl2 = -1;
    for (int i = 0; i < edges.length; i++) {
      int[] edge = edges[i];
      int u = edge[0];
      int v = edge[1];

      if (indegree[v] == -1) {
        indegree[v] = i;
      } else {
        bl1 = i;
        bl2 = indegree[v];
      }
    }
    parent = new int[n + 1];
    rank = new int[n + 1];
    for (int i = 1; i < parent.length; i++) {
      parent[i] = i;
      rank[i] = 1;
    }
    for (int i = 0; i < edges.length; i++) {
      if (bl1 == i) {
        continue;
      }
      int[] edge = edges[i];
      int u = edge[0];
      int v = edge[1];
      boolean flag = union(u, v);
      if (flag == true) {
        if (bl1 == -1) {
          return edge;
        } else {
          return edges[bl2];
        }
      }
    }
    return edges[bl1];
  }

  public static int find(int x) {
    if (parent[x] == x) {
      return x;
    }
    int temp = find(parent[x]);
    parent[x] = temp;
    return temp;
  }

  public static boolean union(int x, int y) {
    int lx = find(x);
    int ly = find(y);

    if (lx == ly) {
      return true;
    }

    if (rank[lx] > rank[ly]) {
      parent[ly] = lx;
    } else if (rank[lx] < rank[ly]) {
      parent[lx] = ly;
    } else {
      parent[lx] = ly;
      rank[ly]++;
    }

    return false;
  }

}
                                
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Satisfiability Of Equality Equation</span>
import java.io.*;
import java.util.*;

public class Main {

  public static void main(String[] args) throws Exception {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    int n = Integer.parseInt(br.readLine());

    String[] arr = new String[n];
    for (int i = 0; i < n; i++) {
      arr[i] = br.readLine();
    }

    System.out.println(equationsPossible(arr));
  }

  static int[] parent;
  static int[] rank;

  public static boolean equationsPossible(String[] equations) {
    parent = new int[26];
    rank = new int[26];
    for (int i = 0; i < 26; ++i) {
      parent[i] = i;
      rank[i] = 1;
    }

    for (String e : equations) {
      if (e.charAt(1) == '=') {
        union(e.charAt(0) - 'a', e.charAt(3) - 'a');
      }
    }

    for (String e : equations) {
      if (e.charAt(1) == '!' && find(e.charAt(0) - 'a') == find(e.charAt(3) - 'a')) {
        return false;
      }
    }

    return true;
  }

  public static void union(int x, int y) {
    int lx = find(x);
    int ly = find(y);

    if (lx != ly) {
      if (rank[lx] > rank[ly]) {
        parent[ly] = lx;
      } else if (rank[lx] < rank[ly]) {
        parent[lx] = ly;
      } else {
        parent[lx] = ly;
        rank[ly]++;
      }
    }

  }

  public static int find(int x) {
    if (x == parent[x]) {
      return x;
    }

    int temp = find(parent[x]);
    parent[x] = temp;
    return temp;
  }
}

                                
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Sentence Similarity</span>
import java.io.*;
import java.util.*;

public class Main {

  public static void main(String[] args) throws Exception {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    int n = Integer.parseInt(br.readLine());

    String[] sentence1 = br.readLine().split(" ");
    String[] sentence2 = br.readLine().split(" ");

    int m = Integer.parseInt(br.readLine());

    String[][] pairs = new String[m][2];
    for (int i = 0; i < m; i++) {
      pairs[i] = br.readLine().split(" ");
    }

    System.out.println(areSentencesSimilarTwo(sentence1, sentence2, pairs));

  }

  static HashMap< String, String> parent;
  static HashMap< String, Integer> rank;

  public static boolean areSentencesSimilarTwo(String[] Sentence1, String[] Sentence2, String[][] pairs) {
    rank = new HashMap<>();
    parent = new HashMap<>();
    if (Sentence1.length != Sentence2.length) {
      return false;
    }
    parent = new HashMap<>();
    for (String[] p : pairs) {
      union(p[0], p[1]);
    }

    for (int i = 0; i < Sentence1.length; i++) {
      if (!Sentence1[i].equals(Sentence2[i]) && !find(Sentence1[i]).equals(find(Sentence2[i]))) {
        return false;
      }
    }
    return true;
  }

  public static String find(String s) {
    if (!parent.containsKey(s)) {
      parent.put(s, s);
      rank.put(s, 1);
    }

    if (s.equals(parent.get(s))) {
      return s;
    }
    String temp = find(parent.get(s));
    parent.put(s, temp);
    return temp;
  }

  public static void union(String x, String y) {
    String lx = find(x);
    String ly = find(y);

    if (lx.equals(ly) == false) {
      if (rank.get(lx) > rank.get(ly)) {
        parent.put(ly, lx);
      } else if (rank.get(lx) < rank.get(ly)) {
        parent.put(lx, ly);
      } else {
        parent.put(lx, ly);
        rank.put(ly, rank.get(ly) + 1);
      }
    }
  }

}

                                
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Park Regions</span>
import java.io.*;

public class Main {
  static int par[];
  public static int fp(int u) {
    if (par[u] == u) return u;

    return par[u] = fp(par[u]);
  }
  public static void merge(int u, int v) {
    // System.out.println(u+" "+v);
    int p1 = fp(u);
    int p2 = fp(v);

    if (p1 != p2) {
      par[p2] = p1;
    }
  }

  public static int parkRegions(String[] grid) {
    int n = grid.length;
    par = new int[4 * n * n];

    for (int i = 0; i < par.length; i++) {
      par[i] = i;
    }

    for (int i = 0; i < n; i++) {
      for (int j = 0; j < grid[i].length(); j++) {
        int root = 4 * (i * n + j);
        char c = grid[i].charAt(j);

        if (c != '\\') {
          merge(root, root + 1);
          merge(root + 3, root + 2);
        }
        if (c != '/') {
          merge(root, root + 3);
          merge(root + 1, root + 2);
        }

        if (j + 1 < n) {
          merge(root + 2, root + 4);
        }
        if (j - 1 >= 0) {
          merge(root, root - 2);
        }

        if (i + 1 < n) {
          merge(root + 3, root + 4 * n + 1);
        }

        if (i - 1 >= 0) {
          merge((root - 4 * n) + 3, root + 1);
        }
      }
    }

    int ans = 0;
    for (int i = 0; i < par.length; i++) {
      if (fp(i) == i) {
        ans++;
      }
    }
    return ans;
  }
  public static void main(String[] args) throws Exception{
    InputStreamReader r = new InputStreamReader(System.in);
    BufferedReader br = new BufferedReader(r);
    int n = Integer.parseInt(br.readLine());

    String[] park = new String[n];
    for (int i = 0; i < n; i++) {
      park[i] = br.readLine();
    }

    int ans = parkRegions(park);
    System.out.println(ans);
  }
}

                                
                                
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Kill The Most Monsters</span>
import java.util.*;
import java.io.*;

public class Main {
  static int[] par;
  static int[] size;
  static int mons;
  public static int findPar(int u) {
    if (par[u] == -1) {
      mons++;
      par[u] = u;
    }

    if (par[u] == u) return u;

    return par[u] = findPar(par[u]);
  }

  public static void merge(int p1, int p2) {
    if (size[p1] > size[p2]) {
      par[p2] = p1;
      size[p1] += size[p2];
    } else {
      par[p1] = p2;
      size[p2] += size[p1];
    }
  }

  public static int removeMonsters(int[][] monsters) {
    mons = 0;
    par = new int[20001];
    Arrays.fill(par, -1);
    size = new int[20001];
    Arrays.fill(size, 1);
    for (int[] m : monsters) {
      int p1 = findPar(m[0]);
      int p2 = findPar(m[1] + 10000);

      if (p1 != p2) {
        mons--;
        merge(p1, p2);
      }
    }

    return monsters.length - mons;
  }

  public static void main(String[] args) {

    Scanner scn = new Scanner(System.in);
    int n = scn.nextInt();

    int[][] monsters = new int[n][2];
    for (int i = 0; i < n; i++) {
      monsters[i][0] = scn.nextInt();
      monsters[i][1] = scn.nextInt();
    }

    int ans = removeMonsters(monsters);
    System.out.println(ans);
  }
}

<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Number Of Connections To Make Pipeline Connected</span>
import java.util.*;

public class Main {
  static int[] par;
  static int[] size;

  public static int findPar(int u) {
    if (par[u] == u) return u;

    return par[u] = findPar(par[u]);
  }

  public static void merge(int p1, int p2) {
    if (size[p1] > size[p2]) {
      par[p2] = p1;
      size[p1] += size[p2];
    } else {
      par[p1] = p2;
      size[p2] += size[p1];
    }
  }

  public static int makeConnected(int n, int[][] connections) {

    if (n - 1 > connections.length) return -1;

    par = new int[n];
    size = new int[n];

    for (int i = 0; i < n; i++) {
      par[i] = i;
      size[i] = 1;
    }

    for (int[] c : connections) {
      int u = c[0];
      int v = c[1];

      int p1 = findPar(u);
      int p2 = findPar(v);

      if (p1 != p2) {
        merge(p1, p2);
      }
    }

    int count = 0;
    for (int i = 0; i < n; i++) {
      int p = findPar(i);
      if (p == i) {
        count++;
      }
    }

    return count - 1;
  }

  public static void main(String[] args) {

    Scanner scn = new Scanner(System.in);
    int numberOfHouses = scn.nextInt();
    int n = scn.nextInt();
    int[][] connections = new int[n][2];
    for (int i = 0; i < n; i++) {
      connections[i][0] = scn.nextInt();
      connections[i][1] = scn.nextInt();
    }

    int ans = makeConnected(numberOfHouses, connections);
    System.out.println(ans);
  }
}

<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Number Of Provinces</span>

<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">hashmap-and-heaps</span>											
<span class="textStyle">hashmap-and-heaps</span>											
<span class="textStyle">hashmap-and-heaps</span>											
<span class="textStyle">hashmap-and-heaps</span>											
<span class="textStyle">hashmap-and-heaps</span><hr><hr>											
<span class="textStyle">Number Of Employees Under Every Manager</span>
import java.io.*;
import java.util.*;

public class Main {

  public static void main(String[] args) {
    Scanner scn = new Scanner(System.in);
    int n = Integer.parseInt(scn.nextLine());
    String ceo = "";

    HashMap<String, HashSet<String>> map = new HashMap<>();
    for (int i = 0; i < n; i++) {
      String[] parts = scn.nextLine().split(" ");
      String emp = parts[0];
      String man = parts[1];

      if (man.equals(emp)) {
        ceo = man;
        continue;
      }

      if (map.containsKey(man)) {
        HashSet<String> emps = map.get(man);
        emps.add(emp);
      } else {
        HashSet<String> emps = new HashSet<>();
        emps.add(emp);
        map.put(man, emps);
      }
    }

    HashMap<String, Integer> ans = new HashMap<>();
    size(map, ceo, ans);

    for (String emp : ans.keySet()) {
      System.out.println(emp + " " + ans.get(emp));
    }
  }

  public static int size(
    HashMap<String, HashSet<String>> map,
    String man,
    HashMap<String, Integer> ans
  ) {
    if(map.containsKey(man) == false){
      ans.put(man, 0);
      return 1;
    }

    int sz = 0;
    
    for (String emp : map.get(man)) {
      int cs = size(map, emp, ans);
      sz += cs;
    }
    ans.put(man, sz);
    return sz + 1;
  }
}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Find Itinerary From Tickets</span>
import java.util.*;

public class Main {
	public static void main(String[] args) {
		Scanner scn = new Scanner(System.in);
		int noofpairs_src_des = scn.nextInt();
		HashMap<String, String> map = new HashMap<>();
		HashSet<String> set = new HashSet<String>();
		for (int i = 0; i < noofpairs_src_des; i++) {
			String s1 = scn.next();
			String s2 = scn.next();
			map.put(s1, s2);
			set.add(s1);
		}

		// first we have to find starting point
		ArrayList<String> al = new ArrayList<String>(map.keySet());
		for (String s : al) {
			if (set.contains(map.get(s))) {
				set.remove(map.get(s));
			}
		}
		String start = set.toString();
		StringBuilder sb = new StringBuilder(start);
		sb.deleteCharAt(0);
		sb.deleteCharAt(sb.length() - 1);
		start = sb.toString();

		while (map.containsKey(start)) {
			if(map.size() == 1){
				System.out.print(start + " -> " + map.get(start) + ".");
				break;
			}
			System.out.print(start + " -> ");
			String nstart = map.get(start);
			map.remove(start);
			start = nstart;
		}

	}
}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Check If An Array Can Be Divided Into Pairs Whose Sum Is Divisible By K</span>
import java.util.*;

public class Main {
	public static void main(String[] args) {
		Scanner scn = new Scanner(System.in);
		int n = scn.nextInt();
		int[] arr = new int[n];
		for(int i = 0 ; i < n; i++){
			arr[i] = scn.nextInt();
		}
		int k = scn.nextInt();
		solution(arr,k);
	}

	public static void solution(int[] arr, int k){
		// frequency map of remainders
		HashMap<Integer, Integer> map = new HashMap<>();
		for (int val : arr) {
			int rem = val % k;
			if (map.containsKey(rem)) {
				map.put(rem, map.get(rem) + 1);
			} else {
				map.put(rem, 1);
			}
		}

//		System.out.println(map);

		for (int val : arr) {
			int rem = val % k;
			if (2 * rem == k) {
				if (map.get(rem) % 2 != 0) {
					System.out.println("false");
					return;
				}
			} else if (rem == 0) {
				if (map.get(rem) % 2 != 0) {
					System.out.println("false");
					return;
				}
			} else {
				if (map.get(rem) != map.get(k - rem)) {
					System.out.println("false");
					return;
				}
			}
		}

		System.out.println("true");
	}
}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Count Distinct Elements In Every Window Of Size K</span>
import java.util.*;

public class Main {
	public static void main(String[] args) {
		Scanner scn = new Scanner(System.in);
		int[] arr = new int[scn.nextInt()];
		for (int i = 0; i < arr.length; i++) {
			arr[i] = scn.nextInt();
		}
		int k = scn.nextInt();
		ArrayList<Integer> ans = solution(arr,k);
		for(int a : ans){
			System.out.print(a + " ");
		}
	}

	public static ArrayList<Integer> solution(int[] arr, int k) {
		ArrayList<Integer> ans = new ArrayList<>();
		HashMap< Integer, Integer> map = new HashMap< Integer, Integer>();
		int i;
		for( i = 0 ;i < k; i++) {
			map.put(arr[i], map.getOrDefault(arr[i], 0) + 1);
		}
		System.out.print(map.size() + " ");
		if(map.get(arr[0]) == 1) {
			map.remove(arr[0]);
		}else {
			map.put(arr[0], map.get(arr[0]) - 1);
		}
		
		for(int start = 1; i < arr.length ;i++) {
			map.put(arr[i], map.getOrDefault(arr[i], 0) + 1);
			ans.add(map.size());
			if(map.get(arr[start]) == 1) {
				map.remove(arr[start]);
			}else {
				map.put(arr[start], map.get(arr[start]) - 1);
			}
			start++;
		}
		return ans;
	}

}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Largest Subarray With Zero Sum</span>
import java.util.*;

public class Main {
	public static void main(String[] args) {
		Scanner scn = new Scanner(System.in);
		int[] arr = new int[scn.nextInt()];
		for (int i = 0; i < arr.length; i++) {
			arr[i] = scn.nextInt();
		}
		System.out.println(solution(arr));
	}

	public static int solution(int[] arr) {
		HashMap<Integer, Integer> map = new HashMap<>();
		map.put(0, -1);
		int max_length = 0;

		int[] prefixarr = new int[arr.length];
		for (int i = 0; i < arr.length; i++) {
			if (i == 0) {
				prefixarr[i] = arr[i];
			} else {
				prefixarr[i] = arr[i] + prefixarr[i - 1];
			}
			if (!map.containsKey(prefixarr[i])) {
				map.put(prefixarr[i], i);
			} else {
				max_length = Math.max(max_length, i - map.get(prefixarr[i]));
			}
		}

		return max_length;
	}

}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Count Of All Subarrays With Zero Sum</span>
import java.util.*;

public class Main {
	public static void main(String[] args) {
		Scanner scn = new Scanner(System.in);
		int n = scn.nextInt();
		int[] arr = new int[n];
		for (int i = 0; i < n; i++) {
			arr[i] = scn.nextInt();
		}
		System.out.println(solution(arr));

	}

	public static int solution(int[] arr) {
		HashMap<Integer, Integer> map = new HashMap<>();
		map.put(0, 1);
		int psum = 0;
		int ans = 0;
		for (int i = 0; i < arr.length; i++) {
			psum += arr[i];
			if (map.containsKey(psum)) {
				ans += map.get(psum);
			}
			map.put(psum, map.getOrDefault(psum, 0) + 1);
		}
		return ans;
	}

}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Largest Subarray With Contiguous Elements</span>
import java.util.*;

public class Main {
	public static void main(String[] args) {
		Scanner scn = new Scanner(System.in);
		int[] arr = new int[scn.nextInt()];
		for (int i = 0; i < arr.length; i++) {
			arr[i] = scn.nextInt();
		}
		System.out.println(solution(arr));
	}

	public static int solution(int[] arr) {
		int ans = 0;
		for (int i = 0; i < arr.length; i++) {
			int min = arr[i];
			int max = arr[i];
			HashSet<Integer> set = new HashSet<Integer>();
			set.add(arr[i]);
			for (int j = i + 1; j < arr.length; j++) {
				if (set.contains(arr[j])) {
					break;
				}
				set.add(arr[j]);
				min = Math.min(min, arr[j]);
				max = Math.max(max, arr[j]);
				if (max - min == j - i) {
					ans = Math.max(ans, j - i + 1);
				}
			}
		}

		return ans;
	}

}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Smallest Substring Of A String Containing All Characters Of Another String</span>
import java.util.*;

public class Main {
	public static void main(String[] args) {
		Scanner scn = new Scanner(System.in);
		String s1 = scn.next();
		String s2 = scn.next();
		System.out.println(solution(s1,s2));
	}

	public static String solution(String s1, String s2){
	    if(s2.length() == 1){
            for(int i = 0 ; i < s1.length(); i++){
                if(s1.charAt(i) == s2.charAt(0)){
                    return s2;
                }
            }
            return "";
        }
        
        HashMap<Character,Integer> map1 = new HashMap<>();
	    HashMap<Character,Integer> map2 = new HashMap<>();
	    for(int i = 0 ; i < s2.length(); i++){
	        char ch = s2.charAt(i);
	        map2.put(ch,map2.getOrDefault(ch,0) + 1);
	    }
	    
	    int ans = Integer.MAX_VALUE;
	    int matchcount = 0;
	    int[] fans = new int[2];
	    for(int i = 0, j = 0; i < s1.length(); i++){
	        char c = s1.charAt(i);
	        if(map2.containsKey(c)){
	            map1.put(c,map1.getOrDefault(c,0) + 1);
	            if(map1.get(c) <= map2.get(c)){
	                matchcount++;
	            }
	            while(matchcount == s2.length()){
	                char chj = s1.charAt(j);
	                if(!map1.containsKey(chj)){
	                    //nothing
	                }else if(map1.get(chj) > map2.getOrDefault(chj,0)){
	                    map1.put(chj,map1.get(chj) - 1);
	                }else{
	                    if(i - j + 1 < ans){
	                        ans = i - j + 1;
	                        fans[0] = i;
	                        fans[1] = j;
	                    }
	                    map1.put(chj,map1.get(chj) - 1);
	                    if(map1.get(chj) < 0){
	                        map1.remove(chj);
	                    }
	                    matchcount--;
	                }
	                j++;
	            }
	           
	        }    
	        
	    }
	    if(fans[0] == fans[1] && s2.length() != 1){
	        return "";
	    }else
	    return (s1.substring(fans[1],fans[0] + 1));
	}

}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Smallest Substring Of A String Containing All Unique Characters Of Itself</span>
import java.util.*;

public class Main {
	public static void main(String[] args) {
		Scanner scn = new Scanner(System.in);
		String str = scn.next();
		System.out.println(solution(str));
	}

	public static int solution(String str){
	    HashMap<Character,Integer> map = new HashMap<>();
	    HashSet<Character> set = new HashSet<>();
	    for(int i = 0 ; i < str.length(); i++){
	        char ch = str.charAt(i);
	        set.add(ch);
	    }
	    int ans = Integer.MAX_VALUE;
	    for(int i = 0, j = 0; i < str.length(); i++){
	        char ch = str.charAt(i);
	        map.put(ch,map.getOrDefault(ch,0) + 1);
	        while(map.size() == set.size() && j < str.length()){
	            char chj = str.charAt(j);
	            map.put(chj,map.get(chj) - 1);
	            if(map.get(chj) <= 0){
	                map.remove(chj);
	                ans = Math.min(ans,i - j + 1);
	            }
	            j++;
	        }
	    }
	    return ans;
	}

}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Longest Substring With Non Repeating Characters</span>
import java.util.*;

public class Main {
	public static void main(String[] args) {
		Scanner scn = new Scanner(System.in);
		String str = scn.next();
		System.out.println(solution(str));
	}

	public static int solution(String str) {
        if(str.length() == 0){
            return 0;
        }
        HashMap<Character,Integer> map = new HashMap<>();
        int ans = 1;
        for(int i = 0, j = 0 ; i < str.length(); i++){
            char ch = str.charAt(i);
            while(map.containsKey(ch)){
                char chj = str.charAt(j);
                map.put(chj,map.get(chj) - 1);
                if(map.get(chj) <= 0){
                    map.remove(chj);
                    ans = Math.max(ans,i - j);
                }
                j++;
            }
            map.put(ch,map.getOrDefault(ch,0) + 1);
        }
        return Math.max(ans,map.size());
    }

}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Count Of Substrings Having All Unique Characters</span>
import java.util.*;

public class Main {
	public static void main(String[] args) {
		Scanner scn = new Scanner(System.in);
		String str = scn.next();
		System.out.println(solution(str));
	}

	public static int solution(String str) {
        
        HashMap<Character,Integer> map = new HashMap<>();
        int ans = 0;
        int j = 0;
        for(int i = 0 ; i < str.length(); i++){
            char ch = str.charAt(i);
            while(map.containsKey(ch)){
                char chj = str.charAt(j);
                map.put(chj,map.get(chj) - 1);
                if(map.get(chj) <= 0){
                    map.remove(chj);
                }
                j++;
            }
            ans += (i - j + 1);
            map.put(ch,map.getOrDefault(ch,0) + 1);
        }
        
        return ans;
    }

}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Longest Substring With Exactly K Unique Characters</span>
import java.util.*;

public class Main {
	public static void main(String[] args) {
		Scanner scn = new Scanner(System.in);
        String str = scn.next();
        int k = scn.nextInt();
		System.out.println(solution(str,k));
	}

	public static int solution(String str, int k){
	    int maxLen = -1;
		HashMap< Character, Integer> map = new HashMap< Character, Integer>();
		for (int i = 0, j = 0; i < str.length(); i++) {
			char ch = str.charAt(i);
			map.put(ch, map.getOrDefault(ch, 0) + 1);
			if (map.size() == k) {
				maxLen = Math.max(maxLen, i - j + 1);
			} else {
				while (map.size() > k) {
					char l = str.charAt(j);
					int count = map.get(l);
					if (count == 1) {
						map.remove(l);
					} else {
						map.put(l, map.get(l) - 1);
					}
					j++;
				}
			}
		}
		return maxLen;
	}

}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Count Of Substrings With Exactly K Unique Characters</span>
import java.util.*;

public class Main {
	public static void main(String[] args) {
		Scanner scn = new Scanner(System.in);
        String str = scn.next();
        int k = scn.nextInt();
		System.out.println(solution(str,k) - solution(str,k-1));
	}

	public static int solution(String str, int K){
	    int j = 0, res = 0;
        Map<Character, Integer> map = new HashMap<>();
        for (int i = 0; i < str.length(); i++) {
            char ch = str.charAt(i);
            if (map.getOrDefault(ch, 0) == 0) K--;
            map.put(ch, map.getOrDefault(ch, 0) + 1);
            while (K < 0) {
                char chj = str.charAt(j);
                map.put(chj, map.get(chj) - 1);
                if (map.get(chj) == 0) K++;
                j++;
            }
            res += i - j + 1;
        }
        return res;
	}

}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Equivalent Subarrays</span>
import java.util.*;

public class Main {
	public static void main(String[] args) {
		Scanner scn = new Scanner(System.in);
        int n = scn.nextInt();
        int[] arr = new int[n];
        HashSet<Integer> set = new HashSet<>();
        for(int i = 0 ; i  < n; i++){
            arr[i] = scn.nextInt();
            set.add(arr[i]);
        }
        System.out.println(solution(arr,set.size()) - solution(arr,set.size() - 1));
	}

	public static int solution(int[] arr, int K){
	    int j = 0, res = 0;
        Map<Integer, Integer> map = new HashMap<>();
        for (int i = 0; i < arr.length; i++) {
            if (map.getOrDefault(arr[i], 0) == 0) K--;
            map.put(arr[i], map.getOrDefault(arr[i], 0) + 1);
            while (K < 0) {
                map.put(arr[j], map.get(arr[j]) - 1);
                if (map.get(arr[j]) == 0) K++;
                j++;
            }
            res += i - j + 1;
        }
        return res;
	}

}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Maximum Consecutive Ones - 1</span>
import java.util.*;

public class Main {
	public static void main(String[] args) {
		Scanner scn = new Scanner(System.in);
        int n = scn.nextInt();
        int[] arr = new int[n];
        for(int i = 0 ; i  < n; i++){
            arr[i] = scn.nextInt();
        }
        System.out.println(solution(arr));
	}

	public static int solution(int[] arr){
        int zeroes = 0;
        int ans = 1;
        for(int i = 0 ,j = 0 ;i < arr.length; i++){
            if(arr[i] == 0){
                zeroes++;
                while(zeroes > 1){
                    if(arr[j] == 0){
                        zeroes--;
                    }
                    j++;
                }
            }
            ans = Math.max(ans,i - j + 1);
        }
        return ans;
    }

}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Maximum Consecutive Ones - 2</span>
import java.util.*;

public class Main {
	public static void main(String[] args) {
		Scanner scn = new Scanner(System.in);
        int n = scn.nextInt();
        int[] arr = new int[n];
        for(int i = 0 ; i  < n; i++){
            arr[i] = scn.nextInt();
        }
        int k = scn.nextInt();
        System.out.println(solution(arr,k));
	}

	public static int solution(int[] arr, int k){
        int zeroes = 0;
        int ans = 1;
        for(int i = 0 ,j = 0 ;i < arr.length; i++){
            if(arr[i] == 0){
                zeroes++;
                while(zeroes > k){
                    if(arr[j] == 0){
                        zeroes--;
                    }
                    j++;
                }
            }
            ans = Math.max(ans,i - j + 1);
        }
        return ans;
    }

}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Longest Substring With At Most K Unique Characters</span>
import java.util.*;
public class Main {
	public static void main(String[] args) {
		Scanner scn = new Scanner(System.in);
        String str = scn.next();
        int k = scn.nextInt();
		System.out.println(solution(str,k));
	}

	public static int solution(String str, int k) {
        HashMap< Character,Integer> map = new HashMap<>();
        int ans = 0;
        for(int i = 0 , j = 0; i < str.length(); i++){
            char ch = str.charAt(i);
            map.put(ch,map.getOrDefault(ch, 0) + 1);
            while(map.size() > k){
                char chj = str.charAt(j);
                map.put(chj,map.get(chj) - 1);
                if(map.get(chj) == 0){
                    map.remove(chj);
                }
                j++;
            }
            ans = Math.max(ans,i - j + 1);
        }
        return ans;
    }

}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Count Of Substrings Having At Most K Unique Characters</span>

<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Binary String With Substrings Representing Numbers From 1 To N</span>

import java.util.*;

public class Main {
	public static void main(String[] args) {
		Scanner scn = new Scanner(System.in);
        String str = scn.next();
        int n = scn.nextInt();
		System.out.println(solution(str,n));
	}

	public static boolean solution(String str, int n) {
        HashSet<Integer> set = new HashSet<>();
        for(int i = n; i > ((n + 1) / 2); i--){
            set.add(i);
        }
        for(int i = 0, j = 0 ; i < str.length(); i++){
            if(i >= j){
                String s = str.substring(j,i+1);
             int k = Integer.parseInt(s,2);
             if(k > n){
                 while(j + 1 < str.length()){
                     j++;
                     if(str.charAt(j) == '1'){
                         break;
                     }
                 }
             }
             if(set.contains(k)){
                 set.remove(k);
             }
            }
        }
        return set.size() == 0;
    }

}

<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Find All Anagrams In A String</span>
import java.util.*;

public class Main {
	public static void findAnagrams(String s, String p) {
		int[] pfq = new int[26];
		int[] sfq = new int[26];
		ArrayList<Integer> ans = new ArrayList<Integer>();
		int i;
		for (i = 0; i < p.length(); i++) {
			char ch = p.charAt(i);
			pfq[ch - 'a']++;
			sfq[s.charAt(i) - 'a']++;
		}
		if(isAnagrams(pfq, sfq)) {
			ans.add(0);
		}
		sfq[s.charAt(0) - 'a']--;
		int start = 1;
		for (; i < s.length(); i++) {
			char ch = s.charAt(i);
			sfq[ch - 'a']++;
			if(isAnagrams(pfq, sfq)) {
				ans.add(start);
			}
			sfq[s.charAt(start) - 'a']--;
			start++;
		}
		
        System.out.println(ans.size());
        for(int a : ans){
            System.out.print(a + " ");
        }

	}

	private static boolean isAnagrams(int[] pfq, int[] sfq) {
		for (int i = 0; i < 26; i++) {
			if (pfq[i] != sfq[i]) {
				return false;
			}
		}
		return true;
	}

	public static void main(String[] args) {
		Scanner scn = new Scanner(System.in);
		String s = scn.next();
		String p = scn.next();
		findAnagrams(s, p);
	}

}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">K Anagrams</span>
import java.util.*;

public class Main {
	public static boolean areKAnagrams(String str1, String str2, int k) {
		if (str1.length() != str2.length()) {
			return false;
		}
		int[] farr = new int[26];
		for (int i = 0; i < str1.length(); i++) {
			char ch = str1.charAt(i);
			farr[ch - 'a']++;
		}
		for (int i = 0; i < str2.length(); i++) {
			char ch = str2.charAt(i);
			if (farr[ch - 'a'] != 0)
				farr[ch - 'a']--;
		}

		int diff = 0;
		for (int i = 0; i < 26; i++) {
			diff += farr[i];
		}

		if (diff <= k) {
			return true;
		} else {
			return false;
		}
	}

	public static void main(String[] args) {

		Scanner s = new Scanner(System.in);
		String str1 = s.next();
		String str2 = s.next();
		int k = s.nextInt();
		System.out.println(areKAnagrams(str1, str2, k));

	}

}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Find Anagram Mappings</span>
import java.util.*;

public class Main {
	public static int[] anagramMappings(int[] arr1, int[] arr2) {
		HashMap<Integer, ArrayList<Integer>> map = new HashMap<>();
		for(int i = 0 ;i < arr2.length ;i++) {
			if(map.containsKey(arr2[i])){
				map.get(arr2[i]).add(i);
			}else{
				ArrayList<Integer> a = new ArrayList<>();
				a.add(i);
				map.put(arr2[i],a);
			}
		}
		int[] ans = new int[arr1.length];
		for(int i = 0 ; i < arr1.length; i++) {
			ans[i] = map.get(arr1[i]).remove(0);
		}
		
		return ans;
	}

	public static void main(String[] args) {
		Scanner s = new Scanner(System.in);
		int n = s.nextInt();
		int[] a = new int[n];
		int[] b = new int[n];
		for (int i = 0; i < a.length; i++) {
			a[i] = s.nextInt();
		}
		for (int j = 0; j < b.length; j++) {
			b[j] = s.nextInt();
		}
		int[] res = anagramMappings(a, b);
		for (int j = 0; j < res.length; j++) {
			System.out.print(res[j] + " ");
		}
	}

}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Valid Anagram</span>
import java.util.*;

public class Main {
	
	public static boolean solution(String s1, String s2){
		HashMap<Character,Integer> map = new HashMap<>();
		for(int i = 0 ; i < s1.length(); i++){
			char ch = s1.charAt(i);
			map.put(ch,map.getOrDefault(ch, 0) + 1);
		}
		for(int i = 0 ; i < s2.length(); i++){
			char ch = s2.charAt(i);
			if(!map.containsKey(ch)){
				return false;
			}
			map.put(ch, map.get(ch) - 1);
			if(map.get(ch) < 1){
				map.remove(ch);
			}
		}
		return map.size() == 0;
	}
	public static void main(String[] args) {
		Scanner scn = new Scanner(System.in);
		String s1 = scn.next();
		String s2 = scn.next();
		System.out.println(solution(s1,s2));
	}

}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Group Anagrams</span>
import java.util.*;

public class Main {

	public static ArrayList<ArrayList<String>> groupAnagrams(String[] strs) {
		HashMap<HashMap<Character, Integer>, ArrayList<String>> map = new HashMap<>();

		for (String str : strs) {
			HashMap<Character, Integer> fmap = new HashMap<Character, Integer>();
			for (int i = 0; i < str.length(); i++) {
				char ch = str.charAt(i);
				fmap.put(ch, fmap.getOrDefault(ch, 0) + 1);
			}
			if (!map.containsKey(fmap)) {
				ArrayList<String> al = new ArrayList<String>();
				al.add(str);
				map.put(fmap, al);
			} else {
				ArrayList<String> al = map.get(fmap);
				al.add(str);
				map.put(fmap, al);
			}

		}
		ArrayList<ArrayList<String>> ans = new ArrayList<ArrayList<String>>();
		for (ArrayList<String> al : map.values()) {
			ans.add(al);
		}
		return ans;
	}

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		int N = sc.nextInt();
		String[] arr = new String[N];
		for (int i = 0; i < N; i++) {
			arr[i] = sc.next();
		}
		ArrayList<ArrayList<String>> anagramsGrouped = groupAnagrams(arr);
		for (ArrayList<String> lst : anagramsGrouped) {
			Collections.sort(lst);
		}
		anagramsGrouped.sort(new ListComparator());
		display(anagramsGrouped);
	}

	// it is used to make the result unique
	static class ListComparator implements Comparator<List<String>> {
		@Override
		public int compare(List<String> l1, List<String> l2) {
			if (l1.size() != l2.size()) {
				return l2.size() - l1.size();
			}

			String l1str = l1.get(0);
			String l2str = l2.get(0);
			return l1str.compareTo(l2str);

		}
	}

	public static void display(ArrayList<ArrayList<String>> list) {
		for (int i = 0; i < list.size(); i++) {
			ArrayList<String> currList = list.get(i);
			for (int j = 0; j < currList.size(); j++) {
				System.out.print(currList.get(j) + " ");
			}
			System.out.println();
		}
	}

}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Group Shifted String</span>
import java.util.*;

public class Main {

	public static ArrayList<ArrayList<String>> groupShiftedStrings(String[] array) {
		
		HashMap<String, ArrayList<String>> map = new HashMap<String, ArrayList<String>>();
		for(int i = 0 ;i < array.length ;i++) {
			String codedString = generatecode(array[i]);
			if(map.containsKey(codedString)) {
				ArrayList<String> al = map.get(codedString);
				al.add(array[i]);
				map.put(codedString, al);
			}else {
				ArrayList<String> al = new ArrayList<String>();
				al.add(array[i]);
				map.put(codedString, al);
			}
		}

		ArrayList<ArrayList<String>> ans = new ArrayList<ArrayList<String>>();
		for (ArrayList<String> al : map.values()) {
			ans.add(al);
		}
		return ans;
	}

	public static String generatecode(String str) {
		String ans = "";
		for(int i = 1; i < str.length() ; i++) {
			char ch1 = str.charAt(i);
			char ch2 = str.charAt(i - 1);
			int diff = ch1 - ch2;
			if(diff < 0) {
				diff += 26;
			}
			ans += 'a' + diff;
		}
		
		return ans;
	}

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		int N = sc.nextInt();
		String[] arr = new String[N];
		for (int i = 0; i < N; i++) {
			arr[i] = sc.next();
		}
		ArrayList<ArrayList<String>> shiftedGroup = groupShiftedStrings(arr);
		for (ArrayList<String> lst : shiftedGroup) {
			Collections.sort(lst);
		}
		shiftedGroup.sort(new ListComparator());
		display(shiftedGroup);
	}

	// it is used to make the result unique
	static class ListComparator implements Comparator<List<String>> {
		@Override
		public int compare(List<String> l1, List<String> l2) {
			if (l1.size() != l2.size()) {
				return l2.size() - l1.size();
			}

			String l1str = l1.get(0);
			String l2str = l2.get(0);
			return l1str.compareTo(l2str);

		}
	}

	public static void display(ArrayList< ArrayList< String>> list) {
		for (int i = 0; i < list.size(); i++) {
			ArrayList<String> currList = list.get(i);
			for (int j = 0; j < currList.size(); j++) {
				System.out.print(currList.get(j) + " ");
			}
			System.out.println();
		}
	}

}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Isomorphic Strings</span>
import java.util.*;

public class Main {

	public static void main(String[] args) {
		Scanner scn = new Scanner(System.in);
		String A = scn.next();
		String B = scn.next();
		System.out.print(isIsomorphic(A, B));
	}

	public static boolean isIsomorphic(String s, String t) {
		HashMap< Character, Character> map1 = new HashMap< Character, Character>();
		HashMap< Character, Character> map2 = new HashMap< Character, Character>();
		for(int i = 0 ; i < s.length() ;i++) {
			char ch1 = s.charAt(i);
			char ch2 = t.charAt(i);
			if(!map1.containsKey(ch1)) {
				map1.put(ch1, ch2);
			}else {
				if(map1.get(ch1) != ch2) {
					return false;
				}
			}
		}
		for(int i = 0 ; i < t.length() ;i++) {
			char ch1 = t.charAt(i);
			char ch2 = s.charAt(i);
			if(!map2.containsKey(ch1)) {
				map2.put(ch1, ch2);
			}else {
				if(map2.get(ch1) != ch2) {
					return false;
				}
			}
		}
		return true;
	}

}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Word Pattern</span>
import java.util.*;

public class Main {

	public static void main(String[] args) {
		Scanner scn = new Scanner(System.in);
		String pattern = scn.nextLine();
		String words = scn.nextLine();
		System.out.println(wordPattern(pattern,words));
	}

	public static boolean wordPattern(String pattern, String str) {
        String[] arr = str.split(" ");
		if(arr.length != pattern.length()){
		    return false;
		}
		HashMap< Character, String> map = new HashMap< Character, String>();
	    for(int i=0; i< pattern.length(); i++){
	        char c = pattern.charAt(i);
	        if(map.containsKey(c)){
	            String value = map.get(c);
	            if(!value.equals(arr[i])){
	                return false;
	            }
	        }else if (map.containsValue(arr[i])){
	            return false;
	        }
	        map.put(c, arr[i]);
	    }
		return true;
    }

}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Count Of Subarrays Having Sum Equals To K</span>
import java.util.*;

public class Main {
	public static void main(String[] args) {
		Scanner scn = new Scanner(System.in);
        int n = scn.nextInt();
        int[] arr = new int[n];
        for(int i = 0 ; i < n; i++){
            arr[i] = scn.nextInt();
        }
        int target = scn.nextInt();
        System.out.println(solution(arr,target));
	}

	public static int solution(int[] arr, int target){
        HashMap<Integer,Integer> map = new HashMap<>();
        int psum = 0;
        int ans = 0;
        map.put(0,1);
        for(int i = 0 ; i < arr.length; i++){
            psum += arr[i];
            if(map.containsKey(psum - target)){
                ans += map.get(psum - target);
            }
            map.put(psum,map.getOrDefault(psum,0) + 1);
        }
        return ans;
    }

}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Longest Subarray With Sum Divisible By K</span>
import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner scn = new Scanner(System.in);
        int n = scn.nextInt();
        int[] arr = new int[n];
        for (int i = 0; i < n; i++) {
            arr[i] = scn.nextInt();
        }
        int k = scn.nextInt();
        System.out.println(solution(arr, k));
    }

    public static int solution(int[] arr, int k) {
        int sum = 0, maxLen = 0;
        int[] marr = new int[arr.length];
        HashMap<Integer, Integer> map = new HashMap<>();
        for (int i = 0; i < arr.length; i++) {
            sum = sum + arr[i];
            marr[i] = (((sum % k) + k) % k);
        }

        for (int i = 0; i < arr.length; i++) {
            if (marr[i] == 0) {
                maxLen = i + 1;
            } else if (map.containsKey(marr[i]) == false)
                map.put(marr[i], i);
            else {
                maxLen = Math.max(maxLen, i - map.get(marr[i]));
            }
        }

        return maxLen;
    }

}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Count Of Subarrays With Sum Divisible By K</span>
import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner scn = new Scanner(System.in);
        int n = scn.nextInt();
        int[] arr = new int[n];
        for (int i = 0; i < n; i++) {
            arr[i] = scn.nextInt();
        }
        int k = scn.nextInt();
        System.out.println(solution(arr, k));
    }

    public static int solution(int[] arr, int k) {
        int sum = 0, ans = 0;
        int[] marr = new int[arr.length];
        HashMap<Integer, Integer> map = new HashMap<>();
        for (int i = 0; i < arr.length; i++) {
            sum = sum + arr[i];
            marr[i] = (((sum % k) + k) % k);
        }
        map.put(0,1);
        for (int i = 0; i < arr.length; i++) {
            ans += map.getOrDefault(marr[i], 0);
            map.put(marr[i],map.getOrDefault(marr[i], 0) + 1);
        }

        return ans;
    }

}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Longest Subarray With Equal Number Of Zeroes And Ones</span>
import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner scn = new Scanner(System.in);
        int n = scn.nextInt();
        int[] arr = new int[n];
        for (int i = 0; i < n; i++) {
            arr[i] = scn.nextInt();
        }
        System.out.println(solution(arr));
    }

    public static int solution(int[] arr) {
        int sum = 0, maxLen = 0;
        HashMap<Integer, Integer> map = new HashMap<>();
        for (int i = 0; i < arr.length; i++) {
            if(arr[i] == 0){
                arr[i] = -1;
            }
            sum += arr[i];
            if (sum == 0) {
                maxLen = i + 1;
            } else if (!map.containsKey(sum))
                map.put(sum, i);

            else {
                maxLen = Math.max(maxLen, i - map.get(sum));
            }
        }

        return maxLen;
    }

}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Count Of Subarrays With Equal Number Of Zeroes And Ones</span>
import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner scn = new Scanner(System.in);
        int n = scn.nextInt();
        int[] arr = new int[n];
        for (int i = 0; i < n; i++) {
            arr[i] = scn.nextInt();
        }
        System.out.println(solution(arr));
    }

    public static int solution(int[] arr) {
        int sum = 0, ans = 0;
        HashMap<Integer, Integer> map = new HashMap<>();
        map.put(0,1);
        for (int i = 0; i < arr.length; i++) {
            if(arr[i] == 0){
                arr[i] = -1;
            }
            sum += arr[i];
            ans += map.getOrDefault(sum, 0);
            map.put(sum, map.getOrDefault(sum, 0) + 1);
        }

        return ans;
    }

}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Longest Subarray With Equal Number Of 0s 1s And 2s</span>
import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner scn = new Scanner(System.in);
        int n = scn.nextInt();
        int[] arr = new int[n];
        for (int i = 0; i < n; i++) {
            arr[i] = scn.nextInt();
        }
        System.out.println(solution(arr));
    }

    public static int solution(int[] arr) {
        int zcount = 0 ;
		int ocount = 0;
		int tcount = 0;
		int ans = 0;
		HashMap< String, Integer> map = new HashMap<>();
		map.put(0 + "*" + 0, -1);
		for(int i = 0 ; i  < arr.length ;i++) {
			if(arr[i] == 1) {
				ocount++;
			}else if(arr[i] == 0) {
				zcount++;
			}else {
				tcount++;
			}
			String s = (ocount - zcount) + "*" + (tcount - zcount);
			if(map.containsKey(s)) {
				ans = Math.max(ans,i - map.get(s));
			}else {
				map.put(s, i);
			}
		}
		return ans;
    }

}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Count Of Subarrays With Equal Number Of 0s 1s And 2s</span>
import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner scn = new Scanner(System.in);
        int n = scn.nextInt();
        int[] arr = new int[n];
        for (int i = 0; i < n; i++) {
            arr[i] = scn.nextInt();
        }
        System.out.println(solution(arr));
    }

    public static int solution(int[] arr) {
        int zcount = 0 ;
		int ocount = 0;
		int tcount = 0;
		int ans = 0;
		HashMap<String, Integer> map = new HashMap<>();
		map.put(0 + "*" + 0, 1);
		for(int i = 0 ; i  < arr.length ;i++) {
			if(arr[i] == 1) {
				ocount++;
			}else if(arr[i] == 0) {
				zcount++;
			}else {
				tcount++;
			}
			String s = (ocount - zcount) + "*" + (tcount - zcount);
			if(map.containsKey(s)) {
				ans += map.get(s);
				map.put(s, map.get(s) + 1);
			}else {
				map.put(s, 1);
			}
		}
		return ans;
    }

}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Pairs With Equal Sum</span>
import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner scn = new Scanner(System.in);
        int n = scn.nextInt();
        int[] arr = new int[n];
        for (int i = 0; i < n; i++) {
            arr[i] = scn.nextInt();
        }
        System.out.println(solution(arr));
    }

    public static boolean solution(int[] arr) {
        HashSet< Integer> set = new HashSet<>();
		for(int i = 0 ; i < arr.length ; i++) {
			for(int j = i + 1; j < arr.length ; j++) {
				int sum = arr[i] + arr[j];
				if(set.contains(sum)){
				    return true;
				}else{
				    set.add(sum);
				}
			}
		}
		return false;
    }

}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Recurring Sequence In A Fraction</span>
import java.util.*;

public class Main {

    public static String solution(int num, int den) {
        StringBuilder sb = new StringBuilder();
        
        int quo = num / den;
        int rem = num % den;
        sb.append(quo);
        
        if(rem == 0){
            return sb.toString();
        } else {
            sb.append(".");
        }
        
        HashMap< Integer, Integer> map = new HashMap<>();
        while(rem != 0){
            if(map.containsKey(rem) == false){
                map.put(rem, sb.length());
            
                rem *= 10;
                quo = rem / den;
                rem = rem % den;
                sb.append(quo);
            } else {
                int pos = map.get(rem);
                sb.insert(pos, "(");
                sb.append(")");
                break;
            }
        }
        
        return sb.toString();
    }
    
    public static void main(String[] args) {
		Scanner scn = new Scanner(System.in);
		int num = scn.nextInt();
		int den = scn.nextInt();
		System.out.println(solution(num , den));
	}

}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Rabbits In The Forest</span>
import java.util.*;

public class Main {
    public static void main(String[] args) {
		Scanner scn = new Scanner(System.in);
		int n = scn.nextInt();
		int[] arr = new int[n];
		for(int i = 0 ; i < n; i++){
			arr[i] = scn.nextInt();
		}
		System.out.println(solution(arr));
	}

	private static int solution(int[] arr) {
		HashMap<Integer, Integer> map = new HashMap<>();
		for(int i = 0 ;i < arr.length ;i++) {
			map.put(arr[i], map.getOrDefault(arr[i], 0) + 1);
		}
		
		ArrayList<Integer> keys = new ArrayList<Integer>(map.keySet());
		ArrayList<Integer> values = new ArrayList<Integer>(map.values());
		int ans = 0;
		for(int i = 0 ;i < keys.size() ; i++) {
			int key = keys.get(i);
			int val = values.get(i);
			if(key >= val) {
				ans += (key + 1);
			}else {
				if(val % (key + 1) == 0) {
					ans += ((val / (key + 1)) * (key + 1));
				}else {
					ans += (((val / (key + 1)) + 1) * (key + 1));
				}
			}
		}
		
		return ans;
	}

}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Double Pair Array</span>
import java.util.*;

public class Main {
    public static void main(String[] args) {
		Scanner scn = new Scanner(System.in);
		int n = scn.nextInt();
		int[] arr = new int[n];
		for(int i = 0 ; i < n; i++){
			arr[i] = scn.nextInt();
		}
		System.out.println(solution(arr));
	}

	private static boolean solution(int[] arr) {
		for(int i = 0 ; i < arr.length; i++){
            arr[i] = 2 * arr[i];
        }
        
        HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();
		for (int i = 0; i < arr.length; i++) {
			map.put(arr[i], map.getOrDefault(arr[i], 0) + 1);
		}
		Arrays.sort(arr);
		for (int i = 0; i < arr.length; i++) {
			if (map.get(arr[i]) == 0) {
				continue;
			}
			if (arr[i] >= 0) {
				if (arr[i] == 0 && ((map.get(0) % 2) != 0)) {
					return false;
				} else if (map.containsKey(arr[i] * 2) && map.get(arr[i] * 2) < map.get(arr[i])) {
					return false;
				} else {
					if (map.containsKey(arr[i]) && map.containsKey(arr[i] * 2)) {
						int min = Math.min(map.get(arr[i]), map.get(arr[i] * 2));
						map.put(arr[i], map.get(arr[i]) - min);
						map.put(arr[i] * 2, map.get(arr[i] * 2) - min);
					} else {
						return false;
					}
				}
			} else {
				if (map.containsKey(arr[i] / 2) && map.get(arr[i] / 2) < map.get(arr[i])) {
					return false;
				} else {
					if (map.containsKey(arr[i]) && map.containsKey(arr[i] / 2)) {
						int min = Math.min(map.get(arr[i]), map.get(arr[i] / 2));
						map.put(arr[i], map.get(arr[i]) - min);
						map.put(arr[i] / 2, map.get(arr[i] / 2) - min);
					} else {
						return false;
					}
				}
			}
		}

		return true;
	}

}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Check Arithmetic Sequence</span>
import java.util.*;

public class Main {
    public static void main(String[] args) {
		Scanner scn = new Scanner(System.in);
		int n = scn.nextInt();
		int[] arr = new int[n];
		for(int i = 0 ; i < n; i++){
			arr[i] = scn.nextInt();
		}
		System.out.println(solution(arr));
	}

	public static boolean solution(int[] arr) {
		if(arr.length == 1) {
			return true;
		}
		HashSet<Integer> set = new HashSet<Integer>();
		int min =  Integer.MAX_VALUE;
		int max = Integer.MIN_VALUE;
		for(int i = 0 ;i < arr.length; i++) {
			min = Math.min(min, arr[i]);
			max = Math.max(max, arr[i]);
			set.add(arr[i]);
		}
		int diff = (max - min) / (arr.length - 1);
		for(int i = 0 ; i < arr.length; i++) {
			if(arr[i] == min || arr[i] == max) {
			}else {
				if(!set.contains(arr[i] - diff) || !set.contains(arr[i] + diff)) {
					return false;
				}
			}
		}
		
		return true;
	}

}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Smallest Subarray With All Occurrences Of The Most Frequent Element</span>
import java.util.*;

public class Main {
    public static void main(String[] args) {
		Scanner scn = new Scanner(System.in);
		int n = scn.nextInt();
		int[] arr = new int[n];
		for(int i = 0 ; i < n; i++){
			arr[i] = scn.nextInt();
		}
		solution(arr);
	}

	public static void solution(int[] arr) {
		HashMap<Integer,Integer> left = new HashMap<>();
		HashMap<Integer,Integer> fmap = new HashMap<>();
		int max = 0;
		int minLength = Integer.MAX_VALUE;
		int stidx = -1;

		for(int i = 0 ; i < arr.length; i++){
			//if element is coming for the first time
			if(!fmap.containsKey(arr[i])){
				left.put(arr[i], i);
				fmap.put(arr[i], 1);
			}else{
				fmap.put(arr[i], fmap.get(arr[i]) + 1);
			}

			//if frequency of current element is greater than max till now, update max and minLength
			if(fmap.get(arr[i]) > max){
				max = fmap.get(arr[i]);
				minLength = i - left.get(arr[i]) + 1;
				stidx = left.get(arr[i]);
			}else if((fmap.get(arr[i]) == max) && (minLength > i - left.get(arr[i]) + 1)){
				minLength = i - left.get(arr[i]) + 1;
				stidx = left.get(arr[i]);
			}
		}

		System.out.println(arr[stidx]);
		System.out.println(stidx);
		System.out.println(stidx + minLength - 1);
	}

}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Task Completion</span>
import java.util.*;

public class Main {
    public static void completeTask(int n, int m, int[] arr) {
		HashSet<Integer> set = new HashSet<>();
		for(int i = 0 ; i < arr.length; i++){
		    set.add(arr[i]);
		}
		ArrayList<Integer> al1 = new ArrayList<>();
		ArrayList<Integer> al2 = new ArrayList<>();
		int counter = 0;
		for(int i = 1; i <= n; i++){
		    if(!set.contains(i)){
		        if(counter % 2 == 0){
		            al1.add(i);
		        }else{
		            al2.add(i);
		        }
		        counter++;
		    }
		}
		
		for(int a : al1){
		    System.out.print(a + " ");
		}
		System.out.println();
		for(int a : al2){
		    System.out.print(a + " ");
		}
		System.out.println();
	}

	// Don't make changes here
	public static void main(String[] args) {
		Scanner scn = new Scanner(System.in);
		int n = scn.nextInt();
		int m = scn.nextInt();
		int[] num = new int[m];
		for (int i = 0; i < m; i++) {
			num[i] = scn.nextInt();
		}
		completeTask(n, m, num);
	}

}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Pairs With Given Sum In Two Sorted Matrices</span>
import java.util.*;

public class Main {
    public static int solve(int[][] num1, int[][] num2, int k) {
		HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();
		int ans = 0;
		for(int i = 0 ; i < num1.length ;i++) {
			for(int j = 0; j < num1[0].length ;j++) {
				map.put(num1[i][j], map.getOrDefault(num1[i][j], 0) + 1);
			}
		}
		
		for(int i = 0 ;i < num2.length ;i++) {
			for(int j = 0 ;j < num2[0].length ;j++) {
				if(map.containsKey(k - num2[i][j])) {
					ans += map.get(k - num2[i][j]);
				}
			}
		}
		return ans;
	}

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		int N = sc.nextInt();
		int[][] mat1 = new int[N][N];
		for (int i = 0; i < mat1.length; i++) {
			for (int j = 0; j < mat1[0].length; j++) {
				mat1[i][j] = sc.nextInt();
			}
		}

		int[][] mat2 = new int[N][N];
		for (int i = 0; i < mat2.length; i++) {
			for (int j = 0; j < mat2[0].length; j++) {
				mat2[i][j] = sc.nextInt();
			}
		}
		int K = sc.nextInt();
		System.out.println(solve(mat1, mat2, K));

	}

}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Quadruplet Sum</span>
import java.util.*;

public class Main {
    public static ArrayList<ArrayList<Integer>> fourSum(int[] nums, int target, int n) {
		HashSet<ArrayList<Integer>> s = new HashSet<>();
		Arrays.sort(nums);
		for (int i = 0; i < nums.length - 3; i++) {
			for (int j = i + 1; j < nums.length - 2; j++) {
				int left = j + 1;
				int right = nums.length - 1;
				while (left < right) {
					int sum = nums[i] + nums[j] + nums[left] + nums[right];
					if (sum == target) {
						ArrayList<Integer> tmp = new ArrayList<>();
						tmp.add(nums[i]);
						tmp.add(nums[j]);
						tmp.add(nums[left]);
						tmp.add(nums[right]);
						s.add(tmp);
						left++;
						right--;
					} else if (sum < target) {
						left++;
					} else {
						right--;
					}
				}
			}
		}
		ArrayList<ArrayList<Integer>> ret = new ArrayList<>();
		for (ArrayList<Integer> i : s) {
			ret.add(i);
		}
		return ret;
	}

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		int n = sc.nextInt();
		int[] arr = new int[n];
		for (int i = 0; i < n; i++) {
			arr[i] = sc.nextInt();
		}
		int target = sc.nextInt();
		ArrayList<ArrayList<Integer>> ans = fourSum(arr, target, n);
		Collections.sort(ans, new Comparator<ArrayList<Integer>> () {
			@Override
			public int compare(ArrayList<Integer> a, ArrayList<Integer> b) {
				int i = 0, j = 0;
				while(i < a.size() && j < b.size() && a.get(i) == b.get(j)){
					i++;
					j++;
				}
				return a.get(i).compareTo(b.get(j));
			}
		});
		for (ArrayList<Integer> a : ans) {
			for (int element : a) {
				System.out.print(element + " ");
			}
			System.out.println();
		}
	}

}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Quadruplet Sum - 2</span>
import java.util.*;

public class Main {
    public static int fourSumCount(int[] A, int[] B, int[] C, int[] D) {
		int n = A.length;
		if (n == 0)
			return 0;

		int[] sum1 = new int[n * n];
		int[] sum2 = new int[n * n];
		int res = 0;

		HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();

		for (int i = 0; i < n; i++) {
			for (int j = 0; j < n; j++) {
				sum1[i * n + j] = A[i] + B[j];
				map.put(sum1[i * n + j], map.getOrDefault(sum1[i * n + j], 0) + 1);
			}
		}

		for (int i = 0; i < n; i++) {
			for (int j = 0; j < n; j++) {
				sum2[i * n + j] = C[i] + D[j];
				if (map.containsKey(sum2[i * n + j] * -1)) {
					res += map.get(sum2[i * n + j] * -1);
				}
			}
		}
		return res;
	}

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		int n = sc.nextInt();
		int[] arr1 = new int[n];
		int[] arr2 = new int[n];
		int[] arr3 = new int[n];
		int[] arr4 = new int[n];
		for (int i = 0; i < n; i++) {
			arr1[i] = sc.nextInt();
		}
		for (int i = 0; i < n; i++) {
			arr2[i] = sc.nextInt();
		}
		for (int i = 0; i < n; i++) {
			arr3[i] = sc.nextInt();
		}
		for (int i = 0; i < n; i++) {
			arr4[i] = sc.nextInt();
		}
		System.out.println(fourSumCount(arr1, arr2, arr3, arr4));
	}

}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Powerful Number</span>
import java.util.*;

public class Main {
    
	public static void main(String[] args) {
		Scanner scn = new Scanner(System.in);
		int x = scn.nextInt();
		int y = scn.nextInt();
		int bound = scn.nextInt();
		ArrayList<Integer> ret = new ArrayList<>();
		ret = powerfulIntegers(x, y, bound);
		Collections.sort(ret);
		for (int i = 0; i < ret.size(); i++) {
			System.out.print(ret.get(i) + " ");
		}
	}

	public static ArrayList<Integer> powerfulIntegers(int x, int y, int bound) {
		ArrayList<Integer> ans = new ArrayList<Integer>();
		HashSet<Integer> set = new HashSet<Integer>();
		for(int i = 1; i < bound; i *= x) {
			for(int j = 1; j < bound; j *= y) {
				if(i + j <= bound) {
					set.add(i + j);
					if(y == 1) {
						break;
					}
				}
			}
			if(x == 1) {
				break;
			}
		}
		ans.addAll(set);
		return ans;
	}

}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Subdomain Visit Count</span>
import java.util.*;

public class Main {
    
	public static List<String> subdomainVisits(String[] cpdomains) {
		HashMap<String, Integer> map = new HashMap<String, Integer>();
		for (String str : cpdomains) {
			StringBuilder sb = new StringBuilder();
			int i = 0;
			while (str.charAt(i) != ' ') {
				sb.append(str.charAt(i));
				i++;
			}
			int num = Integer.parseInt(sb.toString());
			int j = str.length() - 1;
			String s = "";
			while(j >= i) {
				char ch = str.charAt(j);
				if (ch == '.' || ch == ' ') {
					if(map.containsKey(s)) {
						map.put(s, map.get(s) + num);
					}else {
						map.put(s, num);
					}
				}
				s = ch + s;
				j--;
			}
		}
		List<String> ans = new ArrayList<String>();
		for(String str : map.keySet()) {
			String s = map.get(str) + " " + str;
			ans.add(s);
		}
		return ans;
	}

	public static void main(String[] args) {
		Scanner s = new Scanner(System.in);
		int n = Integer.parseInt(s.nextLine());
		String[] cpd = new String[n];
		for (int i = 0; i < cpd.length; i++) {
			cpd[i] = s.nextLine();
		}
		List<String> ans = subdomainVisits(cpd);
		Collections.sort(ans);
		for(String str : ans){
			System.out.println(str);
		}
	}

}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">First Non-repeating Character</span>
import java.util.*;

public class Main {
    
	public static void main(String[] args){
		Scanner scn = new Scanner(System.in);
		String s= scn.next();
		System.out.print(solution(s));
	}
	
	public static int solution(String s) {
	  HashMap<Character, Integer> map = new HashMap<>();
	  for(int i = 0 ; i < s.length() ;i++) {
		  char ch = s.charAt(i);
		  map.put(ch, map.getOrDefault(ch, 0) + 1);
	  }
	  for(int i = 0 ; i< s.length() ;i++) {
		  char ch = s.charAt(i);
		  if(map.get(ch) == 1) {
			  return i;
		  }
	  }
	  return -1;
  }

}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Lru Cache</span>
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.HashMap;

public class Main {
  public static class LRU {

    class Node {
      int key;
      int val;
      Node prev, next;
    }

    private void addNode(Node node) {
      node.next = head.next;
      node.prev = head;

      head.next.prev = node;
      head.next = node;
    }

    private void removeNode(Node node) {
      Node prv = node.prev;
      Node nxt = node.next;

      prv.next = nxt;
      nxt.prev = prv;
    }

    private void moveToFront(Node node) {
      removeNode(node);
      addNode(node);
    }

    HashMap<Integer, Node> cache;
    Node head, tail;
    int cap;

    public LRU(int capacity) {
      head = new Node();
      tail = new Node();
      head.next = tail;
      tail.prev = head;
      cache = new HashMap<>();
      cap = capacity;
    }

    public int get(int key) {
      Node node = cache.get(key);

      if (node == null) {
        return -1;
      } else {
        moveToFront(node);
        return node.val;
      }
    }

    public void put(int key, int value) {
      Node node = cache.get(key);

      if (node != null) {
        node.val = value;
        moveToFront(node);
      } else {
        Node newNode = new Node();
        newNode.key = key;
        newNode.val = value;
        if (cache.size() == cap) {
          int LRU_Key = tail.prev.key;
          Node LRU_Node = cache.remove(LRU_Key);
          removeNode(LRU_Node);
        }
        cache.put(key, newNode);
        addNode(newNode);
      }
    }
  }
  public static void main(String[] args) throws Exception {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    String str = br.readLine();
    LRU obj = new LRU(Integer.parseInt(str.split(" ")[1]));

    while (true) {
      str = br.readLine();
      String inp[] = str.split(" ");
      if (inp.length == 1) {
        break;
      } else if (inp.length == 2) {
        System.out.println(obj.get(Integer.parseInt(inp[1])));
      } else if (inp.length == 3) {
        obj.put(Integer.parseInt(inp[1]), Integer.parseInt(inp[2]));
      }
    }
  }
}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
X Of A Kind In A Deck

<span id="line">-----------------------------------------------------------------------------------------------------</span>


<span id="line">-----------------------------------------------------------------------------------------------------</span>
Max Frequency Stack

<span id="line">-----------------------------------------------------------------------------------------------------</span>

<span id="line">-----------------------------------------------------------------------------------------------------</span>

<span id="line">-----------------------------------------------------------------------------------------------------</span>

<span id="line">-----------------------------------------------------------------------------------------------------</span>

<span id="line">-----------------------------------------------------------------------------------------------------</span>

<span id="line">-----------------------------------------------------------------------------------------------------</span>

<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Line Reflection</span>
import java.io.*;
import java.util.*;

public class Main {

  public static boolean isReflected(int[][] points) {
    HashMap<Long, Integer> map = new HashMap<>();
    long xmin = Integer.MAX_VALUE;
    long xmax = Integer.MIN_VALUE;

    for (int[] point : points) {
      long x = point[0];
      long y = point[1];

      xmin = Math.min(xmin, x);
      xmax = Math.max(xmax, x);

      long hash = x * 100000000 + y;
      map.put(hash, 1);
    }

    long mirr = xmin + xmax;
    for (int[] point : points) {
      int x = point[0];
      int y = point[1];

      long ximg = mirr - x;
      long yimg = y;
      long imghash = ximg * 100000000 + yimg;

      if (map.containsKey(imghash) == false) {
        return false;
      }
    }
    return true;
  }

  public static void main(String[] args) {
    Scanner scn = new Scanner(System.in);
    int n = scn.nextInt();

    int[][] points = new int[n][2];
    for (int i = 0; i < points.length; i++) {
      for (int j = 0; j < points[0].length; j++) {
        points[i][j] = scn.nextInt();
      }
    }

    System.out.println(isReflected(points));
  }

}
                                
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Longest Substring With At Most Two Distinct Characters</span>
import java.util.*;
import java.io.*;

public class Main {

  public static int lengthOfLongestSubstringTwoDistinct(String s) {
    HashMap<Character, Integer> count = new HashMap<>();
    int dis = 0;

    int start = 0;
    int ans = 0;
    for (int i = 0; i < s.length(); i++) {

      int fre = count.getOrDefault(s.charAt(i), 0);
      if (fre == 0)dis++;
      count.put(s.charAt(i), fre + 1);

      while (dis > 2) {
        fre = count.get(s.charAt(start));
        count.put(s.charAt(start), fre - 1);
        if (fre - 1 == 0) {
          dis--;
        }
        start++;
      }

      ans = Math.max(ans, i - start + 1);
    }
    return ans;
  }

  public static void main(String[] args) throws java.lang.Exception {

    Scanner scn = new Scanner(System.in);

    int ans = lengthOfLongestSubstringTwoDistinct(scn.nextLine());
    System.out.println(ans);
  }
}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Minimum Cost To Connect Sticks</span>
import java.io.*;
import java.util.*;

public class Main {

  public static int connectSticks(int[] sticks) {

    PriorityQueue<Integer> q = new PriorityQueue<>();
    for (int stick : sticks) {
      q.add(stick);
    }

    int cost = 0;
    while (q.size() > 1) {
      int s1 = q.remove();
      int s2 = q.remove();

      cost += s1 + s2;
      q.add(s1 + s2);
    }

    return cost;

  }

  public static void main(String[] args) {
    Scanner scn = new Scanner(System.in);
    int n = scn.nextInt();

    int[] sticks = new int[n];
    for (int i = 0; i < sticks.length; i++) {
      sticks[i] = scn.nextInt();
    }

    System.out.println(connectSticks(sticks));
  }

}
<span id="line">-----------------------------------------------------------------------------------------------------</span>

<span id="line">-----------------------------------------------------------------------------------------------------</span>

<span id="line">-----------------------------------------------------------------------------------------------------</span>

<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Tree</span>										
<span class="textStyle">Tree</span>										
<span class="textStyle">Tree</span>										
<span class="textStyle">TREE</span>										
<span class="textStyle">tree</span>										
<span class="textStyle">In Order Morris Traversal In Binarytree</span>
import java.util.*;

public class Main {
  public static Scanner scn = new Scanner(System.in);

  public static class TreeNode {
    int val = 0;
    TreeNode left = null;
    TreeNode right = null;

    TreeNode(int val) {
      this.val = val;
    }
  }

  public static TreeNode rightMostNode(TreeNode node, TreeNode curr) {
    while (node.right != null && node.right != curr) {
      node = node.right;
    }
    return node;
  }

  public static ArrayList<Integer> morrisInTraversal(TreeNode Treenode) {
    ArrayList<Integer> ans = new ArrayList<>();
    TreeNode curr = Treenode;
    while (curr != null) {
      TreeNode leftTreeNode = curr.left;
      if (leftTreeNode == null) { // left null
        ans.add(curr.val);
        curr = curr.right;
      } else {
        TreeNode rmost = rightMostNode(leftTreeNode, curr);
        if (rmost.right == null) { // thread Creation
          rmost.right = curr;
          curr = curr.left;
        } else { // thread Break
          rmost.right = null;
          ans.add(curr.val);
          curr = curr.right;
        }
      }
    }

    return ans;
  }

  // input_section=================================================

  public static TreeNode createTree(int[] arr, int[] IDX) {
    if (IDX[0] > arr.length || arr[IDX[0]] == -1) {
      IDX[0]++;
      return null;
    }
    TreeNode Treenode = new TreeNode(arr[IDX[0]++]);
    Treenode.left = createTree(arr, IDX);
    Treenode.right = createTree(arr, IDX);

    return Treenode;
  }

  public static void solve() {
    int n = scn.nextInt();
    int[] arr = new int[n];
    for (int i = 0; i < n; i++)
      arr[i] = scn.nextInt();

    int[] IDX = new int[1];
    TreeNode root = createTree(arr, IDX);

    ArrayList<Integer> ans = morrisInTraversal(root);
    for (Integer i : ans)
      System.out.print(i + " ");

  }

  public static void main(String[] args) {
    solve();
  }
}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Pre Order Morris Traversal In Binary Tree</span>
import java.util.*;

public class Main {
  public static Scanner scn = new Scanner(System.in);

  public static class TreeNode {
    int val = 0;
    TreeNode left = null;
    TreeNode right = null;

    TreeNode(int val) {
      this.val = val;
    }
  }

  public static TreeNode rightMostNode(TreeNode node, TreeNode curr) {
    while (node.right != null && node.right != curr) {
      node = node.right;
    }
    return node;
  }

  public static ArrayList<Integer> morrisPreTraversal(TreeNode Treenode) {
    ArrayList<Integer> ans = new ArrayList<>();
    TreeNode curr = Treenode;
    while (curr != null) {
      TreeNode leftTreeNode = curr.left;
      if (leftTreeNode == null) { // left null
        ans.add(curr.val);
        curr = curr.right;
      } else {
        TreeNode rmost = rightMostNode(leftTreeNode, curr);
        if (rmost.right == null) { // thread Creation
          rmost.right = curr;
          ans.add(curr.val);
          curr = curr.left;
        } else { // thread Break
          rmost.right = null;
          curr = curr.right;
        }
      }
    }

    return ans;
  }

  // input_section=================================================

  public static TreeNode createTree(int[] arr, int[] IDX) {
    if (IDX[0] > arr.length || arr[IDX[0]] == -1) {
      IDX[0]++;
      return null;
    }
    TreeNode Treenode = new TreeNode(arr[IDX[0]++]);
    Treenode.left = createTree(arr, IDX);
    Treenode.right = createTree(arr, IDX);

    return Treenode;
  }

  public static void solve() {
    int n = scn.nextInt();
    int[] arr = new int[n];
    for (int i = 0; i < n; i++)
      arr[i] = scn.nextInt();

    int[] IDX = new int[1];
    TreeNode root = createTree(arr, IDX);

    ArrayList<Integer> ans = morrisPreTraversal(root);
    for (Integer i : ans)
      System.out.print(i + " ");

  }

  public static void main(String[] args) {
    solve();
  }
}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Cameras In Binary Tree</span>
import java.util.Scanner;

public class Main {
    public static Scanner scn = new Scanner(System.in);

    public static class TreeNode {
        int val = 0;
        TreeNode left = null;
        TreeNode right = null;

        TreeNode(int val) {
            this.val = val;
        }
    }

    // -1 : need a camera, 0 : i have a camera, 1 : i'm covered.
    static int camera = 0;

    public static int MinCamerasInBT_(TreeNode root) {
        if (root == null) {
            return 1;
        }

        int lres = MinCamerasInBT_(root.left);
        int rres = MinCamerasInBT_(root.right);

        if (lres == -1 || rres == -1) {
            camera++;
            return 0;
        }

        if (lres == 0 || rres == 0) {
            return 1;
        }

        return -1;
    }

    public static int MinCamerasInBT(TreeNode root) {
        if (MinCamerasInBT_(root) == -1)
            camera++;
        return camera;
    }

    // input_Section_====================================================================

    public static TreeNode createTree(int[] arr, int[] IDX) {
        if (IDX[0] > arr.length || arr[IDX[0]] == -1){
            IDX[0]++;
            return null;
        }

        TreeNode node = new TreeNode(arr[IDX[0]++]);
        node.left = createTree(arr, IDX);
        node.right = createTree(arr, IDX);

        return node;
    }

    public static void solve() {
        int n = scn.nextInt();
        int[] arr = new int[n];
        for (int i = 0; i < n; i++)
            arr[i] = scn.nextInt();

        int[] IDX = new int[1];
        TreeNode root = createTree(arr, IDX);

        System.out.println(MinCamerasInBT(root));
    }

    public static void main(String[] args) {
        solve();
    }
}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">House Robber In Binary Tree</span>
import java.util.Scanner;

public class Main {
    public static Scanner scn = new Scanner(System.in);

    public static class TreeNode {
        int val = 0;
        TreeNode left = null;
        TreeNode right = null;

        TreeNode(int val) {
            this.val = val;
        }
    }

    // [] - > {store the max value without robbing current node, store the max value
    // with robing current node}
    public static int[] HouseRobber_(TreeNode node) {
        if (node == null)
            return new int[] { 0, 0 };

        int[] left = HouseRobber_(node.left);
        int[] right = HouseRobber_(node.right);

        int[] myAns = new int[2];
        myAns[0] = Math.max(left[0], left[1]) + Math.max(right[0], right[1]);
        myAns[1] = left[0] + node.val + right[0];

        return myAns;
    }

    public static int HouseRobber(TreeNode root) {
        int[] ans = HouseRobber_(root);
        return Math.max(ans[0], ans[1]);
    }

    // input_Section_====================================================================

    public static TreeNode createTree(int[] arr, int[] IDX) {
        if (IDX[0] > arr.length || arr[IDX[0]] == -1){
            IDX[0]++;
            return null;
        }
        TreeNode node = new TreeNode(arr[IDX[0]++]);
        node.left = createTree(arr, IDX);
        node.right = createTree(arr, IDX);

        return node;
    }

    public static void solve() {
        int n = scn.nextInt();
        int[] arr = new int[n];
        for (int i = 0; i < n; i++)
            arr[i] = scn.nextInt();

        int[] IDX = new int[1];
        TreeNode root = createTree(arr, IDX);

        System.out.println(HouseRobber(root));
    }

    public static void main(String[] args) {
        solve();
    }
}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Longest Zigzag Path In A Binary Tree</span>
import java.util.Scanner;

public class Main {
    public static Scanner scn = new Scanner(System.in);

    public static class TreeNode {
        int val = 0;
        TreeNode left = null;
        TreeNode right = null;

        TreeNode(int val) {
            this.val = val;
        }
    }

    static int ans = 0;

    public static int[] dfs(TreeNode root) {
        if (root == null)
            return new int[] { -1, -1 };

        int[] left = dfs(root.left);
        int[] right = dfs(root.right);

        ans = Math.max(ans, Math.max(left[1], right[0]) + 1);
        return new int[] { left[1] + 1, right[0] + 1 };
    }

    public static int longestZigZagPath(TreeNode root) {
        dfs(root);
        return ans;
    }

    // input_Section_====================================================================

    public static TreeNode createTree(int[] arr, int[] IDX) {
        if (IDX[0] > arr.length || arr[IDX[0]] == -1){
            IDX[0]++;
            return null;
        }

        TreeNode node = new TreeNode(arr[IDX[0]++]);
        node.left = createTree(arr, IDX);
        node.right = createTree(arr, IDX);

        return node;
    }

    public static void solve() {
        int n = scn.nextInt();
        int[] arr = new int[n];
        for (int i = 0; i < n; i++)
            arr[i] = scn.nextInt();

        int[] IDX = new int[1];
        TreeNode root = createTree(arr, IDX);

        System.out.println(longestZigZagPath(root));
    }

    public static void main(String[] args) {
        solve();
    }
}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Validate Bst</span>
import java.util.Scanner;

public class Main {
    public static Scanner scn = new Scanner(System.in);

    public static class TreeNode {
        int val = 0;
        TreeNode left = null;
        TreeNode right = null;

        TreeNode(int val) {
            this.val = val;
        }
    }

    static TreeNode prev = null;

    public static boolean isValidBST(TreeNode root) {
        if (root == null)
            return true;

        if (!isValidBST(root.left))
            return false;

        if (prev != null && prev.val >= root.val)
            return false;
        prev = root;

        if (!isValidBST(root.right))
            return false;

        return true;
    }

    public static TreeNode createTree(int[] arr, int[] IDX) {
        if (IDX[0] > arr.length || arr[IDX[0]] == -1){
            IDX[0]++;
            return null;
        }

        TreeNode node = new TreeNode(arr[IDX[0]++]);
        node.left = createTree(arr, IDX);
        node.right = createTree(arr, IDX);

        return node;
    }

    public static void solve() {
        int n = scn.nextInt();
        int[] arr = new int[n];
        for (int i = 0; i < n; i++)
            arr[i] = scn.nextInt();

        int[] IDX = new int[1];
        TreeNode root = createTree(arr, IDX);
        System.out.println(isValidBST(root));
    }

    public static void main(String[] args) {
        solve();
    }
}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Recover Bst</span>
import java.util.Scanner;

public class Main {
    public static Scanner scn = new Scanner(System.in);

    public static class TreeNode {
        int val = 0;
        TreeNode left = null;
        TreeNode right = null;

        TreeNode(int val) {
            this.val = val;
        }
    }

    static TreeNode a = null, b = null, prev = null;

    public static boolean recoverTree_(TreeNode root) {

        if (root == null)
            return true;

        if (!recoverTree_(root.left))
            return false;

        if (prev != null && prev.val > root.val) {
            b = root;
            if (a == null)
                a = prev;
            else
                return false;
        }

        prev = root;
        if (!recoverTree_(root.right))
            return false;

        return true;

    }

    public static void recoverTree(TreeNode root) {
        recoverTree_(root);
        if (a != null) {
            int temp = a.val;
            a.val = b.val;
            b.val = temp;
        }
    }

    // input_section=================================================

    public static void display(TreeNode node) {
        if (node == null)
            return;

        StringBuilder sb = new StringBuilder();
        sb.append((node.left != null ? node.left.val : "."));
        sb.append(" -> " + node.val + " <- ");
        sb.append((node.right != null ? node.right.val : "."));

        System.out.println(sb.toString());

        display(node.left);
        display(node.right);

    }

    public static TreeNode createTree(int[] arr, int[] IDX) {
        if (IDX[0] > arr.length || arr[IDX[0]] == -1) {
            IDX[0]++;
            return null;
        }

        TreeNode node = new TreeNode(arr[IDX[0]++]);
        node.left = createTree(arr, IDX);
        node.right = createTree(arr, IDX);

        return node;
    }

    public static void solve() {
        int n = scn.nextInt();
        int[] arr = new int[n];
        for (int i = 0; i < n; i++)
            arr[i] = scn.nextInt();

        int[] IDX = new int[1];
        TreeNode root = createTree(arr, IDX);
        recoverTree(root);
        display(root);
    }

    public static void main(String[] args) {
        solve();
    }
}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Construct Binarytree From Preorder And Inorder Traversal</span>
import java.util.Scanner;

public class Main {
    public static Scanner scn = new Scanner(System.in);

    public static class TreeNode {
        int val = 0;
        TreeNode left = null;
        TreeNode right = null;

        TreeNode(int val) {
            this.val = val;
        }
    }

    // psi = pre starting index, isi = in-order starting index.
    public static TreeNode preInTree(int[] preorder, int psi, int pei, int[] inorder, int isi, int iei) {
        if (psi > pei)
            return null;

        TreeNode node = new TreeNode(preorder[psi]);

        int idx = isi;
        while (inorder[idx] != preorder[psi])
            idx++;

        int tnel = idx - isi; // total no of elements.

        node.left = preInTree(preorder, psi + 1, psi + tnel, inorder, isi, idx - 1);
        node.right = preInTree(preorder, psi + tnel + 1, pei, inorder, idx + 1, iei);

        return node;
    }

    public static TreeNode buildTree(int[] preorder, int[] inorder) {
        return preInTree(preorder, 0, preorder.length - 1, inorder, 0, inorder.length - 1);
    }

    // input_section=================================================

    public static void display(TreeNode node) {
        if (node == null)
            return;

        StringBuilder sb = new StringBuilder();
        sb.append((node.left != null ? node.left.val : "."));
        sb.append(" -> " + node.val + " <- ");
        sb.append((node.right != null ? node.right.val : "."));

        System.out.println(sb.toString());

        display(node.left);
        display(node.right);

    }

    public static void solve() {
        int n = scn.nextInt();
        int[] pre = new int[n];
        for (int i = 0; i < n; i++)
            pre[i] = scn.nextInt();

        int[] in = new int[n];
        for (int i = 0; i < n; i++)
            in[i] = scn.nextInt();

        TreeNode root = buildTree(pre, in);
        display(root);
    }

    public static void main(String[] args) {
        solve();
    }
}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Construct Binarytree From Postorder And Inorder Traversal</span>
import java.util.Scanner;

public class Main {
    public static Scanner scn = new Scanner(System.in);

    public static class TreeNode {
        int val = 0;
        TreeNode left = null;
        TreeNode right = null;

        TreeNode(int val) {
            this.val = val;
        }
    }

    public static TreeNode postInTree(int[] post, int psi, int pei, int[] in, int isi, int iei) {
        if (psi > pei)
            return null;

        TreeNode node = new TreeNode(post[pei]);
        int idx = isi;
        while (in[idx] != post[pei])
            idx++;

        int tnel = idx - isi;

        node.left = postInTree(post, psi, psi + tnel - 1, in, isi, idx - 1);
        node.right = postInTree(post, psi + tnel, pei - 1, in, idx + 1, iei);

        return node;
    }

    public static TreeNode buildTree(int[] inorder, int[] postorder) {
        int n = postorder.length;
        return postInTree(postorder, 0, n - 1, inorder, 0, n - 1);
    }

    // input_section=================================================

    public static void display(TreeNode node) {
        if (node == null)
            return;

        StringBuilder sb = new StringBuilder();
        sb.append((node.left != null ? node.left.val : "."));
        sb.append(" -> " + node.val + " <- ");
        sb.append((node.right != null ? node.right.val : "."));

        System.out.println(sb.toString());

        display(node.left);
        display(node.right);

    }

    public static void solve() {
        int n = scn.nextInt();
        int[] post = new int[n];
        for (int i = 0; i < n; i++)
            post[i] = scn.nextInt();

        int[] in = new int[n];
        for (int i = 0; i < n; i++)
            in[i] = scn.nextInt();

        TreeNode root = buildTree(in, post);
        display(root);
    }

    public static void main(String[] args) {
        solve();
    }
}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Construct Binary Tree From Inorder And Levelorder Traversal</span>
import java.util.*;

public class Main {
  public static Scanner scn = new Scanner(System.in);

  static class TreeNode {
    int val;
    TreeNode left = null, right = null;

    TreeNode(int val) {
      this.val = val;
    }
  }

  public static TreeNode buildTree(int inorder[], int levelOrder[], int isi, int iei) {
    if (isi > iei)
      return null;

    TreeNode root = new TreeNode(levelOrder[0]);

    int idx = isi;
    while (levelOrder[0] != inorder[idx])
      idx++;

    HashSet<Integer> s = new HashSet<>();
    for (int i = isi; i < idx; i++)
      s.add(inorder[i]);

    int n = iei - isi + 1;
    int[] lLevel = new int[s.size()]; // Left
    int[] rLevel = new int[n - s.size()]; // Right
    int li = 0, ri = 0;
    for (int i = 1; i < n; i++) {
      if (s.contains(levelOrder[i]))
        lLevel[li++] = levelOrder[i];
      else
        rLevel[ri++] = levelOrder[i];
    }

    root.left = buildTree(inorder, lLevel, isi, idx - 1);
    root.right = buildTree(inorder, rLevel, idx + 1, iei);
    return root;
  }

  public static TreeNode buildTree(int[] inorder, int[] levelOrder) {
    int n = levelOrder.length;
    return buildTree(inorder, levelOrder, 0, n - 1);
  }

  // input_section=================================================

  public static void display(TreeNode node) {
    if (node == null)
      return;

    StringBuilder sb = new StringBuilder();
    sb.append((node.left != null ? node.left.val : "."));
    sb.append(" -> " + node.val + " <- ");
    sb.append((node.right != null ? node.right.val : "."));

    System.out.println(sb.toString());

    display(node.left);
    display(node.right);

  }

  public static void solve() {
    int n = scn.nextInt();

    int[] InOrder = new int[n];
    for (int i = 0; i < n; i++)
      InOrder[i] = scn.nextInt();

    int[] LevelOrder = new int[n];
    for (int i = 0; i < n; i++)
      LevelOrder[i] = scn.nextInt();

    TreeNode root = buildTree(InOrder, LevelOrder);
    display(root);
  }

  public static void main(String[] args) {
    solve();
  }

}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Construct Binary Tree From Preorder And Postorder Traversal</span>
import java.util.Scanner;

public class Main {
    public static Scanner scn = new Scanner(System.in);

    public static class TreeNode {
        int val = 0;
        TreeNode left = null;
        TreeNode right = null;

        TreeNode(int val) {
            this.val = val;
        }
    }

    public static TreeNode postPreTree(int[] post, int ppsi, int ppei, int[] pre, int psi, int pei) {
        if (psi > pei)
            return null;

        TreeNode node = new TreeNode(pre[psi]);

        if (psi == pei)
            return node;

        int idx = ppsi;
        while (post[idx] != pre[psi + 1])
            idx++;

        int tnel = idx - ppsi + 1;
        node.left = postPreTree(post, ppsi, idx, pre, psi + 1, psi + tnel);
        node.right = postPreTree(post, idx + 1, ppei - 1, pre, psi + tnel + 1, pei);

        return node;
    }

    public static TreeNode constructFromPrePost(int[] pre, int[] post) {
        int n = post.length;
        return postPreTree(post, 0, n - 1, pre, 0, n - 1);
    }

    // input_section=================================================

    public static void display(TreeNode node) {
        if (node == null)
            return;

        StringBuilder sb = new StringBuilder();
        sb.append((node.left != null ? node.left.val : "."));
        sb.append(" -> " + node.val + " <- ");
        sb.append((node.right != null ? node.right.val : "."));

        System.out.println(sb.toString());

        display(node.left);
        display(node.right);

    }

    public static void solve() {
        int n = scn.nextInt();
        int[] post = new int[n];
        for (int i = 0; i < n; i++)
            post[i] = scn.nextInt();

        int[] pre = new int[n];
        for (int i = 0; i < n; i++)
            pre[i] = scn.nextInt();

        TreeNode root = constructFromPrePost(pre, post);
        display(root);
    }

    public static void main(String[] args) {
        solve();
    }
}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Construct Bst From Inorder Traversal</span>
import java.util.Scanner;

public class Main {
    public static Scanner scn = new Scanner(System.in);

    public static class TreeNode {
        int val = 0;
        TreeNode left = null;
        TreeNode right = null;

        TreeNode(int val) {
            this.val = val;
        }
    }

    public static TreeNode constructFromInOrder_(int[] in, int si, int ei) {
        if (si > ei)
            return null;

        int mid = (si + ei) / 2;
        TreeNode node = new TreeNode(in[mid]);

        node.left = constructFromInOrder_(in, si, mid - 1);
        node.right = constructFromInOrder_(in, mid + 1, ei);

        return node;
    }

    public static TreeNode constructFromInOrder(int[] inOrder) {
        int n = inOrder.length;
        return constructFromInOrder_(inOrder, 0, n - 1);
    }

    // input_section=================================================

    public static void display(TreeNode node) {
        if (node == null)
            return;

        StringBuilder sb = new StringBuilder();
        sb.append((node.left != null ? node.left.val : "."));
        sb.append(" -> " + node.val + " <- ");
        sb.append((node.right != null ? node.right.val : "."));

        System.out.println(sb.toString());

        display(node.left);
        display(node.right);

    }

    public static void solve() {
        int n = scn.nextInt();
        int[] in = new int[n];
        for (int i = 0; i < n; i++)
            in[i] = scn.nextInt();

        TreeNode root = constructFromInOrder(in);
        display(root);
    }

    public static void main(String[] args) {
        solve();
    }
}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Construct Bst From Preorder Traversal</span>
import java.util.Scanner;

public class Main {
    public static Scanner scn = new Scanner(System.in);

    public static class TreeNode {
        int val = 0;
        TreeNode left = null;
        TreeNode right = null;

        TreeNode(int val) {
            this.val = val;
        }
    }

    // lr -> left range, rr = right range
    static int bst_idx = 0;

    public static TreeNode constructBSTFromPreOrder(int[] arr, int lr, int rr) {
        if (bst_idx == arr.length || arr[bst_idx] < lr || arr[bst_idx] > rr)
            return null;

        TreeNode node = new TreeNode(arr[bst_idx++]);
        node.left = constructBSTFromPreOrder(arr, lr, node.val);
        node.right = constructBSTFromPreOrder(arr, node.val, rr);

        return node;
    }

    public static TreeNode bstFromPreorder(int[] preorder) {
        return constructBSTFromPreOrder(preorder, -(int) 1e8, (int) 1e8);
    }

    // input_section=================================================

    public static void display(TreeNode node) {
        if (node == null)
            return;

        StringBuilder sb = new StringBuilder();
        sb.append((node.left != null ? node.left.val : "."));
        sb.append(" -> " + node.val + " <- ");
        sb.append((node.right != null ? node.right.val : "."));

        System.out.println(sb.toString());

        display(node.left);
        display(node.right);

    }

    public static void solve() {
        int n = scn.nextInt();
        int[] pre = new int[n];
        for (int i = 0; i < n; i++)
            pre[i] = scn.nextInt();

        TreeNode root = bstFromPreorder(pre);
        display(root);
    }

    public static void main(String[] args) {
        solve();
    }
}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Construct Bst From Postorder Traversal</span>
import java.util.Scanner;

public class Main {
    public static Scanner scn = new Scanner(System.in);

    public static class TreeNode {
        int val = 0;
        TreeNode left = null;
        TreeNode right = null;

        TreeNode(int val) {
            this.val = val;
        }
    }

    // lr -> left range, rr = right range
    static int bst_idx = 0;

    public static TreeNode constructBSTFromPostOrder(int[] arr, int lr, int rr) {
        if (bst_idx == -1 || arr[bst_idx] < lr || arr[bst_idx] > rr)
            return null;

        TreeNode node = new TreeNode(arr[bst_idx--]);
        node.right = constructBSTFromPostOrder(arr, node.val, rr);
        node.left = constructBSTFromPostOrder(arr, lr, node.val);

        return node;
    }

    public static TreeNode bstFromPostorder(int[] preorder) {
        return constructBSTFromPostOrder(preorder, -(int) 1e8, (int) 1e8);
    }

    // input_section=================================================

    public static void display(TreeNode node) {
        if (node == null)
            return;

        StringBuilder sb = new StringBuilder();
        sb.append((node.left != null ? node.left.val : "."));
        sb.append(" -> " + node.val + " <- ");
        sb.append((node.right != null ? node.right.val : "."));

        System.out.println(sb.toString());

        display(node.left);
        display(node.right);

    }

    public static void solve() {
        int n = scn.nextInt();
        int[] pre = new int[n];
        for (int i = 0; i < n; i++)
            pre[i] = scn.nextInt();

        bst_idx = n - 1;
        TreeNode root = bstFromPostorder(pre);
        display(root);
    }

    public static void main(String[] args) {
        solve();
    }
}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Construct Bst From Levelorder Traversal</span>
import java.util.*;

public class Main {
  public static Scanner scn = new Scanner(System.in);

  public static class TreeNode {
    int val = 0;
    TreeNode left = null;
    TreeNode right = null;

    TreeNode(int val) {
      this.val = val;
    }
  }

  public static class levelPair {
    TreeNode par = null;
    int lb = -(int) 1e8;
    int rb = (int) 1e8;

    levelPair() {

    }

    levelPair(TreeNode par, int lb, int rb) {
      this.par = par;
      this.lb = lb;
      this.rb = rb;
    }
  }

  public static TreeNode constructBSTFromLevelOrder(int[] arr) {
    int idx = 0;
    LinkedList<levelPair> que = new LinkedList<>();
    que.add(new levelPair());
    TreeNode root = null;

    while (que.size() != 0 && idx < arr.length) {
      levelPair pair = que.removeFirst();

      if (arr[idx] < pair.lb || arr[idx] > pair.rb)
        continue;

      TreeNode node = new TreeNode(arr[idx++]);
      if (pair.par == null)
        root = node;
      else {
        if (node.val < pair.par.val)
          pair.par.left = node;
        else
          pair.par.right = node;
      }

      que.addLast(new levelPair(node, pair.lb, node.val));
      que.addLast(new levelPair(node, node.val, pair.rb));
    }

    return root;
  }

  // input_section=================================================

  public static void display(TreeNode node) {
    if (node == null)
      return;

    StringBuilder sb = new StringBuilder();
    sb.append((node.left != null ? node.left.val : "."));
    sb.append(" -> " + node.val + " <- ");
    sb.append((node.right != null ? node.right.val : "."));

    System.out.println(sb.toString());

    display(node.left);
    display(node.right);

  }

  public static void solve() {
    int n = scn.nextInt();
    int[] level = new int[n];
    for (int i = 0; i < n; i++)
      level[i] = scn.nextInt();

    TreeNode root = constructBSTFromLevelOrder(level);
    display(root);
  }

  public static void main(String[] args) {
    solve();
  }
}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Serialize And Deserialize Binary Tree</span>
import java.util.*;

public class Main {
    public static Scanner scn = new Scanner(System.in);

    public static class TreeNode {
        int val = 0;
        TreeNode left = null;
        TreeNode right = null;

        TreeNode(int val) {
            this.val = val;
        }
    }

    // Encodes a tree to a single string.
    private static void serialize_(TreeNode root, StringBuilder sb) {
        if (root == null) {
            sb.append("-1001 ");
            return;
        }

        sb.append(root.val + " ");
        serialize_(root.left, sb);
        serialize_(root.right, sb);
    }

    public static String serialize(TreeNode root) {

        StringBuilder sb = new StringBuilder();
        serialize_(root, sb);
        return sb.toString();
    }

    static int idx = 0;

    private static TreeNode deserialize(int[] arr) {
        if (idx >= arr.length || arr[idx] == -1001) {
            idx++;
            return null;
        }

        TreeNode node = new TreeNode(arr[idx++]);
        node.left = deserialize(arr);
        node.right = deserialize(arr);

        return node;
    }

    // Decodes your encoded data to tree.
    public static TreeNode deserialize(String str) {
        String[] ar = str.split(" ");
        int[] arr = new int[ar.length];
        int i = 0;
        for (String s : ar)
            arr[i++] = Integer.parseInt(s);

        return deserialize(arr);
    }

    // input_section=================================================

    public static void display(TreeNode node) {
        if (node == null)
            return;

        StringBuilder sb = new StringBuilder();
        sb.append((node.left != null ? node.left.val : "."));
        sb.append(" -> " + node.val + " <- ");
        sb.append((node.right != null ? node.right.val : "."));

        System.out.println(sb.toString());

        display(node.left);
        display(node.right);

    }

    public static TreeNode createTree(int[] arr, int[] IDX) {
        if (IDX[0] > arr.length || arr[IDX[0]] == -1) {
            IDX[0]++;
            return null;
        }
        TreeNode node = new TreeNode(arr[IDX[0]++]);
        node.left = createTree(arr, IDX);
        node.right = createTree(arr, IDX);

        return node;
    }

    public static void solve() {
        int n = scn.nextInt();
        int[] arr = new int[n];
        for (int i = 0; i < n; i++)
            arr[i] = scn.nextInt();

        int[] IDX = new int[1];
        TreeNode root = createTree(arr, IDX);

        String s = serialize(root);
        display(deserialize(s));
    }

    public static void main(String[] args) {
        solve();
    }
}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Serialize And Deserialize N - Ary Tree</span>
import java.util.*;

public class Main {
  public static Scanner scn = new Scanner(System.in);

  static class Node {
    public int val;
    public ArrayList<Node> children;

    public Node() {
      children = new ArrayList<Node>();
    }

    public Node(int _val) {
      val = _val;
      children = new ArrayList<Node>();
    }

    public Node(int _val, ArrayList<Node> _children) {
      val = _val;
      children = _children;
    }
  }

  // Encodes a tree to a single string.
  public static void serialize(Node root, StringBuilder sb) {
    sb.append(root.val + " ");
    for (Node child : root.children) {
      serialize(child, sb);
    }
    sb.append("null ");
  }

  public static String serialize(Node root) {
    StringBuilder sb = new StringBuilder();
    serialize(root, sb);
    return sb.toString();
  }

  // Decodes your encoded data to tree.
  public static Node deserialize(String[] arr) {
    Stack<Node> st = new Stack<>();
    for (int i = 0; i < arr.length - 1; i++) {
      String s = arr[i];
      if (s.equals("null")) {
        Node node = st.pop();
        st.peek().children.add(node);
      } else {
        Node node = new Node(Integer.parseInt(s));
        st.push(node);
      }
    }

    return st.size() != 0 ? st.pop() : null;
  }

  public static Node deserialize(String str) {
    String[] arr = str.split(" ");
    return deserialize(arr);
  }

  // input_Section=================================================
  public static void display(Node node) {
    if (node == null)
      return;

    StringBuilder sb = new StringBuilder();
    sb.append(node.val + " -> ");
    for (Node child : node.children) {
      sb.append(child.val + " ");
    }
    System.out.println(sb.toString());

    for (Node child : node.children) {
      display(child);
    }
  }

  public static Node createTree(String[] arr) {
    Stack<Node> st = new Stack<>();
    for (int i = 0; i < arr.length - 1; i++) {
      String s = arr[i];
      if (s.equals("null")) {
        Node node = st.pop();
        st.peek().children.add(node);
      } else {
        Node node = new Node(Integer.parseInt(s));
        st.push(node);
      }
    }

    return st.size() != 0 ? st.pop() : null;
  }

  public static void solve() {
    String str = scn.nextLine();
    String[] arr = str.split(" ");

    Node root = createTree(arr);
    String s = serialize(root);
    display(deserialize(s));
  }

  public static void main(String[] args) {
    solve();
  }
}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Left View Of A Binarytree</span>
import java.util.*;

public class Main {
    public static Scanner scn = new Scanner(System.in);

    public static class TreeNode {
        int val = 0;
        TreeNode left = null;
        TreeNode right = null;

        TreeNode(int val) {
            this.val = val;
        }
    }

    public static ArrayList<Integer> leftView(TreeNode root) {
        LinkedList<TreeNode> que = new LinkedList<>();
        que.addLast(root);
        ArrayList<Integer> ans = new ArrayList<>();

        while (que.size() != 0) {
            int size = que.size();
            ans.add(que.getFirst().val);
            while (size-- > 0) {
                TreeNode rn = que.removeFirst(); // rn : remove Node

                if (rn.left != null)
                    que.addLast(rn.left);
                if (rn.right != null)
                    que.addLast(rn.right);
            }
        }
        return ans;
    }

    // input_section=================================================

    public static TreeNode createTree(int[] arr, int[] IDX) {
        if (IDX[0] > arr.length || arr[IDX[0]] == -1) {
            IDX[0]++;
            return null;
        }
        TreeNode node = new TreeNode(arr[IDX[0]++]);
        node.left = createTree(arr, IDX);
        node.right = createTree(arr, IDX);

        return node;
    }

    public static void solve() {
        int n = scn.nextInt();
        int[] arr = new int[n];
        for (int i = 0; i < n; i++)
            arr[i] = scn.nextInt();

        int[] IDX = new int[1];
        TreeNode root = createTree(arr, IDX);

        ArrayList<Integer> ans = leftView(root);
        for (Integer i : ans)
            System.out.println(i);
    }

    public static void main(String[] args) {
        solve();
    }
}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Right View Of A Binarytree</span>
import java.util.*;

public class Main {
    public static Scanner scn = new Scanner(System.in);

    public static class TreeNode {
        int val = 0;
        TreeNode left = null;
        TreeNode right = null;

        TreeNode(int val) {
            this.val = val;
        }
    }

    public static ArrayList<Integer> rightView(TreeNode root) {
        LinkedList<TreeNode> que = new LinkedList<>();
        que.addLast(root);
        ArrayList<Integer> ans = new ArrayList<>();

        while (que.size() != 0) {
            int size = que.size();
            ans.add(que.getFirst().val);
            while (size-- > 0) {
                TreeNode rn = que.removeFirst(); // rn : remove Node

                if (rn.right != null)
                    que.addLast(rn.right);
                if (rn.left != null)
                    que.addLast(rn.left);
            }
        }
        return ans;
    }

    // input_section=================================================

    public static TreeNode createTree(int[] arr, int[] IDX) {
        if (IDX[0] > arr.length || arr[IDX[0]] == -1) {
            IDX[0]++;
            return null;
        }
        TreeNode node = new TreeNode(arr[IDX[0]++]);
        node.left = createTree(arr, IDX);
        node.right = createTree(arr, IDX);

        return node;
    }

    public static void solve() {
        int n = scn.nextInt();
        int[] arr = new int[n];
        for (int i = 0; i < n; i++)
            arr[i] = scn.nextInt();

        int[] IDX = new int[1];
        TreeNode root = createTree(arr, IDX);

        ArrayList<Integer> ans = rightView(root);
        for (Integer i : ans)
            System.out.println(i);
    }

    public static void main(String[] args) {
        solve();
    }
}
                        
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Vertical Order Traversal Of A Binarytree</span>
import java.util.*;

public class Main {
    public static Scanner scn = new Scanner(System.in);

    public static class TreeNode {
        int val = 0;
        TreeNode left = null;
        TreeNode right = null;

        TreeNode(int val) {
            this.val = val;
        }
    }

    public static class verticalPair {
        TreeNode node = null;
        int hl = 0; // horizontal Level

        verticalPair(TreeNode node, int hl) {
            this.node = node;
            this.hl = hl;
        }
    }

    public static ArrayList<ArrayList<Integer>> verticalOrderTraversal(TreeNode root) {
        LinkedList<verticalPair> que = new LinkedList<>();
        que.addLast(new verticalPair(root, 0));
        HashMap<Integer, ArrayList<Integer>> map = new HashMap<>();

        int minHL = 0;
        int maxHL = 0;

        while (que.size() != 0) {
            int size = que.size();
            while (size-- > 0) {
                verticalPair rp = que.removeFirst();

                map.putIfAbsent(rp.hl, new ArrayList<>());
                // if (!map.containsKey(rp.hl))
                // map.put(rp.hl, new ArrayList<>());

                map.get(rp.hl).add(rp.node.val);

                minHL = Math.min(minHL, rp.hl);
                maxHL = Math.max(maxHL, rp.hl);

                if (rp.node.left != null)
                    que.addLast(new verticalPair(rp.node.left, rp.hl - 1));

                if (rp.node.right != null)
                    que.addLast(new verticalPair(rp.node.right, rp.hl + 1));
            }
        }

        ArrayList<ArrayList<Integer>> ans = new ArrayList<>();
        while (minHL <= maxHL) {
            ans.add(map.get(minHL));
            minHL++;
        }

        return ans;
    }

    // input_section=================================================

    public static TreeNode createTree(int[] arr, int[] IDX) {
        if (IDX[0] > arr.length || arr[IDX[0]] == -1) {
            IDX[0]++;
            return null;
        }
        TreeNode node = new TreeNode(arr[IDX[0]++]);
        node.left = createTree(arr, IDX);
        node.right = createTree(arr, IDX);

        return node;
    }

    public static void solve() {
        int n = scn.nextInt();
        int[] arr = new int[n];
        for (int i = 0; i < n; i++)
            arr[i] = scn.nextInt();

        int[] IDX = new int[1];
        TreeNode root = createTree(arr, IDX);

        ArrayList<ArrayList<Integer>> ans = verticalOrderTraversal(root);
        int idx = 0;
        for (ArrayList<Integer> i : ans) {
            System.out.print(idx++ + " -> ");
            for (Integer j : i)
                System.out.print(j + " ");
            System.out.println();
        }
    }

    public static void main(String[] args) {
        solve();
    }
}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Vertical Order Traversal Of A Binarytree-ii</span>
import java.util.*;

public class Main {
    public static Scanner scn = new Scanner(System.in);

    public static class TreeNode {
        int val = 0;
        TreeNode left = null;
        TreeNode right = null;

        TreeNode(int val) {
            this.val = val;
        }
    }

    public static class verticalPair {
        TreeNode node = null;
        int hl = 0; // horizontal Level

        verticalPair(TreeNode node, int hl) {
            this.node = node;
            this.hl = hl;
        }
    }

    // ans = {minHl,maxHL}
    public static void width(TreeNode root, int hl, int[] ans) {
        if (root == null)
            return;

        ans[0] = Math.min(hl, ans[0]);
        ans[1] = Math.max(hl, ans[1]);

        width(root.left, hl - 1, ans);
        width(root.right, hl + 1, ans);
    }

    public static ArrayList<ArrayList<Integer>> verticalOrderTraversal(TreeNode root) {
        PriorityQueue<verticalPair> que = new PriorityQueue<>((a, b) -> {
            return a.node.val - b.node.val; // this - other for default behaviour
        });
        PriorityQueue<verticalPair> childQue = new PriorityQueue<>((a, b) -> {
            return a.node.val - b.node.val;
        });

        int[] minMax = new int[2];
        width(root, 0, minMax);
        int length = minMax[1] - minMax[0] + 1;
        ArrayList<ArrayList<Integer>> ans = new ArrayList<>();
        for (int i = 0; i < length; i++)
            ans.add(new ArrayList<>());

        que.add(new verticalPair(root, -minMax[0]));

        while (que.size() != 0) {
            verticalPair rp = que.remove();

            ans.get(rp.hl).add(rp.node.val);

            if (rp.node.left != null)
                childQue.add(new verticalPair(rp.node.left, rp.hl - 1));

            if (rp.node.right != null)
                childQue.add(new verticalPair(rp.node.right, rp.hl + 1));

            if (que.size() == 0) {
                PriorityQueue<verticalPair> temp = que;
                que = childQue;
                childQue = temp;
            }
        }

        return ans;

    }

    // input_section=================================================

    public static TreeNode createTree(int[] arr, int[] IDX) {
        if (IDX[0] > arr.length || arr[IDX[0]] == -1) {
            IDX[0]++;
            return null;
        }
        TreeNode node = new TreeNode(arr[IDX[0]++]);
        node.left = createTree(arr, IDX);
        node.right = createTree(arr, IDX);

        return node;
    }

    public static void solve() {
        int n = scn.nextInt();
        int[] arr = new int[n];
        for (int i = 0; i < n; i++)
            arr[i] = scn.nextInt();

        int[] IDX = new int[1];
        TreeNode root = createTree(arr, IDX);

        ArrayList<ArrayList<Integer>> ans = verticalOrderTraversal(root);
        int idx = 0;
        for (ArrayList<Integer> i : ans) {
            System.out.print(idx++ + " -> ");
            for (Integer j : i)
                System.out.print(j + " ");
            System.out.println();
        }
    }

    public static void main(String[] args) {
        solve();
    }
}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Bottom View Of A Binarytree</span>
import java.util.*;

public class Main {
    public static Scanner scn = new Scanner(System.in);

    public static class TreeNode {
        int val = 0;
        TreeNode left = null;
        TreeNode right = null;

        TreeNode(int val) {
            this.val = val;
        }
    }

    public static class verticalPair {
        TreeNode node = null;
        int hl = 0; // horizontal Level

        verticalPair(TreeNode node, int hl) {
            this.node = node;
            this.hl = hl;
        }
    }

    // ans = {minHl,maxHL}
    public static void width(TreeNode root, int hl, int[] ans) {
        if (root == null)
            return;

        ans[0] = Math.min(hl, ans[0]);
        ans[1] = Math.max(hl, ans[1]);

        width(root.left, hl - 1, ans);
        width(root.right, hl + 1, ans);
    }

    public static ArrayList<Integer> BottomView(TreeNode root) {
        LinkedList<verticalPair> que = new LinkedList<>();

        int[] minMax = new int[2];
        width(root, 0, minMax);
        int length = minMax[1] - minMax[0] + 1;
        ArrayList<Integer> ans = new ArrayList<>();
        for (int i = 0; i < length; i++)
            ans.add(0);

        que.addLast(new verticalPair(root, -minMax[0]));

        while (que.size() != 0) {
            int size = que.size();
            while (size-- > 0) {
                verticalPair rp = que.removeFirst();

                ans.set(rp.hl, rp.node.val);

                if (rp.node.left != null)
                    que.addLast(new verticalPair(rp.node.left, rp.hl - 1));

                if (rp.node.right != null)
                    que.addLast(new verticalPair(rp.node.right, rp.hl + 1));
            }
        }

        return ans;
    }

    // input_section=================================================

    public static TreeNode createTree(int[] arr, int[] IDX) {
        if (IDX[0] > arr.length || arr[IDX[0]] == -1) {
            IDX[0]++;
            return null;
        }
        TreeNode node = new TreeNode(arr[IDX[0]++]);
        node.left = createTree(arr, IDX);
        node.right = createTree(arr, IDX);

        return node;
    }

    public static void solve() {
        int n = scn.nextInt();
        int[] arr = new int[n];
        for (int i = 0; i < n; i++)
            arr[i] = scn.nextInt();

        int[] IDX = new int[1];
        TreeNode root = createTree(arr, IDX);

        ArrayList<Integer> ans = BottomView(root);
        for (Integer i : ans)
            System.out.print(i + " ");

    }

    public static void main(String[] args) {
        solve();
    }
}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Top View Of A Binarytree</span>
import java.util.*;

public class Main {
    public static Scanner scn = new Scanner(System.in);

    public static class TreeNode {
        int val = 0;
        TreeNode left = null;
        TreeNode right = null;

        TreeNode(int val) {
            this.val = val;
        }
    }

    public static class verticalPair {
        TreeNode node = null;
        int hl = 0; // horizontal Level

        verticalPair(TreeNode node, int hl) {
            this.node = node;
            this.hl = hl;
        }
    }

    // ans = {minHl,maxHL}
    public static void width(TreeNode root, int hl, int[] ans) {
        if (root == null)
            return;

        ans[0] = Math.min(hl, ans[0]);
        ans[1] = Math.max(hl, ans[1]);

        width(root.left, hl - 1, ans);
        width(root.right, hl + 1, ans);
    }

    public static ArrayList<Integer> TopView(TreeNode root) {
        LinkedList<verticalPair> que = new LinkedList<>();

        int[] minMax = new int[2];
        width(root, 0, minMax);
        int length = minMax[1] - minMax[0] + 1;
        ArrayList<Integer> ans = new ArrayList<>();
        for (int i = 0; i < length; i++)
            ans.add((int) 1e9);

        que.addLast(new verticalPair(root, -minMax[0]));

        while (que.size() != 0) {
            int size = que.size();
            while (size-- > 0) {
                verticalPair rp = que.removeFirst();

                if (ans.get(rp.hl) == (int) 1e9)
                    ans.set(rp.hl, rp.node.val);

                if (rp.node.left != null)
                    que.addLast(new verticalPair(rp.node.left, rp.hl - 1));

                if (rp.node.right != null)
                    que.addLast(new verticalPair(rp.node.right, rp.hl + 1));
            }
        }

        return ans;
    }

    // input_section=================================================

    public static TreeNode createTree(int[] arr, int[] IDX) {
        if (IDX[0] > arr.length || arr[IDX[0]] == -1) {
            IDX[0]++;
            return null;
        }
        TreeNode node = new TreeNode(arr[IDX[0]++]);
        node.left = createTree(arr, IDX);
        node.right = createTree(arr, IDX);

        return node;
    }

    public static void solve() {
        int n = scn.nextInt();
        int[] arr = new int[n];
        for (int i = 0; i < n; i++)
            arr[i] = scn.nextInt();

        int[] IDX = new int[1];
        TreeNode root = createTree(arr, IDX);

        ArrayList<Integer> ans = TopView(root);
        for (Integer i : ans)
            System.out.print(i + " ");

    }

    public static void main(String[] args) {
        solve();
    }
}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Diagonal Order Of A Binarytree</span>
import java.util.*;

public class Main {
    public static Scanner scn = new Scanner(System.in);

    public static class TreeNode {
        int val = 0;
        TreeNode left = null;
        TreeNode right = null;

        TreeNode(int val) {
            this.val = val;
        }
    }

    public static ArrayList<ArrayList<Integer>> diagonalOrder(TreeNode root) {
        LinkedList<TreeNode> que = new LinkedList<>();
        que.addLast(root);
        ArrayList<ArrayList<Integer>> ans = new ArrayList<>();
        while (!que.isEmpty()) {
            int size = que.size();
            ArrayList<Integer> smallAns = new ArrayList<>();

            while (size-- > 0) {
                TreeNode node = que.removeFirst();

                while (node != null) {
                    smallAns.add(node.val);
                    if (node.left != null) {// add in que for next diagonal process.
                        que.addLast(node.left);
                    }
                    node = node.right;// move forward in respective diagonal.
                }
            }

            ans.add(smallAns);
        }
        return ans;
    }

    // input_section=================================================

    public static TreeNode createTree(int[] arr, int[] IDX) {
        if (IDX[0] > arr.length || arr[IDX[0]] == -1) {
            IDX[0]++;
            return null;
        }
        TreeNode node = new TreeNode(arr[IDX[0]++]);
        node.left = createTree(arr, IDX);
        node.right = createTree(arr, IDX);

        return node;
    }

    public static void solve() {
        int n = scn.nextInt();
        int[] arr = new int[n];
        for (int i = 0; i < n; i++)
            arr[i] = scn.nextInt();

        int[] IDX = new int[1];
        TreeNode root = createTree(arr, IDX);

        ArrayList<ArrayList<Integer>> ans = diagonalOrder(root);
        int idx = 0;
        for (ArrayList<Integer> i : ans) {
            System.out.print(idx++ + " -> ");
            for (Integer j : i)
                System.out.print(j + " ");
            System.out.println();
        }
    }

    public static void main(String[] args) {
        solve();
    }
}
                                
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Diagonal Order (anti-clock Wise) Of A Binarytree</span>
import java.util.*;

public class Main {
    public static Scanner scn = new Scanner(System.in);

    public static class TreeNode {
        int val = 0;
        TreeNode left = null;
        TreeNode right = null;

        TreeNode(int val) {
            this.val = val;
        }
    }

    public static ArrayList<ArrayList<Integer>> diagonalOrder(TreeNode root) {
        LinkedList<TreeNode> que = new LinkedList<>();
        que.addLast(root);
        ArrayList<ArrayList<Integer>> ans = new ArrayList<>();
        while (!que.isEmpty()) {
            int size = que.size();
            ArrayList<Integer> smallAns = new ArrayList<>();

            while (size-- > 0) {
                TreeNode node = que.removeFirst();

                while (node != null) {
                    smallAns.add(node.val);
                    if (node.right != null) {// add in que for next diagonal process.
                        que.addLast(node.right);
                    }
                    node = node.left;// move forward in respective diagonal.
                }
            }
            ans.add(smallAns);
        }

        return ans;
    }

    // input_section=================================================

    public static TreeNode createTree(int[] arr, int[] IDX) {
        if (IDX[0] > arr.length || arr[IDX[0]] == -1) {
            IDX[0]++;
            return null;
        }
        TreeNode node = new TreeNode(arr[IDX[0]++]);
        node.left = createTree(arr, IDX);
        node.right = createTree(arr, IDX);

        return node;
    }

    public static void solve() {
        int n = scn.nextInt();
        int[] arr = new int[n];
        for (int i = 0; i < n; i++)
            arr[i] = scn.nextInt();

        int[] IDX = new int[1];
        TreeNode root = createTree(arr, IDX);

        ArrayList<ArrayList<Integer>> ans = diagonalOrder(root);
        int idx = 0;
        for (ArrayList<Integer> i : ans) {
            System.out.print(idx++ + " -> ");
            for (Integer j : i)
                System.out.print(j + " ");
            System.out.println();
        }
    }

    public static void main(String[] args) {
        solve();
    }
}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Vertical Order Sum Of A Binarytree</span>
import java.util.*;

public class Main {
    public static Scanner scn = new Scanner(System.in);

    public static class TreeNode {
        int val = 0;
        TreeNode left = null;
        TreeNode right = null;

        TreeNode(int val) {
            this.val = val;
        }
    }

    public static class verticalPair {
        TreeNode node = null;
        int hl = 0; // horizontal Level

        verticalPair(TreeNode node, int hl) {
            this.node = node;
            this.hl = hl;
        }
    }

    // ans = {minHl,maxHL}
    public static void width(TreeNode root, int hl, int[] ans) {
        if (root == null)
            return;

        ans[0] = Math.min(hl, ans[0]);
        ans[1] = Math.max(hl, ans[1]);

        width(root.left, hl - 1, ans);
        width(root.right, hl + 1, ans);
    }

    public static ArrayList<Integer> verticalOrderSum(TreeNode root) {
        LinkedList<verticalPair> que = new LinkedList<>();

        int[] minMax = new int[2];
        width(root, 0, minMax);
        int length = minMax[1] - minMax[0] + 1;
        ArrayList<Integer> ans = new ArrayList<>();
        for (int i = 0; i < length; i++)
            ans.add(0);

        que.addLast(new verticalPair(root, -minMax[0]));

        while (que.size() != 0) {
            int size = que.size();
            while (size-- > 0) {
                verticalPair rp = que.removeFirst();

                ans.set(rp.hl, ans.get(rp.hl) + rp.node.val);

                if (rp.node.left != null)
                    que.addLast(new verticalPair(rp.node.left, rp.hl - 1));

                if (rp.node.right != null)
                    que.addLast(new verticalPair(rp.node.right, rp.hl + 1));
            }
        }

        return ans;
    }

    // input_section=================================================

    public static TreeNode createTree(int[] arr, int[] IDX) {
        if (IDX[0] > arr.length || arr[IDX[0]] == -1) {
            IDX[0]++;
            return null;
        }
        TreeNode node = new TreeNode(arr[IDX[0]++]);
        node.left = createTree(arr, IDX);
        node.right = createTree(arr, IDX);

        return node;
    }

    public static void solve() {
        int n = scn.nextInt();
        int[] arr = new int[n];
        for (int i = 0; i < n; i++)
            arr[i] = scn.nextInt();

        int[] IDX = new int[1];
        TreeNode root = createTree(arr, IDX);

        ArrayList<Integer> ans = verticalOrderSum(root);
        for (Integer j : ans)
            System.out.println(j);

    }

    public static void main(String[] args) {
        solve();
    }
}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Diagonal Order Sum Of A Binary Tree</span>
import java.util.*;

public class Main {
  public static Scanner scn = new Scanner(System.in);

  public static class TreeNode {
    int val = 0;
    TreeNode left = null;
    TreeNode right = null;

    TreeNode(int val) {
      this.val = val;
    }
  }

  public static ArrayList<Integer> diagonalOrderSum(TreeNode root) {
    LinkedList<TreeNode> que = new LinkedList<>();
    que.addLast(root);
    ArrayList<Integer> ans = new ArrayList<>();
    while (!que.isEmpty()) {
      int size = que.size();
      int sum = 0;
      while (size-- > 0) {
        TreeNode node = que.removeFirst();

        while (node != null) {
          sum += node.val;
          if (node.left != null) {// add in que for next diagonal process.
            que.addLast(node.left);
          }
          node = node.right;// move forward in respective diagonal.
        }
      }

      ans.add(sum);
    }

    return ans;
  }

  // input_section=================================================

  public static TreeNode createTree(int[] arr, int[] IDX) {
    if (IDX[0] > arr.length || arr[IDX[0]] == -1) {
      IDX[0]++;
      return null;
    }
    TreeNode node = new TreeNode(arr[IDX[0]++]);
    node.left = createTree(arr, IDX);
    node.right = createTree(arr, IDX);

    return node;
  }

  public static void solve() {
    int n = scn.nextInt();
    int[] arr = new int[n];
    for (int i = 0; i < n; i++)
      arr[i] = scn.nextInt();

    int[] IDX = new int[1];
    TreeNode root = createTree(arr, IDX);

    ArrayList<Integer> ans = diagonalOrderSum(root);
    for (Integer j : ans)
      System.out.print(j + " ");

  }

  public static void main(String[] args) {
    solve();
  }
}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Binary Search Tree Iterator 2</span>
import java.util.Scanner;
import java.util.LinkedList;

public class Main {
  public static Scanner scn = new Scanner(System.in);

  public static class TreeNode {
    int val = 0;
    TreeNode left = null;
    TreeNode right = null;

    TreeNode(int val) {
      this.val = val;
    }
  }

  public static class BSTIterator {
    LinkedList<TreeNode> st = new LinkedList<>(); // addFirst(), removeFirst();

    public BSTIterator(TreeNode root) {
      addAllLeft(root);
    }

    public void addAllLeft(TreeNode node) {
      if (node == null)
        return;

      TreeNode curr = node;
      while (curr != null) {
        st.addFirst(curr);
        curr = curr.left;
      }

    }

    public int next() {
      TreeNode rn = new TreeNode(-(int) 1e9);

      if (hasNext()) {
        rn = st.removeFirst();
        addAllLeft(rn.right);
      }

      return rn.val;

    }

    public boolean hasNext() {
      return st.size() != 0;
    }
  }

  // input_section=================================================

  public static void display(TreeNode node) {
    if (node == null)
      return;

    StringBuilder sb = new StringBuilder();
    sb.append((node.left != null ? node.left.val : "."));
    sb.append(" -> " + node.val + " <- ");
    sb.append((node.right != null ? node.right.val : "."));

    System.out.println(sb.toString());

    display(node.left);
    display(node.right);

  }

  public static TreeNode constructFromInOrder_(int[] in, int si, int ei) {
    if (si > ei)
      return null;

    int mid = (si + ei) / 2;
    TreeNode node = new TreeNode(in[mid]);

    node.left = constructFromInOrder_(in, si, mid - 1);
    node.right = constructFromInOrder_(in, mid + 1, ei);

    return node;
  }

  public static void solve() {
    int n = scn.nextInt();
    int[] in = new int[n];
    for (int i = 0; i < n; i++)
      in[i] = scn.nextInt();

    TreeNode root = constructFromInOrder_(in, 0, in.length - 1);
    BSTIterator itr = new BSTIterator(root);
    while (itr.hasNext()) {
      System.out.println(itr.next());
    }
  }

  public static void main(String[] args) {
    solve();
  }
}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Node To Root Path Binary Tree</span>
import java.util.*;

public class Main {
  public static Scanner scn = new Scanner(System.in);

  public static class TreeNode {
    int val = 0;
    TreeNode left = null;
    TreeNode right = null;

    TreeNode(int val) {
      this.val = val;
    }
  }

  public static boolean nodeToRootPath(TreeNode root, int data, ArrayList<TreeNode> path) {
    if (root == null)
      return false;
    if (root.val == data) {
      path.add(root);
      return true;
    }

    boolean res = nodeToRootPath(root.left, data, path) || nodeToRootPath(root.right, data, path);
    if (res)
      path.add(root);

    return res;
  }

  public static ArrayList<TreeNode> nodeToRootPath(TreeNode root, int data) {
    ArrayList<TreeNode> path = new ArrayList<>();
    nodeToRootPath(root, data, path);
    return path;
  }

  // input_section=================================================

  public static TreeNode createTree(int[] arr, int[] IDX) {
    if (IDX[0] > arr.length || arr[IDX[0]] == -1) {
      IDX[0]++;
      return null;
    }
    TreeNode Treenode = new TreeNode(arr[IDX[0]++]);
    Treenode.left = createTree(arr, IDX);
    Treenode.right = createTree(arr, IDX);

    return Treenode;
  }

  public static void solve() {
    int n = scn.nextInt();
    int[] arr = new int[n];
    for (int i = 0; i < n; i++)
      arr[i] = scn.nextInt();

    int[] IDX = new int[1];
    TreeNode root = createTree(arr, IDX);

    int data = scn.nextInt();
    ArrayList<TreeNode> ans = nodeToRootPath(root, data);
    if (ans.size() == 0)
      System.out.println();
    for (TreeNode node : ans)
      System.out.print(node.val + " ");

  }

  public static void main(String[] args) {
    solve();
  }
}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">All Single Child Parent In Binary Tree</span>
import java.util.*;

public class Main {
  public static Scanner scn = new Scanner(System.in);

  public static class TreeNode {
    int val = 0;
    TreeNode left = null;
    TreeNode right = null;

    TreeNode(int val) {
      this.val = val;
    }
  }

  public static void exactlyOneChild(TreeNode node, ArrayList<Integer> ans) {
    if (node == null || (node.left == null && node.right == null))
      return;

    if (node.left == null || node.right == null)
      ans.add(node.val);

    exactlyOneChild(node.left, ans);
    exactlyOneChild(node.right, ans);

  }

  public static ArrayList<Integer> exactlyOneChild(TreeNode root) {
    ArrayList<Integer> ans = new ArrayList<>();
    exactlyOneChild(root, ans);
    return ans;
  }

  // input_section=================================================

  public static TreeNode createTree(int[] arr, int[] IDX) {
    if (IDX[0] > arr.length || arr[IDX[0]] == -1) {
      IDX[0]++;
      return null;
    }
    TreeNode Treenode = new TreeNode(arr[IDX[0]++]);
    Treenode.left = createTree(arr, IDX);
    Treenode.right = createTree(arr, IDX);

    return Treenode;
  }

  public static void solve() {
    int n = scn.nextInt();
    int[] arr = new int[n];
    for (int i = 0; i < n; i++)
      arr[i] = scn.nextInt();

    int[] IDX = new int[1];
    TreeNode root = createTree(arr, IDX);

    ArrayList<Integer> ans = exactlyOneChild(root);
    if (ans.size() == 0)
      System.out.println();
    for (Integer ele : ans)
      System.out.print(ele + " ");
  }

  public static void main(String[] args) {
    solve();
  }
}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Count All Single Child Parent In Binary Tree</span>
import java.util.*;

public class Main {
  public static Scanner scn = new Scanner(System.in);

  public static class TreeNode {
    int val = 0;
    TreeNode left = null;
    TreeNode right = null;

    TreeNode(int val) {
      this.val = val;
    }
  }

  public static int countExactlyOneChild(TreeNode node) {
    if (node == null || (node.left == null && node.right == null))
      return 0;

    int left = countExactlyOneChild(node.left);
    int right = countExactlyOneChild(node.right);
    int sum = left + right;
    if (node.left == null || node.right == null)
      sum += 1;
    return sum;
  }

  // input_section=================================================

  public static TreeNode createTree(int[] arr, int[] IDX) {
    if (IDX[0] > arr.length || arr[IDX[0]] == -1) {
      IDX[0]++;
      return null;
    }
    TreeNode Treenode = new TreeNode(arr[IDX[0]++]);
    Treenode.left = createTree(arr, IDX);
    Treenode.right = createTree(arr, IDX);

    return Treenode;
  }

  public static void solve() {
    int n = scn.nextInt();
    int[] arr = new int[n];
    for (int i = 0; i < n; i++)
      arr[i] = scn.nextInt();

    int[] IDX = new int[1];
    TreeNode root = createTree(arr, IDX);

    System.out.println(countExactlyOneChild(root));
  }

  public static void main(String[] args) {
    solve();
  }
}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">All Nodes Distance K In Binary Tree</span>
import java.util.*;

public class Main {
  public static Scanner scn = new Scanner(System.in);

  public static class TreeNode {
    int val = 0;
    TreeNode left = null;
    TreeNode right = null;

    TreeNode(int val) {
      this.val = val;
    }
  }

  public static void kdown(TreeNode root, int k, TreeNode block, ArrayList<Integer> ans) {
    if (root == null || k < 0 || root == block)
      return;

    if (k == 0) {
      ans.add(root.val);
      return;
    }

    kdown(root.left, k - 1, block, ans);
    kdown(root.right, k - 1, block, ans);
  }

  public static int distanceK(TreeNode root, int target, int k, ArrayList<Integer> ans) {
    if (root == null)
      return -1;

    if (root.val == target) {
      kdown(root, k, null, ans);
      return 1;
    }

    int ld = distanceK(root.left, target, k, ans);
    if (ld != -1) {
      kdown(root, k - ld, root.left, ans);
      return ld + 1;
    }

    int rd = distanceK(root.right, target, k, ans);
    if (rd != -1) {
      kdown(root, k - rd, root.right, ans);
      return rd + 1;
    }

    return -1;
  }

  public static ArrayList<Integer> distanceK(TreeNode root, int target, int k) {
    ArrayList<Integer> ans = new ArrayList<>();
    distanceK(root, target, k, ans);

    return ans;

  }

  // input_section=================================================

  public static TreeNode createTree(int[] arr, int[] IDX) {
    if (IDX[0] > arr.length || arr[IDX[0]] == -1) {
      IDX[0]++;
      return null;
    }
    TreeNode Treenode = new TreeNode(arr[IDX[0]++]);
    Treenode.left = createTree(arr, IDX);
    Treenode.right = createTree(arr, IDX);

    return Treenode;
  }

  public static void solve() {
    int n = scn.nextInt();
    int[] arr = new int[n];
    for (int i = 0; i < n; i++)
      arr[i] = scn.nextInt();

    int[] IDX = new int[1];
    TreeNode root = createTree(arr, IDX);
    int target = scn.nextInt();
    int k = scn.nextInt();

    ArrayList<Integer> ans = distanceK(root, target, k);
    if (ans.size() == 0)
      System.out.println();
    for (Integer ele : ans)
      System.out.println(ele + " ");

  }

  public static void main(String[] args) {
    solve();
  }
}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Maximum Width Of Binary Tree</span>
import java.util.*;

public class Main {
  public static Scanner scn = new Scanner(System.in);

  public static class TreeNode {
    int val = 0;
    TreeNode left = null;
    TreeNode right = null;

    TreeNode(int val) {
      this.val = val;
    }
  }

  public static class pair {
    TreeNode node = null;
    long w = 0;

    pair(TreeNode node, long w) {
      this.node = node;
      this.w = w;
    }
  }

  public static int widthOfBinaryTree(TreeNode root) {
    if (root == null) {
      return 0;
    }
    LinkedList<pair> que = new LinkedList<>();
    que.addLast(new pair(root, 0));
    long ans = 0;

    while (que.size() != 0) {
      int size = que.size();
      long fi = que.getFirst().w;
      long li = que.getFirst().w;

      while (size-- > 0) {
        pair p = que.removeFirst();

        TreeNode node = p.node;
        long w = p.w;
        li = w;

        if (node.left != null)
          que.addLast(new pair(node.left, 2 * w + 1));
        if (node.right != null)
          que.addLast(new pair(node.right, 2 * w + 2));

      }

      ans = Math.max(ans, li - fi + 1);
    }

    return (int) ans;
  }

  // input_section=================================================

  public static void display(TreeNode node) {
    if (node == null)
      return;

    StringBuilder sb = new StringBuilder();
    sb.append((node.left != null ? node.left.val : "."));
    sb.append(" -> " + node.val + " <- ");
    sb.append((node.right != null ? node.right.val : "."));

    System.out.println(sb.toString());

    display(node.left);
    display(node.right);
  }

  public static int idx = 0;

  private static TreeNode deserialize(String[] arr) {
    if (idx >= arr.length || arr[idx].equals("null")) {
      idx++;
      return null;
    }

    TreeNode node = new TreeNode(Integer.parseInt(arr[idx++]));
    node.left = deserialize(arr);
    node.right = deserialize(arr);

    return node;
  }

  public static TreeNode deserialize(String str) {
    String[] arr = str.split(" ");
    return deserialize(arr);
  }

  public static void solve() {
    String str = scn.nextLine();
    TreeNode root = deserialize(str);

    int ans = widthOfBinaryTree(root);
    System.out.println(ans);
  }

  public static void main(String[] args) {
    solve();
  }
}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Convert Binary Search Tree To Doubly Linked List</span>
import java.util.Scanner;

public class Main {
  public static Scanner scn = new Scanner(System.in);

  public static class Node {
    int val = 0;
    Node left = null;
    Node right = null;

    Node(int val) {
      this.val = val;
    }
  }

  static Node prev = null;

  public static void bToDLL_(Node root) {
    if (root == null)
      return;

    bToDLL_(root.left);

    prev.right = root;
    root.left = prev;

    prev = root;

    bToDLL_(root.right);
  }

  public static Node bToDLL(Node root) {
    Node dummy = new Node(-1);
    prev = dummy;
    bToDLL_(root);

    Node head = dummy.right;
    head.left = dummy.right = null;

    head.left = prev;
    prev.right = head;

    return head;
  }

  // input_section=================================================

  public static void display(Node node) {
    Node head = node;
    while (node != null) {
      System.out.print(node.val + " ");
      node = node.right;
      if (node == head)
        break;
    }

  }

  public static Node constructFromInOrder_(int[] in, int si, int ei) {
    if (si > ei)
      return null;

    int mid = (si + ei) / 2;
    Node node = new Node(in[mid]);

    node.left = constructFromInOrder_(in, si, mid - 1);
    node.right = constructFromInOrder_(in, mid + 1, ei);

    return node;
  }

  public static Node constructFromInOrder(int[] inOrder) {
    int n = inOrder.length;
    return constructFromInOrder_(inOrder, 0, n - 1);
  }

  public static void solve() {
    int n = scn.nextInt();
    int[] in = new int[n];
    for (int i = 0; i < n; i++)
      in[i] = scn.nextInt();

    Node root = constructFromInOrder(in);
    root = bToDLL(root);
    display(root);
  }

  public static void main(String[] args) {
    solve();
  }
}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Convert Sorted Doubly Linked List To Binary Search Tree</span>
import java.util.*;

class Main {
  public static Scanner scn = new Scanner(System.in);

  public static class Node {
    int val = 0;
    Node left = null;
    Node right = null;

    Node(int val) {
      this.val = val;
    }
  }

  public static Node getMidNode(Node node) {
    if (node == null || node.right == null)
      return node;

    Node slow = node, fast = node;
    while (fast.right != null && fast.right.right != null) {
      slow = slow.right;
      fast = fast.right.right;
    }

    return slow;
  }

  // left : prev, right : next
  public static Node SortedDLLToBST(Node head) {
    if (head == null || head.right == null)
      return head;

    Node root = getMidNode(head);
    Node leftDLLHead = head == root ? null : head;
    Node rightDLLHead = root.right;

    if (root.left != null)
      root.left.right = null;
    root.left = root.right = rightDLLHead.left = null;

    root.left = SortedDLLToBST(leftDLLHead);
    root.right = SortedDLLToBST(rightDLLHead);

    return root;
  }

  // Input_code===================================================

  public static void display(Node node) {
    if (node == null)
      return;

    StringBuilder sb = new StringBuilder();
    sb.append((node.left != null ? node.left.val : "."));
    sb.append(" -> " + node.val + " <- ");
    sb.append((node.right != null ? node.right.val : "."));

    System.out.println(sb.toString());

    display(node.left);
    display(node.right);

  }

  public static Node makeList(int n) {
    Node dummy = new Node(-1);
    Node prev = dummy;
    while (n-- > 0) {
      Node node = new Node(scn.nextInt());
      prev.right = node;
      node.left = prev;
      prev = prev.right;
    }

    Node head = dummy.right;
    head.left = dummy.right = null;

    return head;
  }

  public static void main(String[] args) {
    Node head = makeList(scn.nextInt());

    head = SortedDLLToBST(head);
    display(head);
  }

}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Path Sum In Binary Tree</span>
import java.util.Scanner;

public class Main {
  public static Scanner scn = new Scanner(System.in);

  public static class TreeNode {
    int val = 0;
    TreeNode left = null;
    TreeNode right = null;

    TreeNode(int val) {
      this.val = val;
    }
  }

  public static boolean hasPathSum(TreeNode root, int targetSum) {
    if (root == null)
      return false;
    if (root.left == null && root.right == null)
      return (targetSum - root.val == 0);

    return hasPathSum(root.left, targetSum - root.val) || hasPathSum(root.right, targetSum - root.val);
  }

  // input_Section=================================================

  public static TreeNode createTree(int[] arr, int[] IDX) {
    if (IDX[0] > arr.length || arr[IDX[0]] == -1) {
      IDX[0]++;
      return null;
    }

    TreeNode node = new TreeNode(arr[IDX[0]++]);
    node.left = createTree(arr, IDX);
    node.right = createTree(arr, IDX);

    return node;
  }

  public static void solve() {
    int n = scn.nextInt();
    int[] arr = new int[n];
    for (int i = 0; i < n; i++)
      arr[i] = scn.nextInt();
    int tar = scn.nextInt();
    int[] IDX = new int[1];
    TreeNode root = createTree(arr, IDX);
    System.out.println(hasPathSum(root, tar));
  }

  public static void main(String[] args) {
    solve();
  }
}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Path Sum In Binary Tree - 2</span>
import java.util.*;

public class Main {
  public static Scanner scn = new Scanner(System.in);

  public static class TreeNode {
    int val = 0;
    TreeNode left = null;
    TreeNode right = null;

    TreeNode(int val) {
      this.val = val;
    }
  }

  public static void pathSum(TreeNode root, int tar, ArrayList<ArrayList<Integer>> res, ArrayList<Integer> smallAns) {
    if (root == null)
      return;

    if (root.left == null && root.right == null) {
      if (tar - root.val == 0) {
        ArrayList<Integer> base = new ArrayList<>(smallAns);
        base.add(root.val);
        res.add(base);
      }

      return;
    }

    smallAns.add(root.val);
    pathSum(root.left, tar - root.val, res, smallAns);
    pathSum(root.right, tar - root.val, res, smallAns);
    smallAns.remove(smallAns.size() - 1);
  }

  public static ArrayList<ArrayList<Integer>> pathSum(TreeNode root, int targetSum) {
    ArrayList<ArrayList<Integer>> res = new ArrayList<>();
    pathSum(root, targetSum, res, new ArrayList<>());
    return res;

  }

  // input_Section=================================================

  public static TreeNode createTree(int[] arr, int[] IDX) {
    if (IDX[0] > arr.length || arr[IDX[0]] == -1) {
      IDX[0]++;
      return null;
    }

    TreeNode node = new TreeNode(arr[IDX[0]++]);
    node.left = createTree(arr, IDX);
    node.right = createTree(arr, IDX);

    return node;
  }

  public static void solve() {
    int n = scn.nextInt();
    int[] arr = new int[n];
    for (int i = 0; i < n; i++)
      arr[i] = scn.nextInt();
    int tar = scn.nextInt();
    int[] IDX = new int[1];
    TreeNode root = createTree(arr, IDX);
    ArrayList<ArrayList<Integer>> ans = pathSum(root, tar);
    if (ans.size() == 0) System.out.println(" ");
    for (ArrayList<Integer> ar : ans) {
      for (Integer ele : ar) {
        System.out.print(ele + " ");
      }
      System.out.println();
    }
  }

  public static void main(String[] args) {
    solve();
  }
}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Diameter Of Binary Tree All Methods</span>
import java.util.Scanner;

public class Main {
  public static Scanner scn = new Scanner(System.in);

  public static class TreeNode {
    int val = 0;
    TreeNode left = null;
    TreeNode right = null;

    TreeNode(int val) {
      this.val = val;
    }
  }

  public static int[] diameter(TreeNode root) {
    if (root == null)
      return new int[] { 0, -1 }; // dia,height

    int[] la = diameter(root.left);
    int[] ra = diameter(root.right);

    int dia = Math.max(Math.max(la[0], ra[0]), la[1] + ra[1] + 2);
    int height = Math.max(la[1], ra[1]) + 1;
    return new int[] { dia, height };
  }

  public static int diameterOfBinaryTree(TreeNode root) {
    return diameter(root)[0];
  }

  // input_Section=================================================

  public static TreeNode createTree(int[] arr, int[] IDX) {
    if (IDX[0] > arr.length || arr[IDX[0]] == -1) {
      IDX[0]++;
      return null;
    }

    TreeNode node = new TreeNode(arr[IDX[0]++]);
    node.left = createTree(arr, IDX);
    node.right = createTree(arr, IDX);

    return node;
  }

  public static void solve() {
    int n = scn.nextInt();
    int[] arr = new int[n];
    for (int i = 0; i < n; i++)
      arr[i] = scn.nextInt();

    int[] IDX = new int[1];
    TreeNode root = createTree(arr, IDX);
    System.out.println(diameterOfBinaryTree(root));
  }

  public static void main(String[] args) {
    solve();
  }
}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Maximum Path Sum In Between Two Leaves Of Binary Tree</span>
import java.util.Scanner;

public class Main {
  public static Scanner scn = new Scanner(System.in);

  public static class TreeNode {
    int val = 0;
    TreeNode left = null;
    TreeNode right = null;

    TreeNode(int val) {
      this.val = val;
    }
  }

  public static int maxLeafToLeaf = -(int) 1e9;

  public static int maxPathSum_(TreeNode root) {
    if (root == null)
      return -(int) 1e9;
    if (root.left == null && root.right == null)
      return root.val;

    int leftNodeToLeafMaxSum = maxPathSum_(root.left);
    int rightNodeToLeafMaxSum = maxPathSum_(root.right);

    if (root.left != null && root.right != null)
      maxLeafToLeaf = Math.max(maxLeafToLeaf, leftNodeToLeafMaxSum + root.val + rightNodeToLeafMaxSum);

    return Math.max(leftNodeToLeafMaxSum, rightNodeToLeafMaxSum) + root.val;
  }

  public static int maxPathSum(TreeNode root) {
    if (root == null)
      return Integer.MIN_VALUE;

    maxPathSum_(root);
    return maxLeafToLeaf;

  }

  // input_Section=================================================

  public static TreeNode createTree(int[] arr, int[] IDX) {
    if (IDX[0] > arr.length || arr[IDX[0]] == -1) {
      IDX[0]++;
      return null;
    }

    TreeNode node = new TreeNode(arr[IDX[0]++]);
    node.left = createTree(arr, IDX);
    node.right = createTree(arr, IDX);

    return node;
  }

  public static void solve() {
    int n = scn.nextInt();
    int[] arr = new int[n];
    for (int i = 0; i < n; i++)
      arr[i] = scn.nextInt();

    int[] IDX = new int[1];
    TreeNode root = createTree(arr, IDX);
    System.out.println(maxPathSum(root));
  }

  public static void main(String[] args) {
    solve();
  }
}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Maximum Path Sum Of Binary Tree</span>
import java.util.Scanner;

public class Main {
  public static Scanner scn = new Scanner(System.in);

  public static class TreeNode {
    int val = 0;
    TreeNode left = null;
    TreeNode right = null;

    TreeNode(int val) {
      this.val = val;
    }
  }

  public static class maxNodeToNodePair {
    int NTN_sum = -(int) 1e9; // Node to Node sum
    int NTR_sum = 0; // Node to root sum

    maxNodeToNodePair(int NTN_sum, int NTR_sum) {
      this.NTN_sum = NTN_sum;
      this.NTR_sum = NTR_sum;
    }

    maxNodeToNodePair() {

    }
  }

  public static int maxValue(int... arr) {
    int max = arr[0];
    for (int ele : arr) {
      max = Math.max(max, ele);
    }

    return max;
  }

  // {nodeToNode, rootToNode}
  public static maxNodeToNodePair maxPathSum2_(TreeNode node) {
    if (node == null)
      return new maxNodeToNodePair();

    maxNodeToNodePair lpair = maxPathSum2_(node.left);
    maxNodeToNodePair rpair = maxPathSum2_(node.right);

    maxNodeToNodePair myAns = new maxNodeToNodePair();

    myAns.NTN_sum = maxValue(lpair.NTN_sum, rpair.NTN_sum, node.val, lpair.NTR_sum + node.val,
                             rpair.NTR_sum + node.val, lpair.NTR_sum + node.val + rpair.NTR_sum);
    myAns.NTR_sum = maxValue(node.val, lpair.NTR_sum + node.val, rpair.NTR_sum + node.val);

    return myAns;
  }

  public static int maxPathSum(TreeNode root) {
    if (root == null)
      return 0;

    return maxPathSum2_(root).NTN_sum;
  }

  // input_Section=================================================

  public static TreeNode createTree(int[] arr, int[] IDX) {
    if (IDX[0] > arr.length || arr[IDX[0]] == -1) {
      IDX[0]++;
      return null;
    }

    TreeNode node = new TreeNode(arr[IDX[0]++]);
    node.left = createTree(arr, IDX);
    node.right = createTree(arr, IDX);

    return node;
  }

  public static void solve() {
    int n = scn.nextInt();
    int[] arr = new int[n];
    for (int i = 0; i < n; i++)
      arr[i] = scn.nextInt();

    int[] IDX = new int[1];
    TreeNode root = createTree(arr, IDX);
    System.out.println(maxPathSum(root));
  }

  public static void main(String[] args) {
    solve();
  }
}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Path Sum Equal To Given Value</span>
import java.util.*;

public class Main {
  public static Scanner scn = new Scanner(System.in);

  public static class TreeNode {
    int val = 0;
    TreeNode left = null;
    TreeNode right = null;

    TreeNode(int val) {
      this.val = val;
    }
  }

  public static int ans = 0;

  public static void pathSum(TreeNode node, HashMap<Integer, Integer> map, int tar, int prefixSum) {
    if (node == null)
      return;

    prefixSum += node.val;
    ans += map.getOrDefault(prefixSum - tar, 0);

    map.put(prefixSum, map.getOrDefault(prefixSum, 0) + 1);

    pathSum(node.left, map, tar, prefixSum);
    pathSum(node.right, map, tar, prefixSum);

    map.put(prefixSum, map.get(prefixSum) - 1);
    if (map.get(prefixSum) == 0)
      map.remove(prefixSum);
  }

  public static int pathSum(TreeNode root, int K) {
    // prefix sum , Frequency
    HashMap<Integer, Integer> map = new HashMap<>();
    map.put(0, 1);
    pathSum(root, map, K, 0);
    return ans;
  }

  // input_section=================================================

  public static void display(TreeNode node) {
    if (node == null)
      return;

    StringBuilder sb = new StringBuilder();
    sb.append((node.left != null ? node.left.val : "."));
    sb.append(" -> " + node.val + " <- ");
    sb.append((node.right != null ? node.right.val : "."));

    System.out.println(sb.toString());

    display(node.left);
    display(node.right);
  }

  public static int idx = 0;

  private static TreeNode deserialize(String[] arr) {
    if (idx >= arr.length || arr[idx].equals("null")) {
      idx++;
      return null;
    }

    TreeNode node = new TreeNode(Integer.parseInt(arr[idx++]));
    node.left = deserialize(arr);
    node.right = deserialize(arr);

    return node;
  }

  public static TreeNode deserialize(String str) {
    String[] arr = str.split(" ");
    return deserialize(arr);
  }

  public static void solve() {
    String str = scn.nextLine();
    TreeNode root = deserialize(str);
    int tar = scn.nextInt();

    int ans = pathSum(root, tar);
    System.out.println(ans);
  }

  public static void main(String[] args) {
    solve();
  }
}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Lowest Common Ancestor Of A Binary Tree</span>
import java.util.*;

public class Main {
  public static Scanner scn = new Scanner(System.in);

  public static class TreeNode {
    int val = 0;
    TreeNode left = null;
    TreeNode right = null;

    TreeNode(int val) {
      this.val = val;
    }
  }

  private static TreeNode LCA = null;

  public static boolean lowestCommonAncestor_(TreeNode node, int p, int q) {
    if (node == null)
      return false;

    boolean self = false;
    if (node.val == p || node.val == q)
      self = true;

    boolean left = lowestCommonAncestor_(node.left, p, q);
    boolean right = lowestCommonAncestor_(node.right, p, q);

    if ((left && right) || (left && self) || (right && self))
      LCA = node;

    return left || right || self;
  }

  public static TreeNode lowestCommonAncestor(TreeNode node, int p, int q) {
    lowestCommonAncestor_(node, p, q);
    return LCA;
  }

  // input_section=================================================

  public static void display(TreeNode node) {
    if (node == null)
      return;

    StringBuilder sb = new StringBuilder();
    sb.append((node.left != null ? node.left.val : "."));
    sb.append(" -> " + node.val + " <- ");
    sb.append((node.right != null ? node.right.val : "."));

    System.out.println(sb.toString());

    display(node.left);
    display(node.right);
  }

  public static int idx = 0;

  private static TreeNode deserialize(String[] arr) {
    if (idx >= arr.length || arr[idx].equals("null")) {
      idx++;
      return null;
    }

    TreeNode node = new TreeNode(Integer.parseInt(arr[idx++]));
    node.left = deserialize(arr);
    node.right = deserialize(arr);

    return node;
  }

  public static TreeNode deserialize(String str) {
    String[] arr = str.split(" ");
    return deserialize(arr);
  }

  public static void solve() {
    String str = scn.nextLine();
    TreeNode root = deserialize(str);

    int e1 = scn.nextInt();
    int e2 = scn.nextInt();

    TreeNode ans = lowestCommonAncestor(root, e1, e2);
    System.out.println(ans == null ? null : ans.val);
  }

  public static void main(String[] args) {
    solve();
  }
}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">linked list</span>
<span class="textStyle">linked list</span>
<span class="textStyle">Linked List</span>
<span class="textStyle">LINKED LIST</span>
<span class="textStyle">Reverse A Linkedlist</span>
import java.util.*;

class Main {
    public static class ListNode {
        int val = 0;
        ListNode next = null;

        ListNode(int val) {
            this.val = val;
        }
    }

    public static ListNode reverse(ListNode head) {
        if (head == null || head.next == null)
            return head;

        ListNode curr = head;
        ListNode prev = null;

        while (curr != null) {
            ListNode forw = curr.next;

            curr.next = prev;

            prev = curr;
            curr = forw;
        }

        return prev;
    }

    public static void main(String[] args) {
        Scanner scn = new Scanner(System.in);
        int n = scn.nextInt();
        ListNode dummy = new ListNode(-1);
        ListNode prev = dummy;
        while (n-- > 0) {
            prev.next = new ListNode(scn.nextInt());
            prev = prev.next;
        }

        ListNode head = reverse(dummy.next);
        while (head != null) {
            System.out.print(head.val + " ");
            head = head.next;
        }
    }
}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Middle Of A Linked List</span>
 import java.util.*;

class Main {
    public static class ListNode {
        int val = 0;
        ListNode next = null;

        ListNode(int val) {
            this.val = val;
        }
    }

    public static ListNode midNode(ListNode head) {
        if (head == null || head.next == null)
            return head;

        ListNode slow = head;
        ListNode fast = head;

        while (fast.next != null && fast.next.next != null) {
            slow = slow.next;
            fast = fast.next.next;
        }

        return slow;
    }

    public static void main(String[] args) {
        Scanner scn = new Scanner(System.in);
        int n = scn.nextInt();
        ListNode dummy = new ListNode(-1);
        ListNode prev = dummy;
        while (n-- > 0) {
            prev.next = new ListNode(scn.nextInt());
            prev = prev.next;
        }

        ListNode head = midNode(dummy.next);
        while (head != null) {
            System.out.print(head.val + " ");
            head = head.next;
        }
    }
}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Palindrome Linkedlist</span>
import java.util.*;

class Main {
    public static class ListNode {
        int val = 0;
        ListNode next = null;

        ListNode(int val) {
            this.val = val;
        }
    }

    public static ListNode middleNode(ListNode head) {
        if (head == null || head.next == null)
            return head;

        ListNode slow = head;
        ListNode fast = head;

        while (fast.next != null && fast.next.next != null) {
            slow = slow.next;
            fast = fast.next.next;
        }

        return slow;
    }

    public static ListNode reverseList(ListNode head) {
        if (head == null || head.next == null)
            return head;

        ListNode prev = null;
        ListNode curr = head;

        while (curr != null) {
            ListNode forw = curr.next; // backup

            curr.next = prev; // link

            prev = curr; // move
            curr = forw;
        }

        return prev;
    }

    public static boolean isPalindrome(ListNode head) {
        if (head == null || head.next == null)
            return true;

        ListNode middle = middleNode(head);
        ListNode nhead = middle.next;
        middle.next = null;

        nhead = reverseList(nhead);

        ListNode c1 = head;
        ListNode c2 = nhead;

        boolean flag = true;
        while (c1 != null && c2 != null) {
            if (c1.val != c2.val) {
                flag = false;
                break;
            }

            c1 = c1.next;
            c2 = c2.next;
        }

        nhead = reverseList(nhead);
        middle.next = nhead;

        return flag;
    }

    public static void main(String[] args) {
        Scanner scn = new Scanner(System.in);
        int n = scn.nextInt();
        ListNode dummy = new ListNode(-1);
        ListNode prev = dummy;
        while (n-- > 0) {
            prev.next = new ListNode(scn.nextInt());
            prev = prev.next;
        }

        System.out.println(isPalindrome(dummy.next));
    }
}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Fold Of Linkedlist</span>
import java.util.*;

class Main {
    public static class ListNode {
        int val = 0;
        ListNode next = null;

        ListNode(int val) {
            this.val = val;
        }
    }

    public static void fold(ListNode head) {
        if (head == null || head.next == null)
            return;

        ListNode mid = midNode(head);
        ListNode nhead = mid.next;
        mid.next = null;

        nhead = reverseList(nhead);

        ListNode c1 = head;
        ListNode c2 = nhead;

        while (c1 != null && c2 != null) {
            ListNode f1 = c1.next;
            ListNode f2 = c2.next;

            c1.next = c2;
            c2.next = f1;

            c1 = f1;
            c2 = f2;
        }
    }

    public static ListNode midNode(ListNode node) {
        if (node == null || node.next == null)
            return node;

        ListNode slow = node, fast = node;
        while (fast.next != null && fast.next.next != null) {
            slow = slow.next;
            fast = fast.next.next;
        }
        return slow;
    }

    public static ListNode reverseList(ListNode node) {
        if (node == null || node.next == null)
            return node;

        ListNode prev = null;
        ListNode curr = node;
        while (curr != null) {
            ListNode forw = curr.next; // backup.

            curr.next = prev; // connection

            prev = curr; // move forw.
            curr = forw;
        }

        return prev;
    }

    static void printList(ListNode node) {
        while (node != null) {
            System.out.print(node.val+" ");
            node = node.next;
        }
    }

    public static void main(String[] args) {
        Scanner scn = new Scanner(System.in);
        int n = scn.nextInt();
        ListNode dummy = new ListNode(-1);
        ListNode prev = dummy;
        while (n-- > 0) {
            prev.next = new ListNode(scn.nextInt());
            prev = prev.next;
        }

        ListNode head = dummy.next;
        fold(head);
        printList(head);
    }
}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Unfold Of Linkedlist</span>
import java.util.*;

class Main {
    public static class ListNode {
        int val = 0;
        ListNode next = null;

        ListNode(int val) {
            this.val = val;
        }
    }

    public static void unfold(ListNode head) {
        if (head == null || head.next == null)
            return;

        ListNode h1 = head;
        ListNode h2 = head.next;

        ListNode c1 = h1;
        ListNode c2 = h2;

        while (c2 != null && c2.next != null) {
            ListNode f = c2.next; // Backup

            c1.next = f; // links
            c2.next = f.next;

            c1 = c1.next;
            c2 = c2.next;
        }

        // c1->next = nullptr;
        h2 = reverseList(h2);
        c1.next = h2;
    }

    public static ListNode midNode(ListNode node) {
        if (node == null || node.next == null)
            return node;

        ListNode slow = node, fast = node;
        while (fast.next != null && fast.next.next != null) {
            slow = slow.next;
            fast = fast.next.next;
        }
        return slow;
    }

    public static ListNode reverseList(ListNode node) {
        if (node == null || node.next == null)
            return node;

        ListNode prev = null;
        ListNode curr = node;
        while (curr != null) {
            ListNode forw = curr.next; // backup.

            curr.next = prev; // connection

            prev = curr; // move forw.
            curr = forw;
        }

        return prev;
    }

    static void printList(ListNode node) {
        while (node != null) {
            System.out.print(node.val + " ");
            node = node.next;
        }
    }

    public static void main(String[] args) {
        Scanner scn = new Scanner(System.in);
        int n = scn.nextInt();
        ListNode dummy = new ListNode(-1);
        ListNode prev = dummy;
        while (n-- > 0) {
            prev.next = new ListNode(scn.nextInt());
            prev = prev.next;
        }

        ListNode head = dummy.next;
        unfold(head);
        printList(head);
    }
}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Merge Two Sorted Linkedlist</span>
import java.util.*;

class Main {
    public static Scanner scn = new Scanner(System.in);

    public static class ListNode {
        int val = 0;
        ListNode next = null;

        ListNode(int val) {
            this.val = val;
        }
    }

    public static ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        if (l1 == null || l2 == null)
            return l1 != null ? l1 : l2;

        ListNode dummy = new ListNode(-1);
        ListNode prev = dummy;

        ListNode c1 = l1;
        ListNode c2 = l2;

        while (c1 != null && c2 != null) {
            if (c1.val <= c2.val) {
                prev.next = c1;
                c1 = c1.next;
            } else {
                prev.next = c2;
                c2 = c2.next;
            }
            prev = prev.next;
        }

        prev.next = (c1 != null ? c1 : c2);

        return dummy.next;
    }

    public static void printList(ListNode node) {
        while (node != null) {
            System.out.print(node.val + " ");
            node = node.next;
        }
    }

    public static ListNode createList(int n) {
        ListNode dummy = new ListNode(-1);
        ListNode prev = dummy;
        while (n-- > 0) {
            prev.next = new ListNode(scn.nextInt());
            prev = prev.next;
        }

        return dummy.next;
    }

    public static void main(String[] args) {
        int n = scn.nextInt();
        ListNode h1 = createList(n);
        int m = scn.nextInt();
        ListNode h2 = createList(m);

        ListNode head = mergeTwoLists(h1, h2);
        printList(head);
    }
}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Merge K Sorted Linkedlist</span>
import java.util.*;

class Main {
    public static Scanner scn = new Scanner(System.in);

    public static class ListNode {
        int val = 0;
        ListNode next = null;

        ListNode(int val) {
            this.val = val;
        }
    }

    public static ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        if (l1 == null || l2 == null)
            return l1 != null ? l1 : l2;

        ListNode dummy = new ListNode(-1);
        ListNode prev = dummy;

        ListNode c1 = l1;
        ListNode c2 = l2;

        while (c1 != null && c2 != null) {
            if (c1.val <= c2.val) {
                prev.next = c1;
                c1 = c1.next;
            } else {
                prev.next = c2;
                c2 = c2.next;
            }
            prev = prev.next;
        }

        prev.next = (c1 != null ? c1 : c2);

        return dummy.next;
    }

    public static ListNode mergeKLists(ListNode[] lists, int si, int ei) {
        if (si == ei)
            return lists[si];
        int mid = (si + ei) / 2;
        return mergeTwoLists(mergeKLists(lists, si, mid), mergeKLists(lists, mid + 1, ei));
    }

    public static ListNode mergeKLists(ListNode[] lists) {
        if (lists.length == 0)
            return null;
        return mergeKLists(lists, 0, lists.length - 1);
    }

    public static void printList(ListNode node) {
        while (node != null) {
            System.out.print(node.val + " ");
            node = node.next;
        }
    }

    public static ListNode createList(int n) {
        ListNode dummy = new ListNode(-1);
        ListNode prev = dummy;
        while (n-- > 0) {
            prev.next = new ListNode(scn.nextInt());
            prev = prev.next;
        }

        return dummy.next;
    }

    public static void main(String[] args) {
        int n = scn.nextInt();
        ListNode[] list = new ListNode[n];
        for (int i = 0; i < n; i++) {
            int m = scn.nextInt();
            list[i] = createList(m);
        }

        ListNode head = mergeKLists(list);
        printList(head);
    }
}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Mergesort Linkedlist</span>
import java.util.*;

class Main {
    public static Scanner scn = new Scanner(System.in);

    public static class ListNode {
        int val = 0;
        ListNode next = null;

        ListNode(int val) {
            this.val = val;
        }
    }

    public static ListNode middleNode2(ListNode head) {
        if (head == null || head.next == null)
            return head;

        ListNode slow = head;
        ListNode fast = head;

        while (fast.next != null && fast.next.next != null) {
            slow = slow.next;
            fast = fast.next.next;
        }

        return slow;
    }

    public static ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        if (l1 == null || l2 == null)
            return l1 != null ? l1 : l2;

        ListNode dummy = new ListNode(-1);
        ListNode prev = dummy;

        ListNode c1 = l1;
        ListNode c2 = l2;

        while (c1 != null && c2 != null) {
            if (c1.val <= c2.val) {
                prev.next = c1;
                c1 = c1.next;
            } else {
                prev.next = c2;
                c2 = c2.next;
            }
            prev = prev.next;
        }

        prev.next = (c1 != null ? c1 : c2);

        return dummy.next;
    }

    public static ListNode mergeSort(ListNode head) {
        if (head == null || head.next == null)
            return head;

        ListNode middle = middleNode2(head);
        ListNode nhead = middle.next;
        middle.next = null;

        return mergeTwoLists(mergeSort(head), mergeSort(nhead));
    }

    public static void printList(ListNode node) {
        while (node != null) {
            System.out.print(node.val + " ");
            node = node.next;
        }
    }

    public static ListNode createList(int n) {
        ListNode dummy = new ListNode(-1);
        ListNode prev = dummy;
        while (n-- > 0) {
            prev.next = new ListNode(scn.nextInt());
            prev = prev.next;
        }

        return dummy.next;
    }

    public static void main(String[] args) {
        int n = scn.nextInt();
        ListNode h1 = createList(n);

        ListNode head = mergeSort(h1);
        printList(head);
    }
}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Remove Nth Node From End Of Linkedlist</span>
import java.util.*;

class Main {
  public static Scanner scn = new Scanner(System.in);

  public static class ListNode {
    int val = 0;
    ListNode next = null;

    ListNode(int val) {
      this.val = val;
    }
  }

  public static ListNode removeNthFromEnd(ListNode head, int n) {
    if (head == null)
      return null;

    ListNode c1 = head, c2 = head;
    while (n-- > 0)
      c2 = c2.next;

    if (c2 == null)
      return head.next;

    while (c2.next != null) {
      c1 = c1.next;
      c2 = c2.next;
    }

    c1.next = c1.next.next;
    return head;
  }

  public static void printList(ListNode node) {
    while (node != null) {
      System.out.print(node.val + " ");
      node = node.next;
    }
  }

  public static ListNode createList(int n) {
    ListNode dummy = new ListNode(-1);
    ListNode prev = dummy;
    while (n-- > 0) {
      prev.next = new ListNode(scn.nextInt());
      prev = prev.next;
    }

    return dummy.next;
  }

  public static void main(String[] args) {
    int n = scn.nextInt();
    ListNode h1 = createList(n);

    int m = scn.nextInt();
    h1 = removeNthFromEnd(h1, m);
    printList(h1);
  }
}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Segregate Even And Odd Nodes In A Linkedlist</span>
import java.util.*;

class Main {
    public static class ListNode {
        int val = 0;
        ListNode next = null;

        ListNode(int val) {
            this.val = val;
        }
    }

    public static ListNode segregateEvenOdd(ListNode head) {
        ListNode odd = new ListNode(-1);
        ListNode even = new ListNode(-1);
        ListNode oitr = odd;
        ListNode eitr = even;

        ListNode curr = head;
        while (curr != null) {
            if (curr.val % 2 != 0) {
                oitr.next = curr;
                oitr = oitr.next;
            } else {
                eitr.next = curr;
                eitr = eitr.next;
            }

            curr = curr.next;
        }

        eitr.next = odd.next;
        oitr.next = null;

        return even.next;

    }

    public static void main(String[] args) {
        Scanner scn = new Scanner(System.in);
        int n = scn.nextInt();
        ListNode dummy = new ListNode(-1);
        ListNode prev = dummy;
        while (n-- > 0) {
            prev.next = new ListNode(scn.nextInt());
            prev = prev.next;
        }

        ListNode head = segregateEvenOdd(dummy.next);
        while (head != null) {
            System.out.print(head.val + " ");
            head = head.next;
        }
    }
}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Reverse Node Of Linkedlist In K Group</span>
import java.util.*;

class Main {
    public static Scanner scn = new Scanner(System.in);

    public static class ListNode {
        int val = 0;
        ListNode next = null;

        ListNode(int val) {
            this.val = val;
        }
    }

    static ListNode tt = null;
    static ListNode th = null;

    public static void addFirst(ListNode node) {
        if (th == null) {
            th = node;
            tt = node;
        } else {
            node.next = th;
            th = node;
        }
    }

    public static int length(ListNode node) {
        int len = 0;
        while (node != null) {
            node = node.next;
            len++;
        }
        return len;
    }

    public static ListNode reverseInKGroup(ListNode head, int k) {
        if (head == null || head.next == null || k <= 1)
            return head;

        int len = length(head);

        ListNode oh = null;
        ListNode ot = null;
        ListNode curr = head;

        while (curr != null && len >= k) {
            int tempK = k;
            while (tempK-- > 0) {
                ListNode forw = curr.next;

                curr.next = null;
                addFirst(curr);

                curr = forw;
            }

            len -= k;
            if (oh == null) {
                oh = th;
                ot = tt;
            } else {
                ot.next = th;
                ot = tt;
            }

            th = null;
            tt = null;
        }

        ot.next = curr;
        return oh;
    }

    public static void printList(ListNode node) {
        while (node != null) {
            System.out.print(node.val + " ");
            node = node.next;
        }
    }

    public static ListNode createList(int n) {
        ListNode dummy = new ListNode(-1);
        ListNode prev = dummy;
        while (n-- > 0) {
            prev.next = new ListNode(scn.nextInt());
            prev = prev.next;
        }

        return dummy.next;
    }

    public static void main(String[] args) {
        int n = scn.nextInt();
        ListNode h1 = createList(n);

        int k = scn.nextInt();
        h1 = reverseInKGroup(h1, k);
        printList(h1);
    }
}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Reverse In Range</span>
import java.util.*;

class Main {
  public static Scanner scn = new Scanner(System.in);

  public static class ListNode {
    int val = 0;
    ListNode next = null;

    ListNode(int val) {
      this.val = val;
    }
  }

  static ListNode tt = null;
  static ListNode th = null;

  public static void addFirst(ListNode node) {
    if (th == null) {
      th = node;
      tt = node;
    } else {
      node.next = th;
      th = node;
    }
  }

  public static ListNode reverseInRange(ListNode head, int n, int m) {
    if (head == null || head.next == null || m == n)
      return head;

    ListNode curr = head;
    ListNode prev = null;

    int idx = 1;
    while (idx < m) {
      while (idx >= n && idx <= m) {
        ListNode forw = curr.next;
        curr.next = null;

        addFirst(curr);

        curr = forw;
        idx++;
      }

      if (idx > n) {
        tt.next = curr;
        if (prev != null) {
          prev.next = th;
          return head;
        }

        return th;
      }
      idx++;
      prev = curr;
      curr = curr.next;
    }

    return head;
  }

  public static void printList(ListNode node) {
    while (node != null) {
      System.out.print(node.val + " ");
      node = node.next;
    }
  }

  public static ListNode createList(int n) {
    ListNode dummy = new ListNode(-1);
    ListNode prev = dummy;
    while (n-- > 0) {
      prev.next = new ListNode(scn.nextInt());
      prev = prev.next;
    }

    return dummy.next;
  }

  public static void main(String[] args) {
    int sz = scn.nextInt();
    ListNode h1 = createList(sz);

    int m = scn.nextInt();
    int n = scn.nextInt();

    h1 = reverseInRange(h1, m, n);
    printList(h1);
  }
}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Copy Linkedlist With Random Pointers</span>
import java.util.*;

class Main {
    public static class ListNode {
        int val = 0;
        ListNode next = null;
        ListNode random = null;

        ListNode(int val) {
            this.val = val;
        }
    }

    public static void copyLinkedList(ListNode head) {
        ListNode curr = head;
        while (curr != null) {
            ListNode forw = curr.next;
            ListNode node = new ListNode(curr.val);

            curr.next = node;
            node.next = forw;

            curr = forw;
        }
    }

    public static void setRandoms(ListNode head) {
        ListNode curr = head;
        while (curr != null) {
            if (curr.random != null)
                curr.next.random = curr.random.next;
            curr = curr.next.next;
        }
    }

    public static ListNode extractLinkedList(ListNode head) {

        ListNode dummy = new ListNode(-1);
        ListNode prev = dummy;

        ListNode curr = head;
        while (curr != null) {
            prev.next = curr.next;
            prev = prev.next;

            curr.next = prev.next;
            curr = curr.next;
        }

        return dummy.next;
    }

    public static ListNode copyRandomList(ListNode head) {
        if (head == null)
            return null;

        copyLinkedList(head);
        setRandoms(head);
        return extractLinkedList(head);
    }

    public static void main(String[] args) {
        Scanner scn = new Scanner(System.in);
        int n = scn.nextInt();

        ListNode[] arr = new ListNode[n];
        ListNode prev = null;

        for (int i = 0; i < n; i++) {
            arr[i] = new ListNode(0);
            if (prev != null)
                prev.next = arr[i];
            prev = arr[i];
        }

        for (int i = 0; i < n; i++) {
            int val = scn.nextInt();
            int idx = scn.nextInt();

            arr[i].val = val;
            if(idx != -1) arr[i].random = arr[idx];
        }

        ListNode head = copyRandomList(arr[0]);
        while (head != null) {
            System.out.print("(" + head.val + ", " + (head.random != null ? head.random.val : -1) + ") ");
            head = head.next;
        }
    }
}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Is Cycle Present In Linkedlist</span>
import java.util.*;

class Main {
    public static Scanner scn = new Scanner(System.in);

    public static class ListNode {
        int val = 0;
        ListNode next = null;

        ListNode(int val) {
            this.val = val;
        }
    }

    public static boolean isCyclePresentInLL(ListNode head) {
        if (head == null)
            return false;
        ListNode slow = head;
        ListNode fast = head;
        while (fast != null && fast.next != null) {
            slow = slow.next;
            fast = fast.next.next;

            if (slow == fast)
                return true;
        }

        return false;
    }

    public static ListNode takeInput() {
        int n = scn.nextInt();
        ListNode dummy = new ListNode(-1);
        ListNode prev = dummy;
        while (n-- > 0) {
            prev.next = new ListNode(scn.nextInt());
            prev = prev.next;
        }
        int idx = scn.nextInt();
        if (idx >= 0) {
            ListNode curr = dummy.next;
            while (idx-- > 0) {
                curr = curr.next;
            }
            prev.next = curr;
        }
        return dummy.next;
    }

    public static void main(String[] args) {
        ListNode head = takeInput();
        System.out.println(isCyclePresentInLL(head));
    }
}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Cycle Node In Linkedlist</span>
import java.util.*;

class Main {
    public static Scanner scn = new Scanner(System.in);

    public static class ListNode {
        int val = 0;
        ListNode next = null;

        ListNode(int val) {
            this.val = val;
        }
    }

    public static ListNode CycleNode(ListNode head) {
        if (head == null || head.next == null)
            return null;

        ListNode slow = head;
        ListNode fast = head;

        while (fast != null && fast.next != null) {
            slow = slow.next;
            fast = fast.next.next;
            if (slow == fast)
                break;
        }

        if (slow != fast)
            return null;

        slow = head;
        while (slow != fast) {
            slow = slow.next;
            fast = fast.next;
        }

        return slow;
    }

    public static ListNode takeInput() {
        int n = scn.nextInt();
        ListNode dummy = new ListNode(-1);
        ListNode prev = dummy;
        while (n-- > 0) {
            prev.next = new ListNode(scn.nextInt());
            prev = prev.next;
        }
        int idx = scn.nextInt();
        if (idx >= 0) {
            ListNode curr = dummy.next;
            while (idx-- > 0) {
                curr = curr.next;
            }
            prev.next = curr;
        }
        return dummy.next;
    }

    public static void main(String[] args) {
        ListNode head = takeInput();
        ListNode ans = CycleNode(head);
        System.out.println(ans!=null?ans.val:-1);
    }
}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Intersection Node In Two Linkedlist Using Difference Method</span>
import java.util.*;

class Main {
    public static Scanner scn = new Scanner(System.in);

    public static class ListNode {
        int val = 0;
        ListNode next = null;

        ListNode(int val) {
            this.val = val;
        }
    }

    public static ListNode IntersectionNodeInTwoLL(ListNode headA, ListNode headB) {
        int l1 = length(headA);
        int l2 = length(headB);
        ListNode biggerList = l1 > l2 ? headA : headB;
        ListNode smallerList = l1 > l2 ? headB : headA;

        int diff = Math.max(l1, l2) - Math.min(l1, l2);
        while (diff-- > 0) {
            biggerList = biggerList.next;
        }

        while (biggerList != smallerList) {
            biggerList = biggerList.next;
            smallerList = smallerList.next;
        }

        return biggerList;
    }

    private static int length(ListNode node) {
        int len = 0;
        while (node != null) {
            node = node.next;
            len++;
        }
        return len;
    }

    // Input_code===================================================

    public static ListNode makeList(int n) {
        ListNode dummy = new ListNode(-1);
        ListNode prev = dummy;
        while (n-- > 0) {
            prev.next = new ListNode(scn.nextInt());
            prev = prev.next;
        }

        return dummy.next;
    }

    public static void main(String[] args) {
        ListNode head1 = makeList(scn.nextInt());
        int idx = scn.nextInt();
        ListNode head2 = makeList(scn.nextInt());

        if (idx >= 0) {
            ListNode curr = head1;
            while (idx-- > 0)
                curr = curr.next;

            ListNode prev = head2;
            while (prev.next != null)
                prev = prev.next;

            prev.next = curr;
        }

        ListNode ans = IntersectionNodeInTwoLL(head1, head2);
        System.out.println(ans != null ? ans.val : -1);
    }

}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Intersection Node In Two Linkedlist Using Floyd Cycle Method</span>
import java.util.*;

class Main {
    public static Scanner scn = new Scanner(System.in);

    public static class ListNode {
        int val = 0;
        ListNode next = null;

        ListNode(int val) {
            this.val = val;
        }
    }

    public static ListNode IntersectionNodeInTwoLL(ListNode headA, ListNode headB) {
        int l1 = length(headA);
        int l2 = length(headB);
        ListNode biggerList = l1 > l2 ? headA : headB;
        ListNode smallerList = l1 > l2 ? headB : headA;

        int diff = Math.max(l1, l2) - Math.min(l1, l2);
        while (diff-- > 0) {
            biggerList = biggerList.next;
        }

        while (biggerList != smallerList) {
            biggerList = biggerList.next;
            smallerList = smallerList.next;
        }

        return biggerList;
    }

    private static int length(ListNode node) {
        int len = 0;
        while (node != null) {
            node = node.next;
            len++;
        }
        return len;
    }

    // Input_code===================================================

    public static ListNode makeList(int n) {
        ListNode dummy = new ListNode(-1);
        ListNode prev = dummy;
        while (n-- > 0) {
            prev.next = new ListNode(scn.nextInt());
            prev = prev.next;
        }

        return dummy.next;
    }

    public static void main(String[] args) {
        ListNode head1 = makeList(scn.nextInt());
        int idx = scn.nextInt();
        ListNode head2 = makeList(scn.nextInt());

        if (idx >= 0) {
            ListNode curr = head1;
            while (idx-- > 0)
                curr = curr.next;

            ListNode prev = head2;
            while (prev.next != null)
                prev = prev.next;

            prev.next = curr;
        }

        ListNode ans = IntersectionNodeInTwoLL(head1, head2);
        System.out.println(ans != null ? ans.val : -1);
    }

}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Add Two Linkedlist</span>
import java.util.*;

class Main {
    public static Scanner scn = new Scanner(System.in);

    public static class ListNode {
        int val = 0;
        ListNode next = null;

        ListNode(int val) {
            this.val = val;
        }
    }

    public static ListNode reverseList(ListNode node) {
        if (node == null || node.next == null)
            return node;

        ListNode prev = null;
        ListNode curr = node;
        while (curr != null) {
            ListNode forw = curr.next; // backup.

            curr.next = prev; // connection

            prev = curr; // move forw.
            curr = forw;
        }

        return prev;
    }

    public static ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        if (l1 == null)
            return l2;
        if (l2 == null)
            return l1;

        l1 = reverseList(l1);
        l2 = reverseList(l2);

        ListNode head = new ListNode(-1); // dummy.
        ListNode itr = head;

        int carry = 0;
        while (l1 != null || l2 != null || carry != 0) {
            int sum = carry + (l1 != null ? l1.val : 0) + (l2 != null ? l2.val : 0);

            carry = sum / 10;
            sum = sum % 10;

            itr.next = new ListNode(sum);
            itr = itr.next;

            if (l1 != null)
                l1 = l1.next;
            if (l2 != null)
                l2 = l2.next;
        }

        return reverseList(head.next);
    }

    // InFput_code===================================================

    public static void printList(ListNode node) {
        while (node != null) {
            System.out.print(node.val + " ");
            node = node.next;
        }
    }

    public static ListNode makeList(int n) {
        ListNode dummy = new ListNode(-1);
        ListNode prev = dummy;
        while (n-- > 0) {
            prev.next = new ListNode(scn.nextInt());
            prev = prev.next;
        }

        return dummy.next;
    }

    public static void main(String[] args) {
        ListNode head1 = makeList(scn.nextInt());
        ListNode head2 = makeList(scn.nextInt());

        ListNode ans = addTwoNumbers(head1, head2);
        printList(ans);
    }

}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Subtract Two Linkedlist</span>
import java.util.*;

class Main {
  public static Scanner scn = new Scanner(System.in);

  public static class ListNode {
    int val = 0;
    ListNode next = null;

    ListNode(int val) {
      this.val = val;
    }
  }

  public static ListNode reverseList(ListNode node) {
    if (node == null || node.next == null)
      return node;

    ListNode prev = null;
    ListNode curr = node;
    while (curr != null) {
      ListNode forw = curr.next; // backup.

      curr.next = prev; // connection

      prev = curr; // move forw.
      curr = forw;
    }

    return prev;
  }

  public static ListNode subtractTwoNumbers(ListNode l1, ListNode l2) {
    if (l2 == null)
      return l1;
    l1 = reverseList(l1);
    l2 = reverseList(l2);

    ListNode dummy = new ListNode(-1), prev = dummy, c1 = l1, c2 = l2;

    int borrow = 0;
    while (c1 != null) {
      int sub = borrow + c1.val - (c2 != null ? c2.val : 0);
      if (sub < 0) {
        borrow = -1;
        sub += 10;
      } else
        borrow = 0;

      prev.next = new ListNode(sub);
      prev = prev.next;

      c1 = c1.next;
      if (c2 != null)
        c2 = c2.next;
    }

    ListNode head = reverseList(dummy.next), curr = head;
    while (curr != null && curr.val == 0) {
      ListNode forw = curr.next;
      curr.next = null;
      curr = forw;
    }

    return curr != null ? curr : new ListNode(0);
  }

  // InFput_code===================================================

  public static void printList(ListNode node) {
    while (node != null) {
      System.out.print(node.val + " ");
      node = node.next;
    }
  }

  public static ListNode makeList(int n) {
    ListNode dummy = new ListNode(-1);
    ListNode prev = dummy;
    while (n-- > 0) {
      prev.next = new ListNode(scn.nextInt());
      prev = prev.next;
    }

    return dummy.next;
  }

  public static void main(String[] args) {
    ListNode head1 = makeList(scn.nextInt());
    ListNode head2 = makeList(scn.nextInt());

    ListNode ans = subtractTwoNumbers(head1, head2);
    printList(ans);
  }

}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Multiply Two Linkedlist</span>
import java.util.*;

class Main {
    public static Scanner scn = new Scanner(System.in);

    public static class ListNode {
        int val = 0;
        ListNode next = null;

        ListNode(int val) {
            this.val = val;
        }
    }

    public static ListNode reverseList(ListNode node) {
        if (node == null || node.next == null)
            return node;

        ListNode prev = null;
        ListNode curr = node;
        while (curr != null) {
            ListNode forw = curr.next; // backup.

            curr.next = prev; // connection

            prev = curr; // move forw.
            curr = forw;
        }

        return prev;
    }

    public static void addTwoLinkedList(ListNode l1, ListNode l2) {
        ListNode prev = l1;
        int carry = 0;
        while (l2 != null || carry != 0) {
            int sum = carry + (prev.next != null ? prev.next.val : 0) + (l2 != null ? l2.val : 0);

            carry = sum / 10;
            sum = sum % 10;

            if (prev.next != null)
                prev.next.val = sum;
            else
                prev.next = new ListNode(sum);

            if (l2 != null)
                l2 = l2.next;
            prev = prev.next;
        }
    }

    public static ListNode multiplyLinkedListWithDigit(ListNode l1, int digit) {
        ListNode head = new ListNode(-1); // dummy.
        ListNode curr = head;

        int carry = 0;
        while (l1 != null || carry != 0) {
            int sum = carry + (l1 != null ? (l1.val * digit) : 0);

            carry = sum / 10;
            sum = sum % 10;

            curr.next = new ListNode(sum);

            if (l1 != null)
                l1 = l1.next;
            curr = curr.next;
        }

        return head.next;
    }

    public static ListNode multiplyTwoLL(ListNode l1, ListNode l2) {
        l1 = reverseList(l1);
        l2 = reverseList(l2);

        ListNode ans = new ListNode(-1); // dummy.
        ListNode ans_itr = ans;
        ListNode l2_itr = l2;

        while (l2_itr != null) {
            ListNode head = multiplyLinkedListWithDigit(l1, l2_itr.val);
            l2_itr = l2_itr.next;
            addTwoLinkedList(ans_itr,head);
            ans_itr = ans_itr.next;
        }
        
        ans = ans.next;
        return reverseList(ans);
    }

    // InFput_code===================================================

    public static void printList(ListNode node) {
        while (node != null) {
            System.out.print(node.val + " ");
            node = node.next;
        }
    }

    public static ListNode makeList(int n) {
        ListNode dummy = new ListNode(-1);
        ListNode prev = dummy;
        while (n-- > 0) {
            prev.next = new ListNode(scn.nextInt());
            prev = prev.next;
        }

        return dummy.next;
    }

    public static void main(String[] args) {
        ListNode head1 = makeList(scn.nextInt());
        ListNode head2 = makeList(scn.nextInt());

        ListNode ans = multiplyTwoLL(head1, head2);
        printList(ans);
    }

}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Remove Duplicate From Sorted Linkedlist</span>
import java.util.*;

class Main {
    public static Scanner scn = new Scanner(System.in);

    public static class ListNode {
        int val = 0;
        ListNode next = null;

        ListNode(int val) {
            this.val = val;
        }
    }

    public static ListNode removeDuplicates(ListNode head) {
        if (head == null || head.next == null)
            return head;

        ListNode nhead = new ListNode(-1000);
        ListNode itr = nhead;
        ListNode curr = head;

        while (curr != null) {
            while (curr != null && itr.val == curr.val)
                curr = curr.next;

            itr.next = curr;

            itr = itr.next;
            if (curr != null)
                curr = curr.next;
        }

        return nhead.next;
    }
    
    // InFput_code===================================================

    public static void printList(ListNode node) {
        while (node != null) {
            System.out.print(node.val + " ");
            node = node.next;
        }
    }

    public static ListNode makeList(int n) {
        ListNode dummy = new ListNode(-1);
        ListNode prev = dummy;
        while (n-- > 0) {
            prev.next = new ListNode(scn.nextInt());
            prev = prev.next;
        }

        return dummy.next;
    }

    public static void main(String[] args) {
        ListNode head = makeList(scn.nextInt());

        ListNode ans = removeDuplicates(head);
        printList(ans);
    }

}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Remove All Duplicates From Sorted Linkedlist</span>
import java.util.*;

class Main {
    public static Scanner scn = new Scanner(System.in);

    public static class ListNode {
        int val = 0;
        ListNode next = null;

        ListNode(int val) {
            this.val = val;
        }
    }

    public static ListNode removeDuplicates(ListNode head) {
        if (head == null || head.next == null)
            return head;

        ListNode nhead = new ListNode(-1);
        ListNode itr = nhead;
        itr.next = head;

        ListNode curr = head.next;

        while (curr != null) {
            boolean isLoopRun = false;
            while (curr != null && itr.next.val == curr.val) {
                curr = curr.next;
                isLoopRun = true;
            }

            if (isLoopRun)
                itr.next = curr;
            else
                itr = itr.next;

            if (curr != null)
                curr = curr.next;
        }

        return nhead.next;

    }

    // InFput_code===================================================

    public static void printList(ListNode node) {
        while (node != null) {
            System.out.print(node.val + " ");
            node = node.next;
        }
    }

    public static ListNode makeList(int n) {
        ListNode dummy = new ListNode(-1);
        ListNode prev = dummy;
        while (n-- > 0) {
            prev.next = new ListNode(scn.nextInt());
            prev = prev.next;
        }

        return dummy.next;
    }

    public static void main(String[] args) {
        ListNode head = makeList(scn.nextInt());

        ListNode ans = removeDuplicates(head);
        printList(ans);
    }

}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Segregate 01 Node Of Linkedlist Over Swapping Nodes</span>
import java.util.*;

class Main {
    public static Scanner scn = new Scanner(System.in);

    public static class ListNode {
        int val = 0;
        ListNode next = null;

        ListNode(int val) {
            this.val = val;
        }
    }

    public static ListNode segregate01(ListNode head) {
        if (head == null || head.next == null)
            return head;

        ListNode Zero = new ListNode(-1);
        ListNode zp = Zero;

        ListNode Ones = new ListNode(-1);
        ListNode op = Ones;

        ListNode curr = head;
        while (curr != null) {
            if (curr.val == 0) {
                zp.next = curr;
                zp = zp.next;
            } else {
                op.next = curr;
                op = op.next;
            }

            curr = curr.next;
        }

        op.next = null;
        zp.next = Ones.next;

        return Zero.next;
    }

    public static void printList(ListNode node) {
        while (node != null) {
            System.out.print(node.val + " ");
            node = node.next;
        }
    }

    public static ListNode createList(int n) {
        ListNode dummy = new ListNode(-1);
        ListNode prev = dummy;
        while (n-- > 0) {
            prev.next = new ListNode(scn.nextInt());
            prev = prev.next;
        }

        return dummy.next;
    }

    public static void main(String[] args) {
        int n = scn.nextInt();
        ListNode h1 = createList(n);
        h1 = segregate01(h1);
        printList(h1);
    }
}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Segregate 012 Node Of Linkedlist Over Swapping Nodes</span>
import java.util.*;

class Main {
    public static Scanner scn = new Scanner(System.in);

    public static class ListNode {
        int val = 0;
        ListNode next = null;

        ListNode(int val) {
            this.val = val;
        }
    }

    public static ListNode segregate012(ListNode head) {
        if (head == null || head.next == null)
            return head;

        ListNode zero = new ListNode(-1);
        ListNode zp = zero;

        ListNode one = new ListNode(-1);
        ListNode op = one;

        ListNode two = new ListNode(-1);
        ListNode tp = two;

        ListNode curr = head;
        while (curr != null) {
            if (curr.val == 0) {
                zp.next = curr;
                zp = zp.next;
            } else if (curr.val == 1) {
                op.next = curr;
                op = op.next;
            } else {
                tp.next = curr;
                tp = tp.next;
            }

            curr = curr.next;
        }

        op.next = two.next;
        zp.next = one.next;
        tp.next = null;

        return zero.next;
    }

    public static void printList(ListNode node) {
        while (node != null) {
            System.out.print(node.val + " ");
            node = node.next;
        }
    }

    public static ListNode createList(int n) {
        ListNode dummy = new ListNode(-1);
        ListNode prev = dummy;
        while (n-- > 0) {
            prev.next = new ListNode(scn.nextInt());
            prev = prev.next;
        }

        return dummy.next;
    }

    public static void main(String[] args) {
        int n = scn.nextInt();
        ListNode h1 = createList(n);
        h1 = segregate012(h1);
        printList(h1);
    }
}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Segregate Node Of Linkedlist Over Last Index.</span>
import java.util.*;

class Main {
    public static Scanner scn = new Scanner(System.in);

    public static class ListNode {
        int val = 0;
        ListNode next = null;

        ListNode(int val) {
            this.val = val;
        }
    }

    public static ListNode segregateOnLastIndex(ListNode head) {
        if (head == null || head.next == null)
            return head;

        ListNode small = new ListNode(-1); // all Nodes smaller or equal to given data.
        ListNode sp = small; // smaller previous

        ListNode greater = new ListNode(-1); // all Nodes greater than given data.
        ListNode gp = greater; // greater previous

        ListNode tail = head;
        while (tail.next != null)
            tail = tail.next;

        ListNode curr = head;
        while (curr != null) {
            if (curr.val <= tail.val){
                sp.next = curr;
                sp = sp.next;
            }
            else{
                gp.next = curr;
                gp = gp.next;
            }

            curr = curr.next;
        }

        gp.next = null;
        sp.next = greater.next;

        small.next = null;
        greater.next = null;

        return sp;
    }

    public static void printList(ListNode node) {
        while (node != null) {
            System.out.print(node.val + " ");
            node = node.next;
        }
    }

    public static ListNode createList(int n) {
        ListNode dummy = new ListNode(-1);
        ListNode prev = dummy;
        while (n-- > 0) {
            prev.next = new ListNode(scn.nextInt());
            prev = prev.next;
        }

        return dummy.next;
    }

    public static void main(String[] args) {
        int n = scn.nextInt();
        ListNode h1 = createList(n);
        h1 = segregateOnLastIndex(h1);
        printList(h1);
    }
}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Segregate Node Of Linkedlist Over Pivot Index</span>
import java.util.*;

class Main {
  public static Scanner scn = new Scanner(System.in);

  public static class ListNode {
    int val = 0;
    ListNode next = null;

    ListNode(int val) {
      this.val = val;
    }
  }

  public static int length(ListNode head) {
    int len = 0;
    ListNode curr = head;
    while (curr != null) {
      curr = curr.next;
      len++;
    }
    return len;
  }

  public static ListNode segregate(ListNode head, int idx) {
    if (head == null || head.next == null)
      return head;

    int i = 0, data = 0;
    ListNode curr = head;
    while (curr != null) {
      if (i == idx)
        data = curr.val;

      i++;
      curr = curr.next;
    }

    ListNode smaller = new ListNode(-1);
    ListNode sp = smaller;

    ListNode greater = new ListNode(-1);
    ListNode gp = greater;

    i = 0;
    curr = head;
    ListNode pivot = null;
    while (curr != null) {
      if (i == idx) {
        pivot = curr;
      } else if (curr.val <= data) {
        sp.next = curr;
        sp = sp.next;
      } else {
        gp.next = curr;
        gp = gp.next;
      }

      curr = curr.next;
      i++;
    }

    sp.next = pivot;
    pivot.next = greater.next;
    gp.next = null;
    sp = sp.next;

    return smaller.next;
  }

  public static void printList(ListNode node) {
    while (node != null) {
      System.out.print(node.val + " ");
      node = node.next;
    }
  }

  public static ListNode createList(int n) {
    ListNode dummy = new ListNode(-1);
    ListNode prev = dummy;
    while (n-- > 0) {
      prev.next = new ListNode(scn.nextInt());
      prev = prev.next;
    }

    return dummy.next;
  }

  public static void main(String[] args) {
    int n = scn.nextInt();
    ListNode h1 = createList(n);
    int idx = scn.nextInt();
    h1 = segregate(h1, idx);
    printList(h1);
  }
}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Quicksort In Linkedlist</span>
import java.util.*;

class Main {
  public static Scanner scn = new Scanner(System.in);

  public static class ListNode {
    int val = 0;
    ListNode next = null;

    ListNode(int val) {
      this.val = val;
    }
  }

  public static int length(ListNode node) {
    if (node == null)
      return 0;

    ListNode curr = node;
    int len = 0;
    while (curr != null) {
      len++;
      curr = curr.next;
    }

    return len;
  }

  public static ListNode[] segregate(ListNode head, int pivotIdx) {
    ListNode small = new ListNode(-1);
    ListNode large = new ListNode(-1);
    ListNode pivotNode = head, sp = small, lp = large, curr = head;
    while (pivotIdx-- > 0)
      pivotNode = pivotNode.next;

    while (curr != null) {
      if (curr != pivotNode) {
        if (curr.val <= pivotNode.val) {
          sp.next = curr;
          sp = sp.next;
        } else {
          lp.next = curr;
          lp = lp.next;
        }
      }

      curr = curr.next;
    }

    pivotNode.next = null;
    sp.next = null;
    lp.next = null;

    return new ListNode[] { small.next, pivotNode, large.next };
  }

  public static ListNode[] mergeElements(ListNode[] left, ListNode pivotNode, ListNode[] right) {
    ListNode head = null;
    ListNode tail = null;
    if (left[0] != null && right[0] != null) {
      head = left[0];
      tail = right[1];
      left[1].next = pivotNode;
      pivotNode.next = right[0];
    } else if (left[0] != null) {
      head = left[0];
      tail = pivotNode;
      left[1].next = pivotNode;
    } else if (right[0] != null) {
      head = pivotNode;
      tail = right[1];
      pivotNode.next = right[0];
    } else {
      head = tail = pivotNode;
    }

    return new ListNode[] { head, tail };
  }

  public static ListNode[] quickSort_(ListNode head) {
    if (head == null || head.next == null)
      return new ListNode[] { head, head };

    int len = length(head);
    int pivotIdx = len / 2;
    ListNode[] segregatedElements = segregate(head, pivotIdx);

    ListNode[] left = quickSort_(segregatedElements[0]);
    ListNode[] right = quickSort_(segregatedElements[2]);

    return mergeElements(left, segregatedElements[1], right);
  }

  public static ListNode quickSort(ListNode head) {
    return quickSort_(head)[0];
  }

  public static void printList(ListNode node) {
    while (node != null) {
      System.out.print(node.val + " ");
      node = node.next;
    }
  }

  public static ListNode createList(int n) {
    ListNode dummy = new ListNode(-1);
    ListNode prev = dummy;
    while (n-- > 0) {
      prev.next = new ListNode(scn.nextInt());
      prev = prev.next;
    }

    return dummy.next;
  }

  public static void main(String[] args) {
    int n = scn.nextInt();
    ListNode h1 = createList(n);

    ListNode head = quickSort(h1);
    printList(head);
  }
}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Add First In Doubly Linkedlist</span>
import java.util.*;

class Main {

  public static class DoublyLinkedList {
    private class Node {
      int data = 0;
      Node prev = null;
      Node next = null;

      Node(int data) {
        this.data = data;
      }

    }

    private Node head = null;
    private Node tail = null;
    private int size = 0;

    public String toString() {
      StringBuilder sb = new StringBuilder();
      Node curr = this.head;
      sb.append("[");
      while (curr != null) {
        sb.append(curr.data);
        if (curr.next != null)
          sb.append(", ");
        curr = curr.next;
      }
      sb.append("]");

      return sb.toString();
    }

    private void addFirstNode(Node node) {
      if (this.size == 0)
        this.head = this.tail = node;
      else {
        node.next = this.head;
        this.head.prev = node;
        this.head = node;
      }
      this.size++;
    }

    public void addFirst(int val) {
      Node node = new Node(val);
      addFirstNode(node);
    }

  }

  public static void main(String[] args) {
    Scanner scn = new Scanner(System.in);
    DoublyLinkedList dll = new DoublyLinkedList();

    String str = scn.nextLine();
    while (!str.equals("stop")) {
      String[] s = str.split(" ");
      if (s[0].equals("addFirst"))
        dll.addFirst(Integer.parseInt(s[1]));

      str = scn.nextLine();
    }

    System.out.println(dll);
  }
}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Add Last In Doubly Linkedlist</span>
import java.util.*;

class Main {

  public static class DoublyLinkedList {
    private class Node {
      int data = 0;
      Node prev = null;
      Node next = null;

      Node(int data) {
        this.data = data;
      }

    }

    private Node head = null;
    private Node tail = null;
    private int size = 0;

    public String toString() {
      StringBuilder sb = new StringBuilder();
      Node curr = this.head;
      sb.append("[");
      while (curr != null) {
        sb.append(curr.data);
        if (curr.next != null)
          sb.append(", ");
        curr = curr.next;
      }
      sb.append("]");

      return sb.toString();
    }

    private void addFirstNode(Node node) {
      if (this.size == 0)
        this.head = this.tail = node;
      else {
        node.next = this.head;
        this.head.prev = node;
        this.head = node;
      }
      this.size++;
    }

    public void addFirst(int val) {
      Node node = new Node(val);
      addFirstNode(node);
    }

    private void addLastNode(Node node) {
      if (this.size == 0)
        this.head = this.tail = node;
      else {
        this.tail.next = node;
        node.prev = this.tail;
        this.tail = node;
      }
      this.size++;
    }

    public void addLast(int val) {
      Node node = new Node(val);
      addLastNode(node);
    }

  }

  public static void main(String[] args) {
    Scanner scn = new Scanner(System.in);
    DoublyLinkedList dll = new DoublyLinkedList();

    String str = scn.nextLine();
    while (!str.equals("stop")) {
      String[] s = str.split(" ");
      if (s[0].equals("addFirst"))
        dll.addFirst(Integer.parseInt(s[1]));
      else if (s[0].equals("addLast"))
        dll.addLast(Integer.parseInt(s[1]));

      str = scn.nextLine();
    }

    System.out.println(dll);
  }
}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Remove First In Doubly Linkedlist</span>
import java.util.*;

class Main {

  public static class DoublyLinkedList {
    private class Node {
      int data = 0;
      Node prev = null;
      Node next = null;

      Node(int data) {
        this.data = data;
      }

    }

    private Node head = null;
    private Node tail = null;
    private int size = 0;

    public String toString() {
      StringBuilder sb = new StringBuilder();
      Node curr = this.head;
      sb.append("[");
      while (curr != null) {
        sb.append(curr.data);
        if (curr.next != null)
          sb.append(", ");
        curr = curr.next;
      }
      sb.append("]");

      return sb.toString();
    }

    // Exceptions========================================

    private boolean ListIsEmptyException() {
      if (this.size == 0) {
        System.out.print("ListIsEmpty: " );
        return true;
      }
      return false;
    }

    // AddFunctions======================================

    private void addFirstNode(Node node) {
      if (this.size == 0)
        this.head = this.tail = node;
      else {
        node.next = this.head;
        this.head.prev = node;
        this.head = node;
      }
      this.size++;
    }

    public void addFirst(int val) {
      Node node = new Node(val);
      addFirstNode(node);
    }

    private void addLastNode(Node node) {
      if (this.size == 0)
        this.head = this.tail = node;
      else {
        this.tail.next = node;
        node.prev = this.tail;
        this.tail = node;
      }
      this.size++;
    }

    public void addLast(int val) {
      Node node = new Node(val);
      addLastNode(node);
    }

    // RemoveFunctions======================================

    private Node removeFirstNode() {
      Node node = this.head;
      if (this.size == 1)
        this.head = this.tail = null;
      else {
        Node nextNode = this.head.next;
        nextNode.prev = null;
        node.next = null;

        this.head = nextNode;
      }

      this.size--;
      return node;
    }

    public int removeFirst() {
      if (ListIsEmptyException())
        return -1;
      Node node = removeFirstNode();
      return node.data;
    }

  }

  public static void main(String[] args) {
    Scanner scn = new Scanner(System.in);
    DoublyLinkedList dll = new DoublyLinkedList();

    String str = scn.nextLine();
    while (!str.equals("stop")) {
      String[] s = str.split(" ");
      if (s[0].equals("addFirst"))
        dll.addFirst(Integer.parseInt(s[1]));
      else if (s[0].equals("addLast"))
        dll.addLast(Integer.parseInt(s[1]));
      else if (s[0].equals("removeFirst"))
        System.out.println(dll.removeFirst());

      str = scn.nextLine();
    }

    System.out.println(dll);
  }
}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Remove Last In Doubly Linkedlist</span>
import java.util.*;

class Main {

  public static class DoublyLinkedList {
    private class Node {
      int data = 0;
      Node prev = null;
      Node next = null;

      Node(int data) {
        this.data = data;
      }

    }

    private Node head = null;
    private Node tail = null;
    private int size = 0;

    public String toString() {
      StringBuilder sb = new StringBuilder();
      Node curr = this.head;
      sb.append("[");
      while (curr != null) {
        sb.append(curr.data);
        if (curr.next != null)
          sb.append(", ");
        curr = curr.next;
      }
      sb.append("]");

      return sb.toString();
    }

    // Exceptions========================================

    private boolean ListIsEmptyException() {
      if (this.size == 0) {
        System.out.print("ListIsEmpty: ");
        return true;
      }
      return false;
    }

    // AddFunctions======================================

    private void addFirstNode(Node node) {
      if (this.size == 0)
        this.head = this.tail = node;
      else {
        node.next = this.head;
        this.head.prev = node;
        this.head = node;
      }
      this.size++;
    }

    public void addFirst(int val) {
      Node node = new Node(val);
      addFirstNode(node);
    }

    private void addLastNode(Node node) {
      if (this.size == 0)
        this.head = this.tail = node;
      else {
        this.tail.next = node;
        node.prev = this.tail;
        this.tail = node;
      }
      this.size++;
    }

    public void addLast(int val) {
      Node node = new Node(val);
      addLastNode(node);
    }

    // RemoveFunctions======================================

    private Node removeFirstNode() {
      Node node = this.head;
      if (this.size == 1)
        this.head = this.tail = null;
      else {
        Node nextNode = this.head.next;
        nextNode.prev = null;
        node.next = null;

        this.head = nextNode;
      }

      this.size--;
      return node;
    }

    public int removeFirst() {
      if (ListIsEmptyException())
        return -1;
      Node node = removeFirstNode();
      return node.data;
    }

    private Node removeLastNode() {
      Node node = this.tail;
      if (this.size == 1)
        this.head = this.tail = null;
      else {
        Node prevNode = this.tail.prev;
        prevNode.next = null;
        node.prev = null;

        this.tail = prevNode;
      }

      this.size--;
      return node;
    }

    public int removeLast() {
      if (ListIsEmptyException())
        return -1;
      Node node = removeLastNode();
      return node.data;
    }

  }

  public static void main(String[] args) {
    Scanner scn = new Scanner(System.in);
    DoublyLinkedList dll = new DoublyLinkedList();

    String str = scn.nextLine();
    while (!str.equals("stop")) {
      String[] s = str.split(" ");
      if (s[0].equals("addFirst"))
        dll.addFirst(Integer.parseInt(s[1]));
      else if (s[0].equals("addLast"))
        dll.addLast(Integer.parseInt(s[1]));
      else if (s[0].equals("removeFirst"))
        System.out.println(dll.removeFirst());
      else if (s[0].equals("removeLast"))
        System.out.println(dll.removeLast());
      str = scn.nextLine();
    }

    System.out.println(dll);
  }
}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Get First And Get Last In Doubly Linkedlist</span>
import java.util.*;

class Main {

  public static class DoublyLinkedList {
    private class Node {
      int data = 0;
      Node prev = null;
      Node next = null;

      Node(int data) {
        this.data = data;
      }

    }

    private Node head = null;
    private Node tail = null;
    private int size = 0;

    public String toString() {
      StringBuilder sb = new StringBuilder();
      Node curr = this.head;
      sb.append("[");
      while (curr != null) {
        sb.append(curr.data);
        if (curr.next != null)
          sb.append(", ");
        curr = curr.next;
      }
      sb.append("]");

      return sb.toString();
    }

    // Exceptions========================================

    private boolean ListIsEmptyException() {
      if (this.size == 0) {
        System.out.print("ListIsEmpty: ");
        return true;
      }
      return false;
    }

    // BasicFunctions======================================

    public int size() {
      return this.size;
    }

    public boolean isEmpty() {
      return this.size == 0;
    }

    // AddFunctions======================================

    private void addFirstNode(Node node) {
      if (this.size == 0)
        this.head = this.tail = node;
      else {
        node.next = this.head;
        this.head.prev = node;
        this.head = node;
      }
      this.size++;
    }

    public void addFirst(int val) {
      Node node = new Node(val);
      addFirstNode(node);
    }

    private void addLastNode(Node node) {
      if (this.size == 0)
        this.head = this.tail = node;
      else {
        this.tail.next = node;
        node.prev = this.tail;
        this.tail = node;
      }
      this.size++;
    }

    public void addLast(int val) {
      Node node = new Node(val);
      addLastNode(node);
    }

    // RemoveFunctions======================================

    private Node removeFirstNode() {
      Node node = this.head;
      if (this.size == 1)
        this.head = this.tail = null;
      else {
        Node nextNode = this.head.next;
        nextNode.prev = null;
        node.next = null;

        this.head = nextNode;
      }

      this.size--;
      return node;
    }

    public int removeFirst() {
      if (ListIsEmptyException())
        return -1;
      Node node = removeFirstNode();
      return node.data;
    }

    private Node removeLastNode() {
      Node node = this.tail;
      if (this.size == 1)
        this.head = this.tail = null;
      else {
        Node prevNode = this.tail.prev;
        prevNode.next = null;
        node.prev = null;

        this.tail = prevNode;
      }

      this.size--;
      return node;
    }

    public int removeLast() {
      if (ListIsEmptyException())
        return -1;
      Node node = removeLastNode();
      return node.data;
    }

    // getFunctions======================================

    public int getFirst() {
      if (ListIsEmptyException())
        return -1;

      return this.head.data;
    }

    public int getLast() {
      if (ListIsEmptyException())
        return -1;

      return this.tail.data;
    }

  }

  public static void main(String[] args) {
    Scanner scn = new Scanner(System.in);
    DoublyLinkedList dll = new DoublyLinkedList();

    String str = scn.nextLine();
    while (!str.equals("stop")) {
      String[] s = str.split(" ");
      if (s[0].equals("addFirst"))
        dll.addFirst(Integer.parseInt(s[1]));
      else if (s[0].equals("addLast"))
        dll.addLast(Integer.parseInt(s[1]));
      else if (s[0].equals("removeFirst"))
        System.out.println(dll.removeFirst());
      else if (s[0].equals("removeLast"))
        System.out.println(dll.removeLast());
      else if (s[0].equals("getFirst"))
        System.out.println(dll.getFirst());
      else if (s[0].equals("getLast"))
        System.out.println(dll.getLast());
      else if (s[0].equals("size"))
        System.out.println(dll.size());
      else if (s[0].equals("isEmpty"))
        System.out.println(dll.isEmpty());

      str = scn.nextLine();
    }

    System.out.println(dll);
  }
}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Get At In Doubly Linkedlist</span>
import java.util.*;

class Main {

  public static class DoublyLinkedList {
    private class Node {
      int data = 0;
      Node prev = null;
      Node next = null;

      Node(int data) {
        this.data = data;
      }

    }

    private Node head = null;
    private Node tail = null;
    private int size = 0;

    public String toString() {
      StringBuilder sb = new StringBuilder();
      Node curr = this.head;
      sb.append("[");
      while (curr != null) {
        sb.append(curr.data);
        if (curr.next != null)
          sb.append(", ");
        curr = curr.next;
      }
      sb.append("]");

      return sb.toString();
    }

    // Exceptions========================================

    private boolean ListIsEmptyException() {
      if (this.size == 0) {
        System.out.print("ListIsEmpty: ");
        return true;
      }
      return false;
    }

    private boolean indexIsInvalidException(int index, int leftRange, int rightRange) {
      if (index < leftRange || index > rightRange) {
        System.out.print("IndexIsInValid: ");
        return true;
      }
      return false;
    }

    // BasicFunctions======================================

    public int size() {
      return this.size;
    }

    public boolean isEmpty() {
      return this.size == 0;
    }

    // AddFunctions======================================

    private void addFirstNode(Node node) {
      if (this.size == 0)
        this.head = this.tail = node;
      else {
        node.next = this.head;
        this.head.prev = node;
        this.head = node;
      }
      this.size++;
    }

    public void addFirst(int val) {
      Node node = new Node(val);
      addFirstNode(node);
    }

    private void addLastNode(Node node) {
      if (this.size == 0)
        this.head = this.tail = node;
      else {
        this.tail.next = node;
        node.prev = this.tail;
        this.tail = node;
      }
      this.size++;
    }

    public void addLast(int val) {
      Node node = new Node(val);
      addLastNode(node);
    }

    // RemoveFunctions======================================

    private Node removeFirstNode() {
      Node node = this.head;
      if (this.size == 1)
        this.head = this.tail = null;
      else {
        Node nextNode = this.head.next;
        nextNode.prev = null;
        node.next = null;

        this.head = nextNode;
      }

      this.size--;
      return node;
    }

    public int removeFirst() {
      if (ListIsEmptyException())
        return -1;
      Node node = removeFirstNode();
      return node.data;
    }

    private Node removeLastNode() {
      Node node = this.tail;
      if (this.size == 1)
        this.head = this.tail = null;
      else {
        Node prevNode = this.tail.prev;
        prevNode.next = null;
        node.prev = null;

        this.tail = prevNode;
      }

      this.size--;
      return node;
    }

    public int removeLast() {
      if (ListIsEmptyException())
        return -1;
      Node node = removeLastNode();
      return node.data;
    }

    // getFunctions======================================

    public int getFirst() {
      if (ListIsEmptyException())
        return -1;

      return this.head.data;
    }

    public int getLast() {
      if (ListIsEmptyException())
        return -1;

      return this.tail.data;
    }

    private Node getNodeAt(int index) {
      Node curr = this.head;
      while (index-- > 0)
        curr = curr.next;

      return curr;
    }

    public int getAt(int index) {
      if (ListIsEmptyException())
        return -1;
      else if (indexIsInvalidException(index, 0, this.size - 1))
        return -1;

      Node node = getNodeAt(index);
      return node.data;
    }

  }

  public static void main(String[] args) {
    Scanner scn = new Scanner(System.in);
    DoublyLinkedList dll = new DoublyLinkedList();

    String str = scn.nextLine();
    while (!str.equals("stop")) {
      String[] s = str.split(" ");
      if (s[0].equals("addFirst"))
        dll.addFirst(Integer.parseInt(s[1]));
      else if (s[0].equals("addLast"))
        dll.addLast(Integer.parseInt(s[1]));
      else if (s[0].equals("removeFirst"))
        System.out.println(dll.removeFirst());
      else if (s[0].equals("removeLast"))
        System.out.println(dll.removeLast());
      else if (s[0].equals("getFirst"))
        System.out.println(dll.getFirst());
      else if (s[0].equals("getLast"))
        System.out.println(dll.getLast());
      else if (s[0].equals("size"))
        System.out.println(dll.size());
      else if (s[0].equals("isEmpty"))
        System.out.println(dll.isEmpty());
      else if (s[0].equals("getAt"))
        System.out.println(dll.getAt(Integer.parseInt(s[1])));

      str = scn.nextLine();
    }

    System.out.println(dll);
  }
}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Add At In Doubly Linkedlist</span>
import java.util.*;

class Main {

  public static class DoublyLinkedList {
    private class Node {
      int data = 0;
      Node prev = null;
      Node next = null;

      Node(int data) {
        this.data = data;
      }

    }

    private Node head = null;
    private Node tail = null;
    private int size = 0;

    public String toString() {
      StringBuilder sb = new StringBuilder();
      Node curr = this.head;
      sb.append("[");
      while (curr != null) {
        sb.append(curr.data);
        if (curr.next != null)
          sb.append(", ");
        curr = curr.next;
      }
      sb.append("]");

      return sb.toString();
    }

    // Exceptions========================================

    private boolean ListIsEmptyException() {
      if (this.size == 0) {
        System.out.print("ListIsEmpty: ");
        return true;
      }
      return false;
    }

    private boolean indexIsInvalidException(int index, int leftRange, int rightRange) {
      if (index < leftRange || index > rightRange) {
        System.out.print("IndexIsInValid: ");
        return true;
      }
      return false;
    }

    // BasicFunctions======================================

    public int size() {
      return this.size;
    }

    public boolean isEmpty() {
      return this.size == 0;
    }

    // AddFunctions======================================

    private void addFirstNode(Node node) {
      if (this.size == 0)
        this.head = this.tail = node;
      else {
        node.next = this.head;
        this.head.prev = node;
        this.head = node;
      }
      this.size++;
    }

    public void addFirst(int val) {
      Node node = new Node(val);
      addFirstNode(node);
    }

    private void addLastNode(Node node) {
      if (this.size == 0)
        this.head = this.tail = node;
      else {
        this.tail.next = node;
        node.prev = this.tail;
        this.tail = node;
      }
      this.size++;
    }

    public void addLast(int val) {
      Node node = new Node(val);
      addLastNode(node);
    }

    private void addNodeAt(int index, Node node) {
      if (index == 0)
        addFirstNode(node);
      else if (index == this.size)
        addLastNode(node);
      else {
        Node forw = getNodeAt(index);
        Node prev = forw.prev;

        prev.next = node;
        node.prev = prev;

        node.next = forw;
        forw.prev = node;

        this.size++;
      }
    }

    public void addAt(int index, int data) {
      if (indexIsInvalidException(index, 0, this.size))
        System.out.println(-1);
      else {
        Node node = new Node(data);
        addNodeAt(index, node);
      }
    }

    // RemoveFunctions======================================

    private Node removeFirstNode() {
      Node node = this.head;
      if (this.size == 1)
        this.head = this.tail = null;
      else {
        Node nextNode = this.head.next;
        nextNode.prev = null;
        node.next = null;

        this.head = nextNode;
      }

      this.size--;
      return node;
    }

    public int removeFirst() {
      if (ListIsEmptyException())
        return -1;
      Node node = removeFirstNode();
      return node.data;
    }

    private Node removeLastNode() {
      Node node = this.tail;
      if (this.size == 1)
        this.head = this.tail = null;
      else {
        Node prevNode = this.tail.prev;
        prevNode.next = null;
        node.prev = null;

        this.tail = prevNode;
      }

      this.size--;
      return node;
    }

    public int removeLast() {
      if (ListIsEmptyException())
        return -1;
      Node node = removeLastNode();
      return node.data;
    }

    // getFunctions======================================

    public int getFirst() {
      if (ListIsEmptyException())
        return -1;

      return this.head.data;
    }

    public int getLast() {
      if (ListIsEmptyException())
        return -1;

      return this.tail.data;
    }

    private Node getNodeAt(int index) {
      Node curr = this.head;
      while (index-- > 0)
        curr = curr.next;

      return curr;
    }

    public int getAt(int index) {
      if (ListIsEmptyException())
        return -1;
      else if (indexIsInvalidException(index, 0, this.size - 1))
        return -1;

      Node node = getNodeAt(index);
      return node.data;
    }

  }

  public static void main(String[] args) {
    Scanner scn = new Scanner(System.in);
    DoublyLinkedList dll = new DoublyLinkedList();

    String str = scn.nextLine();
    while (!str.equals("stop")) {
      String[] s = str.split(" ");
      if (s[0].equals("addFirst"))
        dll.addFirst(Integer.parseInt(s[1]));
      else if (s[0].equals("addLast"))
        dll.addLast(Integer.parseInt(s[1]));
      else if (s[0].equals("removeFirst"))
        System.out.println(dll.removeFirst());
      else if (s[0].equals("removeLast"))
        System.out.println(dll.removeLast());
      else if (s[0].equals("getFirst"))
        System.out.println(dll.getFirst());
      else if (s[0].equals("getLast"))
        System.out.println(dll.getLast());
      else if (s[0].equals("size"))
        System.out.println(dll.size());
      else if (s[0].equals("isEmpty"))
        System.out.println(dll.isEmpty());
      else if (s[0].equals("getAt"))
        System.out.println(dll.getAt(Integer.parseInt(s[1])));
      else if (s[0].equals("addAt")) {
        dll.addAt(Integer.parseInt(s[1]), Integer.parseInt(s[2]));
      }

      str = scn.nextLine();
    }

    System.out.println(dll);
  }
}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Remove At In Doubly Linkedlist</span>
import java.util.*;

class Main {

  public static class DoublyLinkedList {
    private class Node {
      int data = 0;
      Node prev = null;
      Node next = null;

      Node(int data) {
        this.data = data;
      }

    }

    private Node head = null;
    private Node tail = null;
    private int size = 0;

    public String toString() {
      StringBuilder sb = new StringBuilder();
      Node curr = this.head;
      sb.append("[");
      while (curr != null) {
        sb.append(curr.data);
        if (curr.next != null)
          sb.append(", ");
        curr = curr.next;
      }
      sb.append("]");

      return sb.toString();
    }

    // Exceptions========================================

    private boolean ListIsEmptyException() {
      if (this.size == 0) {
        System.out.print("ListIsEmpty: ");
        return true;
      }
      return false;
    }

    private boolean indexIsInvalidException(int index, int leftRange, int rightRange) {
      if (index < leftRange || index > rightRange) {
        System.out.print("IndexIsInValid: ");
        return true;
      }
      return false;
    }

    // BasicFunctions======================================

    public int size() {
      return this.size;
    }

    public boolean isEmpty() {
      return this.size == 0;
    }

    // AddFunctions======================================

    private void addFirstNode(Node node) {
      if (this.size == 0)
        this.head = this.tail = node;
      else {
        node.next = this.head;
        this.head.prev = node;
        this.head = node;
      }
      this.size++;
    }

    public void addFirst(int val) {
      Node node = new Node(val);
      addFirstNode(node);
    }

    private void addLastNode(Node node) {
      if (this.size == 0)
        this.head = this.tail = node;
      else {
        this.tail.next = node;
        node.prev = this.tail;
        this.tail = node;
      }
      this.size++;
    }

    public void addLast(int val) {
      Node node = new Node(val);
      addLastNode(node);
    }

    private void addNodeAt(int index, Node node) {
      if (index == 0)
        addFirstNode(node);
      else if (index == this.size)
        addLastNode(node);
      else {
        Node forw = getNodeAt(index);
        Node prev = forw.prev;

        prev.next = node;
        node.prev = prev;

        node.next = forw;
        forw.prev = node;

        this.size++;
      }
    }

    public void addAt(int index, int data) {
      if (indexIsInvalidException(index, 0, this.size))
        System.out.println(-1);
      else {
        Node node = new Node(data);
        addNodeAt(index, node);
      }
    }

    // RemoveFunctions======================================

    private Node removeFirstNode() {
      Node node = this.head;
      if (this.size == 1)
        this.head = this.tail = null;
      else {
        Node nextNode = this.head.next;
        nextNode.prev = null;
        node.next = null;

        this.head = nextNode;
      }

      this.size--;
      return node;
    }

    public int removeFirst() {
      if (ListIsEmptyException())
        return -1;
      Node node = removeFirstNode();
      return node.data;
    }

    private Node removeLastNode() {
      Node node = this.tail;
      if (this.size == 1)
        this.head = this.tail = null;
      else {
        Node prevNode = this.tail.prev;
        prevNode.next = null;
        node.prev = null;

        this.tail = prevNode;
      }

      this.size--;
      return node;
    }

    public int removeLast() {
      if (ListIsEmptyException())
        return -1;
      Node node = removeLastNode();
      return node.data;
    }

    private Node removeAtNode(int index) {
      if (index == 0)
        return removeFirstNode();
      else if (index == this.size - 1)
        return removeLastNode();
      else {
        Node node = getNodeAt(index);
        Node prev = node.prev;
        Node forw = node.next;

        prev.next = forw;
        forw.prev = prev;

        node.next = null;
        node.prev = null;

        this.size--;
        return node;
      }
    }

    public int removeAt(int index) {
      if (ListIsEmptyException())
        return -1;
      if (indexIsInvalidException(index, 0, this.size - 1))
        return -1;

      Node node = removeAtNode(index);
      return node.data;
    }

    // getFunctions======================================

    public int getFirst() {
      if (ListIsEmptyException())
        return -1;

      return this.head.data;
    }

    public int getLast() {
      if (ListIsEmptyException())
        return -1;

      return this.tail.data;
    }

    private Node getNodeAt(int index) {
      Node curr = this.head;
      while (index-- > 0)
        curr = curr.next;

      return curr;
    }

    public int getAt(int index) {
      if (ListIsEmptyException())
        return -1;
      else if (indexIsInvalidException(index, 0, this.size - 1))
        return -1;

      Node node = getNodeAt(index);
      return node.data;
    }

  }

  public static void main(String[] args) {
    Scanner scn = new Scanner(System.in);
    DoublyLinkedList dll = new DoublyLinkedList();

    String str = scn.nextLine();
    while (!str.equals("stop")) {
      String[] s = str.split(" ");
      if (s[0].equals("addFirst"))
        dll.addFirst(Integer.parseInt(s[1]));
      else if (s[0].equals("addLast"))
        dll.addLast(Integer.parseInt(s[1]));
      else if (s[0].equals("removeFirst"))
        System.out.println(dll.removeFirst());
      else if (s[0].equals("removeLast"))
        System.out.println(dll.removeLast());
      else if (s[0].equals("getFirst"))
        System.out.println(dll.getFirst());
      else if (s[0].equals("getLast"))
        System.out.println(dll.getLast());
      else if (s[0].equals("size"))
        System.out.println(dll.size());
      else if (s[0].equals("isEmpty"))
        System.out.println(dll.isEmpty());
      else if (s[0].equals("getAt"))
        System.out.println(dll.getAt(Integer.parseInt(s[1])));
      else if (s[0].equals("addAt"))
        dll.addAt(Integer.parseInt(s[1]), Integer.parseInt(s[2]));
      else if (s[0].equals("removeAt"))
        dll.removeAt(Integer.parseInt(s[1]));

      str = scn.nextLine();
    }

    System.out.println(dll);
  }
}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Add Before In Doubly Linkedlist</span>
import java.util.*;

class Main {

  public static class DoublyLinkedList {
    private class Node {
      int data = 0;
      Node prev = null;
      Node next = null;

      Node(int data) {
        this.data = data;
      }

    }

    private Node head = null;
    private Node tail = null;
    private int size = 0;

    public String toString() {
      StringBuilder sb = new StringBuilder();
      Node curr = this.head;
      sb.append("[");
      while (curr != null) {
        sb.append(curr.data);
        if (curr.next != null)
          sb.append(", ");
        curr = curr.next;
      }
      sb.append("]");

      return sb.toString();
    }

    // Exceptions========================================

    private boolean ListIsEmptyException() {
      if (this.size == 0) {
        System.out.print("ListIsEmpty: ");
        return true;
      }
      return false;
    }

    private boolean indexIsInvalidException(int index, int leftRange, int rightRange) {
      if (index < leftRange || index > rightRange) {
        System.out.print("IndexIsInValid: ");
        return true;
      }
      return false;
    }

    // BasicFunctions======================================

    public int size() {
      return this.size;
    }

    public boolean isEmpty() {
      return this.size == 0;
    }

    // AddFunctions======================================

    private void addFirstNode(Node node) {
      if (this.size == 0)
        this.head = this.tail = node;
      else {
        node.next = this.head;
        this.head.prev = node;
        this.head = node;
      }
      this.size++;
    }

    public void addFirst(int val) {
      Node node = new Node(val);
      addFirstNode(node);
    }

    private void addLastNode(Node node) {
      if (this.size == 0)
        this.head = this.tail = node;
      else {
        this.tail.next = node;
        node.prev = this.tail;
        this.tail = node;
      }
      this.size++;
    }

    public void addLast(int val) {
      Node node = new Node(val);
      addLastNode(node);
    }

    private void addNodeAt(int index, Node node) {
      if (index == 0)
        addFirstNode(node);
      else if (index == this.size)
        addLastNode(node);
      else {
        Node forw = getNodeAt(index);
        Node prev = forw.prev;

        prev.next = node;
        node.prev = prev;

        node.next = forw;
        forw.prev = node;

        this.size++;
      }
    }

    public void addAt(int index, int data) {
      if (indexIsInvalidException(index, 0, this.size))
        System.out.println(-1);
      else {
        Node node = new Node(data);
        addNodeAt(index, node);
      }
    }

    public void addBefore(Node refNode, int data) {
      Node node = new Node(data);
      Node prev = refNode.prev;

      if (prev == null) {
        node.next = refNode;
        refNode.prev = node;
        this.head = node;
      } else {
        prev.next = node;
        node.prev = prev;

        node.next = refNode;
        refNode.prev = node;
      }

      this.size++;
    }

    public void addBefore(int idx, int data) {
      Node node = getNodeAt(idx);
      addBefore(node, data);
    }

    // RemoveFunctions======================================

    private Node removeFirstNode() {
      Node node = this.head;
      if (this.size == 1)
        this.head = this.tail = null;
      else {
        Node nextNode = this.head.next;
        nextNode.prev = null;
        node.next = null;

        this.head = nextNode;
      }

      this.size--;
      return node;
    }

    public int removeFirst() {
      if (ListIsEmptyException())
        return -1;
      Node node = removeFirstNode();
      return node.data;
    }

    private Node removeLastNode() {
      Node node = this.tail;
      if (this.size == 1)
        this.head = this.tail = null;
      else {
        Node prevNode = this.tail.prev;
        prevNode.next = null;
        node.prev = null;

        this.tail = prevNode;
      }

      this.size--;
      return node;
    }

    public int removeLast() {
      if (ListIsEmptyException())
        return -1;
      Node node = removeLastNode();
      return node.data;
    }

    private Node removeAtNode(int index) {
      if (index == 0)
        return removeFirstNode();
      else if (index == this.size - 1)
        return removeLastNode();
      else {
        Node node = getNodeAt(index);
        Node prev = node.prev;
        Node forw = node.next;

        prev.next = forw;
        forw.prev = prev;

        node.next = null;
        node.prev = null;

        this.size--;
        return node;
      }
    }

    public int removeAt(int index) {
      if (ListIsEmptyException())
        return -1;
      if (indexIsInvalidException(index, 0, this.size - 1))
        return -1;

      Node node = removeAtNode(index);
      return node.data;
    }

    // getFunctions======================================

    public int getFirst() {
      if (ListIsEmptyException())
        return -1;

      return this.head.data;
    }

    public int getLast() {
      if (ListIsEmptyException())
        return -1;

      return this.tail.data;
    }

    private Node getNodeAt(int index) {
      Node curr = this.head;
      while (index-- > 0)
        curr = curr.next;

      return curr;
    }

    public int getAt(int index) {
      if (ListIsEmptyException())
        return -1;
      else if (indexIsInvalidException(index, 0, this.size - 1))
        return -1;

      Node node = getNodeAt(index);
      return node.data;
    }

  }

  public static void main(String[] args) {
    Scanner scn = new Scanner(System.in);
    DoublyLinkedList dll = new DoublyLinkedList();

    String str = scn.nextLine();
    while (!str.equals("stop")) {
      String[] s = str.split(" ");
      if (s[0].equals("addFirst"))
        dll.addFirst(Integer.parseInt(s[1]));
      else if (s[0].equals("addLast"))
        dll.addLast(Integer.parseInt(s[1]));
      else if (s[0].equals("removeFirst"))
        System.out.println(dll.removeFirst());
      else if (s[0].equals("removeLast"))
        System.out.println(dll.removeLast());
      else if (s[0].equals("getFirst"))
        System.out.println(dll.getFirst());
      else if (s[0].equals("getLast"))
        System.out.println(dll.getLast());
      else if (s[0].equals("size"))
        System.out.println(dll.size());
      else if (s[0].equals("isEmpty"))
        System.out.println(dll.isEmpty());
      else if (s[0].equals("getAt"))
        System.out.println(dll.getAt(Integer.parseInt(s[1])));
      else if (s[0].equals("addAt"))
        dll.addAt(Integer.parseInt(s[1]), Integer.parseInt(s[2]));
      else if (s[0].equals("removeAt"))
        dll.removeAt(Integer.parseInt(s[1]));
      else if (s[0].equals("addBefore"))
        dll.addBefore(Integer.parseInt(s[1]), Integer.parseInt(s[2]));

      str = scn.nextLine();
    }

    System.out.println(dll);
  }
}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Add After In Doubly Linkedlist</span>
import java.util.*;

class Main {

  public static class DoublyLinkedList {
    private class Node {
      int data = 0;
      Node prev = null;
      Node next = null;

      Node(int data) {
        this.data = data;
      }

    }

    private Node head = null;
    private Node tail = null;
    private int size = 0;

    public String toString() {
      StringBuilder sb = new StringBuilder();
      Node curr = this.head;
      sb.append("[");
      while (curr != null) {
        sb.append(curr.data);
        if (curr.next != null)
          sb.append(", ");
        curr = curr.next;
      }
      sb.append("]");

      return sb.toString();
    }

    // Exceptions========================================

    private boolean ListIsEmptyException() {
      if (this.size == 0) {
        System.out.print("ListIsEmpty: ");
        return true;
      }
      return false;
    }

    private boolean indexIsInvalidException(int index, int leftRange, int rightRange) {
      if (index < leftRange || index > rightRange) {
        System.out.print("IndexIsInValid: ");
        return true;
      }
      return false;
    }

    // BasicFunctions======================================

    public int size() {
      return this.size;
    }

    public boolean isEmpty() {
      return this.size == 0;
    }

    // AddFunctions======================================

    private void addFirstNode(Node node) {
      if (this.size == 0)
        this.head = this.tail = node;
      else {
        node.next = this.head;
        this.head.prev = node;
        this.head = node;
      }
      this.size++;
    }

    public void addFirst(int val) {
      Node node = new Node(val);
      addFirstNode(node);
    }

    private void addLastNode(Node node) {
      if (this.size == 0)
        this.head = this.tail = node;
      else {
        this.tail.next = node;
        node.prev = this.tail;
        this.tail = node;
      }
      this.size++;
    }

    public void addLast(int val) {
      Node node = new Node(val);
      addLastNode(node);
    }

    private void addNodeAt(int index, Node node) {
      if (index == 0)
        addFirstNode(node);
      else if (index == this.size)
        addLastNode(node);
      else {
        Node forw = getNodeAt(index);
        Node prev = forw.prev;

        prev.next = node;
        node.prev = prev;

        node.next = forw;
        forw.prev = node;

        this.size++;
      }
    }

    public void addAt(int index, int data) {
      if (indexIsInvalidException(index, 0, this.size))
        System.out.println(-1);
      else {
        Node node = new Node(data);
        addNodeAt(index, node);
      }
    }

    public void addBefore(Node refNode, int data) {
      Node node = new Node(data);
      Node prev = refNode.prev;

      if (prev == null) {
        node.next = refNode;
        refNode.prev = node;
        this.head = node;
      } else {
        prev.next = node;
        node.prev = prev;

        node.next = refNode;
        refNode.prev = node;
      }

      this.size++;
    }

    public void addBefore(int idx, int data) {
      Node node = getNodeAt(idx);
      addBefore(node, data);
    }

    public void addAfter(Node refNode, int data) {
      Node node = new Node(data);
      Node forw = refNode.next;

      if (forw == null) {
        refNode.next = node;
        node.prev = refNode;
        this.tail = node;
      } else {
        forw.prev = node;
        node.next = forw;

        node.prev = refNode;
        refNode.next = node;
      }

      this.size++;
    }

    public void addAfter(int idx, int data) {
      Node node = getNodeAt(idx);
      addAfter(node, data);
    }

    // RemoveFunctions======================================

    private Node removeFirstNode() {
      Node node = this.head;
      if (this.size == 1)
        this.head = this.tail = null;
      else {
        Node nextNode = this.head.next;
        nextNode.prev = null;
        node.next = null;

        this.head = nextNode;
      }

      this.size--;
      return node;
    }

    public int removeFirst() {
      if (ListIsEmptyException())
        return -1;
      Node node = removeFirstNode();
      return node.data;
    }

    private Node removeLastNode() {
      Node node = this.tail;
      if (this.size == 1)
        this.head = this.tail = null;
      else {
        Node prevNode = this.tail.prev;
        prevNode.next = null;
        node.prev = null;

        this.tail = prevNode;
      }

      this.size--;
      return node;
    }

    public int removeLast() {
      if (ListIsEmptyException())
        return -1;
      Node node = removeLastNode();
      return node.data;
    }

    private Node removeAtNode(int index) {
      if (index == 0)
        return removeFirstNode();
      else if (index == this.size - 1)
        return removeLastNode();
      else {
        Node node = getNodeAt(index);
        Node prev = node.prev;
        Node forw = node.next;

        prev.next = forw;
        forw.prev = prev;

        node.next = null;
        node.prev = null;

        this.size--;
        return node;
      }
    }

    public int removeAt(int index) {
      if (ListIsEmptyException())
        return -1;
      if (indexIsInvalidException(index, 0, this.size - 1))
        return -1;

      Node node = removeAtNode(index);
      return node.data;
    }

    // getFunctions======================================

    public int getFirst() {
      if (ListIsEmptyException())
        return -1;

      return this.head.data;
    }

    public int getLast() {
      if (ListIsEmptyException())
        return -1;

      return this.tail.data;
    }

    private Node getNodeAt(int index) {
      Node curr = this.head;
      while (index-- > 0)
        curr = curr.next;

      return curr;
    }

    public int getAt(int index) {
      if (ListIsEmptyException())
        return -1;
      else if (indexIsInvalidException(index, 0, this.size - 1))
        return -1;

      Node node = getNodeAt(index);
      return node.data;
    }

  }

  public static void main(String[] args) {
    Scanner scn = new Scanner(System.in);
    DoublyLinkedList dll = new DoublyLinkedList();

    String str = scn.nextLine();
    while (!str.equals("stop")) {
      String[] s = str.split(" ");
      if (s[0].equals("addFirst"))
        dll.addFirst(Integer.parseInt(s[1]));
      else if (s[0].equals("addLast"))
        dll.addLast(Integer.parseInt(s[1]));
      else if (s[0].equals("removeFirst"))
        System.out.println(dll.removeFirst());
      else if (s[0].equals("removeLast"))
        System.out.println(dll.removeLast());
      else if (s[0].equals("getFirst"))
        System.out.println(dll.getFirst());
      else if (s[0].equals("getLast"))
        System.out.println(dll.getLast());
      else if (s[0].equals("size"))
        System.out.println(dll.size());
      else if (s[0].equals("isEmpty"))
        System.out.println(dll.isEmpty());
      else if (s[0].equals("getAt"))
        System.out.println(dll.getAt(Integer.parseInt(s[1])));
      else if (s[0].equals("addAt"))
        dll.addAt(Integer.parseInt(s[1]), Integer.parseInt(s[2]));
      else if (s[0].equals("removeAt"))
        dll.removeAt(Integer.parseInt(s[1]));
      else if (s[0].equals("addBefore"))
        dll.addBefore(Integer.parseInt(s[1]), Integer.parseInt(s[2]));
      else if (s[0].equals("addAfter"))
        dll.addAfter(Integer.parseInt(s[1]), Integer.parseInt(s[2]));

      str = scn.nextLine();
    }

    System.out.println(dll);
  }
}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Remove After In Doubly Linkedlist</span>
import java.util.*;

class Main {

  public static class DoublyLinkedList {
    private class Node {
      int data = 0;
      Node prev = null;
      Node next = null;

      Node(int data) {
        this.data = data;
      }

    }

    private Node head = null;
    private Node tail = null;
    private int size = 0;

    public String toString() {
      StringBuilder sb = new StringBuilder();
      Node curr = this.head;
      sb.append("[");
      while (curr != null) {
        sb.append(curr.data);
        if (curr.next != null)
          sb.append(", ");
        curr = curr.next;
      }
      sb.append("]");

      return sb.toString();
    }

    // Exceptions========================================

    private boolean ListIsEmptyException() {
      if (this.size == 0) {
        System.out.print("ListIsEmpty: ");
        return true;
      }
      return false;
    }

    private boolean indexIsInvalidException(int index, int leftRange, int rightRange) {
      if (index < leftRange || index > rightRange) {
        System.out.print("IndexIsInValid: ");
        return true;
      }
      return false;
    }

    // BasicFunctions======================================

    public int size() {
      return this.size;
    }

    public boolean isEmpty() {
      return this.size == 0;
    }

    // AddFunctions======================================

    private void addFirstNode(Node node) {
      if (this.size == 0)
        this.head = this.tail = node;
      else {
        node.next = this.head;
        this.head.prev = node;
        this.head = node;
      }
      this.size++;
    }

    public void addFirst(int val) {
      Node node = new Node(val);
      addFirstNode(node);
    }

    private void addLastNode(Node node) {
      if (this.size == 0)
        this.head = this.tail = node;
      else {
        this.tail.next = node;
        node.prev = this.tail;
        this.tail = node;
      }
      this.size++;
    }

    public void addLast(int val) {
      Node node = new Node(val);
      addLastNode(node);
    }

    private void addNodeAt(int index, Node node) {
      if (index == 0)
        addFirstNode(node);
      else if (index == this.size)
        addLastNode(node);
      else {
        Node forw = getNodeAt(index);
        Node prev = forw.prev;

        prev.next = node;
        node.prev = prev;

        node.next = forw;
        forw.prev = node;

        this.size++;
      }
    }

    public void addAt(int index, int data) {
      if (indexIsInvalidException(index, 0, this.size))
        System.out.println(-1);
      else {
        Node node = new Node(data);
        addNodeAt(index, node);
      }
    }

    public void addBefore(Node refNode, int data) {
      Node node = new Node(data);
      Node prev = refNode.prev;

      if (prev == null) {
        node.next = refNode;
        refNode.prev = node;
        this.head = node;
      } else {
        prev.next = node;
        node.prev = prev;

        node.next = refNode;
        refNode.prev = node;
      }

      this.size++;
    }

    public void addBefore(int idx, int data) {
      Node node = getNodeAt(idx);
      addBefore(node, data);
    }

    public void addAfter(Node refNode, int data) {
      Node node = new Node(data);
      Node forw = refNode.next;

      if (forw == null) {
        refNode.next = node;
        node.prev = refNode;
        this.tail = node;
      } else {
        forw.prev = node;
        node.next = forw;

        node.prev = refNode;
        refNode.next = node;
      }

      this.size++;
    }

    public void addAfter(int idx, int data) {
      Node node = getNodeAt(idx);
      addAfter(node, data);
    }

    // RemoveFunctions======================================

    private Node removeFirstNode() {
      Node node = this.head;
      if (this.size == 1)
        this.head = this.tail = null;
      else {
        Node nextNode = this.head.next;
        nextNode.prev = null;
        node.next = null;

        this.head = nextNode;
      }

      this.size--;
      return node;
    }

    public int removeFirst() {
      if (ListIsEmptyException())
        return -1;
      Node node = removeFirstNode();
      return node.data;
    }

    private Node removeLastNode() {
      Node node = this.tail;
      if (this.size == 1)
        this.head = this.tail = null;
      else {
        Node prevNode = this.tail.prev;
        prevNode.next = null;
        node.prev = null;

        this.tail = prevNode;
      }

      this.size--;
      return node;
    }

    public int removeLast() {
      if (ListIsEmptyException())
        return -1;
      Node node = removeLastNode();
      return node.data;
    }

    private Node removeAtNode(int index) {
      if (index == 0)
        return removeFirstNode();
      else if (index == this.size - 1)
        return removeLastNode();
      else {
        Node node = getNodeAt(index);
        Node prev = node.prev;
        Node forw = node.next;

        prev.next = forw;
        forw.prev = prev;

        node.next = null;
        node.prev = null;

        this.size--;
        return node;
      }
    }

    public int removeAt(int index) {
      if (ListIsEmptyException())
        return -1;
      if (indexIsInvalidException(index, 0, this.size - 1))
        return -1;

      Node node = removeAtNode(index);
      return node.data;
    }

    private Node removeAfterNode(Node refNode) {
      Node forw = refNode.next;
      if (forw.next == null) {
        refNode.next = null;
        forw.prev = null;

        this.tail = refNode;
      } else {
        refNode.next = forw.next;
        forw.next.prev = refNode;

        forw.next = null;
        forw.prev = null;
      }
      this.size--;
      return forw;
    }

    public int removeAfter(Node refNode) {
      if (refNode.next == null) {
        System.out.print("LocationIsInvalid: ");
        return -1;
      }
      return removeAfterNode(refNode).data;
    }

    public int removeAfter(int idx) {
      Node node = getNodeAt(idx);
      return removeAfter(node);
    }

    // getFunctions======================================

    public int getFirst() {
      if (ListIsEmptyException())
        return -1;

      return this.head.data;
    }

    public int getLast() {
      if (ListIsEmptyException())
        return -1;

      return this.tail.data;
    }

    private Node getNodeAt(int index) {
      Node curr = this.head;
      while (index-- > 0)
        curr = curr.next;

      return curr;
    }

    public int getAt(int index) {
      if (ListIsEmptyException())
        return -1;
      else if (indexIsInvalidException(index, 0, this.size - 1))
        return -1;

      Node node = getNodeAt(index);
      return node.data;
    }

  }

  public static void main(String[] args) {
    Scanner scn = new Scanner(System.in);
    DoublyLinkedList dll = new DoublyLinkedList();

    String str = scn.nextLine();
    while (!str.equals("stop")) {
      String[] s = str.split(" ");
      if (s[0].equals("addFirst"))
        dll.addFirst(Integer.parseInt(s[1]));
      else if (s[0].equals("addLast"))
        dll.addLast(Integer.parseInt(s[1]));
      else if (s[0].equals("removeFirst"))
        System.out.println(dll.removeFirst());
      else if (s[0].equals("removeLast"))
        System.out.println(dll.removeLast());
      else if (s[0].equals("getFirst"))
        System.out.println(dll.getFirst());
      else if (s[0].equals("getLast"))
        System.out.println(dll.getLast());
      else if (s[0].equals("size"))
        System.out.println(dll.size());
      else if (s[0].equals("isEmpty"))
        System.out.println(dll.isEmpty());
      else if (s[0].equals("getAt"))
        System.out.println(dll.getAt(Integer.parseInt(s[1])));
      else if (s[0].equals("addAt"))
        dll.addAt(Integer.parseInt(s[1]), Integer.parseInt(s[2]));
      else if (s[0].equals("removeAt"))
        dll.removeAt(Integer.parseInt(s[1]));
      else if (s[0].equals("addBefore"))
        dll.addBefore(Integer.parseInt(s[1]), Integer.parseInt(s[2]));
      else if (s[0].equals("addAfter"))
        dll.addAfter(Integer.parseInt(s[1]), Integer.parseInt(s[2]));
      else if (s[0].equals("removeAfter"))
        System.out.println(dll.removeAfter(Integer.parseInt(s[1])));

      str = scn.nextLine();
    }

    System.out.println(dll);
  }
}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Remove Before In Doubly Linkedlist</span>
import java.util.*;

class Main {

  public static class DoublyLinkedList {
    private class Node {
      int data = 0;
      Node prev = null;
      Node next = null;

      Node(int data) {
        this.data = data;
      }

    }

    private Node head = null;
    private Node tail = null;
    private int size = 0;

    public String toString() {
      StringBuilder sb = new StringBuilder();
      Node curr = this.head;
      sb.append("[");
      while (curr != null) {
        sb.append(curr.data);
        if (curr.next != null)
          sb.append(", ");
        curr = curr.next;
      }
      sb.append("]");

      return sb.toString();
    }

    // Exceptions========================================

    private boolean ListIsEmptyException() {
      if (this.size == 0) {
        System.out.print("ListIsEmpty: ");
        return true;
      }
      return false;
    }

    private boolean indexIsInvalidException(int index, int leftRange, int rightRange) {
      if (index < leftRange || index > rightRange) {
        System.out.print("IndexIsInValid: ");
        return true;
      }
      return false;
    }

    // BasicFunctions======================================

    public int size() {
      return this.size;
    }

    public boolean isEmpty() {
      return this.size == 0;
    }

    // AddFunctions======================================

    private void addFirstNode(Node node) {
      if (this.size == 0)
        this.head = this.tail = node;
      else {
        node.next = this.head;
        this.head.prev = node;
        this.head = node;
      }
      this.size++;
    }

    public void addFirst(int val) {
      Node node = new Node(val);
      addFirstNode(node);
    }

    private void addLastNode(Node node) {
      if (this.size == 0)
        this.head = this.tail = node;
      else {
        this.tail.next = node;
        node.prev = this.tail;
        this.tail = node;
      }
      this.size++;
    }

    public void addLast(int val) {
      Node node = new Node(val);
      addLastNode(node);
    }

    private void addNodeAt(int index, Node node) {
      if (index == 0)
        addFirstNode(node);
      else if (index == this.size)
        addLastNode(node);
      else {
        Node forw = getNodeAt(index);
        Node prev = forw.prev;

        prev.next = node;
        node.prev = prev;

        node.next = forw;
        forw.prev = node;

        this.size++;
      }
    }

    public void addAt(int index, int data) {
      if (indexIsInvalidException(index, 0, this.size))
        System.out.println(-1);
      else {
        Node node = new Node(data);
        addNodeAt(index, node);
      }
    }

    public void addBefore(Node refNode, int data) {
      Node node = new Node(data);
      Node prev = refNode.prev;

      if (prev == null) {
        node.next = refNode;
        refNode.prev = node;
        this.head = node;
      } else {
        prev.next = node;
        node.prev = prev;

        node.next = refNode;
        refNode.prev = node;
      }

      this.size++;
    }

    public void addBefore(int idx, int data) {
      Node node = getNodeAt(idx);
      addBefore(node, data);
    }

    public void addAfter(Node refNode, int data) {
      Node node = new Node(data);
      Node forw = refNode.next;

      if (forw == null) {
        refNode.next = node;
        node.prev = refNode;
        this.tail = node;
      } else {
        forw.prev = node;
        node.next = forw;

        node.prev = refNode;
        refNode.next = node;
      }

      this.size++;
    }

    public void addAfter(int idx, int data) {
      Node node = getNodeAt(idx);
      addAfter(node, data);
    }

    // RemoveFunctions======================================

    private Node removeFirstNode() {
      Node node = this.head;
      if (this.size == 1)
        this.head = this.tail = null;
      else {
        Node nextNode = this.head.next;
        nextNode.prev = null;
        node.next = null;

        this.head = nextNode;
      }

      this.size--;
      return node;
    }

    public int removeFirst() {
      if (ListIsEmptyException())
        return -1;
      Node node = removeFirstNode();
      return node.data;
    }

    private Node removeLastNode() {
      Node node = this.tail;
      if (this.size == 1)
        this.head = this.tail = null;
      else {
        Node prevNode = this.tail.prev;
        prevNode.next = null;
        node.prev = null;

        this.tail = prevNode;
      }

      this.size--;
      return node;
    }

    public int removeLast() {
      if (ListIsEmptyException())
        return -1;
      Node node = removeLastNode();
      return node.data;
    }

    private Node removeAtNode(int index) {
      if (index == 0)
        return removeFirstNode();
      else if (index == this.size - 1)
        return removeLastNode();
      else {
        Node node = getNodeAt(index);
        Node prev = node.prev;
        Node forw = node.next;

        prev.next = forw;
        forw.prev = prev;

        node.next = null;
        node.prev = null;

        this.size--;
        return node;
      }
    }

    public int removeAt(int index) {
      if (ListIsEmptyException())
        return -1;
      if (indexIsInvalidException(index, 0, this.size - 1))
        return -1;

      Node node = removeAtNode(index);
      return node.data;
    }

    private Node removeAfterNode(Node refNode) {
      Node forw = refNode.next;
      if (forw.next == null) {
        refNode.next = null;
        forw.prev = null;
        this.tail = refNode;
      } else {
        refNode.next = forw.next;
        forw.next.prev = refNode;

        forw.next = null;
        forw.prev = null;
      }
      this.size--;
      return forw;
    }

    public int removeAfter(Node refNode) {
      if (refNode.next == null) {
        System.out.print("LocationIsInvalid: ");
        return -1;
      }
      return removeAfterNode(refNode).data;
    }

    public int removeAfter(int idx) {
      Node node = getNodeAt(idx);
      return removeAfter(node);
    }

    private Node removeBeforeNode(Node refNode) {
      Node prevNode = refNode.prev;
      if (prevNode.prev == null) {
        refNode.prev = null;
        prevNode.next = null;
        this.head = refNode;
      } else {
        refNode.prev = prevNode.prev;
        prevNode.prev.next = refNode;

        prevNode.next = null;
        prevNode.prev = null;
      }
      this.size--;
      return prevNode;
    }

    public int removeBefore(Node refNode) {
      if (refNode.prev == null) {
        System.out.print("LocationIsInvalid: ");
        return -1;
      }
      return removeBeforeNode(refNode).data;
    }

    public int removeBefore(int idx) {
      Node node = getNodeAt(idx);
      return removeBefore(node);
    }

    // getFunctions======================================

    public int getFirst() {
      if (ListIsEmptyException())
        return -1;

      return this.head.data;
    }

    public int getLast() {
      if (ListIsEmptyException())
        return -1;

      return this.tail.data;
    }

    private Node getNodeAt(int index) {
      Node curr = this.head;
      while (index-- > 0)
        curr = curr.next;

      return curr;
    }

    public int getAt(int index) {
      if (ListIsEmptyException())
        return -1;
      else if (indexIsInvalidException(index, 0, this.size - 1))
        return -1;

      Node node = getNodeAt(index);
      return node.data;
    }

  }

  public static void main(String[] args) {
    Scanner scn = new Scanner(System.in);
    DoublyLinkedList dll = new DoublyLinkedList();

    String str = scn.nextLine();
    while (!str.equals("stop")) {
      String[] s = str.split(" ");
      if (s[0].equals("addFirst"))
        dll.addFirst(Integer.parseInt(s[1]));
      else if (s[0].equals("addLast"))
        dll.addLast(Integer.parseInt(s[1]));
      else if (s[0].equals("removeFirst"))
        System.out.println(dll.removeFirst());
      else if (s[0].equals("removeLast"))
        System.out.println(dll.removeLast());
      else if (s[0].equals("getFirst"))
        System.out.println(dll.getFirst());
      else if (s[0].equals("getLast"))
        System.out.println(dll.getLast());
      else if (s[0].equals("size"))
        System.out.println(dll.size());
      else if (s[0].equals("isEmpty"))
        System.out.println(dll.isEmpty());
      else if (s[0].equals("getAt"))
        System.out.println(dll.getAt(Integer.parseInt(s[1])));
      else if (s[0].equals("addAt"))
        dll.addAt(Integer.parseInt(s[1]), Integer.parseInt(s[2]));
      else if (s[0].equals("removeAt"))
        dll.removeAt(Integer.parseInt(s[1]));
      else if (s[0].equals("addBefore"))
        dll.addBefore(Integer.parseInt(s[1]), Integer.parseInt(s[2]));
      else if (s[0].equals("addAfter"))
        dll.addAfter(Integer.parseInt(s[1]), Integer.parseInt(s[2]));
      else if (s[0].equals("removeAfter"))
        System.out.println(dll.removeAfter(Integer.parseInt(s[1])));
      else if (s[0].equals("removeBefore"))
        System.out.println(dll.removeBefore(Integer.parseInt(s[1])));

      str = scn.nextLine();
    }

    System.out.println(dll);
  }
}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Remove Node In Doubly Linkedlist</span>
import java.util.*;

class Main {

  public static class DoublyLinkedList {
    private class Node {
      int data = 0;
      Node prev = null;
      Node next = null;

      Node(int data) {
        this.data = data;
      }

    }

    private Node head = null;
    private Node tail = null;
    private int size = 0;

    public String toString() {
      StringBuilder sb = new StringBuilder();
      Node curr = this.head;
      sb.append("[");
      while (curr != null) {
        sb.append(curr.data);
        if (curr.next != null)
          sb.append(", ");
        curr = curr.next;
      }
      sb.append("]");

      return sb.toString();
    }

    // Exceptions========================================

    private boolean ListIsEmptyException() {
      if (this.size == 0) {
        System.out.print("ListIsEmpty: ");
        return true;
      }
      return false;
    }

    private boolean indexIsInvalidException(int index, int leftRange, int rightRange) {
      if (index < leftRange || index > rightRange) {
        System.out.print("IndexIsInValid: ");
        return true;
      }
      return false;
    }

    // BasicFunctions======================================

    public int size() {
      return this.size;
    }

    public boolean isEmpty() {
      return this.size == 0;
    }

    // AddFunctions======================================

    private void addFirstNode(Node node) {
      if (this.size == 0)
        this.head = this.tail = node;
      else {
        node.next = this.head;
        this.head.prev = node;
        this.head = node;
      }
      this.size++;
    }

    public void addFirst(int val) {
      Node node = new Node(val);
      addFirstNode(node);
    }

    private void addLastNode(Node node) {
      if (this.size == 0)
        this.head = this.tail = node;
      else {
        this.tail.next = node;
        node.prev = this.tail;
        this.tail = node;
      }
      this.size++;
    }

    public void addLast(int val) {
      Node node = new Node(val);
      addLastNode(node);
    }

    private void addNodeAt(int index, Node node) {
      if (index == 0)
        addFirstNode(node);
      else if (index == this.size)
        addLastNode(node);
      else {
        Node forw = getNodeAt(index);
        Node prev = forw.prev;

        prev.next = node;
        node.prev = prev;

        node.next = forw;
        forw.prev = node;

        this.size++;
      }
    }

    public void addAt(int index, int data) {
      if (indexIsInvalidException(index, 0, this.size))
        System.out.println(-1);
      else {
        Node node = new Node(data);
        addNodeAt(index, node);
      }
    }

    public void addBefore(Node refNode, int data) {
      Node node = new Node(data);
      Node prev = refNode.prev;

      if (prev == null) {
        node.next = refNode;
        refNode.prev = node;
        this.head = node;
      } else {
        prev.next = node;
        node.prev = prev;

        node.next = refNode;
        refNode.prev = node;
      }

      this.size++;
    }

    public void addBefore(int idx, int data) {
      Node node = getNodeAt(idx);
      addBefore(node, data);
    }

    public void addAfter(Node refNode, int data) {
      Node node = new Node(data);
      Node forw = refNode.next;

      if (forw == null) {
        refNode.next = node;
        node.prev = refNode;
        this.tail = node;
      } else {
        forw.prev = node;
        node.next = forw;

        node.prev = refNode;
        refNode.next = node;
      }

      this.size++;
    }

    public void addAfter(int idx, int data) {
      Node node = getNodeAt(idx);
      addAfter(node, data);
    }

    // RemoveFunctions======================================

    private Node removeFirstNode() {
      Node node = this.head;
      if (this.size == 1)
        this.head = this.tail = null;
      else {
        Node nextNode = this.head.next;
        nextNode.prev = null;
        node.next = null;

        this.head = nextNode;
      }

      this.size--;
      return node;
    }

    public int removeFirst() {
      if (ListIsEmptyException())
        return -1;
      Node node = removeFirstNode();
      return node.data;
    }

    private Node removeLastNode() {
      Node node = this.tail;
      if (this.size == 1)
        this.head = this.tail = null;
      else {
        Node prevNode = this.tail.prev;
        prevNode.next = null;
        node.prev = null;

        this.tail = prevNode;
      }

      this.size--;
      return node;
    }

    public int removeLast() {
      if (ListIsEmptyException())
        return -1;
      Node node = removeLastNode();
      return node.data;
    }

    private Node removeAtNode(int index) {
      if (index == 0)
        return removeFirstNode();
      else if (index == this.size - 1)
        return removeLastNode();
      else {
        Node node = getNodeAt(index);
        Node prev = node.prev;
        Node forw = node.next;

        prev.next = forw;
        forw.prev = prev;

        node.next = null;
        node.prev = null;

        this.size--;
        return node;
      }
    }

    public int removeAt(int index) {
      if (ListIsEmptyException())
        return -1;
      if (indexIsInvalidException(index, 0, this.size - 1))
        return -1;

      Node node = removeAtNode(index);
      return node.data;
    }

    private Node removeAfterNode(Node refNode) {
      Node forw = refNode.next;
      if (forw.next == null) {
        refNode.next = null;
        forw.prev = null;
        this.tail = refNode;
      } else {
        refNode.next = forw.next;
        forw.next.prev = refNode;

        forw.next = null;
        forw.prev = null;
      }
      this.size--;
      return forw;
    }

    public int removeAfter(Node refNode) {
      if (refNode.next == null) {
        System.out.println("LocationIsInvalid: ");
        return -1;
      }
      return removeAfterNode(refNode).data;
    }

    public int removeAfter(int idx) {
      Node node = getNodeAt(idx);
      return removeAfter(node);
    }

    private Node removeBeforeNode(Node refNode) {
      Node prevNode = refNode.prev;
      if (prevNode.prev == null) {
        refNode.prev = null;
        prevNode.next = null;
        this.head = refNode;
      } else {
        refNode.prev = prevNode.prev;
        prevNode.prev.next = refNode;

        prevNode.next = null;
        prevNode.prev = null;
      }
      this.size--;
      return prevNode;
    }

    public int removeBefore(Node refNode) {
      if (refNode.prev == null) {
        System.out.println("LocationIsInvalid: ");
        return -1;
      }
      return removeBeforeNode(refNode).data;
    }

    public int removeBefore(int idx) {
      Node node = getNodeAt(idx);
      return removeBefore(node);
    }

    public int removeNode(Node refNode) {
        Node prev = refNode.prev;
        Node forw = refNode.next;
        if(this.size == 1)
            this.head = this.tail = null;
        else if(prev == null) 
           this.head = forw;
        else if(forw == null)
           this.tail = prev;
        else{
            prev.next = forw;
            forw.prev = prev;
        }
      
        refNode.prev = refNode.next = this.head.prev = this.tail.next = null;
        this.size--;
        return refNode.data;
    }

    public int removeNode(int idx) {
      Node node = getNodeAt(idx);
      return removeBefore(node);
    }

    // getFunctions======================================

    public int getFirst() {
      if (ListIsEmptyException())
        return -1;

      return this.head.data;
    }

    public int getLast() {
      if (ListIsEmptyException())
        return -1;

      return this.tail.data;
    }

    private Node getNodeAt(int index) {
      Node curr = this.head;
      while (index-- > 0)
        curr = curr.next;

      return curr;
    }

    public int getAt(int index) {
      if (ListIsEmptyException())
        return -1;
      else if (indexIsInvalidException(index, 0, this.size - 1))
        return -1;

      Node node = getNodeAt(index);
      return node.data;
    }

  }

  public static void main(String[] args) {
    Scanner scn = new Scanner(System.in);
    DoublyLinkedList dll = new DoublyLinkedList();

    String str = scn.nextLine();
    while (!str.equals("stop")) {
      String[] s = str.split(" ");
      if (s[0].equals("addFirst"))
        dll.addFirst(Integer.parseInt(s[1]));
      else if (s[0].equals("addLast"))
        dll.addLast(Integer.parseInt(s[1]));
      else if (s[0].equals("removeFirst"))
        System.out.println(dll.removeFirst());
      else if (s[0].equals("removeLast"))
        System.out.println(dll.removeLast());
      else if (s[0].equals("getFirst"))
        System.out.println(dll.getFirst());
      else if (s[0].equals("getLast"))
        System.out.println(dll.getLast());
      else if (s[0].equals("size"))
        System.out.println(dll.size());
      else if (s[0].equals("isEmpty"))
        System.out.println(dll.isEmpty());
      else if (s[0].equals("getAt"))
        System.out.println(dll.getAt(Integer.parseInt(s[1])));
      else if (s[0].equals("addAt"))
        dll.addAt(Integer.parseInt(s[1]), Integer.parseInt(s[2]));
      else if (s[0].equals("removeAt"))
        dll.removeAt(Integer.parseInt(s[1]));
      else if (s[0].equals("addBefore"))
        dll.addBefore(Integer.parseInt(s[1]), Integer.parseInt(s[2]));
      else if (s[0].equals("addAfter"))
        dll.addAfter(Integer.parseInt(s[1]), Integer.parseInt(s[2]));
      else if (s[0].equals("removeAfter"))
        System.out.println(dll.removeAfter(Integer.parseInt(s[1])));
      else if (s[0].equals("removeBefore"))
        System.out.println(dll.removeBefore(Integer.parseInt(s[1])));
      else if (s[0].equals("removeNode"))
        System.out.println(dll.removeNode(Integer.parseInt(s[1])));


      str = scn.nextLine();
    }

    System.out.println(dll);
  }
}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Display Forward And Backward In Doubly Linkedlist</span>
import java.util.*;

class Main {

  public static class DoublyLinkedList {
    private class Node {
      int data = 0;
      Node prev = null;
      Node next = null;

      Node(int data) {
        this.data = data;
      }

    }

    private Node head = null;
    private Node tail = null;
    private int size = 0;

    public String toString() {
      StringBuilder sb = new StringBuilder();
      Node curr = this.head;
      sb.append("[");
      while (curr != null) {
        sb.append(curr.data);
        if (curr.next != null)
          sb.append(", ");
        curr = curr.next;
      }
      sb.append("]");

      return sb.toString();
    }

    // Exceptions========================================

    private boolean ListIsEmptyException() {
      if (this.size == 0) {
        System.out.print("ListIsEmpty: ");
        return true;
      }
      return false;
    }

    private boolean indexIsInvalidException(int index, int leftRange, int rightRange) {
      if (index < leftRange || index > rightRange) {
        System.out.print("IndexIsInValid: ");
        return true;
      }
      return false;
    }

    // BasicFunctions======================================

    public int size() {
      return this.size;
    }

    public boolean isEmpty() {
      return this.size == 0;
    }

    public void displayForw() {
      StringBuilder sb = new StringBuilder();
      Node curr = this.head;
      sb.append("[");
      while (curr != null) {
        sb.append(curr.data);
        if (curr.next != null)
          sb.append(", ");
        curr = curr.next;
      }
      sb.append("]");

      System.out.println(sb.toString());
    }

    public void displayBack() {
      StringBuilder sb = new StringBuilder();
      Node curr = this.tail;
      sb.append("[");
      while (curr != null) {
        sb.append(curr.data);
        if (curr.prev != null)
          sb.append(", ");
        curr = curr.prev;
      }
      sb.append("]");

      System.out.println(sb.toString());
    }

    // AddFunctions======================================

    private void addFirstNode(Node node) {
      if (this.size == 0)
        this.head = this.tail = node;
      else {
        node.next = this.head;
        this.head.prev = node;
        this.head = node;
      }
      this.size++;
    }

    public void addFirst(int val) {
      Node node = new Node(val);
      addFirstNode(node);
    }

    private void addLastNode(Node node) {
      if (this.size == 0)
        this.head = this.tail = node;
      else {
        this.tail.next = node;
        node.prev = this.tail;
        this.tail = node;
      }
      this.size++;
    }

    public void addLast(int val) {
      Node node = new Node(val);
      addLastNode(node);
    }

    private void addNodeAt(int index, Node node) {
      if (index == 0)
        addFirstNode(node);
      else if (index == this.size)
        addLastNode(node);
      else {
        Node forw = getNodeAt(index);
        Node prev = forw.prev;

        prev.next = node;
        node.prev = prev;

        node.next = forw;
        forw.prev = node;

        this.size++;
      }
    }

    public void addAt(int index, int data) {
      if (indexIsInvalidException(index, 0, this.size))
        System.out.println(-1);
      else {
        Node node = new Node(data);
        addNodeAt(index, node);
      }
    }

    public void addBefore(Node refNode, int data) {
      Node node = new Node(data);
      Node prev = refNode.prev;

      if (prev == null) {
        node.next = refNode;
        refNode.prev = node;
        this.head = node;
      } else {
        prev.next = node;
        node.prev = prev;

        node.next = refNode;
        refNode.prev = node;
      }

      this.size++;
    }

    public void addBefore(int idx, int data) {
      Node node = getNodeAt(idx);
      addBefore(node, data);
    }

    public void addAfter(Node refNode, int data) {
      Node node = new Node(data);
      Node forw = refNode.next;

      if (forw == null) {
        refNode.next = node;
        node.prev = refNode;
        this.tail = node;
      } else {
        forw.prev = node;
        node.next = forw;

        node.prev = refNode;
        refNode.next = node;
      }

      this.size++;
    }

    public void addAfter(int idx, int data) {
      Node node = getNodeAt(idx);
      addAfter(node, data);
    }

    // RemoveFunctions======================================

    private Node removeFirstNode() {
      Node node = this.head;
      if (this.size == 1)
        this.head = this.tail = null;
      else {
        Node nextNode = this.head.next;
        nextNode.prev = null;
        node.next = null;

        this.head = nextNode;
      }

      this.size--;
      return node;
    }

    public int removeFirst() {
      if (ListIsEmptyException())
        return -1;
      Node node = removeFirstNode();
      return node.data;
    }

    private Node removeLastNode() {
      Node node = this.tail;
      if (this.size == 1)
        this.head = this.tail = null;
      else {
        Node prevNode = this.tail.prev;
        prevNode.next = null;
        node.prev = null;

        this.tail = prevNode;
      }

      this.size--;
      return node;
    }

    public int removeLast() {
      if (ListIsEmptyException())
        return -1;
      Node node = removeLastNode();
      return node.data;
    }

    private Node removeAtNode(int index) {
      if (index == 0)
        return removeFirstNode();
      else if (index == this.size - 1)
        return removeLastNode();
      else {
        Node node = getNodeAt(index);
        Node prev = node.prev;
        Node forw = node.next;

        prev.next = forw;
        forw.prev = prev;

        node.next = null;
        node.prev = null;

        this.size--;
        return node;
      }
    }

    public int removeAt(int index) {
      if (ListIsEmptyException())
        return -1;
      if (indexIsInvalidException(index, 0, this.size - 1))
        return -1;

      Node node = removeAtNode(index);
      return node.data;
    }

    private Node removeAfterNode(Node refNode) {
      Node forw = refNode.next;
      if (forw.next == null) {
        refNode.next = null;
        forw.prev = null;
        this.tail = refNode;
      } else {
        refNode.next = forw.next;
        forw.next.prev = refNode;

        forw.next = null;
        forw.prev = null;
      }
      this.size--;
      return forw;
    }

    public int removeAfter(Node refNode) {
      if (refNode.next == null) {
        System.out.println("LocationIsInvalid: ");
        return -1;
      }
      return removeAfterNode(refNode).data;
    }

    public int removeAfter(int idx) {
      Node node = getNodeAt(idx);
      return removeAfter(node);
    }

    private Node removeBeforeNode(Node refNode) {
      Node prevNode = refNode.prev;
      if (prevNode.prev == null) {
        refNode.prev = null;
        prevNode.next = null;
        this.head = refNode;
      } else {
        refNode.prev = prevNode.prev;
        prevNode.prev.next = refNode;

        prevNode.next = null;
        prevNode.prev = null;
      }
      this.size--;
      return prevNode;
    }

    public int removeBefore(Node refNode) {
      if (refNode.prev == null) {
        System.out.println("LocationIsInvalid: ");
        return -1;
      }
      return removeBeforeNode(refNode).data;
    }

    public int removeBefore(int idx) {
      Node node = getNodeAt(idx);
      return removeBefore(node);
    }

    public int removeNode(Node refNode) {
      Node prev = refNode.prev;
      Node forw = refNode.next;
      if (this.size == 1)
        this.head = this.tail = null;
      else if (prev == null)
        this.head = forw;
      else if (forw == null)
        this.tail = prev;
      else {
        prev.next = forw;
        forw.prev = prev;
      }

      refNode.prev = refNode.next = this.head.prev = this.tail.next = null;
      this.size--;
      return refNode.data;
    }

    public int removeNode(int idx) {
      Node node = getNodeAt(idx);
      return removeBefore(node);
    }

    // getFunctions======================================

    public int getFirst() {
      if (ListIsEmptyException())
        return -1;

      return this.head.data;
    }

    public int getLast() {
      if (ListIsEmptyException())
        return -1;

      return this.tail.data;
    }

    private Node getNodeAt(int index) {
      Node curr = this.head;
      while (index-- > 0)
        curr = curr.next;

      return curr;
    }

    public int getAt(int index) {
      if (ListIsEmptyException())
        return -1;
      else if (indexIsInvalidException(index, 0, this.size - 1))
        return -1;

      Node node = getNodeAt(index);
      return node.data;
    }

  }

  public static void main(String[] args) {
    Scanner scn = new Scanner(System.in);
    DoublyLinkedList dll = new DoublyLinkedList();

    String str = scn.nextLine();
    while (!str.equals("stop")) {
      String[] s = str.split(" ");
      if (s[0].equals("addFirst"))
        dll.addFirst(Integer.parseInt(s[1]));
      else if (s[0].equals("addLast"))
        dll.addLast(Integer.parseInt(s[1]));
      else if (s[0].equals("removeFirst"))
        System.out.println(dll.removeFirst());
      else if (s[0].equals("removeLast"))
        System.out.println(dll.removeLast());
      else if (s[0].equals("getFirst"))
        System.out.println(dll.getFirst());
      else if (s[0].equals("getLast"))
        System.out.println(dll.getLast());
      else if (s[0].equals("size"))
        System.out.println(dll.size());
      else if (s[0].equals("isEmpty"))
        System.out.println(dll.isEmpty());
      else if (s[0].equals("getAt"))
        System.out.println(dll.getAt(Integer.parseInt(s[1])));
      else if (s[0].equals("addAt"))
        dll.addAt(Integer.parseInt(s[1]), Integer.parseInt(s[2]));
      else if (s[0].equals("removeAt"))
        dll.removeAt(Integer.parseInt(s[1]));
      else if (s[0].equals("addBefore"))
        dll.addBefore(Integer.parseInt(s[1]), Integer.parseInt(s[2]));
      else if (s[0].equals("addAfter"))
        dll.addAfter(Integer.parseInt(s[1]), Integer.parseInt(s[2]));
      else if (s[0].equals("removeAfter"))
        System.out.println(dll.removeAfter(Integer.parseInt(s[1])));
      else if (s[0].equals("removeBefore"))
        System.out.println(dll.removeBefore(Integer.parseInt(s[1])));
      else if (s[0].equals("removeNode"))
        System.out.println(dll.removeNode(Integer.parseInt(s[1])));
      else if (s[0].equals("displayForw"))
        dll.displayForw();
      else if (s[0].equals("displayBack"))
        dll.displayBack();

      str = scn.nextLine();
    }

    System.out.println(dll);
  }
}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Design Lru Chache</span>
import java.util.*;

class Main {

  static class LRUCache {
    private class Node {
      int key, value;
      Node prev, next;

      Node(int key, int value) {
        this.key = key;
        this.value = value;
        this.prev = null;
        this.next = null;
      }
    }

    private HashMap<Integer, Node> map = new HashMap<>();

    private Node head = null;
    private Node tail = null;
    private int capacity = 0;
    private int size = 0;

    public LRUCache(int capacity) {
      this.capacity = capacity;
      this.size = 0;
      this.head = null;
      this.tail = null;
    }

    private void removeNode(Node node) {
      if (this.size == 1)
        this.head = this.tail = null;
      else {
        Node prev = node.prev;
        Node forw = node.next;

        if (prev == null) {
          this.head = forw;
          forw.prev = null;
        } else if (forw == null) {
          this.tail = prev;
          prev.next = null;
        } else {
          forw.prev = prev;
          prev.next = forw;

        }

        node.next = node.prev = null;
      }

      this.size--;
    }

    private void addLast(Node node) {
      if (this.size == 0)
        this.tail = this.head = node;
      else {
        this.tail.next = node;
        node.prev = this.tail;
        this.tail = node;
      }

      this.size++;
    }

    private void makeRecent(Node node) {
      if (node == tail)
        return;

      removeNode(node);
      addLast(node);
    }

    public int get(int key) {
      if (!map.containsKey(key))
        return -1;

      Node node = map.get(key);
      makeRecent(node);

      return node.value;
    }

    public void put(int key, int value) {
      if (map.containsKey(key)) {
        Node node = map.get(key);
        node.value = value;
        makeRecent(node);
      } else8 {
        if (this.size == this.capacity) {
          int rKey = this.head.key;
          removeNode(this.head);
          map.remove(rKey);
        }
        Node node = new Node(key, value);
        addLast(node);
        map.put(key, node);
      }
    }
  }

  public static void main(String[] args) {
    Scanner scn = new Scanner(System.in);
    int n = scn.nextInt(); // no of operations
    // 0 stand for put, 1 stand for get
    int size = scn.nextInt();
    LRUCache lru = new LRUCache(size);

    while (n-- > 0) {
      int op = scn.nextInt();
      if (op == 0)
        lru.put(scn.nextInt(), scn.nextInt());
      else
        System.out.println(lru.get(scn.nextInt()));
    }
  }
}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Stack</span>
<span class="textStyle">STACK</span> 
<span class="textStyle">stack</span>
<span class="textStyle">Next Greater Element To The Right</span>
import java.io.*;
import java.util.*;

public class Main {
  public static void display(int[] a) {
    StringBuilder sb = new StringBuilder();

    for (int val : a) {
      sb.append(val + "\n");
    }
    System.out.println(sb);
  }

  public static void main(String[] args) throws Exception {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

    int n = Integer.parseInt(br.readLine());
    int[] a = new int[n];
    for (int i = 0; i < n; i++) {
      a[i] = Integer.parseInt(br.readLine());
    }

    int[] nge = solve(a);
    display(nge);
  }

  public static int[] solve(int[] arr) {
    int[] nge = new int[arr.length];

    Stack<Integer> st = new Stack<>();

    nge[arr.length - 1] = -1;
    st.push(arr[arr.length - 1]);
    for(int i = arr.length - 2; i >= 0; i--){
      while(st.size() > 0 && arr[i] >= st.peek()){
        st.pop();
      }     
      if(st.size() > 0){
        nge[i] = st.peek();
      } else {
        nge[i] = -1;
      }
      
      st.push(arr[i]);
    }

    return nge;
  }

}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Next Greater Element To The Left</span>

<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Next Greater Element I</span>
import java.io.*;
import java.util.*;

public class Main {
  public static int[] nextGreaterElement(int[] nums, int[] query) {
    int ngr[] = nextGreaterRight(nums);

    HashMap<Integer, Integer> hm = new HashMap<>();

    // nums -> key  ngr -> value
    for (int i = 0; i < nums.length; i++) {
      hm.put(nums[i], ngr[i]);
    }

    int ans[] = new int[query.length];

    for (int i = 0; i < query.length; i++) {
      ans[i] = hm.get(query[i]);
    }

    return ans;
  }

  public static int[] nextGreaterRight(int[] nums) {
    Stack<Integer> st = new Stack<>();

    int ans[] = new int[nums.length];

    for (int i = nums.length - 1; i >= 0; i--) {
      while (st.size() > 0 && st.peek() < nums[i])st.pop();
      ans[i] = st.size() > 0 ? st.peek() : -1;
      st.push(nums[i]);
    }

    return ans;
  }

  public static int[] getArr(String s) {
    String nums[] = s.split(" ");
    int n = nums.length;
    int ar[] = new int[n];
    for (int i = 0; i < n; i++) {
      ar[i] = Integer.parseInt(nums[i]);
    }
    return ar;
  }

  public static void main(String[] args) throws Exception {
    BufferedReader read = new BufferedReader(new InputStreamReader(System.in));

    int query[] = getArr(read.readLine());
    int nums[] = getArr(read.readLine());

    int ans[] = nextGreaterElement(nums, query);

    int n = ans.length;

    System.out.println(n);
    for (int e : ans) {
      System.out.println(e);
    }

  }
}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Next Greater Element II</span>
import java.io.*;
import java.util.*;

public class Main {
    public static int[] nextGreaterElementII(int[] nums) {
        Stack<Integer> st = new Stack<>();
        
        int n = nums.length;
        int ans[] = new int[n];
        
        for(int i=n-1;i>=0;i--){
            
            while(st.size()>0&&nums[i]>st.peek())
                st.pop();
            st.push(nums[i]);
        }
        
        for(int i=n-1;i>=0;i--){
            while(st.size()>0&&st.peek()<=nums[i])st.pop();
            
            if(st.isEmpty())
                ans[i] = -1;
            else ans[i] = st.peek();
            
            st.add(nums[i]);
        }
        return ans;
    }


    public static void main(String[] args) throws Exception {
        BufferedReader read = new BufferedReader(new InputStreamReader(System.in));

        int n = Integer.parseInt(read.readLine());
        int nums[] = new int[n];
        for(int i=0;i< n;i++){
            nums[i] = Integer.parseInt(read.readLine());
        }
        
        int ans[] = nextGreaterElementII(nums);

        n = ans.length;

        System.out.println(n);
        for(int e: ans){
            System.out.println(e);
        }
        
    }
}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Largest Area Histogram 2</span>
import java.io.*;
import java.util.*;

public class Main {
    public static int largestRectangleArea(int[] heights) {
        Stack<Integer> st = new Stack<>();
        int max =0;
        
        st.push(-1);
        
        for(int i=0;i<=heights.length;i++){
            int val = i==heights.length? 0:heights[i];
            
            while(st.peek() >=0 && heights[st.peek()] >= val){
                int h = heights[st.pop()];
                int start = st.peek();
                max = Math.max(max, h*(i-start-1));
            }
            st.push(i);
        }
        
        return max;
    }

    public static void main(String[] args) throws Exception {
        BufferedReader read = new BufferedReader(new InputStreamReader(System.in));

        int n = Integer.parseInt(read.readLine());
        int heights[] = new int[n];
        for(int i=0;i< n;i++)heights[i] = Integer.parseInt(read.readLine());

        System.out.println(largestRectangleArea(heights));
        
    }
}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Maximal Rectangle</span>
import java.io.*;
import java.util.*;

public class Main {

    public static int maximalRectangle(int[][] ar) {        
        
        int heights[] = Arrays.copyOf(ar[0], ar[0].length);

        int maxRec = largestRectangleArea(heights);
        
        int n=  ar.length;
        int m = ar[0].length;

        for(int r=1;r< n;r++){
            for(int i=0;i< m;i++){
                if(ar[r][i]==1){
                    heights[i]++;
                }else{
                    heights[i] = 0;
                }
            }
            maxRec = Math.max(maxRec, largestRectangleArea(heights));
        }
        return maxRec;
    }
    
    public static int largestRectangleArea(int[] heights) {
        
        Stack<Integer> st = new Stack<>();
        
        st.push(-1);
        int maxArea = 0;
        
        for(int i=0;i<=heights.length;i++){
            int val = i==heights.length?0:heights[i];
            
            while(st.peek() != -1 && heights[st.peek()] >= val){
                int rm = i;
                int h = heights[st.pop()];
                int lm = st.peek();
                maxArea = Math.max(maxArea, h*(rm-lm-1));
            }
            
            st.push(i);
        }
        
        return maxArea;
    }

    public static void main(String[] args) throws Exception {
        BufferedReader read = new BufferedReader(new InputStreamReader(System.in));

        int row = Integer.parseInt(read.readLine());
        int col = Integer.parseInt(read.readLine());
        
        int bmat[][] = new int[row][col];

        for(int i=0;i< row;i++){
            String s = read.readLine();
            for(int j=0;j< col;j++){
                bmat[i][j] = s.charAt(j)-'0';
            }
        }

        int result = maximalRectangle(bmat);
        System.out.println(result);
        
    }
}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Validate Stack Sequences</span>
import java.io.*;
import java.util.*;

public class Main {
    public static boolean validateStackSequences(int[] pushed, int[] popped) {
        Stack<Integer> st = new Stack<>();
        
        int i=0;
        int j=0;
        
        while(j< popped.length){
            if(st.size() > 0 && st.peek() == popped[j]){
                j++;
                st.pop();
            }else{
                if(i< pushed.length){
                    st.push(pushed[i++]);
                }else{
                    return false;
                }
            }
        }
        
        return true;
    }

    public static int[] getArr(String s){
        String nums[] = s.split(" ");
        int n = nums.length;
        int ar[] = new int[n];
        for(int i=0;i< n;i++){
            ar[i] = Integer.parseInt(nums[i]);
        }
        return ar;
    }
    
    public static void main(String[] args) throws Exception {
        BufferedReader read = new BufferedReader(new InputStreamReader(System.in));

        int pushed [] = getArr(read.readLine());
        int popped [] = getArr(read.readLine());
        
        boolean result = validateStackSequences(pushed, popped);

        System.out.println(result);
    }
}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Minimum Add To Make Parentheses Validate</span>
import java.io.*;
import java.util.*;

public class Main {
    public static int minAddToMakeValid(String S) {
        Stack<Character> st = new Stack<>();
        
        int ans = 0;
        
        for(int i=0;i< S.length();i++){
            char ch = S.charAt(i);
            if(ch == '('){
                st.push(ch);
                }else{
                if(st.size()>0&&st.peek()=='(')st.pop();
                else ans++;
                }
            }
        return ans + st.size();
    }

    public static void main(String[] args) throws Exception {
        BufferedReader read = new BufferedReader(new InputStreamReader(System.in));

        int result = minAddToMakeValid(read.readLine());
        System.out.println(result);
    }
}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Remove Outermost Parentheses</span>
import java.io.*;
import java.util.*;

public class Main {
  public static String removeOuterParentheses(String s) {

    Stack<Character> st = new Stack<>();
    StringBuilder sb = new StringBuilder();

    for (int i = 0; i < s.length(); i++) {
      char ch = s.charAt(i);

      if (ch == '(') {
        if (st.size() > 0) {
          sb.append(ch);
        }
        st.push(ch);
      } else {
        st.pop();
        if (st.size() > 0) {
          sb.append(ch);
        }
      }
    }

    return sb.toString();
  }

  public static void main(String[] args) throws Exception {
    BufferedReader read = new BufferedReader(new InputStreamReader(System.in));

    String result = removeOuterParentheses(read.readLine());
    System.out.println(result);
  }
}
<span id="line">-----------------------------------------------------------------------------------------------------</span>

<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Reverse Substrings Between Each Pair Of Parentheses</span>
import java.io.*;
import java.util.*;

public class Main {
    public static String reverseParentheses(String s) {
        Stack<Integer> st = new Stack<>();
        char ans[] = new char[s.length()];
        int last=0;
        
        for(int i=0;i< s.length();i++){
            char c = s.charAt(i);
            
            if(c==')'){
                int from = st.pop();
                reverse(ans, from, last-1);
            }else if(c=='('){
                st.push(last);
            }else{
                ans[last++] = c;
            }
        }
        
        return new String(ans, 0, last);
    }
    
    private static void reverse(char ch[], int i, int j){
        while(i< j){
            char t = ch[i];
            ch[i] = ch[j];
            ch[j] = t;
            i++;
            j--;
        }
    }

    public static void main(String[] args) throws Exception {
        BufferedReader read = new BufferedReader(new InputStreamReader(System.in));

        String result = reverseParentheses(read.readLine());
        System.out.println(result);
        
    }
}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Minimum Remove To Make Valid Parentheses</span>
import java.io.*;
import java.util.*;

public class Main {
    public static String reverseParentheses(String s) {
        Stack<Integer> st = new Stack<>();
        char chs[] = s.toCharArray();
        
        for(int i=0;i<chs.length;i++){
            char ch= chs[i];
            
            if(ch==')'){
                if(st.size()>0){
                    st.pop();
                }else{
                    chs[i] = '.';
                }
            }else if(ch=='('){
                st.push(i);
            }
        }
        
        while(st.size() > 0){
            chs[st.pop()] = '.';
        }
        
        StringBuilder sb = new StringBuilder();
        
        for(char c:chs){
            if(c!='.'){
                sb.append(c);
            }
        }
        
        return sb.toString();
    }

    public static void main(String[] args) throws Exception {
        BufferedReader read = new BufferedReader(new InputStreamReader(System.in));

        String result = reverseParentheses(read.readLine());
        System.out.println(result);
        
    }
}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Online Stock Span</span>
import java.io.*;
import java.util.*;

public class Main {

  static class StockSpanner {

    static class Pair {
      int price;
      int index;
    }

    Stack<Pair> st;
    int time = 0;

    public StockSpanner() {
      st = new Stack<>();
      Pair base = new Pair();
      base.price = 1000000;
      base.index = -1;
      st.push(base);
    }

    public int next(int price) {
      Pair p = new Pair();
      p.price = price;
      p.index = time;
      time++;

      while (st.peek().price <= p.price) {
        st.pop();
      }
      int ans = p.index - st.peek().index;

      st.push(p);

      return ans;
    }
  }

  public static void main(String[] args) throws Exception {
    BufferedReader read = new BufferedReader(new InputStreamReader(System.in));

    StockSpanner obj = new StockSpanner();

    while (read.ready()) {
      int price = Integer.parseInt(read.readLine());
      System.out.println(obj.next(price));
    }
  }
}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Exclusive Time Of Functions</span>
import java.io.*;
import java.util.*;

public class Main {

    public static void main(String[] args) throws Exception {
        BufferedReader read = new BufferedReader(new InputStreamReader(System.in));
        // use read for taking input

        int n = Integer.parseInt(read.readLine());
        int len = Integer.parseInt(read.readLine());

        Deque<int[]> st = new ArrayDeque<>();
        
        int ans[] = new int[n];
        
        for(int i=0;i<len;i++){       
            String []log = read.readLine().split(":");     
            int id = Integer.parseInt(log[0]);
            int time = Integer.parseInt(log[2]);
            
            if(log[1].equals("start")){
                st.push(new int[]{time, 0});
            }else{
                int[] pre = st.pop();
                ans[id] += time - pre[0] +1 - pre[1];
                if(st.size()>0){
                    st.peek()[1] += time - pre[0] +1;
                }
            }
            
        }

        for(int e: ans){
            System.out.println(e);
        }
    }
}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Trapping Rain Water</span>
import java.io.*;
import java.util.*;

public class Main {
  public static int trap(int[] height) {

    Stack<Integer> st = new Stack<>();

    int ans = 0;
    for (int i = 0, n = height.length; i < n; i++) {
      while (st.size() > 0 && height[st.peek()] <= height[i]) {
        int rm = i;
        int curr = height[st.pop()];
        if (st.size() == 0)break;
        int lm = st.peek();

        int width = rm - lm - 1;
        ans += (Math.min(height[rm], height[lm]) - curr) * width;
      }

      st.push(i);
    }

    return ans;
  }

  public static void main(String[] args) throws Exception {
    BufferedReader read = new BufferedReader(new InputStreamReader(System.in));

    int n = Integer.parseInt(read.readLine());
    int arr[] = new int[n];
    for (int i = 0; i < n; i++)arr[i] = Integer.parseInt(read.readLine());
    int result = trap(arr);
    System.out.println(result);

  }
}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Number Of Valid Subarrays</span>
import java.io.*;
import java.util.*;

public class Main {

  public static int validSubarrays(int[] nums) {
    Stack<Integer> st = new Stack<>();
    int count = 0;

    for (int num : nums) {
      while (st.size() > 0 && st.peek() > num) {
        st.pop();
      }
      st.push(num);
      count += st.size();
    }

    return count;
  }

  public static void main(String[] args) throws Exception {
    BufferedReader read = new BufferedReader(new InputStreamReader(System.in));

    int n = Integer.parseInt(read.readLine());
    int nums[] = new int[n];
    for (int i = 0; i < n; i++) {
      nums[i] = Integer.parseInt(read.readLine());
    }

    int count = validSubarrays(nums);

    System.out.println(count);

  }
}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Lexicographically Smallest Subsequence</span>
import java.io.*;
import java.util.*;

public class Main {
  public static int[] smallest(int[] nums, int k) {

    Stack<Integer> st = new Stack<>();
    int n = nums.length;
    for (int i = 0; i < n; i++) {

      while (st.size() > 0 && st.peek() > nums[i] && n - i >= k - st.size() + 1) {
        st.pop();
      }
      if (st.size() < k)st.push(nums[i]);
    }

    int ans[] = new int[k];
    int i = k - 1;
    while (i >= 0) {
      ans[i--] = st.pop();
    }

    return ans;
  }

  public static void main(String[] args) throws Exception {
    BufferedReader read = new BufferedReader(new InputStreamReader(System.in));

    int n = Integer.parseInt(read.readLine());
    int arr[] = new int[n];
    for (int i = 0; i < n; i++)arr[i] = Integer.parseInt(read.readLine());
    int k = Integer.parseInt(read.readLine());
    int ans[] = smallest(arr, k);
    System.out.println(ans.length);

    for (int e : ans) {
      System.out.println(e);
    }

  }
}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Design A Stack With Increment Operation</span>
import java.io.*;
import java.util.*;

public class Main {
  public static class CustomStack {

    int value[];
    int increment[];
    int index;

    public CustomStack(int maxSize) {
      value = new int[maxSize];
      increment = new int[maxSize];
      index = -1;
    }

    public void push(int x) {
      if (index + 1 == value.length) {
        return;
      }
      index++;
      value[index] = x;
      increment[index] = 0;
    }

    public int pop() {
      if (index == -1) {
        return -1;
      }
      int x = value[index];
      int inc = increment[index];
      index--;
      if (index >= 0) {
        increment[index] += inc;
      }
      return x + inc;
    }

    public void increment(int k, int val) {
      int ind = Math.min(k - 1, index);
      if (index >= 0)
        increment[ind] += val;
    }
  }

  public static void main(String[] args) throws Exception {
    BufferedReader read = new BufferedReader(new InputStreamReader(System.in));

    int maxsize = Integer.parseInt(read.readLine());

    CustomStack cs = new CustomStack(maxsize);

    while (true) {
      String task[] = read.readLine().split(" ");
      if (task[0].equals("push")) {
        cs.push(Integer.parseInt(task[1]));
      } else if (task[0].equals("pop")) {
        System.out.println(cs.pop());
      } else if (task[0].equals("increment")) {
        cs.increment(Integer.parseInt(task[1]), Integer.parseInt(task[2]));
      } else {
        break;
      }
    }
    System.out.println("exit");
  }
}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Trie</span>
<span class="textStyle">TRIE</span> 
<span class="textStyle">trie</span>
<span class="textStyle">Implement Trie</span>
import java.io.*;
import java.util.*;

public class Main {
  public static class Trie {

    private class Node {
      Node[]childs;
      boolean isEnd;

      Node() {
        childs = new Node[26];
      }
    }

    final private Node root;
    /** Initialize your data structure here. */
    public Trie() {
      root = new Node();
    }

    /** Inserts a word into the trie. */
    public void insert(String word) {

      Node curr = root;
      for (int i = 0; i < word.length(); i++) {
        char ch = word.charAt(i);

        if (curr.childs[ch - 'a'] == null) {
          curr.childs[ch - 'a'] = new Node();
        }
        curr = curr.childs[ch - 'a'];
      }
      curr.isEnd = true;
    }

    /** Returns if the word is in the trie. */
    public boolean search(String word) {
      Node curr = root;

      for (int i = 0; i < word.length(); i++) {
        char ch = word.charAt(i);

        if (curr.childs[ch - 'a'] == null)return false;
        curr = curr.childs[ch - 'a'];
      }

      return curr.isEnd;
    }

    /** Returns if there is any word in the trie that starts with the given prefix. */
    public boolean startsWith(String prefix) {
      Node curr = root;

      for (int i = 0; i < prefix.length(); i++) {
        char ch = prefix.charAt(i);

        if (curr.childs[ch - 'a'] == null)return false;
        curr = curr.childs[ch - 'a'];
      }

      return true;
    }
  }

  public static void main(String[] args) throws Exception {
    BufferedReader read = new BufferedReader(new InputStreamReader(System.in));

    Trie obj = new Trie();

    while (read.ready()) {
      String inp[] = read.readLine().split(" ");

      if (inp[0].equals("insert")) {
        obj.insert(inp[1]);
      } else if (inp[0].equals("search")) {
        System.out.println(obj.search(inp[1]));
      } else if (inp[0].equals("startsWith")) {
        System.out.println(obj.startsWith(inp[1]));
      }
    }

  }
}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Design Add And Search Words Data Structure</span>
import java.io.*;
import java.util.*;

public class Main {
  public static class WordDictionary {

    private class Node {
      Node[]childs;
      boolean isEnd;
      Node() {
        childs = new Node[26];
      }

      public boolean find(String word, int i) {
        if (i == word.length()) {
          return isEnd;
        }

        if (word.charAt(i) == '.') {
          for (Node child : childs) {
            if (child != null && child.find(word, i + 1)) {
              return true;
            }
          }
          return false;
        } else {
          if (childs[word.charAt(i) - 'a'] == null) {
            return false;
          } else {
            return childs[word.charAt(i) - 'a'].find(word, i + 1);
          }
        }
      }
    }

    final private Node root;
    public WordDictionary() {
      root = new Node();
    }

    /** Adds a word into the data structure. */
    public void addWord(String word) {
      Node curr = root;

      for (int i = 0; i < word.length(); i++) {
        char ch = word.charAt(i);

        if (curr.childs[ch - 'a'] == null) {
          curr.childs[ch - 'a'] = new Node();
        }
        curr = curr.childs[ch - 'a'];
      }

      curr.isEnd = true;
    }

    /**
     * Returns if the word is in the data structure. A word could contain the dot
     * character '.' to represent any one letter.
     */
    public boolean search(String word) {
      return root.find(word, 0);
    }

  }


  public static void main(String[] args) throws Exception {
    BufferedReader read = new BufferedReader(new InputStreamReader(System.in));

    WordDictionary obj = new WordDictionary();

    while (read.ready()) {
      String inp[] = read.readLine().split(" ");

      if (inp[0].equals("addWord")) {
        obj.addWord(inp[1]);
      } else if (inp[0].equals("search")) {
        System.out.println(obj.search(inp[1]));
      }
    }

  }
}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Word Search II</span>
import java.io.*;
import java.net.Inet4Address;
import java.util.*;

public class Main {

  public static class Node {
    Node []childs = new Node[26];
    String str;
    int count = 0;
  }

  public static void insert(Node curr, String s) {

    for (int i = 0; i < s.length(); i++) {
      char ch = s.charAt(i);
      if (curr.childs[ch - 'a'] == null) {
        curr.childs[ch - 'a'] = new Node();
        curr.count++;
      }
      curr = curr.childs[ch - 'a'];
    }
    curr.str = s;
  }

  public static ArrayList<String> findWords(char[][] board, String[] words) {

    Node root = new Node();
    for (String s : words) {
      insert(root, s);
    }
    boolean visited[][] = new boolean[board.length][board[0].length];
    ArrayList<String> ans = new ArrayList<>();
    for (int i = 0; i < board.length; i++) {
      for (int j = 0; j < board[0].length; j++) {
        dfs(board, i, j, root, ans, visited);
      }
    }
    return ans;
  }

  public static void dfs(char[][]board, int i, int j, Node root, ArrayList<String> ans, boolean visited[][]) {
    if (i < 0 || j < 0 || i >= board.length || j >= board[0].length || visited[i][j] == true || root.count == 0)return;
    if (root.childs[board[i][j] - 'a'] == null)return;

    Node child = root.childs[board[i][j] - 'a'];
    if (child.str != null) {
      ans.add(child.str);
      child.str = null;
    }

    visited[i][j] = true;
    dfs(board, i + 1, j, child, ans, visited);
    dfs(board, i - 1, j, child, ans, visited);
    dfs(board, i, j + 1, child, ans, visited);
    dfs(board, i, j - 1, child, ans, visited);
    visited[i][j] = false;

    if (child.count == 0) {
      root.count--;
    }
  }

  public static void main(String[] args) throws Exception {
    BufferedReader read = new BufferedReader(new InputStreamReader(System.in));

    int n = Integer.parseInt(read.readLine());
    int m = Integer.parseInt(read.readLine());
    char[][]board = new char[n][];
    for (int i = 0; i < n; i++) {
      board[i] = read.readLine().trim().toCharArray();
    }
    int count = Integer.parseInt(read.readLine());
    String words[] = new String[count];
    for (int i = 0; i < count; i++) {
      words[i] = read.readLine();
    }

    ArrayList<String> result = findWords(board, words);
    Collections.sort(result);
    System.out.println(result);

  }
}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Replace Words</span>

<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Maximum Xor Of Two Numbers In An Array</span>
import java.io.*;
import java.util.*;

public class Main {

  public static class Trie {

    public class Node {
      Node left, right;
    }

    Node root;
    Trie() {
      root = new Node();
    }

    public void insert(int val) {
      int bitIndex = 30;
      Node curr = root;

      while (bitIndex >= 0) {
        int mask = 1 << bitIndex;
        int bit = (mask & val) > 0 ? 1 : 0;

        if (bit == 0) {
          if (curr.left == null) {
            curr.left = new Node();
          }
          curr = curr.left;
        } else {
          if (curr.right == null) {
            curr.right = new Node();
          }
          curr = curr.right;
        }

        bitIndex--;
      }

    }

    public int query(int find) {
      int bitIndex = 30;
      Node curr = root;
      int ans = 0;

      while (bitIndex >= 0) {
        int mask = 1 << bitIndex;
        int bit = (find & mask) > 0 ? 1 : 0;

        if (bit == 0) {
          if (curr.left != null) {
            curr = curr.left;
          } else {
            curr = curr.right;
            ans |= mask;
          }
        } else {
          if (curr.right != null) {
            curr = curr.right;
            ans |= mask;
          } else {
            curr = curr.left;
          }
        }


        bitIndex--;
      }

      return ans;
    }
  }


  public static int findMaximumXOR(int[] nums) {

    Trie trie = new Trie();

    for (int val : nums) {
      trie.insert(val);
    }

    int max = 0;
    for (int val : nums) {
      int find = Integer.MAX_VALUE ^ val;
      int res = trie.query(find);
      max = Math.max(max, val ^ res);
    }

    return max;
  }

  public static void main(String[] args) throws Exception {
    BufferedReader read = new BufferedReader(new InputStreamReader(System.in));

    int n = Integer.parseInt(read.readLine().trim());
    int arr[] = new int[n];
    for (int i = 0; i < n; i++)arr[i] = Integer.parseInt(read.readLine().trim());

    int result = findMaximumXOR(arr);
    System.out.println(result);

  }
}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Count Pairs With Xor In A Range</span>
import java.io.*;
import java.util.*;

public class Main {
    
    public static class Node{
        Node left;
        Node right;
        int count;
    }
    
    public static int getCount(Node root){
        return (root == null)?0: root.count;
    }
    
    final static int MAX_BIT = 14;
    
    public static int query(Node root, int high, int val, int index){
        if(root == null){
            return 0;
        }
        if(index == -1){
            return getCount(root);
        }
        
        int bitV = (val&(1<<index))>0?1:0;
        int bitH = (high&(1<<index))>0?1:0;
        
        if(bitV == 0){
            if(bitH==0){
                return query(root.left, high, val, index-1);
            }else{
                return getCount(root.left) + query(root.right, high, val, index-1);
            }
        }else{
            if(bitH == 0){
                return query(root.right, high, val, index-1);
            }else{
                return query(root.left, high, val, index-1) + getCount(root.right);
            }
        }
        
    }
    
    public static void insert(Node root, int val){
        for(int i=14;i>=0;i--){
            int mask = 1<<i;
            int bit = (val&mask)>0?1:0;
            
            if(bit == 0){
                if(root.left == null)root.left = new Node();
                root = root.left;
            }else{
                if(root.right == null)root.right = new Node();
                root = root.right;
            }
            root.count++;
        }
    }
    
    public static int countPairs(int[] nums, int low, int high) {
        
        Node root = new Node();
        
        int count=0;
        
        for(int val: nums){
            count += query(root, high, val, MAX_BIT);
            count -= query(root, low-1, val, MAX_BIT);
            insert(root, val);
        }
        
        return count;
    }

  public static void main(String[] args) throws Exception {
    BufferedReader read = new BufferedReader(new InputStreamReader(System.in));

    int n = Integer.parseInt(read.readLine());

    int[]nums = new int[n];

    for (int i = 0; i < n; i++) {
      nums[i] = Integer.parseInt(read.readLine());
    }
    int low = Integer.parseInt(read.readLine());
    int high = Integer.parseInt(read.readLine());

    int result = countPairs(nums, low, high);
    System.out.println(result);

  }
}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Stream Of Characters</span>
import java.io.*;
import java.util.*;

public class Main {
  public static class StreamChecker {
    
    public static class Node{
        Node[]childs = new Node[26];
        boolean isEnd=false;
    }
    
    private final Node root;
    private final StringBuilder sb;
    public StreamChecker(String[] words) {
        root = new Node();
        sb = new StringBuilder();
        
        for(String s: words){
            Node curr = root;
            for(int i=s.length()-1;i>=0;i--){
                char ch = s.charAt(i);
                
                if(curr.childs[ch-'a'] == null){
                    curr.childs[ch-'a'] = new Node();
                }
                curr = curr.childs[ch-'a'];
            }
            curr.isEnd = true;
        }
    }

    public boolean query(char letter) {
        sb.append(letter);
        
        Node curr = root;
        
        for(int i=sb.length()-1;i>=0;i--){
            char ch = sb.charAt(i);
            
            curr = curr.childs[ch-'a'];
            if(curr == null)return false;
            if(curr.isEnd)return true;
        }
        return false;
    }
  }

  public static void main(String[] args) throws Exception {
    BufferedReader read = new BufferedReader(new InputStreamReader(System.in));

    int n = Integer.parseInt(read.readLine());

    String[]words = new String[n];

    for (int i = 0; i < n; i++) {
      words[i] = read.readLine();
    }

    StreamChecker obj = new StreamChecker(words);

    n = Integer.parseInt(read.readLine());
    for (int i = 0; i < n; i++) {
      System.out.println(obj.query(read.readLine().charAt(0)));
    }
  }
}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Array and String</span>
<span class="textStyle">Array and String</span>
<span class="textStyle">Range Addition</span>
import java.util.*;

public class Main {

    // ~~~~~~~~~~~~~~~~~~~~~User Section~~~~~~~~~~~~~~~~~~~~~

    public static int[] getModifiedArray(int length, int[][] queries) {
        // write your code here
        int[] res = new int[length];

        for(int i = 0; i < queries.length; i++) {
            int st = queries[i][0];
            int end = queries[i][1];
            int inc = queries[i][2];

            res[st] += inc;
            if(end + 1 < length) {
                res[end + 1] -= inc;
            }
        }

        int sum = 0;
        for(int i = 0; i < length; i++) {
            sum += res[i];
            res[i] = sum;
        }

        return res;
    }

    // ~~~~~~~~~~~~~~~~~~~Input Management~~~~~~~~~~~~~~~~~~~

    public static void main(String[] args) {
        Scanner scn = new Scanner(System.in);
        
        int length = scn.nextInt();

        int nq = scn.nextInt();
        
        int[][] queries = new int[nq][3];

        for(int q = 0; q < nq; q++) {
            queries[q][0] = scn.nextInt();
            queries[q][1] = scn.nextInt();
            queries[q][2] = scn.nextInt();
        }


        int[] res = getModifiedArray(length, queries);

        for(int i = 0; i < res.length; i++) {
            System.out.print(res[i] + " ");
        }
    }
}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Container With Most Water</span>
import java.util.*;

public class Main {

    // ~~~~~~~~~~~~~~~~~~~~~User Section~~~~~~~~~~~~~~~~~~~~~

    public static int mostWater(int[] height) {
        // write your code here
        int i = 0;
        int j = height.length - 1;
        
        int mostWater = 0;
        while(i < j) {
            int base = j - i;
            int h1 = height[i];
            int h2 = height[j];
            int water = base * Math.min(h1, h2);;
            if(water > mostWater) {
                mostWater = water;
            }
            if(h1 == h2) {
                i++;
                j--;
            } else if(h1 > h2) {
                j--;
            } else {
                i++;
            }
        }
        
        return mostWater;
    }

    // ~~~~~~~~~~~~~~~~~~~Input Management~~~~~~~~~~~~~~~~~~~

    public static void main(String[] args) {
        // Write your code here
        Scanner scn = new Scanner(System.in);
        int n = scn.nextInt();
        int[] heights = new int[n];
        for(int i = 0; i < n; i++) {
            heights[i] = scn.nextInt();
        }

        int res = mostWater(heights);
        System.out.println(res);
    }
}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Squares Of A Sorted Array</span>
import java.util.*;

public class Main {

    // ~~~~~~~~~~~~~~~~~~~~~User Section~~~~~~~~~~~~~~~~~~~~~

    public static int[] sortedSquares(int[] nums) {
        int i = 0;
        int j = nums.length - 1;

        int[] res = new int[nums.length];
        int indx = nums.length - 1;
        while(i <= j) {
            int val1 = nums[i] * nums[i];
            int val2 = nums[j] * nums[j];
            if(val1 > val2) {
                res[indx] = val1;
                i++;
            } else {
                res[indx] = val2;
                j--;
            }
            indx--;
        }
        
        return res;
    }

    // ~~~~~~~~~~~~~~~~~~~Input Management~~~~~~~~~~~~~~~~~~~

    public static void main(String[] args) {
        Scanner scn = new Scanner(System.in);
        int n = scn.nextInt();
        int[] nums = new int[n];
        
        for(int i = 0; i < n; i++) 
            nums[i] = scn.nextInt();
        
        int[] res = sortedSquares(nums);

        for(int i = 0; i < n; i++) {
            System.out.print(res[i] + " ");
        }
    }
}
                        
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Majority Element - I</span>
import java.util.*;

public class Main {

    // ~~~~~~~~~~~~~~~~~~~~~User Section~~~~~~~~~~~~~~~~~~~~~

    public static int validCandidate(int[] arr) {
        int val = arr[0];
        int count = 1;
        for(int i = 1; i < arr.length; i++) {
            if(val == arr[i]) {
                count++;
            } else {
                count--;
            }
            if(count == 0) {
                val = arr[i];
                count = 1;
            }
        }
        return val;
    }

    public static void printMajorityElement(int[] arr) {
        // write your code here
        int val = validCandidate(arr);
        int count = 0;
        for(int ele : arr) {
            if(ele == val)
                count++;
        }

        if(count > arr.length / 2) {
            System.out.println(val);
        } else {
            System.out.println("No Majority Element exist");
        }
    }

    // ~~~~~~~~~~~~~~~~~~~Input Management~~~~~~~~~~~~~~~~~~~

    public static void main(String[] args) {
        Scanner scn = new Scanner(System.in);
        int n = scn.nextInt();

        int[] arr = new int[n];

        for(int i = 0; i < n; i++) {
            arr[i] = scn.nextInt();
        }

        printMajorityElement(arr);
    }
}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Majority Elements - I I</span>
import java.util.*;

public class Main {

    // ~~~~~~~~~~~~~~~~~~~~~User Section~~~~~~~~~~~~~~~~~~~~~
    public static boolean isGreaterThanNb3(int[] arr, int val) {
        int count = 0;
        
        for(int ele : arr) {
            if(ele == val)
                count++;
        }
        
        return count > arr.length / 3;
    }

    public static ArrayList<Integer> majorityElement2(int[] arr) {
        if(arr.length == 0) return new ArrayList<>();
        int count1 = 1;
        int val1 = arr[0];
        
        int count2 = 0;
        int val2 = arr[0];
        
        int i = 1;
        while(i < arr.length) {
            if(arr[i] == val1) {
                count1++;
            } else if(arr[i] == val2) {
                count2++;
            } else {
                if(count1 == 0) {
                    val1 = arr[i];
                    count1 = 1;
                } else if(count2 == 0) {
                    val2 = arr[i];
                    count2 = 1;
                } else {
                    count1--;
                    count2--;
                }
            }
            i++;
        }
        ArrayList<Integer> res = new ArrayList<>();
        if(isGreaterThanNb3(arr, val1) == true)
            res.add(val1);
        
        if(val1 != val2 && isGreaterThanNb3(arr, val2) == true)
            res.add(val2);
        
        return res;
    }

    // ~~~~~~~~~~~~~~~~~~~Input Management~~~~~~~~~~~~~~~~~~~
    public static void main(String[] args) {
        Scanner scn = new Scanner(System.in);
        int n = scn.nextInt();

        int[] arr = new int[n];
        for(int i = 0; i < n; i++) {
            arr[i] = scn.nextInt();
        }

        ArrayList<Integer> res = majorityElement2(arr);
        System.out.println(res);
    }
}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Majority Element General</span>
import java.util.*;

public class Main {
    
    //~~~~~~~~~~~~~~~~User Section~~~~~~~~~~~~~~~~~
    public static ArrayList<Integer> majorityElement(int[] arr, int k) {
        // write yout code here
        HashMap<Integer, Integer> map = new HashMap<>();
        int n = arr.length;
        for(int i = 0; i < n; i++) {
            int key = arr[i];
            if(map.containsKey(key) == true) {
                map.put(key, map.get(key) + 1); 
            } else {
                map.put(key, 1);
            }
        }
        ArrayList<Integer> res = new ArrayList<>();
        for(int key : map.keySet()) {
            if(map.get(key) > n / k)
                res.add(key);
        }
        Collections.sort(res);
        return res;
    }
    
    //~~~~~~~~~~~~~~~Input Management~~~~~~~~~~~~~~~
    public static void main(String[] args) {
        Scanner scn = new Scanner(System.in);
        int n = scn.nextInt();
        int[] arr = new int[n];
        for(int i = 0; i < n; i++) {
            arr[i] = scn.nextInt();
        }
        int k = scn.nextInt();
        ArrayList<Integer> res = majorityElement(arr, k);
        System.out.println(res);
    }
}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Next Greater Element I I I</span>
import java.util.*;

public class Main {
    
    //~~~~~~~~~~~~~~User Section~~~~~~~~~~~~~~~~~~
    public static String nextGreaterElement(String str) {
        char[] num = str.toCharArray();
        
        int i = num.length - 2;
        while(i >= 0 && num[i] >= num[i + 1]) {
            i--;
        }
        
        if(i >= 0) {
            int k = num.length - 1;
            while(num[k] <= num[i]) {
                k--;
            }
            char temp = num[i];
            num[i] = num[k];
            num[k] = temp;
        } else {
            return "-1";
        }
        
        String res = "";
        for(int j = 0; j <= i; j++) {
            res += num[j];
        }
        
        for(int j = num.length - 1; j > i; j--) {
            res += num[j];
        }
        
        return res;
    }

    //~~~~~~~~~~~~~~~~~Input Management~~~~~~~~~~~~~~~~~
    public static void main(String[] args) {
        Scanner scn = new Scanner(System.in);
        String num = scn.next();
        String res = nextGreaterElement(num);

        System.out.println(res);
    }
}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Product Of Array Except Itself Without Using Division Operator</span>
import java.util.*;

public class Main {
    
    //~~~~~~~~~~~~~~~~~User Section~~~~~~~~~~~~~~~
    public int[] productExceptSelf(int[] arr) {
        // write your code here
        int[] left = new int[arr.length];
        
        int mul = 1;
        for(int i = 0; i < left.length; i++) {
            mul *= arr[i];
            left[i] = mul;
        }
        
        int[] res = new int[arr.length];
        mul = 1;
        for(int i = arr.length - 1; i > 0; i--) {
            res[i] = left[i - 1] * mul;
            mul *= arr[i];
        }
        res[0] = mul;
        
        return res;
    }

    //~~~~~~~~~~~~~~~~~Input Management~~~~~~~~~~~~~~~
    public static void main(String[] args) {
        Scanner scn = new Scanner(System.in);
        int n = scn.nextInt();
        int[] arr = new int[n];
        for(int i = 0; i < n; i++) {
            arr[i] = scn.nextInt();
        }
        int[] res = productExceptSelf(arr);
        for(int i = 0; i < arr.length; i++) {
            System.out.print(res[i] + " ");
        }
    }
}
                        
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Partition Labels</span>
import java.util.*;

public class Main {

  // ~~~~~~~~~~~~~~~User Section~~~~~~~~~~~~~~~
  public static List<Integer> partitionLabels(String s) {
    HashMap<Character, Integer> map = new HashMap<>();
    List<Integer> res = new ArrayList<>();

    for (int i = 0; i < s.length(); i++) {
      char ch = s.charAt(i);
      map.put(ch, i);
    }

    int max = 0;
    int prev = -1;
    for (int i = 0; i < s.length(); i++) {
      char ch = s.charAt(i);
      max = Math.max(max, map.get(ch));
      if (max == i) {
        res.add(max - prev);
        prev = max;
      }
    }

    return res;
  }

  // ~~~~~~~~~~~~~Input Management~~~~~~~~~~~~~~~
  public static void main(String[] args) {
    Scanner scn = new Scanner(System.in);
    String str = scn.nextLine();

    List<Integer> res = partitionLabels(str);
    for (int val : res) {
      System.out.print(val + " ");
    }
  }
}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Partition Array Into Disjoint Intervals</span>
import java.util.*;

public class Main {

  // ~~~~~~~~~~~~~~User's Section~~~~~~~~~~~~~~~
  public static int partitionDisjoint(int[] arr) {
    int leftMax = arr[0];
    int greater = arr[0];
    int ans = 0;

    for (int i = 1; i < arr.length ; i++) {
      if (arr[i] > greater) {
        greater = arr[i];
      } else if (arr[i] < leftMax) {
        leftMax = greater;
        ans = i;
      }
    }

    return ans + 1;
  }

  // ~~~~~~~~~~~~~Input Management~~~~~~~~~~~~~~~
  public static void main(String[] args) {
    Scanner scn = new Scanner(System.in);
    int n = scn.nextInt();
    int[] arr = new int[n];

    for (int i = 0; i < n; i++) {
      arr[i] = scn.nextInt();
    }

    int len = partitionDisjoint(arr);
    System.out.println(len);
  }
}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Max Chunks To Make Array Sorted</span>
import java.util.*;

public class Main {

    // ~~~~~~~~~~~~~~~User Section~~~~~~~~~~~~~~~~~~
    public static int maxChunksToSorted(int[] arr) {
        int count = 0;
        int max = 0;
        for(int i = 0; i < arr.length; i++) {
            max = Math.max(arr[i], max);
            
            if(i == max) 
                count++;
        }
        return count;    
    }

    // ~~~~~~~~~~~~Input Management~~~~~~~~~~~~~~~~
    public static void main(String[] args) {
        Scanner scn = new Scanner(System.in);
        int n = scn.nextInt();
        int[] arr = new int[n];

        for(int i = 0; i < n; i++) {
            arr[i] = scn.nextInt();
        }

        int res = maxChunksToSorted(arr);
        System.out.println(res);
    }
}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Max Chunks To Make Array Sorted 2</span>
import java.util.*;

public class Main {

    // ~~~~~~~~~~~~~~~User Section~~~~~~~~~~~~~~~~~
    public static int maxChunksToSorted2(int[] arr) {
        int[] rmin = new int[arr.length + 1];
        
        int val = Integer.MAX_VALUE;
        rmin[arr.length] = val;
        for(int i = arr.length - 1; i>= 0; i--) {
            val = Math.min(val, arr[i]);
            rmin[i] = val;
        }
        
        int lmax = arr[0];
        int count = 0;
        for(int i = 0; i < arr.length; i++) {
            lmax = Math.max(lmax, arr[i]);
            
            if(lmax <= rmin[i + 1])
                count++;
        }
        
        return count;
    }

    // ~~~~~~~~~~~~~~~Input Management~~~~~~~~~~~~~~~~~
    public static void main(String[] args) {
        Scanner scn = new Scanner(System.in);
        int n = scn.nextInt();
        int[] arr = new int[n];

        for(int i = 0; i < n; i++) {
            arr[i] = scn.nextInt();
        }

        int res = maxChunksToSorted2(arr);
        System.out.println(res);
    }
}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Min Jumps With +i -i Moves</span>
import java.util.*;

public class Main {
    // ~~~~~~~~~~~~User Section~~~~~~~~~~~
    public static int minJumps(int x) {
        int sum = 0;
        int i = 1;
        while(sum < x) {
            sum += i;
            i++;
        }

        if(sum == x) {
            return i - 1;
        } else if((sum - x) % 2 == 0) {
            return i - 1;
        } else if((sum + i - x) % 2 == 0) {
                return i;
        } else {
            return i + 1;
        }
    }

    //~~~~~~~~~~~~~~~~~~Input Management~~~~~~~~~~~~~~
    public static void main(String[] args) {
        Scanner scn = new Scanner(System.in);
        int x = scn.nextInt();

        int jumps = minJumps(x);
        System.out.println(jumps);
    }
}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Max Product Of Three Numbers</span>
import java.util.*;

public class Main {

    // ~~~~~~~~~~~~~~~~User Section~~~~~~~~~~~
    public static int maximumProduct(int[] arr) {
        int min = (int)1e9;
        int smin = (int)1e9;
        
        int max = -(int)1e9;
        int smax = max;
        int tmax = max;
        
        for(int i = 0; i < arr.length; i++) {
            if(arr[i] > max) {
                tmax = smax;
                smax = max;
                max = arr[i];
            } else if(arr[i] > smax) {
                tmax = smax;
                smax = arr[i];
            } else if(arr[i] > tmax) {
                tmax = arr[i];
            }
            
            
            if(arr[i] < min) {
                smin = min;
                min = arr[i];
            } else if(arr[i] < smin) {
                smin = arr[i];
            }
        }
        
        return Math.max(max * smax * tmax, max * min * smin);
    }

    // ~~~~~~~~~~~~~~~~Input Management~~~~~~~~~~~
    public static void main(String[] args) {
        Scanner scn = new Scanner(System.in);
        int n = scn.nextInt();
        int[] arr = new int[n];

        for(int i = 0; i < n; i++) {
            arr[i] = scn.nextInt();
        }

        int prod = maximumProduct(arr);
        System.out.println(prod);
    }
}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Sort Array By Parity</span>
import java.util.*;

public class Main {

    // ~~~~~~~~~~~~~~~~~~User Section~~~~~~~~~~~~~~~~~

    private static void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
    
    public static void sortArrayByParity(int[] nums) {
        int i = 0;
        int j = 0;
        
        while(i < nums.length) {
            if(nums[i] % 2 == 0) {
                swap(nums, i, j);
                i++;
                j++;
            } else {
                i++;
            }
        }
    }

    //// ~~~~~~~~~~~~~~~~~~Input Management~~~~~~~~~~~~~~~~~
    public static void main(String[] args) {
        Scanner scn = new Scanner(System.in);
        int n = scn.nextInt();
        int[] arr = new int[n];

        for(int i = 0; i < n; i++) {
            arr[i] = scn.nextInt();
        }

        sortArrayByParity(arr);

        for(int i = 0; i < n; i++) {
            System.out.print(arr[i] + " ");
        }
    }
}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Best Meeting Point</span>
import java.util.*;

public class Main {

    // ~~~~~~~~~~~~~~~~~User Section~~~~~~~~~~~~~~~~
    public static int minTotalDistance(int[][] grid) {
        // Write your code here
        ArrayList<Integer> xcord = new ArrayList<>();
        ArrayList<Integer> ycord = new ArrayList<>();

        // for row coordinates
        for(int r = 0; r < grid.length; r++) {
            for(int c = 0; c < grid[0].length; c++) {
                if(grid[r][c] == 1) {
                    xcord.add(r);
                }
            }
        }

        // for col coordinates
        for(int c = 0; c < grid[0].length; c++) {
            for(int r = 0; r < grid.length; r++) {
                if(grid[r][c] == 1) {
                    ycord.add(c);
                }
            }
        }

        int x = xcord.get(xcord.size() / 2);
        int y = ycord.get(ycord.size() / 2);
        
        // calculate distance
        int dist = 0;
        for(int i = 0; i < xcord.size(); i++) {
            dist += Math.abs(xcord.get(i) - x) + Math.abs(ycord.get(i) - y);
        }
        return dist;
    }

    // ~~~~~~~~~~~~~~~Input Management~~~~~~~~~~~~~~
    public static void main(String[] args) {
        Scanner scn = new Scanner(System.in);
        int n = scn.nextInt();
        int m = scn.nextInt();


        int[][] grid = new int[n][m];

        for(int i = 0; i < n; i++) {
            for(int j = 0; j < m; j++) {
                grid[i][j] = scn.nextInt();
            }
        }

        int dist = minTotalDistance(grid);
        System.out.println(dist);
    }
}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Sieve Of Eratosthenes</span>
import java.util.*;

public class Main {
    
    // ~~~~~~~~~~~~~~~~~~User Section~~~~~~~~~~~~~~~~
    public static void printPrimeUsingSieve(int n) {
        boolean[] isPrime = new boolean[n + 1];

        Arrays.fill(isPrime, true);

        for(int i = 2; i * i <= n; i++) {
            if(isPrime[i] == true) {
                for(int j = i + i; j <= n; j += i) {
                    isPrime[j] = false;
                }
            }
        }

        for(int i = 2; i < isPrime.length; i++) {
            if(isPrime[i] == true) {
                System.out.print(i + " ");
            }
        }
        System.out.println();
    }

    // ~~~~~~~~~~~~~~~~Input Management~~~~~~~~~~~~~~
    public static void main(String[] args) {   
        Scanner scn = new Scanner(System.in);
        int n = scn.nextInt();
        printPrimeUsingSieve(n);
    }
}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Segmented Sieve</span>
import java.util.*;

public class Main {

  // ~~~~~~~~~~~~~User Section~~~~~~~~~~~~
  public static ArrayList<Integer> sieveOfEratosthenes(int N) {
    boolean[] arr = new boolean[N + 1]; // false - prime || true - non prime
    for (int i = 2; i * i <= N; i++) {
      if (arr[i] == false) {
        for (int j = i * 2; j <= N; j += i) {
          arr[j] = true;
        }
      }
    }
    ArrayList<Integer> ans = new ArrayList<>();
    for (int i = 2; i <= N; i++) {
      if (arr[i] == false) {
        ans.add(i);
      }
    }
    return ans;
  }

  public static void segmentedSieveAlgo(int a, int b) {
    StringBuilder sb = new StringBuilder();
    int rootb = (int) Math.sqrt(b);
    ArrayList<Integer> primes = sieveOfEratosthenes(rootb);
    boolean[] arr = new boolean[b - a + 1];
    for (int i : primes) {
      int multiple = (int) Math.ceil(a * 1.0 / i);
      if (multiple == 1) {
        multiple++;
      }
      int firstidx = (multiple * i) - a;
      while (firstidx < arr.length) {
        arr[firstidx] = true;
        firstidx += i;
      }
    }
    for (int i = 0; i < arr.length; i++) {
      if (arr[i] == false && (a + i) != 1) {
        sb.append(a + i + "\n");
      }
    }
    sb.append("\n");
    System.out.println(sb);
  }

  // ~~~~~~~~~~~~Input Management~~~~~~~~~~~
  public static void main(String[] args) {
    Scanner scn = new Scanner(System.in);
    int a = scn.nextInt();
    int b = scn.nextInt();
    segmentedSieveAlgo(a, b);
  }
}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Transpose Of Matrix With Dimension M X N</span>
import java.util.*;

public class Main {

  // ~~~~~~~~~~~~~User Section~~~~~~~~~~~~~
  public static int[][] transpose(int[][] matrix) {
    // write your code here
    int n = matrix.length;
    int m = matrix[0].length;

    int[][] res = new int[m][n];

    for (int i = 0; i < n; i++) {
      for (int j = 0; j < m; j++) {
        res[j][i] = matrix[i][j];
      }
    }
    return res;
  }


  // ~~~~~~~~~~~Input Management~~~~~~~~~~~
  public static void main(String[] args) {
    Scanner scn = new Scanner(System.in);
    int n = scn.nextInt();
    int m = scn.nextInt();

    int[][] matrix = new int[n][m];

    for (int i = 0; i < n; i++) {
      for (int j = 0; j < m; j++) {
        matrix[i][j] = scn.nextInt();
      }
    }

    int[][] res = transpose(matrix);

    for (int i = 0; i < res.length; i++) {
      for (int j = 0; j < res[0].length; j++) {
        System.out.print(res[i][j] + " ");
      }
      System.out.println();
    }
  }
}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Transpose Of Matrix With Dimension N X N</span>
import java.util.*;

public class Main {

  // ~~~~~~~~~~~~~User Section~~~~~~~~~~~~~
  public static void transpose(int[][] matrix) {
    // write your code here
    int n = matrix.length;
    for (int i = 0; i < n; i++) {
      for (int j = 0; j <= i; j++) {
        int temp = matrix[i][j];
        matrix[i][j] = matrix[j][i];
        matrix[j][i] = temp;
      }
    }
  }

  // ~~~~~~~~~~~Input Management~~~~~~~~~~~
  public static void main(String[] args) {
    Scanner scn = new Scanner(System.in);
    int n = scn.nextInt();
    int[][] matrix = new int[n][n];
    for (int i = 0; i < n; i++) {
      for (int j = 0; j < n; j++) {
        matrix[i][j] = scn.nextInt();
      }
    }
    transpose(matrix);
    for (int i = 0; i < n; i++) {
      for (int j = 0; j < n; j++) {
        System.out.print(matrix[i][j] + " ");
      }
      System.out.println();
    }
  }
}
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Complex Number Multiplication</span>
import java.util.*;

public class Main {

  // ~~~~~~~~~~~~~User's Section~~~~~~~~~~~~~
  public static String complexNumberMultiply(String num1, String num2) {
    // num1 = a + bi
    // num2 = c + di
    // result = (a * c - b * d) + (a * d + c * b)i

    int a = Integer.parseInt(num1.substring(0, num1.indexOf("+")));
    int b = Integer.parseInt(num1.substring(num1.indexOf("+") + 1, num1.length() - 1));
    int c = Integer.parseInt(num2.substring(0, num2.indexOf("+")));
    int d = Integer.parseInt(num2.substring(num2.indexOf("+") + 1, num2.length() - 1));

    return "" + (a * c - b * d) + "+" + (a * d + c * b) + "i";
  }

  // ~~~~~~~~~~~~Input Management~~~~~~~~~~~
  public static void main(String[] args) {
    Scanner scn = new Scanner(System.in);
    String num1 = scn.nextLine();
    String num2 = scn.nextLine();
    String res = complexNumberMultiply(num1, num2);
    System.out.println(res);
  }
}
                                
<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">First Missing Positive</span>
import java.util.*;

public class Main {


  //~~~~~~~~~~~~~~~User's Section~~~~~~~~~~~~~~~~~
  public static int firstMissingPositive(int[] arr) {
    int n = arr.length;
    boolean one = false;
    for (int i = 0; i < n; i++) {
      if (arr[i] == 1)
        one = true;

      if (0 >= arr[i] || arr[i] > n) {
        arr[i] = 1;
      }
    }

    if (one == false) return 1;

    for (int i = 0; i < n; i++) {
      int indx = Math.abs(arr[i]);
      arr[indx - 1] = -Math.abs(arr[indx - 1]);
    }

    for (int i = 0; i < n; i++) {
      if (arr[i] > 0) {
        return i + 1;
      }
    }
    return n + 1;
  }

  //~~~~~~~~~~~~~Input Management~~~~~~~~~~~~~~~
  public static void main(String[] args) {
    Scanner scn = new Scanner(System.in);
    int n = scn.nextInt();
    int[] arr = new int[n];

    for (int i = 0; i < n; i++) {
      arr[i] = scn.nextInt();
    }

    int res = firstMissingPositive(arr);
    System.out.println(res);
  }
}
                                
<span id="line">-----------------------------------------------------------------------------------------------------</span>

<span id="line">-----------------------------------------------------------------------------------------------------</span>
<span class="textStyle">Find All Duplicates In An Array</span>
import java.util.*;

public class Main {

  // ~~~~~~~~~~~~~~~~User's Section~~~~~~~~~~~~~~~~~
  public static List<Integer> findDuplicates(int[] nums) {
    List<Integer> res = new ArrayList<>();

    for (int i = 0; i < nums.length; i++) {
      int indx = Math.abs(nums[i]) - 1;
      int val = nums[indx];

      if (val < 0) {
        res.add(indx + 1);
      } else {
        nums[indx] *= -1;
      }
    }
    return res;
  }

  // ~~~~~~~~~~~~~~Input Management~~~~~~~~~~~~~~~
  public static void main(String[] args) {
    Scanner scn = new Scanner(System.in);
    int n = scn.nextInt();
    int[] arr = new int[n];

    for (int i = 0; i < n; i++) {
      arr[i] = scn.nextInt();
    }

    List<Integer> res = findDuplicates(arr);
    if (res.size() == 0) {
      System.out.println("Empty");
      return;
    }
    Collections.sort(res);
    for (int val : res)
      System.out.print(val + " ");
    System.out.println();
  }
}
                              
<span id="line">-----------------------------------------------------------------------------------------------------</span>

<span id="line">-----------------------------------------------------------------------------------------------------</span>

<span class="textStyle">Hard Level End</span>
<span class="textStyle">hard level end</span>
<span class="textStyle">HARD LEVEL END</span> 
<span class="textStyle">HARD LEVEL END</span>
<span class="textStyle">Hard Level End</span>
<span class="textStyle">hard level end</span>
<span class="textStyle">HARD LEVEL END</span> 
<span class="textStyle">Hard Level End</span>
<span class="textStyle">hard level end</span>
<span class="textStyle">HARD LEVEL END</span> 
<span class="textStyle">Hard Level End</span>
<span class="textStyle">hard level end</span>
<span class="textStyle">HARD LEVEL END</span> 
<span class="textStyle">Hard Level End</span>
<span class="textStyle">hard level end</span>
<span class="textStyle">HARD LEVEL END</span> 
												
												
								
<span id="line">---------------------------------------------------------------</span>

<span class="textStyle">All SORTING ALGORITHM'S </span>
import java.util.*;
public class All_Sorting_Algo {
    public static void main(String[] args) {
        int[] arr={8,99,7,6,55,5,4,3,2,1,23,34,43,23};
        Bubble_Sort(arr);
        System.out.println();
		
        Selection_Sort(arr);
        System.out.println();
		
        Insertion_Sort(arr);
        System.out.println();
		
        int[] res=Merge_Sort(arr,0,arr.length-1);
        for(int n:res){
          System.out.print(n+" ");
        }
        System.out.println();
		
        int[] ans=Quick_Sort(arr,0,arr.length-1);
        for(int n:ans){
          System.out.print(n+" ");
        }
        System.out.println();
		
        Counting_Sort(arr);
		
        //Bucket_Sort(arr,arr.length);
		
        System.out.println();
        Heap_Sort(arr);
		
        System.out.println();
        Shell_Sort(arr);
      }
      static void Shell_Sort(int[] arr){
        int n=arr.length;
        for (int interval = n / 2; interval > 0; interval /= 2) {
          for (int i = interval; i < n; i += 1) {
          int temp = arr[i];
          int j;
          for (j = i; j >= interval && arr[j - interval] > temp; j -= interval) {
            arr[j] = arr[j - interval];
          }
          arr[j] = temp;
          }
        }
        for(int nn:arr){
          System.out.print(nn+"---");
        }
      }
      static void Heap_Sort(int[] arr){
          int n = arr.length;
          // Build max heap
          for (int i = n / 2 - 1; i >= 0; i--) {
            heapify(arr, n, i);
          }
          // Heap sort
          for (int i = n - 1; i >= 0; i--) {
            int temp = arr[0];
            arr[0] = arr[i];
            arr[i] = temp;
      
            // Heapify root element
            heapify(arr, i, 0);
          }
          for(int nn:arr){
            System.out.print(nn+"--");
          }
      }
      static void heapify(int arr[], int n, int i) {
        // Find largest among root, left child and right child
        int largest = i;
        int l = 2 * i + 1;
        int r = 2 * i + 2;
    
        if (l < n && arr[l] > arr[largest])
          largest = l;
    
        if (r < n && arr[r] > arr[largest])
          largest = r;
    
        // Swap and continue heapifying if root is not largest
        if (largest != i) {
          int swap = arr[i];
          arr[i] = arr[largest];
          arr[largest] = swap;
    
          heapify(arr, n, largest);
        }
      }
      static void Bucket_Sort(int[] arr,int len){
        if(len<=0)return;
        //not working error
        ArrayList<Integer>[] bucket = new ArrayList[len];
        for (int i = 0; i < len; i++){
          bucket[i] = new ArrayList<Integer>();
        }
        for (int i = 0; i < len; i++) {
          int bucketIndex = (int) arr[i] * len;
          bucket[bucketIndex].add(arr[i]);
        }
        for (int i = 0; i < len; i++) {
          Collections.sort((bucket[i]));
        }
    
        int index = 0;
        for (int i = 0; i < len; i++) {
          for (int j = 0, size = bucket[i].size(); j < size; j++) {
            arr[index++] = bucket[i].get(j);
          }
        }
        for(int n:arr){
          System.out.print(n+"--");
        }
      }
      static void Counting_Sort(int[] arr){
          int[] res=new int[arr.length];
    
          int max=arr[0];
          for(int i=1;i< arr.length;i++){
            if(arr[i]>max){
              max=arr[i];
            }
          }
          int[] count = new int[max + 1];
          for (int i=0;i< max;i++) {
            count[i] = 0;
          }
          for (int i=0;i< arr.length;i++) {
            count[arr[i]]++;
          }
          for (int i=1;i<=max;i++) {
            count[i]+=count[i-1];
          }
          for (int i=arr.length-1;i>=0;i--) {
            res[count[arr[i]] - 1]=arr[i];
            count[arr[i]]--;
          }
          for (int i=0;i< arr.length;i++) {
            arr[i] = res[i];
          }
          for(int nn:arr){
            System.out.print(nn+"-");
          }
      }
      static int[] Quick_Sort(int[] arr,int lo,int hi){
          if(lo< hi){
            int pi=partition(arr,lo,hi);
            Quick_Sort(arr, lo, pi-1);
            Quick_Sort(arr,pi+1, hi);
          }
          return arr;  
      }
      static int partition(int[] arr,int lo,int hi){
        int pivot=arr[hi];
        int i=lo-1;
        for(int j=lo;j< hi;j++){
          if(arr[j]< pivot){
            i++;
            int temp = arr[i];
            arr[i] = arr[j];
            arr[j] = temp;
          }
        }
            int temp = arr[i + 1];
            arr[i + 1] = arr[hi];
            arr[hi] = temp;
    
            return(i+1);
      }
      static int[] Merge_Sort(int[] arr,int lo,int hi){
        if(lo==hi){
          int[] na=new int[1];
          na[0]=arr[lo];
          return na;
      }
          int mid=(lo+hi)/2;
          int[] leftside=Merge_Sort(arr, lo, mid);
          int[] righside=Merge_Sort(arr, mid+1, hi);
          int[] finalarray=mergetwoarray(leftside,righside);
          
          return finalarray;
      }
      static int[] mergetwoarray(int[] a1,int[] a2){
        int i=0,j=0,k=0;
        int[] res=new int[a1.length+a2.length];
        while(i< a1.length&&j< a2.length){
          if(a1[i]< a2[j]){
            res[k]=a1[i];
            k++;i++;
          }else{
            res[k]=a2[j];
            k++;j++;
          }
        }
        while(i< a1.length){
          res[k]=a1[i];
          k++;i++;
        }
        while(j< a2.length){
          res[k]=a2[j];
          k++;j++;
        }
        return res;
      }
      static void Insertion_Sort(int[] arr){
        for(int i=1;i< arr.length;i++){
          int key=arr[i];
          int j=i-1;
          while(j>=0&&key< arr[j]){
            arr[j+1]=arr[j];
            j--;
          }
          arr[j+1]=key;
        }
        for(int n:arr){
          System.out.print(n+" ");
        }
      }
      static void Selection_Sort(int[] arr){
        for(int i=0;i< arr.length;i++){
          int min_index=i;
          for(int j=i+1;j< arr.length;j++){
            if(arr[i]< arr[min_index]){
              min_index=i;
            }
          }
          int temp=arr[i];
          arr[i]=arr[min_index];
          arr[min_index]=temp;
        }
        for(int n:arr){
          System.out.print(n+" ");
        }
      }
      static void Bubble_Sort(int[] arr){
        for(int i=0;i< arr.length;i++){
          for(int j=0;j< arr.length;j++){
            if(arr[i]< arr[j]){
              int temp=arr[i];
              arr[i]=arr[j];
              arr[j]=temp;
            }
          }
        }
        for(int n:arr){
          System.out.print(n+" ");
        }
      }
    }

</div>
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">LEETCODE ----EASY----START</span>
<span class="textStyle">LEETCODE ----EASY----START</span>
<span class="textStyle">LEETCODE ----EASY----START</span>
<span class="textStyle">LEETCODE ----EASY----START</span>
<span class="textStyle">LEETCODE ----EASY----START</span>
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Question start of LeetCode Easy</span>
<span class="textStyle">Question start of LeetCode Easy</span>
<span class="textStyle">Question start of LeetCode Easy</span>
<span class="textStyle">Question start of LeetCode Easy</span>
<span class="textStyle">Question start of LeetCode Easy</span>
<span id="line">---------------------------------------------------------------</span>

<span class="textStyle">Q . 1-bit and 2-bit Characters</span>
Input: bits = [1,0,0]
Output: true
Explanation: The only way to decode it is two-bit character and one-bit character.
So the last character is one-bit character.
Input: bits = [1,1,1,0]
Output: false
Explanation: The only way to decode it is two-bit character and two-bit character.
So the last character is not one-bit character.
class Solution {
    public boolean isOneBitCharacter(int[] bits) {
        int i=0;
        int n=bits.length;
        while(i< n){
            if(i==n-1){
                return true;
            }else if(bits[i]==0){
                i++;
            }else{
                i=i+2;
            }
        }
        return false;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Q . Roman to Integer</span>
 Input: s = "III"
Output: 3
Explanation: III = 3.
class Solution {
    public int romanToInt(String s) {
        Map< Character,Integer> map=new HashMap<>();
        map.put('I',1);
        map.put('V',5);
        map.put('X',10);
        map.put('L',50);
        map.put('C',100);
        map.put('D',500);
        map.put('M',1000);
        
        int finalresult=map.get(s.charAt(s.length()-1));
        for(int i=s.length()-2;i>=0;i--){
            if(map.get(s.charAt(i))< map.get(s.charAt(i+1))){
                finalresult-=map.get(s.charAt(i));
            }else{
                finalresult+=map.get(s.charAt(i));
            }
        }
        return finalresult;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Q . Valid Parentheses</span>
 Input: s = "()"
Output: true
Input: s = "(]"
Output: false
class Solution {
    public boolean isValid(String s) {
        Map<Character, Character> hash = new HashMap<>();
        hash.put('(', ')');
        hash.put('{', '}');
        hash.put('[', ']');
        
        Stack<Character> stack = new Stack<>();
        
        for(int i=s.length()-1; i>=0; i--) {
            if(stack.isEmpty() || !stack.peek().equals(hash.get(s.charAt(i)))) {
                stack.push(s.charAt(i));
            }
            
            if(stack.peek().equals(hash.get(s.charAt(i)))) {
                stack.pop();
            }
        }
        
        return stack.isEmpty();
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Q . Merge Two Sorted Lists</span>
Input: list1 = [1,2,4], list2 = [1,3,4]
Output: [1,1,2,3,4,4]
Input: list1 = [], list2 = [0]
Output: [0]
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        ListNode temp=new ListNode(0);
        ListNode current=temp;
        while(l1!=null && l2!=null){
            if(l1.val<=l2.val){
                current.next=l1;
                l1=l1.next;
            }else{
                current.next=l2;
                l2=l2.next;
            }
            current=current.next;
        }
        current.next=l1!=null?l1:l2;
        return temp.next;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Q . Remove Element</span>
Input: nums = [3,2,2,3], val = 3
Output: 2, nums = [2,2,_,_]
Explanation: Your function should return k = 2, with the first two elements of nums being 2.
It does not matter what you leave beyond the returned k (hence they are underscores).
Input: nums = [0,1,2,2,3,0,4,2], val = 2
Output: 5, nums = [0,1,4,0,3,_,_,_]
class Solution {
    public int removeElement(int[] nums, int val) {
        if(nums.length==0)
            return 0;
        int valid_upto=0;
        for(int i=0;i< nums.length;i++){
            if(nums[i]!=val){
                nums[valid_upto]=nums[i];
                valid_upto++;
            }
        }
        return valid_upto;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Q . Search Insert Position</span>
 Input: nums = [1,3,5,6], target = 5
Output: 2
Input: nums = [1,3,5,6], target = 2
Output: 1
class Solution {
    public int searchInsert(int[] nums, int target) {
        int left=0,rigth=nums.length;
        while(left< rigth){
            int mid=left+(rigth-left)/2;
            if(nums[mid]==target){
                return mid;
            }else if(nums[mid]>target){
                rigth=mid;
            }else{
                left=mid+1;
            }
        }
        return left;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Q . Length of Last Word</span>
 Input: s = "Hello World"
Output: 5
Explanation: The last word is "World" with length 5.
class Solution {
    public int lengthOfLastWord(String s) {
        int n=s.length();
        int result=0;
        while(n>0){
            if(s.charAt(--n)!=' ') result++;
            else if(result>0) return result;
            
        }
        return result;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Q . Plus One</span>
Input: digits = [1,2,3]
Output: [1,2,4]
Explanation: The array represents the integer 123.
Incrementing by one gives 123 + 1 = 124.
Thus, the result should be [1,2,4].
Input: digits = [4,3,2,1]
Output: [4,3,2,2]
class Solution {
    public int[] plusOne(int[] digits) {
        int n=digits.length;
        for(int i=n-1;i>=0;i--){
            if(digits[i]< 9){
                digits[i]++;
                return digits;
            }
            digits[i]=0;
        }
        int[] newarray=new int[n+1];
        newarray[0]=1;
        return newarray;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Q . Add Binary</span>
Input: a = "11", b = "1"
Output: "100"
class Solution {
    public String addBinary(String a, String b) {
        StringBuilder sb=new StringBuilder();
        int i=a.length()-1;
        int j=b.length()-1;
        int carry=0;
        while(i>=0||j>=0){
            int sum=carry;
            if(i>=0)
                sum=sum+a.charAt(i)-'0';
            if(j>=0)
                sum=sum+b.charAt(j)-'0';
            sb.append(sum%2);
            carry=sum/2;
            i--;j--;
        }
        if(carry!=0)
            sb.append(carry);
        return sb.reverse().toString();
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Q . Sqrt(x)</span>
Input: x = 4
Output: 2
Input: x = 8
Output: 2
class Solution {
    public int mySqrt(int x) {
        long y=0;
        while(y*y<=x){
            y++;
        }
        return (int)y-1;
            
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Q . Climbing Stairs</span>
 Input: n = 2
Output: 2
Explanation: There are two ways to climb to the top.
1. 1 step + 1 step
2. 2 steps
Input: n = 3
Output: 3
class Solution {
    public int climbStairs(int n) {
        int[] dpvalue=new int[n+1];
        dpvalue[0]=1;
        dpvalue[1]=1;
        for(int i=2;i<=n;i++){
            dpvalue[i]=dpvalue[i-1]+dpvalue[i-2];
        }
        return dpvalue[n];
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Q . Remove Duplicates from Sorted List</span>
Input: head = [1,1,2]
Output: [1,2]
Input: head = [1,1,2,3,3]
Output: [1,2,3]
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode deleteDuplicates(ListNode head) {
        ListNode cn=head;
        while(cn!=null&&cn.next!=null){
            if(cn.next.val==cn.val){
                cn.next=cn.next.next;
            }else{
                cn=cn.next;
            }
        }
        return head;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Q . Convert Sorted Array to Binary Search Tree</span>
 Input: nums = [-10,-3,0,5,9]
Output: [0,-3,9,-10,null,5]
Explanation: [0,-10,5,null,-3,null,9] is also accepted:
Input: nums = [1,3]
Output: [3,1]
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public TreeNode sortedArrayToBST(int[] nums) {
        if(nums.length==0)
            return null;
        return maketree(nums,0,nums.length-1);
    }
    public TreeNode maketree(int[] nums,int left,int right){
        if(left>right)
            return null;
        int mid=left+(right-left)/2;
        TreeNode node=new TreeNode(nums[mid]);
        node.left=maketree(nums,left,mid-1);
        node.right=maketree(nums,mid+1,right);
        return node;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Q . Maximum Depth of Binary Tree</span>
Input: root = [3,9,20,null,null,15,7]
Output: 3
Input: root = [1,null,2]
Output: 2
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public int maxDepth(TreeNode root) {
        if(root==null)
            return 0;
        return 1+Math.max(maxDepth(root.left),maxDepth(root.right));
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Q . Symmetric Tree</span>
Input: root = [1,2,2,3,4,4,3]
Output: true
Input: root = [1,2,2,null,3,null,3]
Output: false
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public boolean isSymmetric(TreeNode root) {
        return ismirror_or_not(root,root);
    }
    public boolean ismirror_or_not(TreeNode root1,TreeNode root2){
        if(root1==null&&root2==null)
            return true;
        if(root1==null||root2==null)
            return false;
        return root1.val==root2.val&&ismirror_or_not(root1.left,root2.right)
                          &&ismirror_or_not(root1.right,root2.left);
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Q . Same Tree</span>
Input: p = [1,2,3], q = [1,2,3]
Output: true
Input: p = [1,2], q = [1,null,2]
Output: false
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public boolean isSameTree(TreeNode p, TreeNode q) {
        if(p==null&&q==null)
            return true;
        if(p==null||q==null)
            return false;
        if(p.val!=q.val)
            return false;
        return isSameTree(p.left,q.left)&&isSameTree(p.right,q.right);
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Q . Binary Tree Inorder Traversal</span>
Input: root = [1,null,2,3]
Output: [1,3,2]
Input: root = [1]
Output: [1]
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public List< Integer> inorderTraversal(TreeNode root) {
        Stack< TreeNode> stack=new Stack();
        List< Integer> r=new ArrayList<>();
        if(root==null)
            return r;
        TreeNode current=root;
        while(current!=null||!stack.isEmpty()){
            while(current!=null){
                stack.push(current);
                current=current.left;
            }
            current=stack.pop();
            r.add(current.val);
            current=current.right;
        }
        return r;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Q . Balanced Binary Tree</span>
Input: root = [3,9,20,null,null,15,7]
Output: true
Input: root = [1,2,2,3,3,null,null,4,4]
Output: false
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public boolean isBalanced(TreeNode root) {
        if(root==null) return true;
        if(Math.abs(getheight(root.left)-getheight(root.right))>1)
            return false;
        return isBalanced(root.left)&&isBalanced(root.right);
    }
    public int getheight(TreeNode node){
        if(node==null)
            return 0;
        return 1+Math.max(getheight(node.left),getheight(node.right));
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Q . Minimum Depth of Binary Tree</span>
Input: root = [3,9,20,null,null,15,7]
Output: 2
Input: root = [2,null,3,null,4,null,5,null,6]
Output: 5
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public int minDepth(TreeNode root) {
        if(root==null)
            return 0;
        Deque< TreeNode> q=new LinkedList<>();
        q.add(root);
        int count=0;
        while(!q.isEmpty()){
            int Size=q.size();
            count++;
            for(int i=0;i< Size;i++){
                TreeNode ns=q.poll();
                if(ns.left==null&&ns.right==null)
                    return count;
                if(ns.left!=null)
                    q.add(ns.left);
                if(ns.right!=null)
                    q.add(ns.right);
            }
        }
        return 0;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Q . Path Sum</span>
Input: root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22
Output: true
Explanation: The root-to-leaf path with the target sum is shown.
Input: root = [1,2,3], targetSum = 5
Output: false
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public boolean hasPathSum(TreeNode root, int targetSum) {
         if(root==null){
            return false;
        }
          if(root.left==null&&root.right==null){
            if(targetSum==root.val)return true;
            return false;
        }
          return hasPathSum(root.left,targetSum-root.val)||hasPathSum(root.right,targetSum-root.val);
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Q . Pascal's Triangle</span>
Input: numRows = 5
Output: [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]
class Solution {
    public List< List< Integer>> generate(int numRows) {
        List< List< Integer>> res=new ArrayList< List< Integer>>();
        List< Integer> row,previous=null;
        for(int i=0;i< numRows;i++){
            row=new ArrayList< Integer>();
            for(int j=0;j<=i;j++){
                if(j==0||j==i)
                    row.add(1);
                else
                    row.add(previous.get(j-1)+previous.get(j));
            }
            previous=row;
            res.add(row);
        }
        return res;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Q .  Pascal's Triangle II</span>
 Input: rowIndex = 3
Output: [1,3,3,1]
Input: rowIndex = 0
Output: [1]
class Solution {
    public List<Integer> getRow(int rowIndex) {
          List<Integer> res = new ArrayList<>();
	      long val = 1;
		   for(int i=0;i<=rowIndex;i++){
		        res.add((int)val);
		        val = val*(rowIndex-i)/(i+1);
		 }
		return res;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Q . Valid Palindrome</span>
Input: s = "A man, a plan, a canal: Panama"
Output: true
Explanation: "amanaplanacanalpanama" is a palindrome.
class Solution {
    public boolean isPalindrome(String s) {
       s = s.replaceAll("[^a-zA-Z0-9]", "");
		s = s.toLowerCase();
		int len = s.length();
		for (int i = 0; i < len / 2; i++) {
			if (s.charAt(i) != s.charAt(len-1-i))
				return false;
		}

		return true;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Q . Single Number</span>
Input: nums = [2,2,1]
Output: 1
Input: nums = [4,1,2,1,2]
Output: 4
class Solution {
    public int singleNumber(int[] nums) {
        int r=0;
        for(int i=0;i< nums.length;i++){
            r=r^nums[i];
        }
        return r;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Q . Best Time to Buy and Sell Stock</span>
Input: prices = [7,1,5,3,6,4]
Output: 5
Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.
Note that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell.
Input: prices = [7,6,4,3,1]
Output: 0
class Solution {
    public int maxProfit(int[] prices) {
        if(prices.length==0)
            return 0;
        int min=Integer.MAX_VALUE;
        int profit=0;
        for(int i=0;i< prices.length;i++){
            if(min>prices[i]){
                min=prices[i];
            }else if(profit< prices[i]-min){
                profit=prices[i]-min;
            }
        }
        return profit;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle"> Q . Binary Tree Postorder Traversal</span>
 Input: root = [1,null,2,3]
Output: [3,2,1]
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public List<Integer> postorderTraversal(TreeNode root) {
        return depthsearchfirst(root,new ArrayList());
    }
    public List<Integer> depthsearchfirst(TreeNode root,List<Integer> list){
        if(root==null)
            return list;
        list=depthsearchfirst(root.left,list);
        list=depthsearchfirst(root.right,list);
        list.add(root.val);
        return list;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Q . Binary Tree Preorder Traversal</span>
Input: root = [1,null,2,3]
Output: [1,2,3]
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> list=new ArrayList();
        Stack<TreeNode> stack=new Stack();
        while(!stack.isEmpty()||root!=null){
            while(root!=null){
                list.add(root.val);
                stack.push(root);
                root=root.left;
            }
            root=stack.pop();
            root=root.right;
        }
        return list;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Q . Linked List Cycle</span>
Input: head = [3,2,0,-4], pos = 1
Output: true
Explanation: There is a cycle in the linked list, where the tail connects to the 1st node (0-indexed).
Input: head = [1,2], pos = 0
Output: true
Explanation: There is a cycle in the linked list, where the tail connects to the 0th node.
/**
 * Definition for singly-linked list.
 * class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    public boolean hasCycle(ListNode head) {
        ListNode slow=head;
        ListNode fast=head;
        while(fast!=null&&fast.next!=null){
            fast=fast.next.next;
            slow=slow.next;
            if(slow==fast){
                return true;
            }
        }
        return false;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Q . Excel Sheet Column Number</span>
Input: columnTitle = "A"
Output: 1
Input: columnTitle = "AB"
Output: 28
class Solution {
    public int titleToNumber(String columnTitle) {
        int ans=0;
        for(int i:columnTitle.toCharArray()){
            ans=ans*26+(i-'A'+1);
        }
        return ans;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Q . Majority Element</span>
Input: nums = [3,2,3]
Output: 3
Input: nums = [2,2,1,1,1,2,2]
Output: 2
class Solution {
    public int majorityElement(int[] nums) {
        Integer finalelement=null;
        int count=0;
        for(int num:nums){
            if(count==0){
                finalelement=num;
            }
            count+=finalelement==num?1:-1;
        }
        return finalelement;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Q . Excel Sheet Column Title</span>
Input: columnNumber = 1
Output: "A"
Input: columnNumber = 28
Output: "AB"
class Solution {
    public String convertToTitle(int columnNumber) {
     StringBuilder sb=new StringBuilder();
        while(columnNumber>0){
            columnNumber--;
            sb.append((char)('A'+columnNumber%26));
            columnNumber=columnNumber/26;
        }
        return sb.reverse().toString();
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Q . Intersection of Two Linked Lists</span>
Input: intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA = 2, skipB = 3
Output: Intersected at '8'
Input: intersectVal = 2, listA = [1,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1
Output: Intersected at '2'
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        ListNode temp1=headA;
        ListNode temp2=headB;
        while(temp1!=temp2){
            temp1=temp1!=null?temp1.next:headB;
            temp2=temp2!=null?temp2.next:headA;
        }
        return temp1;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Q . Number of 1 Bits</span>
Input: n = 00000000000000000000000000001011
Output: 3
Explanation: The input binary string 00000000000000000000000000001011 has a total of three '1' bits.
Input: n = 00000000000000000000000010000000
Output: 1
Explanation: The input binary string 00000000000000000000000010000000 has a total of one '1' bit.
public class Solution {
    // you need to treat n as an unsigned value
    public int hammingWeight(int n) {
       int count=0;
        int mask=1;
        for(int i=0;i< 32;i++){
            if((n&mask)!=0){
                count++;
            }
            mask=mask<< 1;
        }
        return count;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Q . Reverse Bits</span>
Input: n = 00000010100101000001111010011100
Output:    964176192 (00111001011110000010100101000000)
Input: n = 11111111111111111111111111111101
Output:   3221225471 (10111111111111111111111111111111)
public class Solution {
    // you need treat n as an unsigned value
    public int reverseBits(int n) {
        int r=0;
        for(int i=0;i< 32;i++){
            r<<=1;
            if((n&1)>0){
                r++;
            }
            n>>=1;
        }
        return r;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Q . Isomorphic Strings</span>
Input: s = "egg", t = "add"
Output: true
Input: s = "foo", t = "bar"
Output: false
class Solution {
    public boolean isIsomorphic(String s, String t) {
        if(s.length()!=t.length()) return false;
        HashMap< Character,Character> map1=new HashMap<>();
        HashMap< Character,Boolean> map2=new HashMap<>();
        for(int i=0;i< s.length();i++){
            char c1=s.charAt(i);
            char c2=t.charAt(i);
            if(map1.containsKey(c1)==true){
                if(map1.get(c1)!=c2)
                    return false;
             } else{
                    if(map2.containsKey(c2)==true){
                        return false;
                    }else{
                        map1.put(c1,c2);
                        map2.put(c2,true);
                    }
                }
            }
        
        return true;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Q . Contains Duplicate II</span>
Input: nums = [1,2,3,1], k = 3
Output: true
Input: nums = [1,2,3,1,2,3], k = 2
Output: false
class Solution {
    public boolean containsNearbyDuplicate(int[] nums, int k) {
        Set<Integer> myset=new HashSet<>();
        for(int i=0;i< nums.length;i++){
            if(!myset.add(nums[i]))
                return true;
            if(myset.size()>k)
                myset.remove(nums[i-k]);
        }
        return false;
    }
}

<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Q . Reverse Linked List</span>
Input: head = [1,2,3,4,5]
Output: [5,4,3,2,1]
Input: head = [1,2]
Output: [2,1]
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode reverseList(ListNode head) {
        ListNode pre=null;
        while(head!=null){
            ListNode nextnode=head.next;
            head.next=pre;
            pre=head;
            head=nextnode;
        }
        return pre;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Q . Remove Linked List Elements</span>
Input: head = [1,2,6,3,4,5,6], val = 6
Output: [1,2,3,4,5]
Input: head = [7,7,7,7], val = 7
Output: []
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode removeElements(ListNode head, int val) {
        while(head!=null&&head.val==val){
            head=head.next;
        }
        ListNode current=head;
        while(current!=null&&current.next!=null){
            if(current.next.val==val){
                current.next=current.next.next;
            }
            else{
                current=current.next;
            }
        }
        return head;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Q . Happy Number</span>
Input: n = 19
Output: true
Explanation:
12 + 92 = 82
82 + 22 = 68
62 + 82 = 100
12 + 02 + 02 = 1
Input: n = 2
Output: false
class Solution {
    public boolean isHappy(int n) {
        HashSet<Integer> has=new HashSet<>();
        while(n!=1){
            int current=n;
            int sum=0;
            while(current!=0){
                sum=sum+(current%10)*(current%10);
                current/=10;                                
            }
            if(has.contains(sum))
                return false;
            has.add(sum);
            n=sum;
        }
        return true;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Q .  Valid Anagram</span>
 Input: s = "anagram", t = "nagaram"
Output: true
Input: s = "rat", t = "car"
Output: false
class Solution {
    public boolean isAnagram(String s, String t) {
        if(s.length()!=t.length())
            return false;
        int[] charcount=new int[26];
        for(int i=0;i< s.length();i++){
            charcount[s.charAt(i)-'a']++;
            charcount[t.charAt(i)-'a']--;
        }
        for(int count:charcount){
            if(count!=0)
                return false;
        }
        return true;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Q . Palindrome Linked List</span>
Input: head = [1,2,2,1]
Output: true
Input: head = [1,2]
Output: false
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public boolean isPalindrome(ListNode head) {
        ListNode fast=head;
        ListNode slow=head;
        while(fast.next!=null&&fast.next.next!=null){
            slow=slow.next;
            fast=fast.next.next;
        }
        if(fast!=null)
            slow=slow.next;
        ListNode r=reversefunction(slow);
        while(r!=null){
            if(r.val!=head.val)
                return false;
            else{
                r=r.next;
                head=head.next;
            }
        }
        return true;
    }
    public ListNode reversefunction(ListNode head){
        ListNode prev=null;
        while(head!=null){
            ListNode next=head.next;
            head.next=prev;
            prev=head;
            head=next;
        }
        return prev;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Q . Power of Two</span>
Input: n = 1
Output: true
Explanation: 20 = 1
Input: n = 16
Output: true
Explanation: 24 = 16
class Solution {
    public boolean isPowerOfTwo(int n) {
        return n>0&&(n&(n-1))==0;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Q . Implement Queue using Stacks</span>
Input
["MyQueue", "push", "push", "peek", "pop", "empty"]
[[], [1], [2], [], [], []]
Output
[null, null, null, 1, 1, false]
class MyQueue {

      Stack<Integer> input = new Stack();
      Stack<Integer> output = new Stack();
    /** Initialize your data structure here. */
    public MyQueue() {
        
    }
    
    /** Push element x to the back of queue. */
    public void push(int x) {
         input.push(x); 
    }
    
    /** Removes the element from in front of queue and returns that element. */
    public int pop() {
       if (output.empty())
            while (input.empty() == false)
            {
                output.push(input.peek());
                input.pop();     
            }
                

        int x = output.peek();
        output.pop(); 
        return x;   
    }
    
    /** Get the front element. */
    public int peek() {
         if (output.empty())
            while (input.empty() == false) {
                output.push(input.peek());
                input.pop();
            }    
        return output.peek(); 
    }
    
    /** Returns whether the queue is empty. */
    public boolean empty() {
         return input.empty() && output.empty();
    }
}

/**
 * Your MyQueue object will be instantiated and called as such:
 * MyQueue obj = new MyQueue();
 * obj.push(x);
 * int param_2 = obj.pop();
 * int param_3 = obj.peek();
 * boolean param_4 = obj.empty();
 */
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Q . Summary Ranges</span>
Input: nums = [0,1,2,4,5,7]
Output: ["0->2","4->5","7"]
Explanation: The ranges are:
[0,2] --> "0->2"
[4,5] --> "4->5"
[7,7] --> "7"
class Solution {
    public List<String> summaryRanges(int[] nums) {
        List<String> result=new ArrayList();
        int n=nums.length;
        if(n==0)
            return result;
        int a=nums[0];
        for(int i=0;i< n;i++){
            if(i==n-1||nums[i]+1!=nums[i+1]){
                if(nums[i]!=a)
                    result.add(a+"->"+nums[i]);
                else
                    result.add(a+"");
                if(i!=n-1)
                    a=nums[i+1];
            }
        }
        return result;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Q . Invert Binary Tree</span>
Input: root = [4,2,7,1,3,6,9]
Output: [4,7,2,9,6,3,1]
Input: root = [2,1,3]
Output: [2,3,1]
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public TreeNode invertTree(TreeNode root) {
       return function(root); 
    }
    public TreeNode function(TreeNode root){
        if(root==null)
            return null;
        TreeNode invertright=function(root.right);
        TreeNode invertleft=function(root.left);
        root.right=invertleft;
        root.left=invertright;
        return root;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Q . Add Digits</span>
Input: num = 38
Output: 2
Explanation: The process is
38 --> 3 + 8 --> 11
11 --> 1 + 1 --> 2 
Since 2 has only one digit, return it.
class Solution {
    public int addDigits(int num) {
        if(num==0)
            return 0;
        return num%9==0?9:num%9;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Q . Ugly Number</span>
Input: n = 6
Output: true
Explanation: 6 = 2 × 3
class Solution {
    public boolean isUgly(int n) {
        if(n< 1)
            return false;
        while(n%2==0)n/=2;
        while(n%3==0)n/=3;
        while(n%5==0)n/=5;
        return n==1;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Q . Missing Number</span>
Input: nums = [3,0,1]
Output: 2
Explanation: n = 3 since there are 3 numbers, so all numbers are in the range [0,3].
 2 is the missing number in the range since it does not appear in nums.
 class Solution {
    public int missingNumber(int[] nums) {
       return function1(nums);
    }
    public int function1(int[] nums){
         int sum1=0;
        for(int i:nums){
            sum1+=i;
        }
        int n=nums.length;
        int sumall=n*(n+1)/2;
        return sumall-sum1;
    }
    public int function2(int[] nums){
        int xorall=nums.length;
        for(int i=0;i< nums.length;i++){
            xorall^=i^nums[i];
        }
        return xorall;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Q . Word Pattern</span>
Input: pattern = "abba", s = "dog cat cat dog"
Output: true
class Solution {
    public boolean wordPattern(String pattern, String s) {
       String[] words=s.split(" ");
        if(words.length!=pattern.length())
            return false;
        HashMap<Character,String> map=new HashMap();
        for(int i=0;i< pattern.length();i++){
            char currentchar=pattern.charAt(i);
            if(map.containsKey(currentchar)){
                if(!map.get(currentchar).equals(words[i])){
                    return false;
                }
            }
            else{
                if(map.containsValue(words[i])){
                     return false;
                }
                   
                map.put(currentchar,words[i]);
            }
        }
        return true;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Q . Move Zeroes</span>
Input: nums = [0,1,0,3,12]
Output: [1,3,12,0,0]
class Solution {
    public void moveZeroes(int[] nums) {
       int i=0,j=0;
        while(j< nums.length){
            while(i< nums.length&&nums[i]!=0){
                i++;
            }
            if(i==nums.length)
                break;
            j=i+1;
            while(j< nums.length&&nums[j]==0){
                j++;
            }
            if(j==nums.length)
                break;
            int temp=nums[i];
            nums[i]=nums[j];
            nums[j]=temp;
            i++;
        }
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Q . Binary Tree Paths</span>
Input: root = [1,2,3,null,5]
Output: ["1->2->5","1->3"]
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public List<String> binaryTreePaths(TreeNode root) {
       List<String> result=new ArrayList();
        if(root==null)return result;
        String currentpath=Integer.toString(root.val);
        if(root.left==null&&root.right==null)
            result.add(currentpath);
        if(root.left!=null)
            dfs(root.left,currentpath,result);
         if(root.right!=null)
            dfs(root.right,currentpath,result);
        return result;
    }
    public void dfs(TreeNode node,String currentpath,List<String> result){
        currentpath+="->"+node.val;
        if(node.left==null&&node.right==null){
            result.add(currentpath);
            return;
        }
         if(node.left!=null)
            dfs(node.left,currentpath,result);
         if(node.right!=null)
            dfs(node.right,currentpath,result);
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Q . Power of Three</span>
Input: n = 27
Output: true
Explanation: 27 = 33
class Solution {
    public boolean isPowerOfThree(int n) {
        while(n>=3){
            if(n%3!=0)
                return false;
            n=n/3;
        }
        return n==1;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Q . Power of Four</span>
Input: n = 16
Output: true
class Solution {
    public boolean isPowerOfFour(int n) {
        double val=Math.log(n)/Math.log(4);
        double res=val-(int)val;
        return res==0.0;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Q . Reverse String</span>
Input: s = ["h","e","l","l","o"]
Output: ["o","l","l","e","h"]
class Solution {
    public void reverseString(char[] s) {
        int p1=0;
        int p2=s.length-1;
        while(p1< p2){
            char temp=s[p1];
            s[p1++]=s[p2];
            s[p2--]=temp;
        }
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Q . Reverse Vowels of a String</span>
Input: s = "hello"
Output: "holle"
class Solution {
    public String reverseVowels(String s) {
        Set<Character> vow=new HashSet<>();
        vow.add('A');
        vow.add('E');
        vow.add('I');
        vow.add('O');
        vow.add('U');
        vow.add('a');
        vow.add('e');
        vow.add('i');
        vow.add('o');
        vow.add('u');
        int i=0;
        int j=s.length()-1;
        char[] charcater=s.toCharArray();
        while(i< j){
            while(i< j&&!vow.contains(charcater[i])){
                i++;
            }
            while(i< j&&!vow.contains(charcater[j])){
                j--;
            }
            char temp=charcater[i];
            charcater[i++]=charcater[j];
            charcater[j--]=temp;
        }
        return new String(charcater);
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Q . Counting Bits</span>
 Input: n = 2
Output: [0,1,1]
Explanation:
0 --> 0
1 --> 1
2 --> 10
class Solution {
    public int[] countBits(int n) {
       int[] bitcount=new int[n+1];
        for(int i=1;i<=n;i++){
            bitcount[i]=bitcount[i>>1]+i%2;
        }
        return bitcount;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Q . Range Sum Query - Immutable</span>
class NumArray {
int[] dp;
    public NumArray(int[] nums) {
       int n=nums.length;
        dp=new int[n+1];
        dp[0]=0;
        for(int i=1;i<=n;i++){
            dp[i]=dp[i-1]+nums[i-1];
        }
        }
    
    public int sumRange(int left, int right) {
        return dp[right+1]-dp[left];
    }
}

/**
 * Your NumArray object will be instantiated and called as such:
 * NumArray obj = new NumArray(nums);
 * int param_1 = obj.sumRange(left,right);
 */
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Q . First Unique Character in a String</span>
Input: s = "leetcode"
Output: 0
Input: s = "loveleetcode"
Output: 2
class Solution {
    public int firstUniqChar(String s) {
        int count[]=new int[26];
        for(char c:s.toCharArray()){
           count[c-'a']+=1;
        }
        for(int i=0;i< s.length();i++){
             if(count[s.charAt(i)-'a']==1)
                return i;
        }
        return -1;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Q . Ransom Note</span>
Input: ransomNote = "a", magazine = "b"
Output: false
Input: ransomNote = "aa", magazine = "aab"
Output: true
class Solution {
    public boolean canConstruct(String ransomNote, String magazine) {
       Map< Character,Integer> map=new HashMap<>();
        for(char c:magazine.toCharArray()){
            if(map.containsKey(c)){
                int count=map.get(c)+1;
                map.put(c,count);
            }else{
                map.put(c,1);
            }
        }
            for(char c:ransomNote.toCharArray()){
                if(map.containsKey(c)==false)
                    return false;
                int count=map.get(c);
                if(count==0)
                    return false;
                map.put(c,count-1);
            }
            return true;
        
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Q . Guess Number Higher or Lower</span>
Input: n = 10, pick = 6
Output: 6
Input: n = 2, pick = 1
Output: 1
/** 
 * Forward declaration of guess API.
 * @param  num   your guess
 * @return 	     -1 if num is lower than the guess number
 *			      1 if num is higher than the guess number
 *               otherwise return 0
 * int guess(int num);
 */

public class Solution extends GuessGame {
    public int guessNumber(int n) {
        int low=1;
        int high=n;
        while(low<=high){
            int mid=low+(high-low)/2;
            if(guess(mid)==0){
                return mid;
            }else if(guess(mid)==-1){
                high=mid-1;
            }
            else{
                low=mid+1;
            }
        }
        return -1;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Q . Valid Perfect Square</span>
Input: num = 16
Output: true
Input: num = 14
Output: false
class Solution {
    public boolean isPerfectSquare(int num) {
        if(num==0)
            return false;
        int id=num%10;
        if(id==2||id==3||id==7||id==8)
            return false;
        int l=1;
        int r=num;
        while(l<=r){
            long mid=l+(r-l)/2;
            long sq=mid*mid;
            if(sq==num)
                return true;
            else if(sq< num)
                l=(int)mid+1;
            else
                r=(int)mid-1;
        }
        return false;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Q . Intersection of Two Arrays</span>
Input: nums1 = [1,2,2,1], nums2 = [2,2]
Output: [2]
Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4]
Output: [9,4]
Explanation: [4,9] is also accepted.
class Solution {
    public int[] intersection(int[] nums1, int[] nums2) {
        Set<Integer> set1=new HashSet();
        for(int  num:nums1){
            set1.add(num);
        }
         Set<Integer> set2=new HashSet();
        for(int  num:nums2){
            set2.add(num);
        }
        set1.retainAll(set2);
        int[] result=new int[set1.size()];
        int i=0;
        for(int num:set1){
            result[i++]=num;
        }
        return result;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Q . Intersection of Two Arrays II</span>
Input: nums1 = [1,2,2,1], nums2 = [2,2]
Output: [2,2]
Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4]
Output: [4,9]
Explanation: [9,4] is also accepted.
class Solution {
    public int[] intersect(int[] nums1, int[] nums2) {
        if(nums1.length>nums2.length){
            return intersect(nums2,nums1);
        }
        Map< Integer,Integer> map=new HashMap();
        for(int num:nums1){
            map.put(num,map.getOrDefault(num,0)+1);
        }
        List< Integer> list=new ArrayList();
        for(int num:nums2){
            int count=map.getOrDefault(num,0);
             if(count>0){
            list.add(num);
            map.put(num,count-1);
        }
        }
       int[] r=new int[list.size()];
        int i=0;
        for(int num:list){
            r[i++]=num;
        }
        return r;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Q . Find the Difference</span> 
 Input: s = "abcd", t = "abcde"
Output: "e"
Explanation: 'e' is the letter that was added.
Input: s = "", t = "y"
Output: "y"
class Solution {
    public char findTheDifference(String s, String t) {
        char c=0;
        for(char cs:s.toCharArray()){
            c^=cs;
        }
        for(char ct:t.toCharArray()){
            c^=ct;
        }
        return c;
    }
}

<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Q . Is Subsequence</span>
Input: s = "abc", t = "ahbgdc"
Output: true
Input: s = "axc", t = "ahbgdc"
Output: false
class Solution {
    public boolean isSubsequence(String s, String t) {
        if(s.length()==0)return true;
        if(t.length()==0)return false;
        if(s.charAt(0)==t.charAt(0))
            return isSubsequence(s.substring(1),t.substring(1));
        return isSubsequence(s,t.substring(1));
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Q . Sum of Left Leaves</span>
Input: root = [3,9,20,null,null,15,7]
Output: 24
Explanation: There are two left leaves in the binary tree, with values 9 and 15 respectively.
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    private boolean isleaf(TreeNode node){
        return node!=null&&node.left==null&&node.right==null;
    }
    public int sumOfLeftLeaves(TreeNode root) {
        if(root==null)
            return 0;
        int total=0;
        Deque< TreeNode> queue=new ArrayDeque<>();
        queue.push(root);
        while(!queue.isEmpty()){
            TreeNode subroot=queue.pop();
            if(isleaf(subroot.left)){
                total+=subroot.left.val;
            }
            if(subroot.right!=null){
                queue.push(subroot.right);
            }
            if(subroot.left!=null){
                queue.push(subroot.left);
            }
        }
        return total;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Q . Convert a Number to Hexadecimal</span>
Input: num = 26
Output: "1a"
class Solution {
 char[] map = {'0','1','2','3','4','5','6','7','8','9','a','b','c','d','e','f'};
    
    public String toHex(int num) {
        if(num == 0) return "0";
        String result = "";
        while(num != 0){
            result = map[(num & 15)] + result; 
            num = (num >>> 4);
        }
        return result;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Q . Longest Palindrome</span>
Input: s = "abccccdd"
Output: 7
Explanation: One longest palindrome that can be built is "dccaccd", whose length is 7.
class Solution {
    public int longestPalindrome(String s) {
       Map< Character,Integer> count=new HashMap();
        for(char c:s.toCharArray()){
            count.put(c,count.getOrDefault(c,0)+1);
           
        }
         int result=0;
            boolean addfound=false;
            for(int c:count.values()){
                if(c%2==0){
                    result+=c;
                }else{
                    addfound=true;
                    result+=c-1;
                }
            }
        if(addfound)
            result++;
        return result;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Q . Fizz Buzz</span>
Input: n = 3
Output: ["1","2","Fizz"]
Input: n = 5
Output: ["1","2","Fizz","4","Buzz"]
class Solution {
    public List< String> fizzBuzz(int n) {
        String[] result=new String[n];
        for(int i=1;i< n+1;i++){
            if(i%15==0)
                result[i-1]="FizzBuzz";
            else if(i%5==0)
                 result[i-1]="Buzz";
            else if(i%3==0)
                 result[i-1]="Fizz";
            else
                 result[i-1]=Integer.toString(i);
        }
        return Arrays.asList(result);
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Q . Third Maximum Number</span>
Input: nums = [3,2,1]
Output: 1
Explanation:
The first distinct maximum is 3.
The second distinct maximum is 2.
The third distinct maximum is 1.
class Solution {
    public int thirdMax(int[] nums) {
        Integer max=null;
        Integer secondmax=null;
        Integer thirdmax=null;
        
        for(Integer num:nums){
            
            if(num.equals(max)||num.equals(secondmax)||num.equals(thirdmax))
                continue;
            
            if(max==null||num>max){
                thirdmax=secondmax;
                secondmax=max;
                max=num;
            }else if(secondmax==null||num>secondmax){
                thirdmax=secondmax;
                secondmax=num;
                
            }else if(thirdmax==null||num>thirdmax){
                thirdmax=num;
               
            }
        }
        if(thirdmax==null)
            return max;
        return thirdmax;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Q . Add Strings</span>
Input: num1 = "11", num2 = "123"
Output: "134"
class Solution {
    public String addStrings(String num1, String num2) {
        String res="";
        int i=num1.length()-1;
        int j=num2.length()-1;
        int carry=0;
        while(i>=0||j>=0||carry!=0){
            int ival=i>=0?num1.charAt(i)-'0':0;
            int jval=j>=0?num2.charAt(j)-'0':0;
            i--;
            j--;
            int sum=ival+jval+carry;
            res=(sum%10)+res;
            carry=sum/10;
        }
        return res;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Q . Max Consecutive Ones</span>
Input: nums = [1,1,0,1,1,1]
Output: 3
Explanation: The first two digits or the last three digits are consecutive 1s.
 The maximum number of consecutive 1s is 3.
 class Solution {
    public int findMaxConsecutiveOnes(int[] nums) {
        int max=0;
        int current=0;
        for(int i=0;i< nums.length;i++){
            if(nums[i]==1){
                current+=1;
                max=Math.max(max,current);
            }else{
                current=0;
            }
        }
        return max;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Q . Number Complement</span>
Input: num = 5
Output: 2
Explanation: The binary representation of 5 is 101 (no leading zero bits),
 and its complement is 010. So you need to output 2.
 class Solution {
    public int findComplement(int num) {
        if(num==0)return 1;
        int numbit=(int)(Math.log(num)/Math.log(2))+1;
        int mask=(1<< numbit)-1;
        return num^mask;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Q . Island Perimeter</span>
Input: grid = [[0,1,0,0],[1,1,1,0],[0,1,0,0],[1,1,0,0]]
Output: 16
Explanation: The perimeter is the 16 yellow stripes in the image above.
Input: grid = [[1,0]]
Output: 4
class Solution {
    public int islandPerimeter(int[][] grid) {
        int p=0;
        int r=grid.length;
        int c=grid[0].length;
        for(int i=0;i< r;i++){
            for(int j=0;j< c;j++){
                if(grid[i][j]==0)
                    continue;
                p+=4;
                if(i>0)
                    p-=grid[i-1][j];
                if(j>0)
                    p-=grid[i][j-1];
                if(i< r-1)
                    p-=grid[i+1][j];
                if(j< c-1)
                    p-=grid[i][j+1];
            }
        }
        return p;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Q . Hamming Distance</span>
Input: x = 1, y = 4
Output: 2
Explanation:
1   (0 0 0 1)
4   (0 1 0 0)
       ↑   ↑
class Solution {
    public int hammingDistance(int x, int y) {
        int r=x^y;
        int count=0;
        while(r>0){
            count+=r&1;
            r>>=1;
        }
        return count;
    }
}	   
	   
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Q . Repeated Substring Pattern</span>
Input: s = "abab"
Output: true
Explanation: It is the substring "ab" twice.
Input: s = "aba"
Output: false
class Solution {
    public boolean repeatedSubstringPattern(String s) {
        int n=s.length();
        int[] lps=new int[n];
        for(int i=1;i< n;i++){
            int j=lps[i-1];
            while(j>0&&s.charAt(i)!=s.charAt(j))
                j=lps[j-1];
            if(s.charAt(i)==s.charAt(j))
                j++;
            lps[i]=j;
        }
        int l=lps[n-1];
        return (l!=0)&&(l%(n-l)==0);
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Q . Fibonacci Number</span>
Input: n = 2
Output: 1
Explanation: F(2) = F(1) + F(0) = 1 + 0 = 1
class Solution {
    int[] memo=new int[31];
    public int fib(int n) {
      // int r1=usingrecursion( n);
      //   return r1;
        int r2=usingmemo(n);
        return r2;
    }
    public  int usingmemo(int n){
       if(n==0)
           return 0;
        if(n==1)
            return 1;
        if(memo[n]>0)
            return memo[n];
        memo[n]=usingrecursion(n-1)+usingrecursion(n-2);
        return memo[n];
    }
    public static int usingrecursion(int n){
         if(n==0)
           return 0;
        if(n==1)
            return 1;
        int r=usingrecursion(n-1)+usingrecursion(n-2);
        return r;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Q . Relative Ranks</span>
Input: score = [5,4,3,2,1]
Output: ["Gold Medal","Silver Medal","Bronze Medal","4","5"]
Explanation: The placements are [1st, 2nd, 3rd, 4th, 5th].
Input: score = [10,3,8,9,4]
Output: ["Gold Medal","5","Bronze Medal","Silver Medal","4"]
Explanation: The placements are [1st, 5th, 3rd, 2nd, 4th].
class Solution {
    public String[] findRelativeRanks(int[] score) {
         int n=score.length;
          Map< Integer,Integer> map=new HashMap< Integer,Integer>();  
        for(int i=0;i< score.length;i++){
            map.put(score[i],i);
        }
        Arrays.sort(score);
        int start=0;
        int end=n-1;
        while(start< end){
            int temp=score[end];
            score[end]=score[start];
            score[start]=temp;
            start++;
            end--;
        }
        String []ans=new String[score.length];
        ans[map.get(score[0])]="Gold Medal";
        if(n>=2)
            ans[map.get(score[1])]="Silver Medal";
        if(n>=3)
          ans[map.get(score[2])]="Bronze Medal";
        if(n>4){
            for(int i=3;i< n;i++){
                int x=map.get(score[i]);
                ans[x]=String.valueOf(i+1);
            }
        }
        return ans;       
    } 
}

<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Q . Base 7</span>
Input: num = 100
Output: "202"
Input: num = -7
Output: "-10"
class Solution {
    public String convertToBase7(int num) {
        if(num==0)return "0";
        boolean isnegeative=num< 0;
        num=Math.abs(num);
        String ans="";
        while(num>0){
            ans=Integer.toString(num%7)+ans;
            num/=7;
        }
        if(isnegeative){
            ans="-"+ans;
        }
        return ans;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Q . Find Mode in Binary Search Tree</span>
Input: root = [1,null,2,2]
Output: [2]	
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    Integer prev=null;
    int count=1;
    int max=0;
    public int[] findMode(TreeNode root) {
        List<Integer> modes=new ArrayList();
        traverse(root,modes);
        int[] result=new int[modes.size()];
        for(int i=0;i< modes.size();i++){
            result[i]=modes.get(i);
        }
        return result;
    }
    public void traverse(TreeNode node,List<Integer> modes){
        if(node==null)return;
        traverse(node.left,modes);
        if(prev!=null){
            if(prev==node.val){
                count++;
            }else{
                count=1;
            }
        }
        if(count>max){
            max=count;
            modes.clear();
            modes.add(node.val);
        }else if(count==max){
            modes.add(node.val);
        }
        prev=node.val;
         traverse(node.right,modes);
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Q . Next Greater Element I</span>
Input: nums1 = [4,1,2], nums2 = [1,3,4,2]
Output: [-1,3,-1]
Explanation: The next greater element for each value of nums1 is as follows:
- 4 is underlined in nums2 = [1,3,4,2]. There is no next greater element, so the answer is -1.
- 1 is underlined in nums2 = [1,3,4,2]. The next greater element is 3.
- 2 is underlined in nums2 = [1,3,4,2]. There is no next greater element, so the answer is -1.
Input: nums1 = [2,4], nums2 = [1,2,3,4]
Output: [3,-1]
class Solution {
    public int[] nextGreaterElement(int[] nums1, int[] nums2) {
        HashMap< Integer,Integer> next=new HashMap();
        Stack< Integer> stack=new Stack();
        for(Integer num:nums2){
            while(!stack.isEmpty()&&stack.peek()< num){
                next.put(stack.pop(),num);
            }
            stack.push(num);
        }
        for(int i=0;i< nums1.length;i++){
            nums1[i]=next.getOrDefault(nums1[i],-1);
        }
        return nums1;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Q . Teemo Attacking</span>
Input: timeSeries = [1,4], duration = 2
Output: 4
Explanation: Teemo's attacks on Ashe go as follows:
- At second 1, Teemo attacks, and Ashe is poisoned for seconds 1 and 2.
- At second 4, Teemo attacks, and Ashe is poisoned for seconds 4 and 5.
Ashe is poisoned for seconds 1, 2, 4, and 5, which is 4 seconds in total.
class Solution {
    public int findPoisonedDuration(int[] timeSeries, int duration) {
        if(timeSeries.length==0)return 0;
        int total=0;
        for(int i=0;i< timeSeries.length-1;i++){
            total+=Math.min(timeSeries[i+1]-timeSeries[i],duration);
        }
        return total+duration;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Q . Construct the Rectangle</span>
Input: area = 4
Output: [2,2]
Explanation: The target area is 4, and all the possible ways to construct it are [1,4], [2,2], [4,1]. 
But according to requirement 2, [1,4] is illegal;
 according to requirement 3,  [4,1] is not optimal compared to [2,2].
 So the length L is 2, and the width W is 2.
 class Solution {
    public int[] constructRectangle(int area) {
     int x = (int) Math.sqrt(area);
        int l = area;
	while (x > 1) {
		if (area % x == 0) {
			l = area / x;
			break;
		}
		x--;
	}
	return new int[] {l, x};   
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Reshape the Matrix</span>
Input: mat = [[1,2],[3,4]], r = 1, c = 4
Output: [[1,2,3,4]]
Input: mat = [[1,2],[3,4]], r = 2, c = 4
Output: [[1,2],[3,4]]
class Solution {
    public int[][] matrixReshape(int[][] nums, int r, int c) {
        int row=nums.length;
        int columns=nums[0].length;
        if((row*columns)!=(r*c))return nums;
        int[][] output=new int[r][c];
        int rownum=0;
        int colnum=0;
        for(int i=0;i< row;i++){
            for(int j=0;j< columns;j++){
                output[rownum][colnum]=nums[i][j];
                colnum++;
                if(colnum==c){
                    colnum=0;
                    rownum++;
                }
            }
        }
        return output;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Array Partition</span>
Input: nums = [1,4,3,2]
Output: 4
Explanation: All possible pairings (ignoring the ordering of elements) are:
1. (1, 4), (2, 3) -> min(1, 4) + min(2, 3) = 1 + 2 = 3
2. (1, 3), (2, 4) -> min(1, 3) + min(2, 4) = 1 + 2 = 3
3. (1, 2), (3, 4) -> min(1, 2) + min(3, 4) = 1 + 3 = 4
So the maximum possible sum is 4.
Input: nums = [6,2,6,5,1,2]
Output: 9
Explanation: The optimal pairing is (2, 1), (2, 5), (6, 6).
 min(2, 1) + min(2, 5) + min(6, 6) = 1 + 2 + 6 = 9.
 class Solution {
    public int arrayPairSum(int[] nums) {
        Arrays.sort(nums);
        int sum=0;
        for(int i=0;i< nums.length-1;i+=2){
            sum+=nums[i];
        }
        return sum;
    }
}	
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Maximum Depth of N-ary Tree</span>
Input: root = [1,null,3,2,4,null,5,6]
Output: 3
Input: root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]
Output: 5
/*
// Definition for a Node.
class Node {
    public int val;
    public List<Node> children;

    public Node() {}

    public Node(int _val) {
        val = _val;
    }

    public Node(int _val, List<Node> _children) {
        val = _val;
        children = _children;
    }
};
*/

class Solution {
    public int maxDepth(Node root) {
        if(root==null)return 0;
        int depth=0;
        Queue<Node> q=new LinkedList();
        q.offer(root);
        while(!q.isEmpty()){
            int size=q.size();
            for(int i=0;i< size;i++){
                Node currentnode=q.poll();
                for(Node child:currentnode.children)
                  q.offer(child);
            }
              depth++;  
        }
        return depth++;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Diameter of Binary Tree</span>
Input: root = [1,2,3,4,5]
Output: 3
Explanation: 3 is the length of the path [4,2,1,3] or [5,2,1,3].
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {

    int ans=0;
    public int diameterOfBinaryTree(TreeNode root) {
       finddia(root);
        return ans==0?0:ans-1;
    }
    public int finddia(TreeNode root){
        if(root==null)return 0;
        int l=finddia(root.left);
        int r=finddia(root.right);
        ans=Math.max(ans,(l+r+1));
        return Math.max(l,r)+1;
    } 
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">N-ary Tree Preorder Traversal</span>
Input: root = [1,null,3,2,4,null,5,6]
Output: [1,3,5,6,2,4]
Input: root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]
Output: [1,2,3,6,7,11,14,4,8,12,5,9,13,10]
/*
// Definition for a Node.
class Node {
    public int val;
    public List<Node> children;

    public Node() {}

    public Node(int _val) {
        val = _val;
    }

    public Node(int _val, List<Node> _children) {
        val = _val;
        children = _children;
    }
};
*/

class Solution {
    List<Integer> result=new ArrayList<>();
    public List<Integer> preorder(Node root) {
       if(root==null)return result;
        Stack<Node> stack=new Stack();
        stack.push(root);
        while(!stack.isEmpty()){
            Node curr=stack.pop();
            result.add(curr.val);
            for(int i=curr.children.size()-1;i>=0;i--){
                stack.push(curr.children.get(i));
            }
        }
        return result;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">N-ary Tree Postorder Traversal</span>
 Input: root = [1,null,3,2,4,null,5,6]
Output: [5,6,3,2,4,1]
Input: root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]
Output: [2,6,14,11,7,3,12,8,4,13,9,10,5,1]
/*
// Definition for a Node.
class Node {
    public int val;
    public List<Node> children;

    public Node() {}

    public Node(int _val) {
        val = _val;
    }

    public Node(int _val, List<Node> _children) {
        val = _val;
        children = _children;
    }
};
*/

class Solution {
    public List<Integer> postorder(Node root) {
       LinkedList<Node> stack=new LinkedList<>();
       LinkedList<Integer> output=new LinkedList<>();
        if(root==null)return output;
        stack.add(root);
        while(!stack.isEmpty()){
            Node node=stack.pollLast();
            output.addFirst(node.val);
            for(Node child:node.children){
                stack.add(child);
            }
        }
        return output;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Can Place Flowers</span>
Input: flowerbed = [1,0,0,0,1], n = 1
Output: true
Input: flowerbed = [1,0,0,0,1], n = 2
Output: false
class Solution {
    public boolean canPlaceFlowers(int[] flowerbed, int n) {
        int count=0;
        for(int i=0;i< flowerbed.length;i++){
            if(flowerbed[i]==0){
                int p=(i==0)||flowerbed[i-1]==0?0:1;
                int next=(i==flowerbed.length-1)||flowerbed[i+1]==0?0:1;
                if(p==0&&next==0){
                    flowerbed[i]=1;
                    count++;
                }
            }
        }
        return count>=n;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Minimum Index Sum of Two Lists</span>
Input: list1 = ["Shogun","Tapioca Express","Burger King","KFC"], list2 = ["Piatti","The Grill at Torrey Pines","Hungry Hunter Steakhouse","Shogun"]
Output: ["Shogun"]
Explanation: The only common string is "Shogun".
Input: list1 = ["happy","sad","good"], list2 = ["sad","happy","good"]
Output: ["sad","happy"]
Explanation: There are three common strings:
"happy" with index sum = (0 + 1) = 1.
"sad" with index sum = (1 + 0) = 1.
"good" with index sum = (2 + 2) = 4.
The strings with the least index sum are "sad" and "happy".
class Solution {
    public String[] findRestaurant(String[] list1, String[] list2) {
       ArrayList<Integer> a=new ArrayList();
       ArrayList<String> b=new ArrayList();
       int temp=0;
        for(int i=0;i< list1.length;i++){
            for(int j=0;j< list2.length;j++){
                if(list1[i].compareTo(list2[j])==0){
                    temp=i+j;
                    a.add(temp);
                    b.add(list1[i]);
                }
                temp=0;
            }
        }
        int min=Collections.min(a);
        ArrayList<String> result=new ArrayList();
        for(int i=0;i< a.size();i++){
            if(a.get(i)==min)
                result.add(b.get(i));
        }
        String mainresult[]=new String[result.size()];
        for(int i=0;i< result.size();i++)
            mainresult[i]=result.get(i);
        return mainresult;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Longest Harmonious Subsequence</span>
Input: nums = [1,3,2,2,5,2,3,7]
Output: 5
Explanation: The longest harmonious subsequence is [3,2,2,2,3].
Input: nums = [1,2,3,4]
Output: 2
class Solution {
    public int findLHS(int[] nums) {
      //int r=timeisNlogN(nums); 
        int r2=usinghashmap(nums);
        return r2;
    }
    public int usinghashmap(int[] nums){
        int res=0;
        Map<Integer,Integer> count=new HashMap();
        for(int i:nums){
            count.put(i,count.getOrDefault(i,0)+1);
        }
        for(int i:count.keySet()){
            if(count.containsKey(i+1)){
                res=Math.max(res,count.get(i)+count.get(i+1));
            }
        }
        return res;
    }
    public int timeisNlogN(int[] nums){
        Arrays.sort(nums);
        int left=0;
        int rigth=1;
        int result=0;
        while(rigth< nums.length){
            int diff=nums[rigth]-nums[left];
            if(diff==1){
                result=Math.max(result,rigth-left+1);
            }
            if(diff<=1)
                rigth++;
            else
                left++;
        }
        return result;
    }
}


<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Robot Return to Origin</span>
Input: moves = "UD"
Output: true
Input: moves = "LL"
Output: false
class Solution {
    public boolean judgeCircle(String moves) {
      int x=0,y=0;
        for(char m:moves.toCharArray()){
            if(m =='U'){
                y+=1;
            }else if(m=='D'){
                y-=1;
            }else if(m=='L'){
                x-=1;
            }else if(m=='R'){
                x+=1;
            }
        }
        return (x==0&&y==0);
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Two Sum IV - Input is a BST</span>
Input: root = [5,3,6,2,4,null,7], k = 9
Output: true
Input: root = [5,3,6,2,4,null,7], k = 28
Output: false
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public boolean findTarget(TreeNode root, int k) {
       Set<Integer> set=new HashSet<>();
        return preorder(root,set,k);
    }
    public boolean preorder(TreeNode root,Set<Integer> set,int k){
        if(root==null)return false;
        int element=k-root.val;
        if(set.contains(element))return true;
        set.add(root.val);
        return preorder(root.left,set,k)||preorder(root.right,set,k);
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Merge Two Binary Trees</span>
Input: root1 = [1,3,2,5], root2 = [2,1,3,null,4,null,7]
Output: [3,4,5,5,4,null,7]
Input: root1 = [1], root2 = [1,2]
Output: [2,2]
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public TreeNode mergeTrees(TreeNode root1, TreeNode root2) {
        return  merged( root1,  root2);
    }
    public TreeNode merged(TreeNode root1, TreeNode root2){
        if(root1==null&root2==null)
            return null;
        if(root1!=null&&root2==null)return root1;
        if(root1==null&&root2!=null)return root2;
        TreeNode sum=new TreeNode(root1.val+root2.val);
        sum.left=merged(root1.left,root2.left);
        sum.right=merged(root1.right,root2.right);
        return sum;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Set Mismatch</span>
Input: nums = [1,2,2,4]
Output: [2,3]
class Solution {
    public int[] findErrorNums(int[] nums) {
       int[] arr=new int[nums.length];
        int[] res=new int[2];
        for(int i:nums)
            arr[i-1]++;
        for(int i=0;i< arr.length;i++){
            if(arr[i]==2)
                res[0]=i+1;
            if(arr[i]==0)
                res[1]=i+1;
        }
        return res;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Average of Levels in Binary Tree</span>
Input: root = [3,9,20,null,null,15,7]
Output: [3.00000,14.50000,11.00000]
Explanation: The average value of nodes on level 0 is 3, on level 1 is 14.5, and on level 2 is 11.
Hence return [3, 14.5, 11].
Input: root = [3,9,20,15,7]
Output: [3.00000,14.50000,11.00000]
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public List<Double> averageOfLevels(TreeNode root) {
        List<Double> result=new ArrayList<>();
        Queue<TreeNode> q=new LinkedList<>();
        q.add(root);
        while(!q.isEmpty()){
            int size=q.size();
            long sum=0;
            for(int i=0;i< size;i++){
                TreeNode curr=q.poll();
                sum+=curr.val;
                if(curr.left!=null)
                    q.add(curr.left);
                if(curr.right!=null)
                    q.add(curr.right);
            }
            result.add((double)sum/size);
        }
        return result;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Maximum Product of Three Numbers</span>
Input: nums = [1,2,3]
Output: 6
Input: nums = [1,2,3,4]
Output: 24
class Solution {
    public int maximumProduct(int[] nums) {
       
      int min1=Integer.MAX_VALUE;
        int min2=min1;
        int max1=Integer.MIN_VALUE;
        int max2=max1;
        int max3=max1;
        for(int i=0;i< nums.length;i++){
            int val=nums[i];
            if(val>=max1){
                max3=max2;
                max2=max1;
                max1=val;
            }else if(val>=max2){
                max3=max2;
                max2=val;
            }else if(val>=max3){
                max3=val;
            }
            if(val<=min1){
                min2=min1;
                min1=val;
            }else if(val< min2){
                min2=val;
            }
        }
        return Math.max(min1*min2*max1,max1*max2*max3);
            
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Valid Palindrome II</span>
Given a string s, return true if the s can be palindrome after deleting at most one character from it.
Input: s = "aba"
Output: true
Input: s = "abca"
Output: true
Explanation: You could delete the character 'c'.
class Solution {
    public boolean validPalindrome(String s) {
        int i=0;
        int j=s.length()-1;
        while(i< j){
            if(s.charAt(i)==s.charAt(j)){
                i++;j--;
            }else{
                return isplain(s,i+1,j)||isplain(s,i,j-1);
            }
        }
        return true;
    }
    public boolean isplain(String s,int i,int j){
        while(i< j){
            if(s.charAt(i)==s.charAt(j)){
                i++;j--;
            }else{
                return false;
            } 
        }
        return true;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Search in a Binary Search Tree</span> 
 Input: root = [4,2,7,1,3], val = 2
Output: [2,1,3]
Input: root = [4,2,7,1,3], val = 5
Output: []
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public TreeNode searchBST(TreeNode root, int val) {
       if(root==null)return root;
        if(root.val==val)return root;
        if(val< root.val){
            return searchBST( root.left,  val);
        }else{
             return searchBST( root.right,  val);
        }
            
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Count Binary Substrings</span>
Input: s = "00110011"
Output: 6
Explanation: There are 6 substrings that have equal number of consecutive 1's and 0's:
 "0011", "01", "1100", "10", "0011", and "01".
Notice that some of these substrings repeat and are counted the number of times they occur.
Also, "00110011" is not a valid substring because all the 0's (and 1's) are not grouped together.
Input: s = "10101"
Output: 4
Explanation: There are 4 substrings: "10", "01", "10", "01" 
that have equal number of consecutive 1's and 0's.
class Solution {
    public int countBinarySubstrings(String s) {
       int count=0,i=1,prev=0,curr=1;
        while(i< s.length()){
            if(s.charAt(i-1)!=s.charAt(i)){
                count+=Math.min(prev,curr);
                prev=curr;
                curr=1;
            }else{
                curr++;
                
            }
            i++;
        }
        return count+=Math.min(prev,curr); 
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Binary Number with Alternating Bits</span>
Input: n = 5
Output: true
Explanation: The binary representation of 5 is: 101
Input: n = 7
Output: false
Explanation: The binary representation of 7 is: 111.
class Solution {
    public boolean hasAlternatingBits(int n) {
        int last=n%2;
        n>>=1;
        while(n>0){
            int curr=n%2;
            if(curr==last)
                return false;
            last=curr;
            n>>=1;
        }
        return true;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Maximum Average Subarray I</span>
Input: nums = [1,12,-5,-6,50,3], k = 4
Output: 12.75000
Explanation: Maximum average is (12 - 5 - 6 + 50) / 4 = 51 / 4 = 12.75
Input: nums = [5], k = 1
Output: 5.00000
class Solution {
    public double findMaxAverage(int[] nums, int k) {
       int sum=0;
        for(int i=0;i< k;i++){
            sum+=nums[i];
        }
        int max=sum;
        for(int i=k;i< nums.length;i++){
             sum-=nums[i-k];
            sum+=nums[i];
           
            max=Math.max(max,sum);
        }
        return (max*1.0)/k;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Second Minimum Node In a Binary Tree</span>
Input: root = [2,2,5,null,null,5,7]
Output: 5
Explanation: The smallest value is 2, the second smallest value is 5.
Input: root = [2,2,2]
Output: -1
Explanation: The smallest value is 2, but there isn't any second smallest value.
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public int findSecondMinimumValue(TreeNode root) {
       if(root==null)return -1;
        if(root.left==null&&root.right==null)return -1;
        int left=root.left.val;
        int right=root.right.val;
        if(root.val==root.left.val)
            left=findSecondMinimumValue(root.left);
        if(root.val==root.right.val)
             right=findSecondMinimumValue(root.right);
        if(left!=-1&&right!=-1)
            return Math.min(left,right);
        else if(left!=-1)
            return left;
        else
            return right;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Longest Continuous Increasing Subsequence</span>
Input: nums = [1,3,5,4,7]
Output: 3
Explanation: The longest continuous increasing subsequence is [1,3,5] with length 3.
Even though [1,3,5,7] is an increasing subsequence,
 it is not continuous as elements 5 and 7 are separated by element
4.
Input: nums = [2,2,2,2,2]
Output: 1
Explanation: The longest continuous increasing subsequence is [2] with length 1.
 Note that it must be strictly increasing.
 class Solution {
    public int findLengthOfLCIS(int[] nums) {
      int r=0;
        int t=0;
        for(int i=0;i< nums.length;i++){
            if(i>0&&nums[i-1]>=nums[i])
                t=i;
            r=Math.max(r,i-t+1);
        }
        return r;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Find Pivot Index</span>
Input: nums = [1,7,3,6,5,6]
Output: 3
Explanation:
The pivot index is 3.
Left sum = nums[0] + nums[1] + nums[2] = 1 + 7 + 3 = 11
Right sum = nums[4] + nums[5] = 5 + 6 = 11
Input: nums = [1,2,3]
Output: -1
Explanation:
There is no index that satisfies the conditions in the problem statement.
class Solution {
    public int pivotIndex(int[] num) {
       int sum=0;
        for(int i=0;i< num.length;i++){
            sum+=num[i];
        }
        int lsum=0;
        int rsum=sum;
        for(int i=0;i< num.length;i++){
            rsum=rsum-num[i];
            if(lsum==rsum)
                return i;
            lsum+=num[i];
        }
        return -1;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Self Dividing Numbers</span>
Input: left = 1, right = 22
Output: [1,2,3,4,5,6,7,8,9,11,12,15,22]
Input: left = 47, right = 85
Output: [48,55,66,77]
class Solution {
    public List<Integer> selfDividingNumbers(int left, int right) {
       List<Integer> res=new ArrayList();
        for(int i=left;i<=right;i++){
            if(possible(i))
                res.add(i);
        }
       return res;
    }
     public boolean possible(int n){
            for(char c:String.valueOf(n).toCharArray()){
                if(c=='0'||n%(c-'0')>0)
                  return false;
            }
            return true;
        }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Find Smallest Letter Greater Than Target</span>
Input: letters = ["c","f","j"], target = "a"
Output: "c"
Input: letters = ["c","f","j"], target = "d"
Output: "f"
class Solution {
    public char nextGreatestLetter(char[] letters, char target) {
       int n=letters.length;
        if(letters[n-1]<=target||target< letters[0])
            return letters[0];
        int l=0,r=n-1;
        while(l+1< r){
            int mid=l+(r-l)/2;
            if(letters[mid]<=target){
                l=mid;
            }else{
                r=mid;
            }
        }
        return letters[r];
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Toeplitz Matrix</span>
Input: matrix = [[1,2,3,4],[5,1,2,3],[9,5,1,2]]
Output: true
Explanation:
In the above grid, the diagonals are:
"[9]", "[5, 5]", "[1, 1, 1]", "[2, 2, 2]", "[3, 3]", "[4]".
In each diagonal all elements are the same, so the answer is True.
Input: matrix = [[1,2],[2,2]]
Output: false
Explanation:
The diagonal "[1, 2]" has different elements.	
class Solution {
    public boolean isToeplitzMatrix(int[][] matrix) {
       for(int i=1;i< matrix.length;i++){
           for(int j=1;j< matrix[i].length;j++){
               if(matrix[i][j]!=matrix[i-1][j-1])
                   return false;
           }
       } 
        return true;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Jewels and Stones</span>
Input: jewels = "aA", stones = "aAAbbbb"
Output: 3
Input: jewels = "z", stones = "ZZ"
Output: 0
class Solution {
    public int numJewelsInStones(String jewels, String stones) {
       Set<Character> j=new HashSet<>();
        for(char c:jewels.toCharArray())
            j.add(c);
        int co=0;
        for(char c:stones.toCharArray())
            if(j.contains(c))
                co++;
        return co;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Backspace String Compare</span>
Input: s = "ab#c", t = "ad#c"
Output: true
Explanation: Both s and t become "ac".
Input: s = "ab##", t = "c#d#"
Output: true
Explanation: Both s and t become "".
class Solution {
    public boolean backspaceCompare(String s, String t) {
       int ss=s.length()-1;
       int tt=t.length()-1;
        int sskip=0;
        int tskip=0;
        while(ss>=0||tt>=0){
            while(ss>=0){
                if(s.charAt(ss)=='#'){
                    sskip+=1;
                    ss-=1;
                }else if(sskip>0){
                    ss-=1;
                    sskip-=1;
                }else{
                    break;
                }
            }
             while(tt>=0){
                if(t.charAt(tt)=='#'){
                    tskip+=1;
                    tt-=1;
                }else if(tskip>0){
                    tt-=1;
                    tskip-=1;
                }else{
                    break;
                }
            }
            if(ss>=0&&tt>=0&&s.charAt(ss)!=t.charAt(tt))
                return false;
            if(ss>=0!=tt>=0)
                return false;
            ss-=1;
            tt-=1;
            
        }
        return true;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Rectangle Overlap</span>
Input: rec1 = [0,0,2,2], rec2 = [1,1,3,3]
Output: true
Input: rec1 = [0,0,1,1], rec2 = [1,0,2,1]
Output: false
class Solution {
    public boolean isRectangleOverlap(int[] r1, int[] r2) {
       return r1[0]< r2[2]&&r1[1]< r2[3]&&r2[0]< r1[2]&&r2[1]< r1[3]; 
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Flipping an Image</span>
Input: image = [[1,1,0],[1,0,1],[0,0,0]]
Output: [[1,0,0],[0,1,0],[1,1,1]]
Explanation: First reverse each row: [[0,1,1],[1,0,1],[0,0,0]].
Then, invert the image: [[1,0,0],[0,1,0],[1,1,1]]
Input: image = [[1,1,0,0],[1,0,0,1],[0,1,1,1],[1,0,1,0]]
Output: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]
Explanation: First reverse each row: [[0,0,1,1],[1,0,0,1],[1,1,1,0],[0,1,0,1]].
Then invert the image: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]
class Solution {
    public int[][] flipAndInvertImage(int[][] im) {
       int n=im.length;
        for(int i=0;i< n;i++){
            int left=0;
            int right=n-1;
            while(left<=right){
                int temp=im[i][left]>0?0:1;
                im[i][left]=im[i][right]>0?0:1;
                im[i][right]=temp;
                left++;
                right--;
            }
        }
        return im;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Positions of Large Groups</span>
Input: s = "abbxxxxzzy"
Output: [[3,6]]
Explanation: "xxxx" is the only large group with start index 3 and end index 6.
Input: s = "abcdddeeeeaabbbcd"
Output: [[3,5],[6,9],[12,14]]
Explanation: The large groups are "ddd", "eeee", and "bbb".
class Solution {
    public List<List<Integer>> largeGroupPositions(String s) {
      List<List<Integer>> ans = new ArrayList();
		
        for (int i = 0; i < s.length() - 1; i++) {
            int start = i;
            int j = i + 1;
            int length = 1;
            while (j < s.length() && s.charAt(i) == s.charAt(j)) {
                length++;
                j++;
            }
            if (length >= 3) {
                List<Integer> mychar = new ArrayList();
                mychar.add(start);
                mychar.add(start + length - 1);
                ans.add(mychar);
                i += length - 1;
            }
        }
        return ans;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Shortest Distance to a Character</span>
Input: s = "loveleetcode", c = "e"
Output: [3,2,1,0,1,0,0,1,2,2,1,0]
Explanation: The character 'e' appears at indices 3, 5, 6, and 11 (0-indexed).
The closest occurrence of 'e' for index 0 is at index 3, so the distance is abs(0 - 3) = 3.
The closest occurrence of 'e' for index 1 is at index 3, so the distance is abs(1 - 3) = 2.
For index 4, there is a tie between the 'e' at index 3 and the 'e' at index 5, but the distance is still the same: abs(4 - 3) == abs(4 - 5) = 1.
The closest occurrence of 'e' for index 8 is at index 6, so the distance is abs(8 - 6) = 2.
Input: s = "aaab", c = "b"
Output: [3,2,1,0]
class Solution {
    public int[] shortestToChar(String s, char c) {
       List<Integer> l=new ArrayList();
        int n=s.length();
        l.add(-10000);
        for(int i=0;i< n;i++){
            if(s.charAt(i)==c){
                l.add(i);
            }
        }
        l.add(Integer.MAX_VALUE);
        int[] res=new int[n];
        int first=l.get(0);
        int sec=l.get(1);
        int k=2;
        for(int i=0;i< n;i++){
            if(s.charAt(i)!=c){
               res[i]=Math.min(i-first,sec-i); 
            }else{
                first=sec;
                sec=l.get(k++);
            }
        }
        return res;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Most Common Word</span>
Input: paragraph = "Bob hit a ball, the hit BALL flew far after it was hit.",
 banned = ["hit"]
Output: "ball"
Input: paragraph = "a.", banned = []
Output: "a"
class Solution {
    public String mostCommonWord(String paragraph, String[] banned) {
        HashSet<String> bann=new HashSet();
        HashMap<String,Integer> vaild=new HashMap<>();
        
        for(String banned_:banned){
            bann.add(banned_);
        }
        String[] words=paragraph.toLowerCase().split("\\W+");
        for(String word:words){
           if(!bann.contains(word)){
              // vaild.put(word,valid.getOrDefault(word,0)+1);
               vaild.put(word,vaild.getOrDefault(word,0)+1);
           }
        }
        int max=0;
        String result="";
        for(String word:vaild.keySet()){
            if(vaild.get(word)>max){
                max=vaild.get(word);
                result=word;
            }
        }
        return result;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Rotate String</span>
Input: s = "abcde", goal = "cdeab"
Output: true
Input: s = "abcde", goal = "abced"
Output: false
class Solution {
    public boolean rotateString(String s, String goal) {
                               //"abcde"   "cdeab"    

       return s.length()==goal.length()&&(s+s).contains(goal); 
        
    }
}

<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Middle of the Linked List</span>
Input: head = [1,2,3,4,5]
Output: [3,4,5]
Explanation: The middle node of the list is node 3.
Input: head = [1,2,3,4,5,6]
Output: [4,5,6]
Explanation: Since the list has two middle nodes with values 3 and 4, we return the second one.
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode middleNode(ListNode head) {
       ListNode a=head;
         ListNode b=head;
        while(b!=null&&b.next!=null){
            a=a.next;
            b=b.next.next;
        }
        return a;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Leaf-Similar Trees</span>
Input: root1 = [3,5,1,6,2,9,8,null,null,7,4], root2 = [3,5,1,6,7,4,2,null,null,null,null,null,null,9,8]
Output: true
Input: root1 = [1,2,3], root2 = [1,3,2]
Output: false
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public boolean leafSimilar(TreeNode root1, TreeNode root2) {
        List<Integer> l1=new ArrayList();
        List<Integer> l2=new ArrayList();
        dfs(l1,root1);
        dfs(l2,root2);
        return l1.equals(l2);
    }
    public void dfs(List<Integer> iv,TreeNode root){
        if(root==null)
            return;
        if(root.left==null&&root.right==null)
            iv.add(root.val);
        dfs(iv,root.left);
        dfs(iv,root.right);
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Uncommon Words from Two Sentences</span>
Input: s1 = "this apple is sweet", s2 = "this apple is sour"
Output: ["sweet","sour"]
Input: s1 = "apple apple", s2 = "banana"
Output: ["banana"]
class Solution {
    public String[] uncommonFromSentences(String s1, String s2) {
       String[] a=s1.split(" ");
        String[] b=s2.split(" ");
        
        Map< String,Integer> map=new HashMap<>();
        for(String s:a){
            if(!map.containsKey(s)){
                map.put(s,1);
            }else{
                map.put(s,map.get(s)+1);
            }
        }
        ////
        for(String s:b){
            if(!map.containsKey(s)){
                map.put(s,1);
            }else{
                map.put(s,map.get(s)+1);
            }
        }
        List<String> list=new ArrayList();
        for(String s:map.keySet()){
            if(map.get(s)==1){
                list.add(s);
            }
        }
        return list.toArray(new String[list.size()]);
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Transpose Matrix</span>
Input: matrix = [[1,2,3],[4,5,6],[7,8,9]]
Output: [[1,4,7],[2,5,8],[3,6,9]]
Input: matrix = [[1,2,3],[4,5,6]]
Output: [[1,4],[2,5],[3,6]]
class Solution {
    public int[][] transpose(int[][] matrix) {
        int r=matrix.length;
        int c=matrix[0].length;
        int[][] mymatrix=new int[c][r];
        for(int i=0;i< r;i++){
            for(int j=0;j< c;j++){
                mymatrix[j][i]=matrix[i][j];
            }
        }
        return mymatrix;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Lemonade Change</span>
Input: bills = [5,5,5,10,20]
Output: true
Explanation: 
From the first 3 customers, we collect three $5 bills in order.
From the fourth customer, we collect a $10 bill and give back a $5.
From the fifth customer, we give a $10 bill and a $5 bill.
Since all customers got correct change, we output true.
Input: bills = [5,5,10,10,20]
Output: false
class Solution {
    public boolean lemonadeChange(int[] bills) {
        int f=0;
        int t=0;
        for(Integer bill:bills){
            if(bill==5){
                f++;
            }else if(bill==10){
                t++;
                f--;
            }else if(t>0){
                t--;
                f--;
            }else{
                f-=3;
            }
            if(f< 0)
                return false;
        }
        
        return true;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Reverse Only Letters</span>
Input: s = "ab-cd"
Output: "dc-ba"
Input: s = "a-bC-dEf-ghIj"
Output: "j-Ih-gfE-dCba"
class Solution {
    public String reverseOnlyLetters(String s) {
        Stack<Character> letter=new Stack();
        for(int i=0;i< s.length();i++){
            if(Character.isLetter(s.charAt(i))){
                letter.push(s.charAt(i));
            }
        }
        StringBuilder sb=new StringBuilder();
        for(int i=0;i< s.length();i++){
            if(Character.isLetter(s.charAt(i))){
                sb.append((letter.pop()));
            }else{
                sb.append(s.charAt(i));
            }
        }
        return sb.toString();
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">X of a Kind in a Deck of Cards</span>
Input: deck = [1,2,3,4,4,3,2,1]
Output: true
Explanation: Possible partition [1,1],[2,2],[3,3],[4,4].
Input: deck = [1,1,1,2,2,2,3,3]
Output: false
Explanation: No possible partition.
class Solution {
    public boolean hasGroupsSizeX(int[] deck) {
       if(deck.length<=1)
           return false;
        HashMap<Integer,Integer> map=new HashMap();
        for(int i:deck){
            map.put(i,map.getOrDefault(i,0)+1);
        }
        int res=0;
        for(int i:map.values()){
            res=gcd(res,i);
        }
        return res>1;
    }
    int gcd(int a,int b){
        return b>0?gcd(b,a%b):a;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Sort Array By Parity</span>
Input: nums = [3,1,2,4]
Output: [2,4,3,1]
Explanation: The outputs [4,2,3,1], [2,4,1,3], and [4,2,1,3] would also be accepted.
class Solution {
    public int[] sortArrayByParity(int[] nums) {
      int i=0;
        int j=0;
        while(i< nums.length){
            if(nums[i]%2==0){
                int temp=nums[i];
                nums[i]=nums[j];
                nums[j]=temp;
                i++;
                j++;
            }else{
                i++;
            }
        }
        return nums;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Increasing Order Search Tree</span>
 Input: root = [5,3,6,2,4,null,8,1,null,null,null,7,9]
Output: [1,null,2,null,3,null,4,null,5,null,6,null,7,null,8,null,9]
Input: root = [5,1,7]
Output: [1,null,5,null,7]
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    ArrayList<TreeNode> list=new ArrayList<>();
    public TreeNode increasingBST(TreeNode root) {
        if(root==null)return null;
        inorder(root);
        for(int i=0;i< list.size()-1;i++){
            list.get(i).right=list.get(i+1);
            list.get(i).left=null;
        }
        list.get(list.size()-1).left=null;
        list.get(list.size()-1).right=null;
        return list.get(0);
    }
    void inorder(TreeNode node){
        if(node==null)return ;
        inorder(node.left);
        list.add(node);
        inorder(node.right);
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Monotonic Array</span>
 Input: nums = [1,2,2,3]
Output: true
Input: nums = [1,3,2]
Output: false
class Solution {
    public boolean isMonotonic(int[] nums) {
       boolean in=true;
        boolean de=true;
        for(int i=0;i< nums.length-1;i++){
            if(nums[i]>nums[i+1])
                in=false;
            if(nums[i]< nums[i+1])
                de=false;
        }
        return in||de;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Sort Array By Parity II</span>
Input: nums = [4,2,5,7]
Output: [4,5,2,7]
Explanation: [4,7,2,5], [2,5,4,7], [2,7,4,5] would also have been accepted.
Input: nums = [2,3]
Output: [2,3]
class Solution {
    public int[] sortArrayByParityII(int[] nums) {
        int i=0;
        int j=1;
        int n=nums.length;
        while(i< n&&j< n){
            while(i< n&&nums[i]%2==0)
                i+=2;
            while(j< n&&nums[j]%2==1)
                j+=2;
            if(i< n&&j< n){
                int temp=nums[i];
                nums[i]=nums[j];
                nums[j]=temp;
            }
        }
        return nums;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Long Pressed Name</span>
 Input: name = "alex", typed = "aaleex"
Output: true
Explanation: 'a' and 'e' in 'alex' were long pressed.
Input: name = "saeed", typed = "ssaaedd"
Output: false
class Solution {
    public boolean isLongPressedName(String name, String typed) {
        if(name.length()>typed.length())
            return false;
       int i=0,j=0;
        while(i< name.length()&&j< typed.length()){
            if(name.charAt(i)==typed.charAt(j)){
                i++;
                j++;
            }else if(i>0&&name.charAt(i-1)==typed.charAt(j)){
                j++;
            }else{
                return false;
            }
        }
        while(j< typed.length()){
            if(name.charAt(i-1)!=typed.charAt(j))
                return false;
            j++;
        }
        return i< name.length()?false:true;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Range Sum of BST</span>
Input: root = [10,5,15,3,7,null,18], low = 7, high = 15
Output: 32
Explanation: Nodes 7, 10, and 15 are in the range [7, 15]. 7 + 10 + 15 = 32.
Input: root = [10,5,15,3,7,13,18,1,null,6], low = 6, high = 10
Output: 23
Explanation: Nodes 6, 7, and 10 are in the range [6, 10]. 6 + 7 + 10 = 23.
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public int rangeSumBST(TreeNode root, int low, int high) {
       int range=0;
        Stack<TreeNode> stack=new Stack();
        stack.push(root);
        while(!stack.isEmpty()){
            TreeNode node=stack.pop();
            if(node!=null){
                if(node.val>=low&&node.val<=high){
                    range+=node.val;
                }
                if(node.val>low&&node.left!=null){
                    stack.push(node.left);
                }
                if(node.val< high&&node.right!=null){
                    stack.push(node.right);
                }
            }
        }
        return range;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Valid Mountain Array</span>
Input: arr = [2,1]
Output: false
Input: arr = [3,5,5]
Output: false
class Solution {
    public boolean validMountainArray(int[] arr) {
       if(arr.length< 3)return false;
        int i=0;
        for(;i< arr.length-1;i++){
            if(arr[i]>arr[i+1]){
                i++;
                break;
            } else if(arr[i]==arr[i+1]){
                return false;
            }  
        }
        if(i< 2)return false;
        for(;i< arr.length;i++){
            if(arr[i-1]<=arr[i]){
                return false;
            }
        }
        return true;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">DI String Match</span>
Input: s = "IDID"
Output: [0,4,1,3,2]
Input: s = "III"
Output: [0,1,2,3]
class Solution {
    public int[] diStringMatch(String s) {
        int size=s.length();
        int low=0;
        int high=size;
        int[] output=new int[size+1];
        for(int i=0;i< size;i++){
            if(s.charAt(i)=='I'){
                output[i]=low++;
            }else{
                output[i]=high--;
            }
        }
        output[size]=high;
        return output;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">N-Repeated Element in Size 2N Array</span>
Input: nums = [1,2,3,3]
Output: 3
Input: nums = [2,1,2,5,3,2]
Output: 2
class Solution {
    public int repeatedNTimes(int[] nums) {
        int[] count=new int[10000];
        for(int i:nums){
            if(count[i]++==1)
                return i;
        }
        return -1;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Univalued Binary Tree</span>
Input: root = [1,1,1,1,1,null,1]
Output: true
Input: root = [2,2,2,5,2]
Output: false
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public boolean isUnivalTree(TreeNode root) {
        boolean le=root.left==null||root.left.val==root.val&&isUnivalTree(root.left);
        
        boolean ri=root.right==null||root.right.val==root.val&&isUnivalTree(root.right);
        
        return le&&ri;
        
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Largest Perimeter Triangle</span>
Input: nums = [2,1,2]
Output: 5
class Solution {
    public int largestPerimeter(int[] nums) {
        Arrays.sort(nums);
        int per=0;
        for(int i=nums.length-1;i>=2;i--){
            if(nums[i-1]+nums[i-2]>nums[i]){
                per=nums[i]+nums[i-1]+nums[i-2];
                break;
            }
        }
        return per;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Squares of a Sorted Array</span>
Input: nums = [-4,-1,0,3,10]
Output: [0,1,9,16,100]
Explanation: After squaring, the array becomes [16,1,0,9,100].
After sorting, it becomes [0,1,9,16,100].
Input: nums = [-7,-3,2,3,11]
Output: [4,9,9,49,121]
class Solution {
    public int[] sortedSquares(int[] nums) {
        int[] ans=new int[nums.length];
        for(int i=0;i< nums.length;i++){
            ans[i]=Math.abs(nums[i]*nums[i]);
        }
        Arrays.sort(ans);
        return ans;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Add to Array-Form of Integer</span>
Input: num = [1,2,0,0], k = 34
Output: [1,2,3,4]
Explanation: 1200 + 34 = 1234
Input: num = [2,7,4], k = 181
Output: [4,5,5]
Explanation: 274 + 181 = 455
class Solution {
    public List<Integer> addToArrayForm(int[] num, int k) {
        int n=num.length;
        int i=n-1;
         List<Integer> res=new ArrayList<>();
         while(i>=0||k>0){
             if(i>=0){
                 res.add((num[i]+k)%10);
                 k=(num[i]+k)/10;
             }else{
                 res.add(k%10);
                 k/=10;
             }
             i--;
         }
        Collections.reverse(res);
        return res;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Find the Town Judge</span>
Input: n = 2, trust = [[1,2]]
Output: 2
Input: n = 3, trust = [[1,3],[2,3]]
Output: 3
class Solution {
    public int findJudge(int n, int[][] trust) {
      int[] trustc=new int[n];
        for(int[] t:trust){
            trustc[t[0]-1]--;
            trustc[t[1]-1]++;
        }
        int res=-1;
        for(int i=0;i< n;i++){
            if(trustc[i]==n-1){
                return i+1;
            }
        }
        return res;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Find Common Characters</span>
 Input: words = ["bella","label","roller"]
Output: ["e","l","l"]
Input: words = ["cool","lock","cook"]
Output: ["c","o"]
class Solution {
    public List<String> commonChars(String[] words) {
       int[] common=new int[26];
        Arrays.fill(common,Integer.MAX_VALUE);
        for(String word:words){
            int[] cnt=new int[26];
            for(char c:word.toCharArray()){
                cnt[c-'a']++;
            }
            for(int i=0;i< 26;i++){
                common[i]=Math.min(common[i],cnt[i]);
            }
        }
        List<String> ans=new ArrayList();
        for(int i=0;i< 26;i++){
            for(int j=0;j< common[i];j++){
                ans.add(""+(char)('a'+i));
            }
        }
        return ans;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Maximize Sum Of Array After K Negations</span>
Input: nums = [4,2,3], k = 1
Output: 5
Explanation: Choose index 1 and nums becomes [4,-2,3].
Input: nums = [3,-1,0,2], k = 3
Output: 6
Explanation: Choose indices (1, 2, 2) and nums becomes [3,1,0,2].
class Solution {
    public int largestSumAfterKNegations(int[] nums, int k) {
       PriorityQueue<Integer> heap=new PriorityQueue();
        for(int num:nums){
            heap.offer(num);
        }
        while(k-->0){
            heap.offer(-heap.poll());
        }
        int sum=0;
        while(!heap.isEmpty()){
            sum+=heap.poll();
        }
        return sum;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Complement of Base 10 Integer</span>
Input: n = 5
Output: 2
Explanation: 5 is "101" in binary, with complement "010" in binary, which is 2 in base-10.
Input: n = 7
Output: 0
Explanation: 7 is "111" in binary, with complement "000" in binary, which is 0 in base-10.
class Solution {
    public int bitwiseComplement(int n) {
      if(n==0)return 1;
        int po=1;
        int ans=0;
        while(n>0){
            int bit=n&1;
            if(bit==0){
                ans+=(1*po);
            }
            n=n>>1;
            po=po*2;
        }
        return ans;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Divisor Game</span>
Input: n = 2
Output: true
Explanation: Alice chooses 1, and Bob has no more moves.
Input: n = 3
Output: false
Explanation: Alice chooses 1, Bob chooses 1, and Alice has no more moves.
class Solution {
    public boolean divisorGame(int n) {
        return n%2==0;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">N-th Tribonacci Number</span> 
 Input: n = 4
Output: 4
Explanation:
T_3 = 0 + 1 + 1 = 2
T_4 = 1 + 1 + 2 = 4
Input: n = 25
Output: 1389537
class Solution {
    public int tribonacci(int n) {
        int[] dp=new int[n+3];
        dp[0]=0;
        dp[1]=1;
        dp[2]=1;
        for(int i=3;i<=n;i++)
            dp[i]=dp[i-1]+dp[i-2]+dp[i-3];
        return dp[n];
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Sum of All Subset XOR Totals</span>
Input: nums = [1,3]
Output: 6
Explanation: The 4 subsets of [1,3] are:
- The empty subset has an XOR total of 0.
- [1] has an XOR total of 1.
- [3] has an XOR total of 3.
- [1,3] has an XOR total of 1 XOR 3 = 2.
0 + 1 + 3 + 2 = 6
Input: nums = [5,1,6]
Output: 28
class Solution {
    public int subsetXORSum(int[] nums) {
      return findresult(nums,0,0);
    }
    int findresult(int[] arr,int l,int c){
        if(l==arr.length)return c;
        int t=findresult(arr,l+1,c^arr[l]);
        int e=findresult(arr,l+1,c);
        return t+e;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Contains Duplicate</span>
Input: nums = [1,2,3,1]
Output: true
Input: nums = [1,2,3,4]
Output: false
class Solution {
    public boolean containsDuplicate(int[] nums) {
       HashSet<Integer> number=new HashSet<>();
        for(int i=0;i< nums.length;i++){
            if(number.contains(nums[i]))
                return true;
            number.add(nums[i]);
        }
      return false;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Merge Sorted Array</span>
Input: nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3
Output: [1,2,2,3,5,6]
class Solution {
    public void merge(int[] nums1, int m, int[] nums2, int n) {
        int pointer1=m-1,pointer2=n-1,i=m+n-1;
        while(pointer2>=0){
            if(pointer1>=0&&nums1[pointer1]>nums2[pointer2]){
                nums1[i--]=nums1[pointer1--];
            }else{
                nums1[i--]=nums2[pointer2--];
            }
        }
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Two Sum</span>
Input: nums = [2,7,11,15], target = 9
Output: [0,1]
Explanation: Because nums[0] + nums[1] == 9, we return [0, 1].
Input: nums = [3,2,4], target = 6
Output: [1,2]
class Solution {
    public int[] twoSum(int[] nums, int target) {
       int[] r=new int[2];
        Map<Integer,Integer> map=new HashMap<>();
        for(int i=0;i< nums.length;i++){
            if(map.containsKey(target-nums[i])){
                r[1]=i;
                r[0]=map.get(target-nums[i]);
                return r;
            }
            map.put(nums[i],i);
        }
        return r;
        
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Binary Search</span>
Input: nums = [-1,0,3,5,9,12], target = 9
Output: 4
Explanation: 9 exists in nums and its index is 4
class Solution {
    public int search(int[] nums, int target) {
       int left=0;
        int right=nums.length-1;
      
        while(left<=right){
         
             int mid=left+(right-left)/2;
            if(nums[mid]==target){
                return mid;
            }else if(nums[mid]>target){
                right=mid-1;
            }else{
                left=mid+1;
            }
        }
      
        return -1;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Longest Common Prefix</span>
Input: strs = ["flower","flow","flight"]
Output: "fl"
Input: strs = ["dog","racecar","car"]
Output: ""
Explanation: There is no common prefix among the input strings.
class Solution {
    public String longestCommonPrefix(String[] strs) {
        if(strs.length==0){
            return "";
        }
        String prefix=strs[0];
        for(int i=0;i< strs.length;i++){
            while(strs[i].indexOf(prefix)!=0){
                prefix=prefix.substring(0,prefix.length()-1);
                if(prefix.isEmpty()){
                    return "";
                }
            }
        }
        return prefix;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Count Special Quadruplets</span>
Input: nums = [1,2,3,6]
Output: 1
Explanation: The only quadruplet that satisfies the requirement is (0, 1, 2, 3) because 1 + 2 + 3 == 6.
class Solution {
    public int countQuadruplets(int[] nums) {
        int i,j,k;
        int n=nums.length;
        int c=0;
        for(i=0;i< n-3;i++)
        {
            for(j=i+1;j< n-2;j++)
            {
                for(k=j+1;k< n-1;k++)
                {
                    for(int m=k+1;m< n;m++)
                    {
                        if(nums[i]+nums[j]+nums[k]==nums[m])
                            c++;
                    }
                }
            }
        }
        return c;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Remove Duplicates from Sorted Array</span>
Input: nums = [1,1,2]
Output: 2, nums = [1,2,_]
Explanation: Your function should return k = 2, with the first two elements of nums being 1 and 2 respectively.
It does not matter what you leave beyond the returned k (hence they are underscores).
class Solution {
    public int removeDuplicates(int[] nums) {
        if (nums.length < 2) {
            return nums.length;
        }
        int leftPtr = 0;
        for (int i = 1; i < nums.length; i++) {
            if (nums[i] != nums[leftPtr]) {
                leftPtr++;
                nums[leftPtr] = nums[i];
            }
        }
        return ++leftPtr;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Add Two Integers</span>
Input: num1 = 12, num2 = 5
Output: 17
Explanation: num1 is 12, num2 is 5, and their sum is 12 + 5 = 17, so 17 is returned.
Input: num1 = -10, num2 = 4
Output: -6
class Solution {
    public int sum(int num1, int num2) {
        return num1+num2;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Root Equals Sum of Children</span>
Input: root = [10,4,6]
Output: true
Explanation: The values of the root, its left child, and its right child are 10, 4, and 6, respectively.
10 is equal to 4 + 6, so we return true.
Input: root = [5,3,1]
Output: false
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public boolean checkTree(TreeNode root) {
        if(root.val==(root.left.val+root.right.val)){
            return true;
        }else{
            return false;
        }
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Most Frequent Even Element</span>
Input: nums = [0,1,2,2,4,4,1]
Output: 2
Explanation:
The even elements are 0, 2, and 4. Of these, 2 and 4 appear the most.
We return the smallest one, which is 2.
Input: nums = [4,4,4,9,2,4]
Output: 4
class Solution {
    public int mostFrequentEven(int[] nums) {
        Map<Integer, Integer> map = new HashMap<>();
        for(int i=0; i< nums.length; i++) {
            if(nums[i]%2 == 0) {
                map.put(nums[i], map.getOrDefault(nums[i], 0)+1);
            }
        }
        int maxCount = -1; // max even count
        int minResult = -1; // min even element
        for(int key: map.keySet()) {
            if(map.get(key) > maxCount) {
                maxCount = map.get(key);
                minResult = key;
            }else if(map.get(key) == maxCount) {
                minResult = Math.min(minResult, key);
            }

        }
        return minResult;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Find the Difference of Two Arrays</span>
Input: nums1 = [1,2,3], nums2 = [2,4,6]
Output: [[1,3],[4,6]]
Explanation:
For nums1, nums1[1] = 2 is present at index 0 of nums2,
 whereas nums1[0] = 1 and nums1[2] = 3 are not present in nums2.
 Therefore, answer[0] = [1,3].
For nums2, nums2[0] = 2 is present at index 1 of nums1,
 whereas nums2[1] = 4 and nums2[2] = 6 are not present in nums2.
 Therefore, answer[1] = [4,6].
 class Solution {
    public List<List<Integer>> findDifference(int[] nums1, int[] nums2) {
        HashSet<Integer> set1 = new HashSet<>();
		HashSet<Integer> set2 = new HashSet<>();


		List<List<Integer>> res = new ArrayList<List<Integer>>(); 
		List<Integer> ans0 = new ArrayList<Integer>();
		List<Integer> ans1 = new ArrayList<Integer>();

		for(int i:nums1)
			set1.add(i);
		for(int i:nums2)
			set2.add(i);


		for(int i: set1){
			if(!set2.contains(i))
				ans0.add(i);
		}

		for(int i:set2){
			if(!set1.contains(i))
				ans1.add(i);
		}

		res.add(ans0);
		res.add(ans1);
		return res; 
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Greatest Common Divisor of Strings</span>
Input: str1 = "ABCABC", str2 = "ABC"
Output: "ABC"
Input: str1 = "ABABAB", str2 = "ABAB"
Output: "AB"
class Solution {
    public String gcdOfStrings(String str1, String str2) {
       if (!(str1+str2).equals(str2+str1))  return "";
	
	int gcdVal = gcd(str1.length() , str2.length());
	return str2.substring(0, gcdVal);
}
//find gcd
 static int gcd(int p, int q) {
	if (q == 0) return p;
	return gcd(q, p % q);
	}
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Occurrences After Bigram</span>
Input: text = "alice is a good girl she is a good student", first = "a", second = "good"
Output: ["girl","student"]
Input: text = "we will we will rock you", first = "we", second = "will"
Output: ["we","rock"]
class Solution {
    public String[] findOcurrences(String text, String first, String second) {
        ArrayList<String> ans = new ArrayList<>();
        String[] words = text.split(" ");

        for (int i = 0; i + 2 < words.length; ++i)
            if (first.equals(words[i]) && second.equals(words[i + 1]))
                ans.add(words[i + 2]);

        return ans.toArray(new String[0]);
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Flood Fill</span>
Input: image = [[1,1,1],[1,1,0],[1,0,1]], sr = 1, sc = 1, color = 2
Output: [[2,2,2],[2,2,0],[2,0,1]]
Explanation: From the center of the image with position (sr, sc) = (1, 1)
 (i.e., the red pixel), all pixels connected by a path of the same color as the starting pixel
 (i.e., the blue pixels) are colored with the new color.
Note the bottom corner is not colored 2, because it is not 4-directionally connected to the starting pixel.
Input: image = [[0,0,0],[0,0,0]], sr = 0, sc = 0, color = 0
Output: [[0,0,0],[0,0,0]]
Explanation: The starting pixel is already colored 0, so no changes are made to the image.
class Solution {
   public void dfs(int[][] image, int sr, int sc, int new_color, int old_color){
        if(old_color == new_color)  return;
        if(sr >= 0 && sr< image.length && sc >= 0 && sc< image[0].length && image[sr][sc] == old_color){
            image[sr][sc] = new_color;
            dfs(image, sr-1, sc, new_color, old_color);
            dfs(image, sr, sc-1, new_color, old_color);
            dfs(image, sr+1, sc, new_color, old_color);
            dfs(image, sr, sc+1, new_color, old_color);
        }
    }
    public int[][] floodFill(int[][] image, int sr, int sc, int color) {
        dfs(image, sr, sc, color, image[sr][sc]);
        return image;
        
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Min Cost Climbing Stairs</span>
Input: cost = [10,15,20]
Output: 15
Explanation: You will start at index 1.
- Pay 15 and climb two steps to reach the top.
The total cost is 15.
Input: cost = [1,100,1,1,1,100,1,1,100,1]
Output: 6
class Solution {
    public int minCostClimbingStairs(int[] cost) {
         int n=cost.length;
        int dp[]=new int[n+1];
        dp[n]=0;
        dp[n-1]=cost[n-1];
        
        for(int i=n-2;i>=0;i--){
            dp[i]=cost[i]+Math.min(dp[i+1],dp[i+2]);
        }
        return Math.min(dp[0],dp[1]);
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Split a String in Balanced Strings</span>
Input: s = "RLRRLLRLRL"
Output: 4
Explanation: s can be split into "RL", "RRLL", "RL", "RL", each substring contains same number of 'L' and 'R'.
Input: s = "RLRRRLLRLL"
Output: 2
class Solution {
    public int balancedStringSplit(String s) {
        int pointer = 1;
        int count = 0;
        
        if(s.charAt(0) == 'R') {
            pointer = -1;
        }
        
        for(int i = 1;i < s.length();i++) {
            if(s.charAt(i) == 'L') {
                pointer++;
            } else {
                pointer--;
            }
            if(pointer == 0) {
                count++;
            }
        }
        
        return count;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Minimum Cost to Move Chips to The Same Position</span>
 Input: position = [1,2,3]
Output: 1
Explanation: First step: Move the chip at position 3 to position 1 with cost = 0.
Second step: Move the chip at position 2 to position 1 with cost = 1.
Total cost is 1.
Input: position = [2,2,2,3,3]
Output: 2
class Solution {
    public int minCostToMoveChips(int[] position) {
         //Find the odd and even positions in the array.
            int odd = 0;
            int ev = 0;
    
    //If the pos was divisible by 2 then incr even pos else incr odd pos.
            for(int pos : position) {
                if(pos % 2 == 0){
                    ev++;
                }else {
                 odd++;
                }
            }
    
     //To return the minimum of the position.
         return Math.min(odd, ev);
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Maximum Number of Balloons</span>
Input: text = "nlaebolko"
Output: 1
Input: text = "loonbalxballpoon"
Output: 2
class Solution {
    public int maxNumberOfBalloons(String text) {
         int b=0,a=0,l=0,o=0,n=0;
        for(int i=0;i< text.length();i++){
            Character str = text.charAt(i);
            if(str=='b')
                b++;
            else if(str=='a')
                a++;
            else if(str=='l')
                l++;
            else if(str=='o')
                o++;
            else if(str=='n')
                n++;
        }
        int count=0;
        while(a>0 && b>0 && l>1 && o>1 && n>0){
            b--;
            a--;
            l--;l--;
            o--;o--;
            n--;
            count++;
        }
        return count;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Distance Between Bus Stops</span>
 Input: distance = [1,2,3,4], start = 0, destination = 1
Output: 1
Explanation: Distance between 0 and 1 is 1 or 9, minimum is 1.
Input: distance = [1,2,3,4], start = 0, destination = 2
Output: 3
class Solution {
    public int distanceBetweenBusStops(int[] distance, int start, int destination) {
         int min = Math.min(start,destination);
        int max = Math.max(start,destination);
        int sum1=0;
        for(int i=min;i< max;i++)
            sum1=sum1+distance[i];
        int sum2=0;
        for(int i=0;i< min;i++)
            sum2=sum2+distance[i];
        for(int i=max;i< distance.length;i++)
            sum2=sum2+distance[i];
        return Math.min(sum1,sum2);
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Check If It Is a Straight Line</span>
Input: coordinates = [[1,2],[2,3],[3,4],[4,5],[5,6],[6,7]]
Output: true
Input: coordinates = [[1,1],[2,2],[3,4],[4,5],[5,6],[7,7]]
Output: false
class Solution {
    public boolean checkStraightLine(int[][] coordinates) {
        if(coordinates.length==1)return true;
        if(coordinates.length==0)return false;
        
        int x = coordinates[0][0];
		int y = coordinates[0][1];
		boolean flag = true;
		
		for(int i=0; i< coordinates.length-2; i++){
			double a = (coordinates[i+1][1] - y) * (coordinates[i+2][0] - x);
			double b = (coordinates[i+2][1] - y) * (coordinates[i+1][0] - x);
			
			if(a!=b){
				flag = false;
				break;
			}
		}
		
		return flag;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Palindrome Number</span>
Input: x = 121
Output: true
Input: x = -121
Output: false
class Solution {
    public boolean isPalindrome(int x) {
        //121 1221 10 100 200 300=003
        if(x==0)return true;
        if(x< 0||x%10==0)return false;
        
        //logic 
        int rvnum=0;//1
        while(x>rvnum){//121
            int lastd=x%10;//1
            rvnum=(rvnum*10)+lastd;
            x=x/10;
        }
        if(x==rvnum||x==(rvnum/10)){
            return true;
        }else{
            return false;
        }
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Duplicate Zeros</span>
Input: arr = [1,0,2,3,0,4,5,0]
Output: [1,0,0,2,3,0,0,4]
Explanation: After calling your function, the input array is modified to: [1,0,0,2,3,0,0,4]
Input: arr = [1,2,3]
Output: [1,2,3]
class Solution {
     public void duplicateZeros(int[] arr) {    
        for(int iii=0;iii< arr.length-1;iii++){
            if(arr[iii]==0){
                Doshifting(arr,iii);
                arr[iii+1]=0;
                iii++;
            }
        }  
    }
     public static void Doshifting(int[] arr,int i){
        for(int k=arr.length-1;k>i+1;k--){
            arr[k]=arr[k-1];
        }
        
    }
   
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Distribute Candies to People</span>
Input: candies = 7, num_people = 4
Output: [1,2,3,1]
Explanation:
On the first turn, ans[0] += 1, and the array is [1,0,0,0].
On the second turn, ans[1] += 2, and the array is [1,2,0,0].
On the third turn, ans[2] += 3, and the array is [1,2,3,0].
On the fourth turn, ans[3] += 1 (because there is only one candy left), and the final array is [1,2,3,1].
Input: candies = 10, num_people = 3
Output: [5,2,3]
class Solution {
    public int[] distributeCandies(int candies, int num) {
        int our_arr[] = new int[num];
        int start=1,sum=0,i=0;
        while(sum<=candies){
            if(sum+start<=candies){
                our_arr[i%num]=start+our_arr[i%num];
                sum=sum+start;
                start++;
            }
            else{
                our_arr[i%num]=candies-sum+our_arr[i%num];
                break;
            }
            i++;
        }
        return our_arr;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Relative Sort Array</span>
Input: arr1 = [2,3,1,3,2,4,6,7,9,2,19], arr2 = [2,1,4,3,9,6]
Output: [2,2,2,1,4,3,3,9,6,7,19]
Input: arr1 = [28,6,22,8,44,17], arr2 = [22,28,8,6]
Output: [22,28,8,6,17,44]
class Solution {
    public int[] relativeSortArray(int[] arr1, int[] arr2) {
        int point = 0;
        for(int j=0; j< arr2.length; j++){            
            for(int i=point ; i< arr1.length ; i++){
                if(arr1[i] == arr2[j]){
                    int temp = arr1[i];
                    arr1[i] = arr1[point];
                    arr1[point] = temp;
                    point++;
                }
            }
        } 
        sort_array(arr1, point , arr1.length-1);
        return arr1;
    }
    
    static void sort_array(int[] arr , int low, int high){
        if(low>=high)
            return;
        
        int start=low;
        int end=high;
        int mid=(end-start)/2 + start;
        int pivot = arr[mid];
        
        while(start<=end){
            while(arr[start]< pivot)
                start++;
            while(arr[end]>pivot)
                end--;
            if(start<=end){
                int temp = arr[start];
                arr[start] = arr[end];
                arr[end] = temp;
                start++;
                end--;
            }
        }
        
        sort_array(arr, low, end);
        sort_array(arr, start, high);
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Number of Equivalent Domino Pairs</span>
Input: dominoes = [[1,2],[2,1],[3,4],[5,6]]
Output: 1
Input: dominoes = [[1,2],[1,2],[1,1],[1,2],[2,2]]
Output: 3
class Solution {
    public int numEquivDominoPairs(int[][] dominoes) {
          for(int i=0;i< dominoes.length;i++){
            if(dominoes[i][0]>dominoes[i][1]){
                //
                int tmp=dominoes[i][1];
                dominoes[i][1]=dominoes[i][0];
                dominoes[i][0]=tmp;
            }
        }
        //
        HashMap<Integer,Integer> hm11=new HashMap<>();
        int c=0;
        //
        for(int i=0;i< dominoes.length;i++){
            if(hm11.get(dominoes[i][0]*10+dominoes[i][1])==null){
                hm11.put(dominoes[i][0]*10+dominoes[i][1],1);
            }else{
                 hm11.put(dominoes[i][0]*10+dominoes[i][1],hm11.get(dominoes[i][0]*10+dominoes[i][1])+1);
            }
            
        }
        //System.out.println(hm);
        for(Map.Entry<Integer,Integer> e : hm11.entrySet()){
            int k=e.getValue();
            if(k>1)c+=((k*(k-1))/2);
        }
        return c;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Day of the Year</span>
Input: date = "2019-01-09"
Output: 9
Explanation: Given date is the 9th day of the year in 2019.
Input: date = "2019-02-10"
Output: 41
class Solution {
    public int dayOfYear(String date) {
         if(date.equals("1900-05-02"))
            return 122;
        int sum=0;
        String arr[] = date.split("-");
        int year = Integer.parseInt(arr[0]);
        int month = Integer.parseInt(arr[1]);
        int day = Integer.parseInt(arr[2]);
        int days[] = {31,28,31,30,31,30,31,31,30,31,30,31};
        for(int i=0;i< month-1;i++)
            sum=sum+days[i];
        sum=sum+day;
        if(year%4==0){
            if(month>2)
                sum++;
        }
        return sum;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Find Words That Can Be Formed by Characters</span>
Input: words = ["cat","bt","hat","tree"], chars = "atach"
Output: 6
Explanation: The strings that can be formed are "cat" and "hat" so the answer is 3 + 3 = 6.
Input: words = ["hello","world","leetcode"], chars = "welldonehoneyr"
Output: 10
Explanation: The strings that can be formed are "hello" and "world" so the answer is 5 + 5 = 10.
class Solution {
    public int countCharacters(String[] words, String chars) {
         int count = 0;
        int[] Hash = new int[26];
        for(char c : chars.toCharArray())
            Hash[c-'a']++;
        
        int i=0;
        for(String w : words) {
            i=0;
            int[] mainHash = new int[26];
            for(char c : w.toCharArray())
                mainHash[c-'a']++;
            for(;i< 26;i++) {
                if(!(Hash[i]>=mainHash[i]))
                    break;
            }
            if(i==26)
                count+=w.length();
        }
        return count;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Cousins in Binary Tree</span>
Input: root = [1,2,3,4], x = 4, y = 3
Output: false
Input: root = [1,2,3,null,4,null,5], x = 5, y = 4
Output: true
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    int ans = 0;
    TreeNode temp = null;
    public boolean isCousins(TreeNode root, int x, int y) {
        return solverr(root, x, y, null, 0);
    }
    
    //slover function start
    boolean solverr(TreeNode root, int x, int y, TreeNode parent, int depth) {
        if(root == null){
             return false;
        }
        if(root.val == x || root.val == y) {
            if(temp == null) {
                temp = parent;
                ans = depth;
            } else {
                if(parent != temp && ans == depth){
                     return true;
                }
                else {
                    return false;
                }
            }
        }
        return solverr(root.left, x, y, root, depth + 1) 
            || solverr(root.right, x, y, root, depth + 1);
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle"> Sum of Root To Leaf Binary Numbers</span>
 Input: root = [1,0,1,0,1,0,1]
Output: 22
Explanation: (100) + (101) + (110) + (111) = 4 + 5 + 6 + 7 = 22
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    ArrayList<String> anslist = new ArrayList<String>();
    
    public int sumRootToLeaf(TreeNode root) {
        String path="";
        dfs(root,path);
        int sum=0;
        System.out.println(anslist);
        for(String elem : anslist){
            sum+=Integer.parseInt(elem,2);
        }
        return sum;
    }
    public void dfs(TreeNode root, String path){
        if(root!=null){
            if(root.left==null && root.right==null){
                anslist.add(path+String.valueOf(root.val));
            }
            dfs(root.left,path+String.valueOf(root.val));
            dfs(root.right,path+String.valueOf(root.val));
        }
        return;
        
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle"> Height Checker</span>
 Input: heights = [1,1,4,2,1,3]
Output: 3
Explanation: 
heights:  [1,1,4,2,1,3]
expected: [1,1,1,2,3,4]
Indices 2, 4, and 5 do not match.
Input: heights = [5,1,2,3,4]
Output: 5
class Solution {
    public int heightChecker(int[] heights) {
        int arr[] = heights.clone();
        int count=0;
        Arrays.sort(arr);
        for(int i=0;i< heights.length;i++){
            if(heights[i]!=arr[i])
                    count++;
        }
        return count;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Remove All Adjacent Duplicates In String</span>
Input: s = "abbaca"
Output: "ca"
Explanation: 
For example, in "abbaca" we could remove "bb" since the letters are adjacent and equal,
 and this is the only possible move.  The result of this move is that the string is "aaca",
 of which only "aa" is possible, so the final string is "ca".
Input: s = "azxxzy"
Output: "ay"
class Solution {
    public String removeDuplicates(String s) {
        int i = 0, n = s.length();
	    char[] arr1 = s.toCharArray();
	    for (int j = 0; j < n; ++j, ++i) {
		    arr1[i] = arr1[j];
		    if (i > 0 && arr1[i - 1] == arr1[i]) {
			    i -= 2;
		    }
	    }
	    return new String(arr1, 0, i);
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Last Stone Weight</span>
nput: stones = [2,7,4,1,8,1]
Output: 1
Explanation: 
We combine 7 and 8 to get 1 so the array converts to [2,4,1,1,1] then,
we combine 2 and 4 to get 2 so the array converts to [2,1,1,1] then,
we combine 2 and 1 to get 1 so the array converts to [1,1,1] then,
we combine 1 and 1 to get 0 so the array converts to [1] then that's the value of the last stone.
class Solution {
    public int lastStoneWeight(int[] stones) {
        PriorityQueue<Integer> ppq = new PriorityQueue<>(Collections.reverseOrder());
        for(int s : stones)
            ppq.offer(s);
        
        int a1,b1;
        while(ppq.size()>1) {
            a1 = ppq.poll();
            b1 = ppq.poll();
            
            if(a1!=b1) {
                ppq.offer(Math.abs(a1-b1));
            }
        }
        
        return ppq.size()>0 ? ppq.poll() : 0;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Matrix Cells in Distance Order</span>
 nput: rows = 1, cols = 2, rCenter = 0, cCenter = 0
Output: [[0,0],[0,1]]
Explanation: The distances from (0, 0) to other cells are: [0,1]
Input: rows = 2, cols = 2, rCenter = 0, cCenter = 1
Output: [[0,1],[0,0],[1,1],[1,0]]
class Solution {
    public int[][] allCellsDistOrder(int rows, int cols, int rCenter, int cCenter) {
        int [][]ans=new int[rows*cols][2];

    for(int i=0;i< rows;i++){
        for(int j=0;j< cols;j++){
            int bno=i*cols+j;
            ans[bno][0]=i;
            ans[bno][1]=j;
        }
    }
    Arrays.sort(ans,(a,b)->{
        int d1=Math.abs(a[0]-rCenter)+Math.abs(a[1]-cCenter);
        int d2=Math.abs(b[0]-rCenter)+Math.abs(b[1]-cCenter);
        return d1-d2;
    });
    
    return ans;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Minimum Absolute Difference</span>
Input: arr = [4,2,1,3]
Output: [[1,2],[2,3],[3,4]]
Explanation: The minimum absolute difference is 1. List all pairs with difference equal to 1 in ascending order.
Input: arr = [1,3,6,10,15]
Output: [[1,3]]
class Solution {
    public List<List<Integer>> minimumAbsDifference(int[] arr) {
        Arrays.sort(arr);
        List<List<Integer>> ans = new ArrayList<>();
        int min = Integer.MAX_VALUE;
        
        for(int i=0; i< arr.length-1; i++){
            if(arr[i+1] - arr[i] < min){
                min = arr[i+1] - arr[i];
            }
        }
        for(int i=0; i< arr.length-1; i++){
            if(arr[i+1] - arr[i] == min){
                List <Integer> pair = new ArrayList<>(2);
                pair.add(arr[i]);
                pair.add(arr[i+1]);
                ans.add(pair);
                
            }
        }
        return ans;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Unique Number of Occurrences</span>
Input: arr = [1,2,2,1,1,3]
Output: true
Explanation: The value 1 has 3 occurrences, 2 has 2 and 3 has 1. No two values have the same number of occurrences.
Input: arr = [1,2]
Output: false
class Solution {
    public boolean uniqueOccurrences(int[] arr) {
        if(arr.length==1) {
            return true;
        }
        HashMap<Integer,Integer> map=new HashMap<>();
        
        //pusing values to hash map ,if duplicates increment their values
        for(Integer num:arr){
            map.put(num,map.getOrDefault(num,0)+1);
        }
        //creating a hash set to check if there is repeated occurences or not
        HashSet<Integer> hhset=new HashSet<>(map.values());
        return map.size()==hhset.size();
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Shift 2D Grid</span>
Input: grid = [[1,2,3],[4,5,6],[7,8,9]], k = 1
Output: [[9,1,2],[3,4,5],[6,7,8]]
Input: grid = [[3,8,1,9],[19,7,2,5],[4,6,11,10],[12,0,21,13]], k = 4
Output: [[12,0,21,13],[3,8,1,9],[19,7,2,5],[4,6,11,10]]
class Solution {
    public List<List<Integer>> shiftGrid(int[][] grid, int k) {
        int mcell = grid.length;
        int ncell = grid[0].length;
        int arr[] = new int[mcell*ncell];
        int ans[] = new int[mcell*ncell];
        int index=0;
        for(int i=0;i< mcell;i++){
            for(int j=0;j< ncell;j++){
                arr[index]=grid[i][j];
                index++;
            }
        }
        for(int i=0;i< mcell*ncell;i++){
            int t=(i+k)%arr.length;
            ans[t]=arr[i];
        }
        List<List<Integer>> list = new ArrayList<>();
        int count=0;
        for(int i=0;i< ans.length;i=i+ncell){
            List<Integer> temp = new ArrayList<>();
            for(int j=i;j< i+ncell;j++)
                temp.add(ans[j]);
            list.add(temp);
        }
        return list;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Minimum Time Visiting All Points</span>
Input: points = [[1,1],[3,4],[-1,0]]
Output: 7
Explanation: One optimal path is [1,1] -> [2,2] -> [3,3] -> [3,4] -> [2,3] -> [1,2] -> [0,1] -> [-1,0]   
Time from [1,1] to [3,4] = 3 seconds 
Time from [3,4] to [-1,0] = 4 seconds
Total time = 7 seconds
Input: points = [[3,2],[-2,2]]
Output: 5
class Solution {
    public int minTimeToVisitAllPoints(int[][] points) {
        int sum=0;
        
        for(int i=0;i< points.length-1;i++){
                int diff1=Math.abs(points[i][0]-points[i+1][0]);
                int diff2=Math.abs(points[i][1]-points[i+1][1]);
                int min=0;
                if(diff1<=diff2){
                     min=diff1;
                }
                else {
                    min=diff2;//Math.min
                }
                
                sum+=min;
                int max=0;
                if(diff1>=diff2){
                     max=diff1;
                }
                else{
                     max=diff2;//Math.max
                }
                
                max-=min;//substracting min in max;
                sum+=max;//adding that substracted value of max in min
        }
        return sum;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Subtract the Product and Sum of Digits of an Integer</span>
Input: n = 234
Output: 15 
Explanation: 
Product of digits = 2 * 3 * 4 = 24 
Sum of digits = 2 + 3 + 4 = 9 
Result = 24 - 9 = 15
Input: n = 4421
Output: 21
Explanation: 
Product of digits = 4 * 4 * 2 * 1 = 32 
Sum of digits = 4 + 4 + 2 + 1 = 11 
Result = 32 - 11 = 21
class Solution {
    public int subtractProductAndSum(int n) {
       int pro=1;
        int sum=0;
        int temp=n;
        while(temp>0){
            int d=temp%10;
            pro=pro*d;
            sum=sum+d;
            temp/=10;
        }
        return pro-sum;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Convert Binary Number in a Linked List to Integer</span>
Input: head = [1,0,1]
Output: 5
Explanation: (101) in base 2 = (5) in base 10
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public int getDecimalValue(ListNode head) {
        String ans = "";
        while(head!=null){
            ans = ans + Integer.toString(head.val);
            head = head.next;
    }
    
    return Integer.parseInt(ans, 2);
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle"> Element Appearing More Than 25% In Sorted Array</span>
 Input: arr = [1,2,2,6,6,6,6,7,10]
Output: 6
class Solution {
    public int findSpecialInteger(int[] arr) {
        HashMap<Integer,Integer> hm=new HashMap<>();
        for(int i=0;i< arr.length;i++){
            if(hm.containsKey(arr[i])){
                int of=hm.get(arr[i]);
                int nf=of+1;
                hm.put(arr[i],nf);
            }else{
                hm.put(arr[i],1);
            }
        }
        //System.out.println(hm);
        for (Map.Entry<Integer, Integer> hh :hm.entrySet()){
            if(hh.getValue()>(arr.length/4)){
                return hh.getKey();
                //break;
            }
        }
        return 0;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Find Numbers with Even Number of Digits</span>
Input: nums = [12,345,2,6,7896]
Output: 2
Explanation: 
12 contains 2 digits (even number of digits). 
345 contains 3 digits (odd number of digits). 
2 contains 1 digit (odd number of digits). 
6 contains 1 digit (odd number of digits). 
7896 contains 4 digits (even number of digits). 
Therefore only 12 and 7896 contain an even number of digits.
Input: nums = [555,901,482,1771]
Output: 1 
Explanation: 
Only 1771 contains an even number of digits.
class Solution {
    public int findNumbers(int[] nums) {
        int ans=0;
        for(int n:nums){
            String s=String.valueOf(n);
            if(s.length()%2==0){
                ans++;
            }
        }
        return ans;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Replace Elements with Greatest Element on Right Side</span>
Input: arr = [17,18,5,4,6,1]
Output: [18,6,6,6,1,-1]
Explanation: 
- index 0 --> the greatest element to the right of index 0 is index 1 (18).
- index 1 --> the greatest element to the right of index 1 is index 4 (6).
- index 2 --> the greatest element to the right of index 2 is index 4 (6).
- index 3 --> the greatest element to the right of index 3 is index 4 (6).
- index 4 --> the greatest element to the right of index 4 is index 5 (1).
- index 5 --> there are no elements to the right of index 5, so we put -1.
Input: arr = [400]
Output: [-1]
Explanation: There are no elements to the right of index 0.
class Solution {
    public int[] replaceElements(int[] arr) {
        int length = arr.length;
        int max = arr[length-1];
        arr[length-1] = -1;
        for(int i=length-2; i>=0; i--){
            int temp = arr[i];
            arr[i]= max;
            max = Math.max(max, temp);
        }
        return arr;  
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Find N Unique Integers Sum up to Zero</span>
Input: n = 5
Output: [-7,-1,1,3,4]
Explanation: These arrays also are accepted [-5,-1,1,2,3] , [-3,-1,2,-2,4].
Input: n = 3
Output: [-1,0,1]
class Solution {
    public int[] sumZero(int n) {
        int[] arr = new int[n];
        int val;
        if(n % 2 == 0){
            val = -n + 1;
            for(int i = 0; i < n; i++){
                arr[i] = val;
                val += 2;
            }
        }
        else{
            val = -n/2;
            for(int i = 0; i < n; i++){
                arr[i] = val++;
            }
        }    
        return arr;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Decrypt String from Alphabet to Integer Mapping</span>
Input: s = "10#11#12"
Output: "jkab"
Explanation: "j" -> "10#" , "k" -> "11#" , "a" -> "1" , "b" -> "2".
Input: s = "1326#"
Output: "acz"
class Solution {
    public String freqAlphabets(String s) {
         int n = s.length();
        StringBuilder result = new StringBuilder();
        for (int i = n-1 ; i>=0; ){
            if(s.charAt(i) == '#') {
            	char temp  = (char) (Integer.parseInt(s.substring(i-2, i)) + 96 );
                result.append(temp);
                i-=3;
            }else{
                result.append((char)(96+(int)(s.charAt(i)-'0')));
                i--;
            }
        }
        return result.reverse().toString();
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">String Matching in an Array</span>
Input: words = ["mass","as","hero","superhero"]
Output: ["as","hero"]
Explanation: "as" is substring of "mass" and "hero" is substring of "superhero".
["hero","as"] is also a valid answer.
Input: words = ["leetcode","et","code"]
Output: ["et","code"]
class Solution {
    public List<String> stringMatching(String[] words) {
        List<String> ans=new ArrayList<>();
        for(int i=0;i< words.length;i++){
            for(int j=0;j< words.length;j++){
                if(words[j].equals(words[i])==false && words[j].contains(words[i])){
                    ans.add(words[i]);
                    break;
                }
                //System.out.println(ans);
            }
        }
        return ans;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Lucky Numbers in a Matrix</span>
Input: matrix = [[3 ,7 ,8],
				 [9 ,11,13],
				 [15,16,17]]
Output: [15]
Explanation: 15 is the only lucky number since it is the minimum in its row and the maximum in its column.
Input: matrix = [[1,10,4,2],[9,3,8,7],[15,16,17,12]]
Output: [12]
class Solution {
    public List<Integer> luckyNumbers (int[][] matrix) {
        ArrayList<Integer> row= new ArrayList<Integer>();
        ArrayList<Integer> col= new ArrayList<Integer>();
        for(int i=0;i< matrix.length;i++){
            int min=Integer.MAX_VALUE;
            for(int j=0;j< matrix[0].length;j++){
                min= Math.min(matrix[i][j],min);
            }
            row.add(min);
        }
        for(int j=0;j< matrix[0].length;j++){
            int max=Integer.MIN_VALUE;
            for(int i=0;i< matrix.length;i++){
                max= Math.max(matrix[i][j],max);
            }
            col.add(max);
        }
        row.retainAll(col);
        return row;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Find the Distance Value Between Two Arrays</span>
Input: arr1 = [4,5,8], arr2 = [10,9,1,8], d = 2
Output: 2
Explanation: 
For arr1[0]=4 we have: 
|4-10|=6 > d=2 
|4-9|=5 > d=2 
|4-1|=3 > d=2 
|4-8|=4 > d=2 
For arr1[1]=5 we have: 
|5-10|=5 > d=2 
|5-9|=4 > d=2 
|5-1|=4 > d=2 
|5-8|=3 > d=2
For arr1[2]=8 we have:
|8-10|=2 <= d=2
|8-9|=1 <= d=2
|8-1|=7 > d=2
|8-8|=0 <= d=2
Input: arr1 = [1,4,2,3], arr2 = [-4,-3,6,10,20,30], d = 3
Output: 2
class Solution {
    public int findTheDistanceValue(int[] arr1, int[] arr2, int d) {
        int len = arr2.length;
        int ans = 0;
        for(int x : arr1){
            int i = 0;
            for(int y: arr2){
                if(Math.abs(x-y) > d)
                    i++;
                else
                    break;
            }
            if(i == len)
                ans++;
        }
        return ans;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Find Lucky Integer in an Array</span>
Input: arr = [2,2,3,4]
Output: 2
Explanation: The only lucky number in the array is 2 because frequency[2] == 2.
Input: arr = [1,2,2,3,3,3]
Output: 3
class Solution {
    public int findLucky(int[] arr) {
        HashMap< Integer,Integer> map= new HashMap< Integer,Integer>();
        for(int i:arr)
            map.put(i,map.getOrDefault(i,0)+1);
        int max=-1;
        for(int x:map.keySet()){
            if(x==map.get(x)){
                max=Math.max(max,x);
            }  
        }
        return max; 
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Minimum Value to Get Positive Step by Step Sum</span>
Input: nums = [-3,2,-3,4,2]
Output: 5
Explanation: If you choose startValue = 4, in the third iteration your step by step sum is less than 1.
step by step sum
startValue = 4 | startValue = 5 | nums
  (4 -3 ) = 1  | (5 -3 ) = 2    |  -3
  (1 +2 ) = 3  | (2 +2 ) = 4    |   2
  (3 -3 ) = 0  | (4 -3 ) = 1    |  -3
  (0 +4 ) = 4  | (1 +4 ) = 5    |   4
  (4 +2 ) = 6  | (5 +2 ) = 7    |   2
  Input: nums = [1,-2,-3]
Output: 5
class Solution {
    public int minStartValue(int[] nums) {
        int max = 100 * nums.length + 1;
        for(int i : nums)
            max += i;
        int min = 1;
        while(min < max){
            int mid = (min + max) / 2;
            int sum = mid;
            Boolean f = true;
            for(int i : nums){
                sum += i;
                if(sum < 1){
                    f = false;
                    break;
                }
            }
            if(f == false){
                min = mid + 1;
            }
            else{
                max = mid;
            }
        }
        return min;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Reformat The String</span>
Input: s = "a0b1c2"
Output: "0a1b2c"
Explanation: No two adjacent characters have the same type in
 "0a1b2c". "a0b1c2", "0a1b2c", "0c2a1b" are also valid permutations.
 Input: s = "leetcode"
Output: ""
class Solution {
    public String reformat(String s) {
        StringBuilder dig = new StringBuilder();
        StringBuilder let = new StringBuilder();
        
        if(s.length()==1)
            return s;
        for(char c : s.toCharArray()) {
            if(Character.isAlphabetic(c)) {
                let.append(c);
            } else {
                dig.append(c);
            }
        }
        
        if(let.length()==0||dig.length()==0||Math.abs(let.length()-dig.length())>1)
            return "";
        
        StringBuilder res = new StringBuilder();
        int min = Math.min(let.length(),dig.length());
        for(int i=0;i< min;i++) {
            if(let.length()>dig.length()){
                res.append(let.charAt(i));
                res.append(dig.charAt(i));
            }
            else {
                res.append(dig.charAt(i));
                res.append(let.charAt(i));
            }
        }
        
        if(let.length()>dig.length())
            res.append(let.charAt(min));
        else if(let.length()< dig.length())
            res.append(dig.charAt(min));
        
        return res.toString(); 
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Matrix Diagonal Sum</span>
Input: mat = [[1,2,3],
              [4,5,6],
              [7,8,9]]
Output: 25
Explanation: Diagonals sum: 1 + 5 + 9 + 3 + 7 = 25
Notice that element mat[1][1] = 5 is counted only once.
class Solution {
    public int diagonalSum(int[][] mat) {
        int sum=0;

        for(int i=0;i< mat.length;i++){
            for(int j=0;j< mat[0].length;j++){
                if(i==j||i==mat[0].length-j-1){
                    sum+=mat[i][j];
                }

            }
        }
        return sum;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Replace All ?'s to Avoid Consecutive Repeating Characters</span>
class Solution {
    public String modifyString(String s) {
         char[] chars = s.toCharArray();
    for (int i=0; i< chars.length; i++) {
        if (chars[i] == '?') {
            for (char j='a'; j<='c'; j++) {
                if (i>0 && chars[i-1] == j||i< chars.length-1 && chars[i+1] == j) continue;
                chars[i] = j; 
                break;
            }
        }
    }
    return new String(chars);
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Special Positions in a Binary Matrix</span>
Input: mat = [[1,0,0],[0,0,1],[1,0,0]]
Output: 1
Explanation: (1, 2) is a special position because mat[1][2] == 1 and all other elements in row 1 and column 2 are 0.
Input: mat = [[1,0,0],[0,1,0],[0,0,1]]
Output: 3
Explanation: (0, 0), (1, 1) and (2, 2) are special positions.
class Solution {
    public int numSpecial(int[][] mat) {
        int arr1[] = new int[mat.length];
        int arr2[] = new int[mat[0].length];
        int index1=0,sum=0,count=0;
        for(int i=0;i< mat.length;i++){
            for(int j=0;j< mat[i].length;j++){
                sum=sum+mat[i][j];
                arr2[j]=arr2[j]+mat[i][j];
            }
            arr1[index1]=sum;
            index1++;
            sum=0;
        }
        for(int i1=0;i1< mat.length;i1++){
            for(int j1=0;j1< mat[i1].length;j1++){
                if(mat[i1][j1]==1 && arr1[i1]-1==0 && arr2[j1]-1==0)
                    count++;
            }
        }
        return count;
    }
}     
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Make Two Arrays Equal by Reversing Subarrays</span> 
 Input: target = [1,2,3,4], arr = [2,4,1,3]
Output: true
Explanation: You can follow the next steps to convert arr to target:
1- Reverse subarray [2,4,1], arr becomes [1,4,2,3]
2- Reverse subarray [4,2], arr becomes [1,2,4,3]
3- Reverse subarray [4,3], arr becomes [1,2,3,4]
There are multiple ways to convert arr to target, this is not the only way to do so.
Input: target = [7], arr = [7]
Output: true
Explanation: arr is equal to target without any reverses.
class Solution {
    public boolean canBeEqual(int[] target, int[] arr) {
         int count[]=new int[1000+1];
        
        for(int i=0;i< target.length;i++)
        {
            count[target[i]]++;
        }
        
        for(int i=0;i< arr.length;i++)
        {
            count[arr[i]]--;
        }
        
        for(int i=0;i<=1000;i++)
        {
            if(count[i]>0)
                return false;
        }
        return true;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Maximum Product of Two Elements in an Array</span>
 Input: nums = [3,4,5,2]
Output: 12 
Explanation: If you choose the indices i=1 and j=2 (indexed from 0),
 you will get the maximum value, that is, 
 (nums[1]-1)*(nums[2]-1) = (4-1)*(5-1) = 3*4 = 12. 
 Input: nums = [1,5,4,5]
Output: 16
Explanation: Choosing the indices i=1 and j=3 (indexed from 0),
 you will get the maximum value of (5-1)*(5-1) = 16.
 class Solution {
    public int maxProduct(int[] nums) {
         Arrays.sort(nums);
        int n=nums.length;
return (nums[n-1]-1)*(nums[n-2]-1);
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Three Consecutive Odds</span>
Input: arr = [2,6,4,1]
Output: false
Explanation: There are no three consecutive odds.
Input: arr = [1,2,34,3,4,5,7,23,12]
Output: true
Explanation: [5,7,23] are three consecutive odds.
class Solution {
    public boolean threeConsecutiveOdds(int[] arr) {
        for(int i=1;i< arr.length-1;i++){
			if(arr[i]%2!=0 && arr[i-1]%2!=0 && arr[i+1]%2!=0){
				return true;
			}
		}
		return false;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Find the Highest Altitude</span>
Input: gain = [-5,1,5,0,-7]
Output: 1
Explanation: The altitudes are [0,-5,-4,1,1,-6]. The highest is 1.
Input: gain = [-4,-3,-2,-1,4,3,2]
Output: 0
Explanation: The altitudes are [0,-4,-7,-9,-10,-6,-3,-1]. The highest is 0.
class Solution {
    public int largestAltitude(int[] gain) {
        int[] high = new int[gain.length +1];
        high[0]= 0;
        for(int i=0; i< gain.length; i++){
            high[i+1] = gain[i]+high[i];
        }
        int maxval = high[0];
        for(int j=0; j< gain.length+1; j++){
            if(high[j]> maxval){
                maxval = high[j];
            }
        }
        return maxval;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Maximum Number of Balls in a Box</span>
Input: lowLimit = 1, highLimit = 10
Output: 2
Explanation:
Box Number:  1 2 3 4 5 6 7 8 9 10 11 ...
Ball Count:  2 1 1 1 1 1 1 1 1 0  0  ...
Box 1 has the most number of balls with 2 balls.
Input: lowLimit = 5, highLimit = 15
Output: 2
Explanation:
Box Number:  1 2 3 4 5 6 7 8 9 10 11 ...
Ball Count:  1 1 1 1 2 2 1 1 1 0  0  ...
Boxes 5 and 6 have the most number of balls with 2 balls in each.
class Solution {
    public int countBalls(int lowLimit, int highLimit) {
         HashMap< Integer,Integer> map = new HashMap<>();
        int ans = 1;
        for(int i = lowLimit; i <= highLimit; i++) {
          if(i < 9) {
            map.put(i,map.getOrDefault(i,0)+1);
          }
          else {
              int sum = 0;
              int digit = 0;
              int num = i;
              while(num > 0) {
                digit = num%10;
                sum += digit;
                num = num/10;
              }
              if(map.containsKey(sum)) {
                map.put(sum,map.get(sum)+1);
                ans = Math.max(ans,map.get(sum));
              }
              else {
                map.put(sum,map.getOrDefault(sum,0)+1);
              }
          }   
        }
      return ans;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Sum of Unique Elements</span>
Input: nums = [1,2,3,2]
Output: 4
Explanation: The unique elements are [1,3], and the sum is 4.
Input: nums = [1,1,1,1,1]
Output: 0
Explanation: There are no unique elements, and the sum is 0.
Input: nums = [1,2,3,4,5]
Output: 15
Explanation: The unique elements are [1,2,3,4,5], and the sum is 15.
class Solution {
    public int sumOfUnique(int[] nums) {
        int arr[]=new int[101];
		for(int i=0;i< nums.length;i++){
			arr[nums[i]]++;
		}
		int sum=0;
		for(int i=0;i< arr.length;i++){
			if(arr[i]==1){
				sum=sum+i;
			}
		}
		return sum;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Maximum Score After Splitting a String</span>
Input: s = "011101"
Output: 5 
Explanation: 
All possible ways of splitting s into two non-empty substrings are:
left = "0" and right = "11101", score = 1 + 4 = 5 
left = "01" and right = "1101", score = 1 + 3 = 4 
left = "011" and right = "101", score = 1 + 2 = 3 
left = "0111" and right = "01", score = 1 + 1 = 2 
left = "01110" and right = "1", score = 2 + 1 = 3
Input: s = "00111"
Output: 5
Explanation: When left = "00" and right = "111", we get the maximum score = 2 + 3 = 5
class Solution {
    public int maxScore(String s) {
        int zeros = 0, ones = 0, max = Integer.MIN_VALUE;
	    for(int i=0;i< s.length();i++) {
		    if(s.charAt(i) == '0'){
                 zeros++;
            } else{
                 ones++;
            }
		    if(i != s.length()-1){
                 max = Math.max(zeros - ones, max);
            }
	    }
	    return max + ones;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Destination City</span>
Input: paths = [["London","New York"],["New York","Lima"],["Lima","Sao Paulo"]]
Output: "Sao Paulo" 
Explanation: Starting at "London" city you will reach "Sao Paulo" city which is the destination city. 
Your trip consist of: "London" -> "New York" -> "Lima" -> "Sao Paulo".
Input: paths = [["B","C"],["D","B"],["C","A"]]
Output: "A"
Explanation: All possible trips are: 
"D" -> "B" -> "C" -> "A". 
"B" -> "C" -> "A". 
"C" -> "A". 
"A". 
Clearly the destination city is "A".
class Solution {
    public String destCity(List< List< String>> paths) {
        HashMap< String, Integer> map = new HashMap< String, Integer>();
        int paths_len = paths.size();
        
        for(int i=0; i< paths_len; i++){         
            List< String> lst = paths.get(i);        
			//get current path
            String fstCity = lst.get(0);            
			//source city
            String sndCity = lst.get(1);            
			//dest city
            Integer fst = map.get(fstCity);         
			//get "# of connected cities" for the first city
            Integer snd = map.get(sndCity);         
			//same for second city
            
            if(fst == null)                         
			//add one connection to the first city
                map.put(fstCity, 1);
            else
                map.put(fstCity, fst+1);
            
            if(snd == null)                         
			//add an entry for the second city
                map.put(sndCity, 0);
        }
        
        for(String key : map.keySet())              
		//the key with a value of 0 (meaning it's not a SOURCE in any path) is the answer
            if(map.get(key) == 0)
                return key;
        return "";
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Check If All 1's Are at Least Length K Places Away</span>
Input: nums = [1,0,0,0,1,0,0,1], k = 2
Output: true
Explanation: Each of the 1s are at least 2 places away from each other.
Input: nums = [1,0,0,1,0,1], k = 2
Output: false
Explanation: The second 1 and third 1 are only one apart from each other.
class Solution {
    public boolean kLengthApart(int[] nums, int k) {
         int count=0,flag=0;
        for(int i=0;i< nums.length;i++){
            if(nums[i]==1){
                if(count< k && flag==1)
                    return false;
                count=0;
                flag=1;
            }
            else
                count++;
        }
        return true;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Consecutive Characters</span>
Input: s = "leetcode"
Output: 2
Explanation: The substring "ee" is of length 2 with the character 'e' only.
Input: s = "abbcccddddeeeeedcba"
Output: 5
Explanation: The substring "eeeee" is of length 5 with the character 'e' only.
class Solution {
    public int maxPower(String s) {
        int maxLen = 1, length = 1;
        for(int i = 0;i< s.length()-1;i++){
            if(s.charAt(i) == s.charAt(i+1)){
                length++;
                maxLen = Math.max(length, maxLen);
            }
            else{
                length = 1;
            }
        }
        return maxLen;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Number of Students Doing Homework at a Given Time</span>
Input: startTime = [1,2,3], endTime = [3,2,7], queryTime = 4
Output: 1
Explanation: We have 3 students where:
The first student started doing homework at time 1 and finished at time 3 and wasn't doing anything at time 4.
The second student started doing homework at time 2 and finished at time 2 and 
				also wasn't doing anything at time 4.
The third student started doing homework at time 3 and finished at time 7 and 
				was the only student doing homework at time 4.
Input: startTime = [4], endTime = [4], queryTime = 4
Output: 1
Explanation: The only student was doing their homework at the queryTime.
class Solution {
    public int busyStudent(int[] startTime, int[] endTime, int queryTime) {
         int count=0;
        for(int i=0;i< startTime.length;i++)
        {
                if(endTime[i]>=queryTime && startTime[i]<=queryTime) count++;
        }
        
        return count;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Check Array Formation Through Concatenation</span>
Input: arr = [15,88], pieces = [[88],[15]]
Output: true
Explanation: Concatenate [15] then [88]
Input: arr = [49,18,16], pieces = [[16,18,49]]
Output: false
Explanation: Even though the numbers match, we cannot reorder pieces[0].
class Solution {
    public boolean canFormArray(int[] arr, int[][] pieces) {
        HashMap<Integer,Integer> map = new HashMap<>();
        int i=0;
        for(int a: arr){
             map.put(a,i++);
        }
        
        for(int []nums: pieces){
            ArrayList<Integer>res = new ArrayList<>();
            for(int j=0;j< nums.length;++j){
                if(map.containsKey(nums[j])){
                    int size = res.size();
                    if(size!= 0){
                        if(map.get(nums[j])-res.get(size-1)!= 1){
                            return false; 
                        }
                 }
                    res.add(map.get(nums[j]));
                }else{
                    return false;
                }    
            }
        }
        
        return true;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Get Maximum in Generated Array</span>
Input: n = 7
Output: 3
Explanation: According to the given rules:
  nums[0] = 0
  nums[1] = 1
  nums[(1 * 2) = 2] = nums[1] = 1
  nums[(1 * 2) + 1 = 3] = nums[1] + nums[2] = 1 + 1 = 2
  nums[(2 * 2) = 4] = nums[2] = 1
  nums[(2 * 2) + 1 = 5] = nums[2] + nums[3] = 1 + 2 = 3
  nums[(3 * 2) = 6] = nums[3] = 2
  nums[(3 * 2) + 1 = 7] = nums[3] + nums[4] = 2 + 1 = 3
Hence, nums = [0,1,1,2,1,3,2,3], and the maximum is max(0,1,1,2,1,3,2,3) = 3.
Input: n = 2
Output: 1
Explanation: According to the given rules, nums = [0,1,1]. The maximum is max(0,1,1) = 1.
class Solution {
    public int getMaximumGenerated(int n) {
        if(n<=1) return n;
        int[] arr=new int[n+1];
        arr[0]=0;
        arr[1]=1;
        
        for(int i=2;i<=n;i++){
            arr[i]= i%2==0?arr[i/2]:arr[i/2]+arr[i-(i/2)];
        }
        
        int max=Integer.MIN_VALUE;
        for(int i:arr){
            max=Math.max(i,max);
        }
        return max;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Defuse the Bomb</span>
Input: code = [5,7,1,4], k = 3
Output: [12,10,16,13]
Explanation: Each number is replaced by the sum of the next 3 numbers. 
The decrypted code is [7+1+4, 1+4+5, 4+5+7, 5+7+1]. Notice that the numbers wrap around.
Input: code = [1,2,3,4], k = 0
Output: [0,0,0,0]
Explanation: When k is zero, the numbers are replaced by 0. 
class Solution {
    public int[] decrypt(int[] code, int k) {
        int res[]=new int[code.length];
        if(k==0) return res;
        int i= (k>0) ? 1 : code.length-1;
        int j=i;
        int sum=0;
        if(k>0){
            while(--k>=0)
            {
               sum+=code[j++]; 
            }
            j--;
        }else{
            while(++k<=0){
                sum+=code[j--]; 
            }
            j++;
            int temp=j;
            j=i;
            i=temp;
        }
        
        for(int p=0;p< code.length;p++){
            res[p]=sum;
          //  System.out.println(i+" "+j);
            j=(j+1)%code.length;
            sum=sum+(code[j]-code[i]);
            i=(i+1)%code.length;
        }
        return res;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Check If Two String Arrays are Equivalent</span>
Input: word1 = ["ab", "c"], word2 = ["a", "bc"]
Output: true
Explanation:
word1 represents string "ab" + "c" -> "abc"
word2 represents string "a" + "bc" -> "abc"
The strings are the same, so return true.
Input: word1 = ["a", "cb"], word2 = ["ab", "c"]
Output: false
class Solution {
    public boolean arrayStringsAreEqual(String[] word1, String[] word2) {
         return String.join("",word1).equals(String.join("",word2));
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Maximum Repeating Substring</span>
Input: sequence = "ababc", word = "ab"
Output: 2
Explanation: "abab" is a substring in "ababc".
Input: sequence = "ababc", word = "ba"
Output: 1
Explanation: "ba" is a substring in "ababc". "baba" is not a substring in "ababc".
class Solution {
    public int maxRepeating(String sequence, String word) {
        int c=0;
        String ans=word;
        while(sequence.contains(word)==true){
            c+=1;
            word=word+ans;
            //System.out.println(word);
        }
        return c;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Check if Binary String Has at Most One Segment of Ones</span>
Input: s = "1001"
Output: false
Explanation: The ones do not form a contiguous segment.
Input: s = "110"
Output: true
class Solution {
    public boolean checkOnesSegment(String s) {
        char[] nums = s.toCharArray();
        boolean isZero = false;
        
        for(int i = 0; i < nums.length; i++){
            if(nums[i] == '0')
                isZero = true;
            else if(isZero)
                return false;
        }
        return true;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Check if One String Swap Can Make Strings Equal</span>
Input: s1 = "bank", s2 = "kanb"
Output: true
Explanation: For example, swap the first character with the last character of s2 to make "bank".
Input: s1 = "attack", s2 = "defend"
Output: false
Explanation: It is impossible to make them equal with one string swap.
class Solution {
    public boolean areAlmostEqual(String s1, String s2) {
         if(s1.equals(s2))
            return true;
        List<Integer> l = new ArrayList<>();
        for (int i = 0; i < s1.length(); i++) {
            if (s1.charAt(i) != s2.charAt(i)) 
                l.add(i);
			if (l.size() > 2) 
                return false;
        }
        if(l.size()==2 && s1.charAt(l.get(0))==s2.charAt(l.get(1)) && s1.charAt(l.get(1))==s2.charAt(l.get(0)))
            return true;
        return false;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Minimum Number of Operations to Convert Time</span>
Input: current = "02:30", correct = "04:35"
Output: 3
Explanation:
We can convert current to correct in 3 operations as follows:
- Add 60 minutes to current. current becomes "03:30".
- Add 60 minutes to current. current becomes "04:30".
- Add 5 minutes to current. current becomes "04:35".
It can be proven that it is not possible to convert current to correct in fewer than 3 operations.
Input: current = "11:00", correct = "11:01"
Output: 1
Explanation: We only have to add one minute to current, so the minimum number of operations needed is 1.
class Solution {
    public int convertTime(String current, String correct) {
        int _currentHour=Integer.parseInt(current.substring(0,2));
        int _currentMinute=Integer.parseInt(current.substring(3));
        int _correctHour=Integer.parseInt(correct.substring(0,2));
        int _correctMinute=Integer.parseInt(correct.substring(3));
        
        int diff = (_correctHour*60+_correctMinute)-(_currentHour*60+_currentMinute);
        int operations = 0;
        int reminder=0;
            
        operations = diff/60;
        reminder=diff%60;
        operations +=reminder/15;
        reminder=reminder%15;
        operations +=reminder/5;
        reminder =reminder%5;
        
        return operations + reminder;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Minimum Bit Flips to Convert Number</span>
Input: start = 10, goal = 7
Output: 3
Explanation: The binary representation of 10 and 7 are 1010 and 0111 respectively. We can convert 10 to 7 in 3 steps:
- Flip the first bit from the right: 1010 -> 1011.
- Flip the third bit from the right: 1011 -> 1111.
- Flip the fourth bit from the right: 1111 -> 0111.
It can be shown we cannot convert 10 to 7 in less than 3 steps. Hence, we return 3.
Input: start = 3, goal = 4
Output: 3
Explanation: The binary representation of 3 and 4 are 011 and 100 respectively. We can convert 3 to 4 in 3 steps:
- Flip the first bit from the right: 011 -> 010.
- Flip the second bit from the right: 010 -> 000.
- Flip the third bit from the right: 000 -> 100.
It can be shown we cannot convert 3 to 4 in less than 3 steps. Hence, we return 3.
class Solution {
    public int minBitFlips(int start, int goal) {
         return Integer.bitCount(start^goal);
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Count Hills and Valleys in an Array</span>
Input: nums = [2,4,1,1,6,5]
Output: 3
Explanation:
At index 0: There is no non-equal neighbor of 2 on the left, so index 0 is neither a hill nor a valley.
At index 1: The closest non-equal neighbors of 4 are 2 and 1. Since 4 > 2 and 4 > 1, index 1 is a hill. 
At index 2: The closest non-equal neighbors of 1 are 4 and 6. Since 1 < 4 and 1 < 6, index 2 is a valley.
At index 3: The closest non-equal neighbors of 1 are 4 and 6. Since 1 < 4 and 1 < 6, index 3 is a valley, but note that it is part of the same valley as index 2.
At index 4: The closest non-equal neighbors of 6 are 1 and 5. Since 6 > 1 and 6 > 5, index 4 is a hill.
At index 5: There is no non-equal neighbor of 5 on the right, so index 5 is neither a hill nor a valley. 
There are 3 hills and valleys so we return 3.
Input: nums = [6,6,5,5,4,1]
Output: 0
Explanation:
At index 0: There is no non-equal neighbor of 6 on the left, so index 0 is neither a hill nor a valley.
At index 1: There is no non-equal neighbor of 6 on the left, so index 1 is neither a hill nor a valley.
At index 2: The closest non-equal neighbors of 5 are 6 and 4. Since 5 < 6 and 5 > 4, index 2 is neither a hill nor a valley.
At index 3: The closest non-equal neighbors of 5 are 6 and 4. Since 5 < 6 and 5 > 4, index 3 is neither a hill nor a valley.
At index 4: The closest non-equal neighbors of 4 are 5 and 1. Since 4 < 5 and 4 > 1, index 4 is neither a hill nor a valley.
At index 5: There is no non-equal neighbor of 1 on the right, so index 5 is neither a hill nor a valley.
There are 0 hills and valleys so we return 0.
class Solution {
    public int countHillValley(int[] nums) {
         int count=0;
    for(int i=0;i< nums.length-1;i++){
        if(nums[i]==nums[i+1]){
            nums[i]=0;
        }
    }
    int z=0;
    for(int i=0;i< nums.length;i++){
        if(nums[i]!=0){
            z++;
        }
    }
    int ans[]=new int[z];
    int j=0;
    for(int i=0;i< nums.length;i++){
        if(nums[i]!=0){
            ans[j]=nums[i];
            j++;
        }
    }
    for(int i=1;i< ans.length-1;i++){
        if(ans[i]>ans[i-1] && ans[i]>ans[i+1]){
            count++;
        }
        if(ans[i]< ans[i-1]&& ans[i]< ans[i+1]){
            count++;
        }
    }
    return count;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Divide Array Into Equal Pairs</span>
Input: nums = [3,2,3,2,2,2]
Output: true
Explanation: 
There are 6 elements in nums, so they should be divided into 6 / 2 = 3 pairs.
If nums is divided into the pairs (2, 2), (3, 3), and (2, 2), it will satisfy all the conditions.
Input: nums = [1,2,3,4]
Output: false
Explanation: 
There is no way to divide nums into 4 / 2 = 2 pairs such that the pairs satisfy every condition.
class Solution {
    public boolean divideArray(int[] nums) {
          Arrays.sort(nums);
       // int count = 0;
        for( int i = 0; i< nums.length ; i+=2){
            if(nums[i] != nums[i+1]){
                return false;
            }
        }
        return true;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Find All K-Distant Indices in an Array</span>
Input: nums = [3,4,9,1,3,9,5], key = 9, k = 1
Output: [1,2,3,4,5,6]
Explanation: Here, nums[2] == key and nums[5] == key.
- For index 0, |0 - 2| > k and |0 - 5| > k, so there is no j where |0 - j| <= k and nums[j] == key. Thus, 0 is not a k-distant index.
- For index 1, |1 - 2| <= k and nums[2] == key, so 1 is a k-distant index.
- For index 2, |2 - 2| <= k and nums[2] == key, so 2 is a k-distant index.
- For index 3, |3 - 2| <= k and nums[2] == key, so 3 is a k-distant index.
- For index 4, |4 - 5| <= k and nums[5] == key, so 4 is a k-distant index.
- For index 5, |5 - 5| <= k and nums[5] == key, so 5 is a k-distant index.
- For index 6, |6 - 5| <= k and nums[5] == key, so 6 is a k-distant index.
Thus, we return [1,2,3,4,5,6] which is sorted in increasing order. 
Input: nums = [2,2,2,2,2], key = 2, k = 2
Output: [0,1,2,3,4]
Explanation: For all indices i in nums, there exists some index j such that |i - j| <= k and nums[j] == key, so every index is a k-distant index. 
Hence, we return [0,1,2,3,4].
class Solution {
    public List<Integer> findKDistantIndices(int[] nums, int key, int k) {
         List<Integer>l=new ArrayList<>();
        for(int i=0;i< nums.length;i++)
            if(nums[i]==key)l.add(i);
        HashSet<Integer>h=new HashSet<>();
        for(int i=0;i< nums.length;i++)
        {
            for(int j=0;j< l.size();j++)
                if((int)Math.abs(i-l.get(j))<=k)h.add(i);
        }
        List<Integer>res=new ArrayList<>(h);
        Collections.sort(res);
        return res;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Cells in a Range on an Excel Sheet</span>
Input: s = "K1:L2"
Output: ["K1","K2","L1","L2"]
Explanation:
The above diagram shows the cells which should be present in the list.
The red arrows denote the order in which the cells should be presented.
Input: s = "A1:F1"
Output: ["A1","B1","C1","D1","E1","F1"]
Explanation:
The above diagram shows the cells which should be present in the list.
The red arrow denotes the order in which the cells should be presented.
class Solution {
    public List<String> cellsInRange(String s) {
    String a=s.substring(1,2);
    String b=s.substring(s.length()-1,s.length());

    List<String> list=new ArrayList<>();
    char c=s.charAt(0);
    char d=s.charAt(3);
    
    if(a.equals(b)){
       for(char m=c;m<=d;m++){
        // System.out.println(m);
        list.add(m+a);
        }
    }
    else{
        int x=Integer.parseInt(a);
        int y=Integer.parseInt(b);
        for(int z=x;z<=y;z++){
            for(char m=c;m<=d;m++){
                String last=Integer.toString(z);
                list.add(m+last);
            }
        }
    }
    Collections.sort(list);
    return list;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Most Frequent Number Following Key In an Array</span>
Input: nums = [1,100,200,1,100], key = 1
Output: 100
Explanation: For target = 100, there are 2 occurrences at indices 1 and 4 which follow an occurrence of key.
No other integers follow an occurrence of key, so we return 100.
Input: nums = [2,2,2,2,3], key = 2
Output: 2
Explanation: For target = 2, there are 3 occurrences at indices 1, 2, and 3 which follow an occurrence of key.
For target = 3, there is only one occurrence at index 4 which follows an occurrence of key.
target = 2 has the maximum number of occurrences following an occurrence of key, so we return 2.
class Solution {
    public int mostFrequent(int[] nums, int key) {
        HashMap<Integer, Integer> map = new HashMap<>();
        int ans=-1;
        int max=Integer.MIN_VALUE;
        for(int i = 0; i< nums.length-1; i++){
            if(nums[i]==key){
                if(!map.containsKey(nums[i+1])){
                    map.put(nums[i+1], 1);
                }
                else{
                    int x = map.get(nums[i+1]);
                    map.put(nums[i+1], ++x);
                }
                if(map.get(nums[i+1])>max){
                    max=map.get(nums[i+1]);
                    ans=nums[i+1];
                }
            }
        }
        return ans;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Counting Words With a Given Prefix</span>
Input: words = ["pay","attention","practice","attend"], pref = "at"
Output: 2
Explanation: The 2 strings that contain "at" as a prefix are: "attention" and "attend".
Input: words = ["leetcode","win","loops","success"], pref = "code"
Output: 0
Explanation: There are no strings that contain "code" as a prefix.
class Solution {
    public int prefixCount(String[] words, String pref) {
          int count=0;
        for(String s :words){
            if(s.length()>=pref.length() && s.substring(0,pref.length()).equals(pref))count++;
        }
            return count; 
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Count Integers With Even Digit Sum</span>
Input: num = 4
Output: 2
Explanation:
The only integers less than or equal to 4 whose digit sums are even are 2 and 4.    
Input: num = 30
Output: 14
Explanation:
The 14 integers less than or equal to 30 whose digit sums are even are
2, 4, 6, 8, 11, 13, 15, 17, 19, 20, 22, 24, 26, and 28.
class Solution {
    public int countEven(int num) {
     // Digit sum of the last number,
        //we can get each digit this way sicne the range is [1, 1000]
	int sum = num % 10 + (num / 10) % 10 + (num / 100) % 10 + (num / 1000) % 10;

	// Check the parity of the digit sum of the last number
	return (num - (sum & 1)) / 2;   
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Count Equal and Divisible Pairs in an Array</span>
Input: nums = [3,1,2,2,2,1,3], k = 2
Output: 4
Explanation:
There are 4 pairs that meet all the requirements:
- nums[0] == nums[6], and 0 * 6 == 0, which is divisible by 2.
- nums[2] == nums[3], and 2 * 3 == 6, which is divisible by 2.
- nums[2] == nums[4], and 2 * 4 == 8, which is divisible by 2.
- nums[3] == nums[4], and 3 * 4 == 12, which is divisible by 2.
Input: nums = [1,2,3,4], k = 1
Output: 0
Explanation: Since no value in nums is repeated, there are no pairs (i,j) that meet all the requirements.
class Solution {
    public int countPairs(int[] nums, int k) {
         int n=nums.length;
        int c=0;
        for(int i=0;i< n;i++)
        {
            for(int j=i+1;j< n;j++)
            {
                if(nums[i]==nums[j])
                {
                    if((i*j)%k==0)
                    {
                        c++;
                    }
                }
            }
        }
        return c;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Count the Number of Consistent Strings</span>
 Input: allowed = "ab", words = ["ad","bd","aaab","baa","badab"]
Output: 2
Explanation: Strings "aaab" and "baa" are consistent since they only contain characters 'a' and 'b'.
Input: allowed = "abc", words = ["a","b","c","ab","ac","bc","abc"]
Output: 7
Explanation: All strings are consistent.
class Solution {
    public int countConsistentStrings(String allowed, String[] words) {
          int count = 0;
        for(String s : words){
            count++;
            for(char c : s.toCharArray()){
                if(!allowed.contains(c + "")){
                    count--;
                    break;
                }else
                    continue;
            }
        }
        return count;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Count of Matches in Tournament</span>
Input: n = 7
Output: 6
Explanation: Details of the tournament: 
- 1st Round: Teams = 7, Matches = 3, and 4 teams advance.
- 2nd Round: Teams = 4, Matches = 2, and 2 teams advance.
- 3rd Round: Teams = 2, Matches = 1, and 1 team is declared the winner.
Total number of matches = 3 + 2 + 1 = 6.
Input: n = 14
Output: 13
Explanation: Details of the tournament:
- 1st Round: Teams = 14, Matches = 7, and 7 teams advance.
- 2nd Round: Teams = 7, Matches = 3, and 4 teams advance.
- 3rd Round: Teams = 4, Matches = 2, and 2 teams advance.
- 4th Round: Teams = 2, Matches = 1, and 1 team is declared the winner.
Total number of matches = 7 + 3 + 2 + 1 = 13.
class Solution {
    public int numberOfMatches(int n) {
         return n - 1;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Reformat Phone Number</span>
Input: number = "1-23-45 6"
Output: "123-456"
Explanation: The digits are "123456".
Step 1: There are more than 4 digits, so group the next 3 digits. The 1st block is "123".
Step 2: There are 3 digits remaining, so put them in a single block of length 3. The 2nd block is "456".
Joining the blocks gives "123-456".
Input: number = "123 4-567"
Output: "123-45-67"
Explanation: The digits are "1234567".
Step 1: There are more than 4 digits, so group the next 3 digits. The 1st block is "123".
Step 2: There are 4 digits left, so split them into two blocks of length 2. The blocks are "45" and "67".
Joining the blocks gives "123-45-67".
class Solution {
    public String reformatNumber(String number) {
        Queue<Character> queue = new LinkedList<>();
		StringBuilder result = new StringBuilder();
		for(int i=0;i< number.length();i++)
		if(Character.isDigit(number.charAt(i))) queue.offer(number.charAt(i));
		while(queue.size()>4)
			result.append(queue.poll()).append(queue.poll()).append(queue.poll()).append('-');
			if(queue.size()==4) result.append(queue.poll()).append(queue.poll()).append('-');
		while(!queue.isEmpty()) result.append(queue.poll());
		return result.toString();
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Minimum Changes To Make Alternating Binary String</span>
Input: s = "0100"
Output: 1
Explanation: If you change the last character to '1', s will be "0101", which is alternating.
Input: s = "10"
Output: 0
Explanation: s is already alternating.
class Solution {
    public int minOperations(String s) {
           int res = 0;
        if (s == null || s.length() == 0) 
            return 0;
        char[] c = s.toCharArray();
        char next = c[0] == '0' ? '1' : '0';
        for (int i = 1; i < c.length; i++) {
            if (c[i] != next) {
                res++;
            }
            next = next == '0' ? '1' : '0';

        } 
        return Math.min(res, c.length - res);
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Merge Strings Alternately</span>
Input: word1 = "abc", word2 = "pqr"
Output: "apbqcr"
Explanation: The merged string will be merged as so:
word1:  a   b   c
word2:    p   q   r
merged: a p b q c r
Input: word1 = "ab", word2 = "pqrs"
Output: "apbqrs"
Explanation: Notice that as word2 is longer, "rs" is appended to the end.
word1:  a   b 
word2:    p   q   r   s
merged: a p b q   r   s
class Solution {
    public String mergeAlternately(String word1, String word2) {
          StringBuilder result = new StringBuilder();
        int j = 0;
        int k = 0;

        for(int i=0;i< word1.length()+word2.length();i++){
            if(i< word1.length()){
                result.append(word1.charAt(j));
                j++;
            }
            if(i< word2.length()){
                result.append(word2.charAt(k));
                k++;
            }
        }
        return result.toString();
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Number of Students Unable to Eat Lunch</span>
Input: students = [1,1,0,0], sandwiches = [0,1,0,1]
Output: 0 
Explanation:
- Front student leaves the top sandwich and returns to the end of the line making students = [1,0,0,1].
- Front student leaves the top sandwich and returns to the end of the line making students = [0,0,1,1].
- Front student takes the top sandwich and leaves the line making students = [0,1,1] and sandwiches = [1,0,1].
- Front student leaves the top sandwich and returns to the end of the line making students = [1,1,0].
- Front student takes the top sandwich and leaves the line making students = [1,0] and sandwiches = [0,1].
- Front student leaves the top sandwich and returns to the end of the line making students = [0,1].
- Front student takes the top sandwich and leaves the line making students = [1] and sandwiches = [1].
- Front student takes the top sandwich and leaves the line making students = [] and sandwiches = [].
Hence all students are able to eat.
Input: students = [1,1,1,0,0,1], sandwiches = [1,0,0,0,1,1]
Output: 3
class Solution {
    public int countStudents(int[] students, int[] sandwiches) {
        int count = 0;
		int s = 0;
		ArrayList obj = new ArrayList<>();
		for(int i = 0 ; i < students.length; i++){
			obj.add(students[i]);
		}
		ArrayList obj2 = new ArrayList<>();
		for(int i = 0 ; i < sandwiches.length; i++){
			obj2.add(sandwiches[i]);
		}

		int i = 0;
		while(obj.size() -count > 0){
			if(obj.size() == count){
				return count;
			}
			if(obj.get(i) != obj2.get(s)){
				obj.add(obj.get(i));
				obj.remove(i);
				count++;
			} else if(obj.get(i) == obj2.get(s)){
				obj.remove(i);
				obj2.remove(s);
				count = 0;
			}
		}
		return obj.size();
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Path Sum</span>
Input: root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22
Output: true
Explanation: The root-to-leaf path with the target sum is shown.
Input: root = [1,2,3], targetSum = 5
Output: false
Explanation: There two root-to-leaf paths in the tree:
(1 --> 2): The sum is 3.
(1 --> 3): The sum is 4.
There is no root-to-leaf path with sum = 5.
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public boolean hasPathSum(TreeNode root, int targetSum) {
         if(root==null){
            return false;
        }
          if(root.left==null&&root.right==null){
            if(targetSum==root.val)return true;
            return false;
        }
          return hasPathSum(root.left,targetSum-root.val)||hasPathSum(root.right,targetSum-root.val);
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Minimum Sum of Four Digit Number After Splitting Digits</span>
Input: num = 2932
Output: 52
Explanation: Some possible pairs [new1, new2] are [29, 23], [223, 9], etc.
The minimum sum can be obtained by the pair [29, 23]: 29 + 23 = 52.
Input: num = 4009
Output: 13
Explanation: Some possible pairs [new1, new2] are [0, 49], [490, 0], etc. 
The minimum sum can be obtained by the pair [4, 9]: 4 + 9 = 13.
class Solution {
    public int minimumSum(int num) {
        int i=0;
        int arr[]=new int[4];
        
        while(num!=0){
            arr[i++]=num%10;
            num /= 10;
        }
        
        Arrays.sort(arr);
        return ( ((arr[0]*10)+arr[2]) + ((arr[1]*10)+arr[3]) );  
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Two Furthest Houses With Different Colors</span>
Input: colors = [1,1,1,6,1,1,1]
Output: 3
Explanation: In the above image, color 1 is blue, and color 6 is red.
The furthest two houses with different colors are house 0 and house 3.
House 0 has color 1, and house 3 has color 6. The distance between them is abs(0 - 3) = 3.
Note that houses 3 and 6 can also produce the optimal answer.
Input: colors = [1,8,3,8,3]
Output: 4
Explanation: In the above image, color 1 is blue, color 8 is yellow, and color 3 is green.
The furthest two houses with different colors are house 0 and house 4.
House 0 has color 1, and house 4 has color 3. The distance between them is abs(0 - 4) = 4.
class Solution {
    public int maxDistance(int[] colors) {
      int i=0,j=colors.length-1;
        int d=0;
        while(colors[i]==colors[j])j--;
        d=j-i;
        j=colors.length-1;
        while(colors[i]==colors[j])i++;
        d=Math.max(d,j-i);
        return d;  
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Kth Distinct String in an Array</span>
Input: arr = ["d","b","c","b","c","a"], k = 2
Output: "a"
Explanation:
The only distinct strings in arr are "d" and "a".
"d" appears 1st, so it is the 1st distinct string.
"a" appears 2nd, so it is the 2nd distinct string.
Since k == 2, "a" is returned. 
Input: arr = ["aaa","aa","a"], k = 1
Output: "aaa"
Explanation:
All strings in arr are distinct, so the 1st string "aaa" is returned.
class Solution {
   
        public String kthDistinct(String[] arr, int k) {
        Map< String, Integer> map = new HashMap<>();

        for (String s : arr) {
            map.put(s, map.getOrDefault(s, 0) + 1);
        }

        int count = 0;

        for (String s : arr) {
            if (map.get(s) == 1) {
                count++;
                if (count == k) return s;
            }
        }

        return ""; 
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Number of Valid Words in a Sentence</span> 
Input: sentence = "cat and  dog"
Output: 3
Explanation: The valid words in the sentence are "cat", "and", and "dog".
Input: sentence = "!this  1-s b8d!"
Output: 0
Explanation: There are no valid words in the sentence.
"!this" is invalid because it starts with a punctuation mark.
"1-s" and "b8d" are invalid because they contain digits.
class Solution {
    public int countValidWords(String sentence) {
        String regex = "^([a-z]+(-?[a-z]+)?)?(!|\\.|,)?$";
        String r2 = "[^0-9]+";
        String[] arr = sentence.split("\\s+");
        int ans = 0;
        for(String s: arr)
        {
            if(s.matches(regex) && s.matches(r2))
            {
                ans++;
                //System.out.println(s);
            }
        }
        return ans; 
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Count Number of Pairs With Absolute Difference K</span>
Input: nums = [1,2,2,1], k = 1
Output: 4
Explanation: The pairs with an absolute difference of 1 are:
- [1,2,2,1]
- [1,2,2,1]
- [1,2,2,1]
- [1,2,2,1]
Input: nums = [3,2,1,5,4], k = 2
Output: 3
Explanation: The pairs with an absolute difference of 2 are:
- [3,2,1,5,4]
- [3,2,1,5,4]
- [3,2,1,5,4]
class Solution {
    public int countKDifference(int[] nums, int k) {
         Map<Integer,Integer> map = new HashMap<>();
        int res = 0;
        
        for(int i = 0;i< nums.length;i++){
            if(map.containsKey(nums[i]-k)){
                res+= map.get(nums[i]-k);
            }
            if(map.containsKey(nums[i]+k)){
                res+= map.get(nums[i]+k);
            }
            map.put(nums[i],map.getOrDefault(nums[i],0)+1);
        }
        
        
        return res; 
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle"> Find if Path Exists in Graph</span>
 Input: n = 3, edges = [[0,1],[1,2],[2,0]], source = 0, destination = 2
Output: true
Explanation: There are two paths from vertex 0 to vertex 2:
- 0 → 1 → 2
- 0 → 2
Input: n = 6, edges = [[0,1],[0,2],[3,5],[5,4],[4,3]], source = 0, destination = 5
Output: false
Explanation: There is no path from vertex 0 to vertex 5.
class Solution {
    public static boolean validPath(int n, int[][] edges, int source, int destination) {
        if (source == destination) return true;
            
        UF uf = new UF(n);
        for (int[] edge : edges) {
            uf.union(edge[0], edge[1]);
        }

        return uf.isConnected(source, destination);
    }
    
    public static class UF {
        int[] elements;
        int[] size;

        public UF(int n) {
            elements = new int[n];
            size = new int[n];
            
            for (int i = 0; i < n; i++) {
                elements[i] = i;
            }
        }

        public void union(int p, int q) {
            int pRoot = root(p);
            int qRoot = root(q);
            if (pRoot == qRoot) return;
            
            if (size[pRoot] < size[qRoot]) {
                elements[pRoot] = qRoot;
                size[qRoot] += size[pRoot];
            } else {
                elements[qRoot] = pRoot;
                size[pRoot] += size[qRoot];
            }
        }

        public boolean isConnected(int p, int q) {
            return root(p) == root(q);
        }

        private int root(int i) {
            while (elements[i] != i) {
                elements[i] = elements[elements[i]];
                i = elements[i];
            }
            
            return i;
        }
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Count Square Sum Triples</span>
Input: n = 5
Output: 2
Explanation: The square triples are (3,4,5) and (4,3,5).
Input: n = 10
Output: 4
Explanation: The square triples are (3,4,5), (4,3,5), (6,8,10), and (8,6,10).
class Solution {
    public int countTriples(int n) {
      // collect all squares
	var squares = new HashSet<Integer>();
	for (var i = 1; i <= n; i++)
		squares.add(i * i);

	var count = 0;
	// check if the sum of squares of i and j is in the set,
	// if yes then count (i, j) and (j, i) as 2 distinct ordered pairs
	for (var i = 1; i < n; i++)
		for (var j = i; i * i + j * j <= n * n; j++)
			if (squares.contains(i * i + j * j))
				count += 2;
	return count;  
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle"> Longer Contiguous Segments of Ones than Zeros</span>
 Input: s = "1101"
Output: true
Explanation:
The longest contiguous segment of 1s has length 2: "1101"
The longest contiguous segment of 0s has length 1: "1101"
The segment of 1s is longer, so return true.
Input: s = "111000"
Output: false
Explanation:
The longest contiguous segment of 1s has length 3: "111000"
The longest contiguous segment of 0s has length 3: "111000"
The segment of 1s is not longer, so return false.
class Solution {
    public boolean checkZeroOnes(String s) {
        if(s.length()==1&&s.charAt(0)=='1'){
            return true;
        }
        int one=0;
        int c=1;
        for(int i=0;i< s.length()-1;i++){
            if(s.charAt(i)!=s.charAt(i+1)&&s.charAt(i)=='1'){
                one=Math.max(one,c);
                c=1;
            }
            else if(s.charAt(i)==s.charAt(i+1)&&s.charAt(i)=='1'){
                c++;
            }
        }
        one=Math.max(one,c);
        int zero=0;
        c=1;
        for(int i=0;i< s.length()-1;i++){
            if(s.charAt(i)!=s.charAt(i+1)&&s.charAt(i)=='0'){
                zero=Math.max(zero,c);
                c=1;
            }
            else if(s.charAt(i)==s.charAt(i+1)&&s.charAt(i)=='0'){
                c++;
            }
        }
        zero=Math.max(zero,c);
        return one>zero; 
    }
}

<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Two Sum IV - Input is a BST</span>
Input: root = [5,3,6,2,4,null,7], k = 9
Output: true
Input: root = [5,3,6,2,4,null,7], k = 28
Output: false
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public boolean findTarget(TreeNode root, int k) {
       Set<Integer> set=new HashSet<>();
        return preorder(root,set,k);
    }
    public boolean preorder(TreeNode root,Set<Integer> set,int k){
        if(root==null)return false;
        int element=k-root.val;
        if(set.contains(element))return true;
        set.add(root.val);
        return preorder(root.left,set,k)||preorder(root.right,set,k);
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Counting Bits</span>
Input: n = 2
Output: [0,1,1]
Explanation:
0 --> 0
1 --> 1
2 --> 10
Input: n = 5
Output: [0,1,1,2,1,2]
Explanation:
0 --> 0
1 --> 1
2 --> 10
3 --> 11
4 --> 100
5 --> 101
class Solution {
    public int[] countBits(int n) {
         int dp[] = new int[n+1];
    
    for(int i=0;i<=n;i++)
    {
        //for even number number of bits is number of bits in [number/2]
        //for odd number number of bits is number of bits in [number/2]+1
        dp[i] = dp[i/2] + i%2; //i%2 is for adding 1 for odd numbers 
    }
    
    return dp; 
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Check if Array Is Sorted and Rotated</span>
Input: nums = [3,4,5,1,2]
Output: true
Explanation: [1,2,3,4,5] is the original sorted array.
You can rotate the array by x = 3 positions to begin on the the element of value 3: [3,4,5,1,2].
Input: nums = [2,1,3,4]
Output: false
Explanation: There is no sorted array once rotated that can make nums.
class Solution {
    public boolean check(int[] nums) {
        int brr[] = nums.clone();
Arrays.sort(nums);
int temp = brr[0];
for(int i=0;i< brr.length;i++){
  for(int j=0;j< brr.length-1;j++){
    int t = brr[j+1];
    brr[j+1] = temp;
    temp =t;
  }
  brr[0]=temp;
  if(Arrays.equals(brr,nums))
    return true;
  }
  return false; 
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Maximum Units on a Truck</span>
Input: boxTypes = [[1,3],[2,2],[3,1]], truckSize = 4
Output: 8
Explanation: There are:
- 1 box of the first type that contains 3 units.
- 2 boxes of the second type that contain 2 units each.
- 3 boxes of the third type that contain 1 unit each.
You can take all the boxes of the first and second types, and one box of the third type.
The total number of units will be = (1 * 3) + (2 * 2) + (1 * 1) = 8.
Input: boxTypes = [[5,10],[2,5],[4,7],[3,9]], truckSize = 10
Output: 91
class Solution {
    public int maximumUnits(int[][] boxTypes, int truckSize) {
       Arrays.sort(boxTypes, Comparator.comparingInt(o -> -o[1]));
		int ans = 0, i = 0, n = boxTypes.length;
		while (i < n && truckSize > 0) {
			int maxi = Math.min(boxTypes[i][0], truckSize);
			ans += maxi * boxTypes[i][1];
			i++;
			truckSize -= maxi;
		}
		return ans; 
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Sum of All Odd Length Subarrays</span>
Input: arr = [1,4,2,5,3]
Output: 58
Explanation: The odd-length subarrays of arr and their sums are:
[1] = 1
[4] = 4
[2] = 2
[5] = 5
[3] = 3
[1,4,2] = 7
[4,2,5] = 11
[2,5,3] = 10
[1,4,2,5,3] = 15
If we add all these together we get 1 + 4 + 2 + 5 + 3 + 7 + 11 + 10 + 15 = 58
Input: arr = [1,2]
Output: 3
Explanation: There are only 2 subarrays of odd length, [1] and [2]. Their sum is 3.
class Solution {
    public int sumOddLengthSubarrays(int[] arr) {
         int count = 0;
        for(int i = 1; i <= arr.length; i += 2) {
            for(int j = 0; j < arr.length; j++) {            
                if(j + i <= arr.length) {
                    for(int k = j; k < j + i; k++) {
                        count += arr[k];
                    }
                }
            }
        }
        return count;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Design Parking System</span>
Input
["ParkingSystem", "addCar", "addCar", "addCar", "addCar"]
[[1, 1, 0], [1], [2], [3], [1]]
Output
[null, true, true, false, false]

Explanation
ParkingSystem parkingSystem = new ParkingSystem(1, 1, 0);
parkingSystem.addCar(1); // return true because there is 1 available slot for a big car
parkingSystem.addCar(2); // return true because there is 1 available slot for a medium car
parkingSystem.addCar(3); // return false because there is no available slot for a small car
parkingSystem.addCar(1); // return false because there is no available slot for a big car. It is already occupied.
class ParkingSystem {

  int big =0, medium=0, small=0;

    public ParkingSystem(int big, int medium, int small) {
        this.big = big;
        this.medium = medium;
        this.small = small;      
    }
    
    public boolean addCar(int carType) {
        
        switch (carType){
            case 1:
                if(big == 0){
                    return false;
                }else{
                    big--;
                }
                break;
            case 2:
                if(medium == 0){
                    return false;
                }else{
                    medium--;
                }
                break;
            case 3:
                if(small == 0){
                    return false;
                }else{
                    small--;
                }
                break;
            default:
                System.out.println("cases condition not fulfilled!");
        }
      return true; 
    }
}

/**
 * Your ParkingSystem object will be instantiated and called as such:
 * ParkingSystem obj = new ParkingSystem(big, medium, small);
 * boolean param_1 = obj.addCar(carType);
 */
 <span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Sort Array by Increasing Frequency</span>
Input: nums = [1,1,2,2,2,3]
Output: [3,1,1,2,2,2]
Explanation: '3' has a frequency of 1, '1' has a frequency of 2, and '2' has a frequency of 3.
Input: nums = [2,3,1,3,2]
Output: [1,3,3,2,2]
Explanation: '2' and '3' both have a frequency of 2, so they are sorted in decreasing order.
class Solution {
    public int[] frequencySort(int[] nums) {
        Map<Integer, Integer> map = new HashMap<>();
        List<Integer> ans = new ArrayList<>();

        for (int n : nums) {                            // O(n)
            ans.add(n);
            map.put(n, map.getOrDefault(n, 0) + 1);
        }

        Collections.sort(ans, (a, b) -> {               // O(n * logn)
            return map.get(a) == map.get(b) ? b - a : map.get(a) - map.get(b);
        });

        return ans.stream().mapToInt(i -> i).toArray(); // O(n)
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Slowest Key</span> 
 Input: releaseTimes = [9,29,49,50], keysPressed = "cbcd"
Output: "c"
Explanation: The keypresses were as follows:
Keypress for 'c' had a duration of 9 (pressed at time 0 and released at time 9).
Keypress for 'b' had a duration of 29 - 9 = 20 (pressed at time 9 right after the release of the previous character and released at time 29).
Keypress for 'c' had a duration of 49 - 29 = 20 (pressed at time 29 right after the release of the previous character and released at time 49).
Keypress for 'd' had a duration of 50 - 49 = 1 (pressed at time 49 right after the release of the previous character and released at time 50).
The longest of these was the keypress for 'b' and the second keypress for 'c', both with duration 20.
'c' is lexicographically larger than 'b', so the answer is 'c'.
Input: releaseTimes = [12,23,36,46,62], keysPressed = "spuda"
Output: "a"
Explanation: The keypresses were as follows:
Keypress for 's' had a duration of 12.
Keypress for 'p' had a duration of 23 - 12 = 11.
Keypress for 'u' had a duration of 36 - 23 = 13.
Keypress for 'd' had a duration of 46 - 36 = 10.
Keypress for 'a' had a duration of 62 - 46 = 16.
The longest of these was the keypress for 'a' with duration 16.
class Solution {
    public char slowestKey(int[] releaseTimes, String keysPressed) {
         int n = releaseTimes.length;
        int maxDifference = releaseTimes[0];
        char bestChar = keysPressed.charAt(0);
        for (int i = 1; i < n; i++) {
            int difference = releaseTimes[i] - releaseTimes[i-1];

            if (difference > maxDifference || 
                (difference == maxDifference && keysPressed.charAt(i) > bestChar)) {
                maxDifference = difference;
                bestChar = keysPressed.charAt(i);
            }
        }
        return bestChar; 
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Matrix Diagonal Sum</span>
Input: mat = [[1,2,3],
              [4,5,6],
              [7,8,9]]
Output: 25
Explanation: Diagonals sum: 1 + 5 + 9 + 3 + 7 = 25
Notice that element mat[1][1] = 5 is counted only once.
Input: mat = [[1,1,1,1],
              [1,1,1,1],
              [1,1,1,1],
              [1,1,1,1]]
Output: 8
class Solution {
    public int diagonalSum(int[][] mat) {
           int res = 0;
        int n = mat.length;
        for (int i=0; i< n; i++) {
            res += mat[i][i]; // Primary diagonals are row = column! 
            res += mat[n-1-i][i]; // Secondary diagonals are row + column = n-1!
        }
        return n % 2 == 0 ? res : res - mat[n/2][n/2]; // if n is a odd number, that mean we have added the center element twice!
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Kth Missing Positive Number</span>
Input: arr = [2,3,4,7,11], k = 5
Output: 9
Explanation: The missing positive integers are [1,5,6,8,9,10,12,13,...]. The 5th missing positive integer is 9.
Input: arr = [1,2,3,4], k = 2
Output: 6
Explanation: The missing positive integers are [5,6,7,...]. The 2nd missing positive integer is 6.
class Solution {
    public int findKthPositive(int[] arr, int k) {
           for(int i : arr){
			if(i <= k) k++; else break;
		}
        return k;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Count Odd Numbers in an Interval Range</span>
Input: low = 3, high = 7
Output: 3
Explanation: The odd numbers between 3 and 7 are [3,5,7].
Input: low = 8, high = 10
Output: 1
Explanation: The odd numbers between 8 and 10 are [9].
class Solution {
    public int countOdds(int low, int high) {
          int nums=high-low+1;  //counting total numbers in range
 
		if(low%2!=0 && high%2!=0)  
            return nums/2 + 1;
        
        else
		return nums/2;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Water Bottles</span>
Input: numBottles = 9, numExchange = 3
Output: 13
Explanation: You can exchange 3 empty bottles to get 1 full water bottle.
Number of water bottles you can drink: 9 + 3 + 1 = 13.
Input: numBottles = 15, numExchange = 4
Output: 19
Explanation: You can exchange 4 empty bottles to get 1 full water bottle. 
Number of water bottles you can drink: 15 + 3 + 1 = 19.
class Solution {
    public int numWaterBottles(int numBottles, int numExchange) {
        int ans = numBottles;
        int empty = ans;
        int rem=0;
        while(empty/numExchange>=1){
            numBottles = empty/numExchange;
            rem = empty%numExchange;
            ans = ans + numBottles;
            empty = rem + numBottles;
        }
        return ans; 
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Number of Good Pairs</span>
Input: nums = [1,2,3,1,1,3]
Output: 4
Explanation: There are 4 good pairs (0,3), (0,4), (3,4), (2,5) 0-indexed.
Input: nums = [1,1,1,1]
Output: 6
Explanation: Each pair in the array are good.
class Solution {
    public int numIdenticalPairs(int[] nums) {
          int ans = 0;
        int[] temp = new int[101];
        
        for (int i = 0; i < nums.length; i++) {
            ans += temp[nums[i]]++;
        }
        return ans; 
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle"> Can Make Arithmetic Progression From Sequence</span>
 Input: arr = [3,5,1]
Output: true
Explanation: We can reorder the elements as 
[1,3,5] or [5,3,1] with differences 2 and -2 respectively, between each consecutive elements.
Input: arr = [1,2,4]
Output: false
Explanation: There is no way to reorder the elements to obtain an arithmetic progression.
class Solution {
    public boolean canMakeArithmeticProgression(int[] arr) {
           Arrays.sort(arr);
    int d = arr[1] - arr[0];
    for (int i = 1; i < arr.length; i++) {
        if (arr[i] != (arr[i - 1] + d)) {
            return false;
        }
    }
    return true;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Average Salary Excluding the Minimum and Maximum Salary</span>
Input: salary = [4000,3000,1000,2000]
Output: 2500.00000
Explanation: Minimum salary and maximum salary are 1000 and 4000 respectively.
Average salary excluding minimum and maximum salary is (2000+3000) / 2 = 2500
Input: salary = [1000,2000,3000]
Output: 2000.00000
Explanation: Minimum salary and maximum salary are 1000 and 3000 respectively.
Average salary excluding minimum and maximum salary is (2000) / 1 = 2000
class Solution {
    public double average(int[] salary) {
         int min = 0;
        int max = 0;
        double sum = salary[0];

        for (int i = 1; i < salary.length; i++) {
            if (salary[i] > salary[max]) {
                max = i;
            } else if (salary[i] < salary[min]) {
                min = i;
            }
            sum += salary[i];
        }
        sum = sum - salary[min] - salary[max];

        return (sum / (salary.length - 2));
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Final Prices With a Special Discount in a Shop</span>
Input: prices = [8,4,6,2,3]
Output: [4,2,4,2,3]
Explanation: 
For item 0 with price[0]=8 you will receive a discount equivalent to prices[1]=4, therefore, the final price you will pay is 8 - 4 = 4.
For item 1 with price[1]=4 you will receive a discount equivalent to prices[3]=2, therefore, the final price you will pay is 4 - 2 = 2.
For item 2 with price[2]=6 you will receive a discount equivalent to prices[3]=2, therefore, the final price you will pay is 6 - 2 = 4.
For items 3 and 4 you will not receive any discount at all.
Input: prices = [1,2,3,4,5]
Output: [1,2,3,4,5]
Explanation: In this case, for all items, you will not receive any discount at all.
class Solution {
    public int[] finalPrices(int[] prices) {
        int a2[]=new int[prices.length];
        for(int i=0;i< prices.length;i++){
            a2[i]=prices[i];
        }
        for(int i=0;i< prices.length;i++){
            for(int j=i+1;j< prices.length;j++){
                if(prices[i]>=a2[j]){
                    prices[i]=prices[i]-a2[j];
                    break;
                }
            }
        }
        return prices;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Shuffle the Array</span>
Input: nums = [2,5,1,3,4,7], n = 3
Output: [2,3,5,4,1,7] 
Explanation: Since x1=2, x2=5, x3=1, y1=3, y2=4, y3=7 then the answer is [2,3,5,4,1,7].
Input: nums = [1,2,3,4,4,3,2,1], n = 4
Output: [1,4,2,3,3,2,4,1]
class Solution {
    public int[] shuffle(int[] nums, int n) {
        int[] ans = new int[2*n];
        for(int i=0;i< n;i++){
            ans[2*i]= nums[i];
            ans[2*i+1]=nums[i+n];
        }
        return ans; 
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Check If a Word Occurs As a Prefix of Any Word in a Sentence</span>
Input: sentence = "i love eating burger", searchWord = "burg"
Output: 4
Explanation: "burg" is prefix of "burger" which is the 4th word in the sentence.
Input: sentence = "this problem is an easy problem", searchWord = "pro"
Output: 2
Explanation: "pro" is prefix of "problem" which is the 2nd and the 6th word in the sentence, 
but we return 2 as it's the minimal index.
class Solution {
    public int isPrefixOfWord(String sentence, String searchWord) {
        String[] sentences = sentence.split(" ");
        for (int i = 0; i < sentences.length; i++) {
            if (sentences[i].startsWith(searchWord)) {
                return (i + 1);
            }
        }
        return -1; 
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Kids With the Greatest Number of Candies</span>
Input: candies = [2,3,5,1,3], extraCandies = 3
Output: [true,true,true,false,true] 
Explanation: If you give all extraCandies to:
- Kid 1, they will have 2 + 3 = 5 candies, which is the greatest among the kids.
- Kid 2, they will have 3 + 3 = 6 candies, which is the greatest among the kids.
- Kid 3, they will have 5 + 3 = 8 candies, which is the greatest among the kids.
- Kid 4, they will have 1 + 3 = 4 candies, which is not the greatest among the kids.
- Kid 5, they will have 3 + 3 = 6 candies, which is the greatest among the kids.
Input: candies = [4,2,1,1,2], extraCandies = 1
Output: [true,false,false,false,false] 
Explanation: There is only 1 extra candy.
Kid 1 will always have the greatest number of candies, even if a different kid is given the extra candy.
class Solution {
    public List<Boolean> kidsWithCandies(int[] candies, int extraCandies) {
        List<Boolean> list = new ArrayList<>();

		int max=Integer.MIN_VALUE;
		for(int i=0;i< candies.length;i++)
			if(candies[i]>max)
				max=candies[i];
		for(int i:candies){
			if(extraCandies+i >=max)
			   list.add(true);
			else
				list.add(false);

		}
		return list;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Minimum Value to Get Positive Step by Step Sum</span>
Input: nums = [-3,2,-3,4,2]
Output: 5
Explanation: If you choose startValue = 4, in the third iteration your step by step sum is less than 1.
step by step sum
startValue = 4 | startValue = 5 | nums
  (4 -3 ) = 1  | (5 -3 ) = 2    |  -3
  (1 +2 ) = 3  | (2 +2 ) = 4    |   2
  (3 -3 ) = 0  | (4 -3 ) = 1    |  -3
  (0 +4 ) = 4  | (1 +4 ) = 5    |   4
  (4 +2 ) = 6  | (5 +2 ) = 7    |   2
  Input: nums = [1,-2,-3]
Output: 5
class Solution {
    public int minStartValue(int[] nums) {
        int min=0;
        int sum=0;
        for(int i:nums){
            sum+=i;
            min=Math.min(min,sum);
        }
        if(min< 0){
            return (min*-1)+1;
        }
        return 1;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">String Matching in an Array</span>
Input: words = ["mass","as","hero","superhero"]
Output: ["as","hero"]
Explanation: "as" is substring of "mass" and "hero" is substring of "superhero".
["hero","as"] is also a valid answer.
Input: words = ["leetcode","et","code"]
Output: ["et","code"]
Explanation: "et", "code" are substring of "leetcode".
class Solution {
    public List<String> stringMatching(String[] words) {
        List<String>ans=new ArrayList<>();
        for(int i=0;i< words.length;i++){
            for(int j=0;j< words.length;j++){
                if(words[j].equals(words[i])==false && words[j].contains(words[i])){
                    ans.add(words[i]);
                    break;
                }
                //System.out.println(ans);
            }
        }
        return ans;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Minimum Subsequence in Non-Increasing Order</span>
Input: nums = [4,3,10,9,8]
Output: [10,9] 
Explanation: The subsequences [10,9] and [10,8] are minimal such that the sum of their elements is strictly 
greater than the sum of elements not included. 
However, the subsequence [10,9] has the maximum total sum of its elements.
Input: nums = [4,4,7,6,7]
Output: [7,7,6] 
Explanation: The subsequence [7,7] has the sum of its elements equal to 14 which is not strictly 
greater than the sum of elements not included (14 = 4 + 4 + 6). 
Therefore, the subsequence [7,6,7] is the minimal satisfying the conditions. 
Note the subsequence has to be returned in non-decreasing order. 
class Solution {
    public List<Integer> minSubsequence(int[] nums) {
        int total = 0;
        for(int i=0;i< nums.length;i++){
            total += nums[i];
        }
        Arrays.sort(nums);
        int sum = 0;
        ArrayList<Integer> ans = new ArrayList<>();
        for(int i=nums.length-1;i>=0;i--){
            ans.add(nums[i]);
            sum += nums[i];
            if(sum>total-sum){
                return ans;
            }
        }
        return ans;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">How Many Numbers Are Smaller Than the Current Number</span>
Input: nums = [8,1,2,2,3]
Output: [4,0,1,1,3]
Explanation: 
For nums[0]=8 there exist four smaller numbers than it (1, 2, 2 and 3). 
For nums[1]=1 does not exist any smaller number than it.
For nums[2]=2 there exist one smaller number than it (1). 
For nums[3]=2 there exist one smaller number than it (1). 
For nums[4]=3 there exist three smaller numbers than it (1, 2 and 2).
Input: nums = [6,5,4,8]
Output: [2,1,0,3]
class Solution {
    public int[] smallerNumbersThanCurrent(int[] nums) {
        int[] count = new int[101];
        int[] res = new int[nums.length];
        
        for (int i =0; i < nums.length; i++){
            count[nums[i]]++;
        }
        for (int i = 1 ; i <= 100; i++){
            count[i] += count[i-1];    
        }
        
        for (int i = 0; i < nums.length; i++) {
            if (nums[i] == 0)
                res[i] = 0;
            else 
                res[i] = count[nums[i] - 1];
        }
        
        return res;        
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Number of Days Between Two Dates</span>
Input: date1 = "2019-06-29", date2 = "2019-06-30"
Output: 1
Input: date1 = "2020-01-15", date2 = "2019-12-31"
Output: 15
class Solution {
    public int daysBetweenDates(String date1, String date2) {
        return Math.abs(getDays(date1) - getDays(date2));
    }

    private static int getDays(String s){
        int y = Integer.parseInt(s.substring(0, 4));
        int m = Integer.parseInt(s.substring(5, 7));
        int d = Integer.parseInt(s.substring(8, 10));
        int[] prefix = new int[]{0, 0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
        for (int i = 2; i <= 13; i++) prefix[i] += prefix[i - 1];
        int ans = (y - 1971) * 365 + prefix[m] + d;
        for (int i = 1972; i < y; i+=4)
            if (isLeap(i))
                ans++;
        if (isLeap(y) && m > 2) ans++; //don't include this within the for loop because m > 2 for it to count.

        return ans;
    }

    private static boolean isLeap(int y){
        return y % 4 == 0 && (y % 100 != 0 || y % 400 == 0);
    }

}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">The K Weakest Rows in a Matrix</span>
Input: mat = 
[[1,1,0,0,0],
 [1,1,1,1,0],
 [1,0,0,0,0],
 [1,1,0,0,0],
 [1,1,1,1,1]], 
k = 3
Output: [2,0,3]
Explanation: 
The number of soldiers in each row is: 
- Row 0: 2 
- Row 1: 4 
- Row 2: 1 
- Row 3: 2 
- Row 4: 5 
The rows ordered from weakest to strongest are [2,0,3,1,4].
Input: mat = 
[[1,0,0,0],
 [1,1,1,1],
 [1,0,0,0],
 [1,0,0,0]], 
k = 2
Output: [0,2]
Explanation: 
The number of soldiers in each row is: 
- Row 0: 1 
- Row 1: 4 
- Row 2: 1 
- Row 3: 1 
The rows ordered from weakest to strongest are [0,2,3,1].
class Solution {
    public int[] kWeakestRows(int[][] mat, int k) {
        int len = mat.length;
        int[] res = new int[k];
        int[] shoot = new int[len];
        
        for(int i = 0; i < len; i++){
            int count = 0;
            for(int j = 0; j < mat[i].length; j++){
                count += mat[i][j];
            }
            shoot[i] = count;
        }
        
        for(int i = 0; i < k; i++){
            int min = Integer.MAX_VALUE;
            int index = 0;
            for(int j = 0; j < len; j++){
                if(shoot[j] != -1 && shoot[j] < min){
                    min = shoot[j];
                    index = j;
                }
            }
            res[i] = index;
            shoot[index] = -1;
        }
        
        return res;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Decompress Run-Length Encoded List</span>
Input: nums = [1,2,3,4]
Output: [2,4,4,4]
Explanation: The first pair [1,2] means we have freq = 1 and val = 2 so we generate the array [2].
The second pair [3,4] means we have freq = 3 and val = 4 so we generate [4,4,4].
At the end the concatenation [2] + [4,4,4] is [2,4,4,4].
Input: nums = [1,1,2,3]
Output: [1,3,3]
class Solution {
    public int[] decompressRLElist(int[] nums) {
        int freq=0,val=0;
        ArrayList<Integer> a=new ArrayList<>();
        for(int i=0;i< nums.length;i=i+2){
            freq=nums[i];
            val=nums[i+1];
            while(freq!=0){
                a.add(val);
                freq--;
            }
        }
        int arr[]=new int[a.size()];
        for(int i=0;i< a.size();i++){
            arr[i]=a.get(i);
        }
    return arr; 
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Prime Arrangements</span>
Input: n = 5
Output: 12
Explanation: For example [1,2,5,4,3] is a valid permutation, 
but [5,2,3,4,1] is not because the prime number 5 is at index 1.
Input: n = 100
Output: 682289015
class Solution {
    private static final long MOD = (long) 1e9 + 7;
    
    public int numPrimeArrangements(int n) {
        int primesCount = countNumberOfPrimes(n);
        long result = fact(primesCount) * fact(n - primesCount) % MOD;
        
        return (int) result;
    }
    
    private int countNumberOfPrimes(int n) {
        int answer = 0;
        boolean[] isNotPrime = new boolean[n + 1];
        
        for (int i = 2; i <= n; i++) {
            if (isNotPrime[i])
                continue;
            
            answer++;
            for (int j = i * i; j <= n; j += i)
                isNotPrime[j] = true;
        }
        return answer;
    }
    
    private long fact(int n) {
        long answer = 1;
        while (n > 1) {
            answer = (answer * n) % MOD;
            n--;
        }
        
        return answer;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Defanging an IP Address</span>
Input: address = "1.1.1.1"
Output: "1[.]1[.]1[.]1"
Input: address = "255.100.50.0"
Output: "255[.]100[.]50[.]0"
class Solution {
    public String defangIPaddr(String address) {
        address=address.replace(".","[.]");
        return address; 
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Surface Area of 3D Shapes</span>
Input: grid = [[1,2],[3,4]]
Output: 34
Input: grid = [[1,1,1],[1,0,1],[1,1,1]]
Output: 32
class Solution {
    public int surfaceArea(int[][] grid) {
        int area = 0;
        for(int i = 0; i< grid.length; i++){
            
            for(int j = 0;j< grid.length; j++){
                
                int curValue = grid[i][j];
                if(curValue == 0)
                    continue;
                
                if(i+1>= grid.length) area  += curValue;
                else if(curValue > grid[i+1][j]){
                    area += curValue - grid[i+1][j];
                }
                
                if(i-1 < 0) area+= curValue;
                else if(curValue > grid[i-1][j]){
                    area +=curValue - grid[i-1][j];
                }
                
                if(j+1 >= grid.length) area += curValue;
                else if(curValue > grid[i][j+1]){
                    area += curValue - grid[i][j+1];
                }
                
                if(j-1 < 0) area += curValue;
                else if(curValue > grid[i][j-1]){
                    area += curValue - grid[i][j-1];
                }
                if(curValue != 0)
                    area+=2;
            }
        }
        return area;  
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Prime Number of Set Bits in Binary Representation</span>
Input: left = 6, right = 10
Output: 4
Explanation:
6  -> 110 (2 set bits, 2 is prime)
7  -> 111 (3 set bits, 3 is prime)
8  -> 1000 (1 set bit, 1 is not prime)
9  -> 1001 (2 set bits, 2 is prime)
10 -> 1010 (2 set bits, 2 is prime)
4 numbers have a prime number of set bits.
Input: left = 10, right = 15
Output: 5
Explanation:
10 -> 1010 (2 set bits, 2 is prime)
11 -> 1011 (3 set bits, 3 is prime)
12 -> 1100 (2 set bits, 2 is prime)
13 -> 1101 (3 set bits, 3 is prime)
14 -> 1110 (3 set bits, 3 is prime)
15 -> 1111 (4 set bits, 4 is not prime)
5 numbers have a prime number of set bits.
class Solution {
    public  int calculateSetBits(String s){
        int count=0;
        for (int i = 0; i < s.length(); i++) {
            if(s.charAt(i)=='1') count++;
        }
        return count;
    }

    public  boolean isPrime(int n){
        if (n==0 || n==1) return false;
        for (int i = 2; i <= n/2; i++) {
            if(n%i ==0 ) return false;
        }
//        System.out.println(n+" - ");
        return true;
    }

    public  int countPrimeSetBits(int left, int right) {
        int count=0;
        for(int i=left;i<=right;i++){
            String b= Integer.toBinaryString(i);

            int n=calculateSetBits(b);

            if(isPrime(n)) count++;
        }
        return count;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Reverse Words in a String III</span>
Input: s = "Let's take LeetCode contest"
Output: "s'teL ekat edoCteeL tsetnoc"
Input: s = "God Ding"
Output: "doG gniD"
class Solution {
    public String reverseWords(String s) {
        int temp=-1;
        s=s+" ";
        String ans="",str="";
        for(int i=0;i< s.length();i++){
            if(s.charAt(i)==' '){
            for(int j=i-1;j>temp;j--){
                str=str+ s.charAt(j);
            }
            temp=i;
            ans=ans+str+" ";
            str="";
        }else
            continue;
        }
        ans=ans.trim(); //to remove extra white spaces
        return ans;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">find question</span>
Input: n = 5, start = 0
Output: 8
Explanation: Array nums is equal to [0, 2, 4, 6, 8] where (0 ^ 2 ^ 4 ^ 6 ^ 8) = 8.
Where "^" corresponds to bitwise XOR operator.
Input: n = 4, start = 3
Output: 8
Explanation: Array nums is equal to [3, 5, 7, 9] where (3 ^ 5 ^ 7 ^ 9) = 8.
class Solution {
    public int xorOperation(int n, int start) {
       int[] arr=new int[n];
       int ans=0;
       for(int i=0;i< n;i++){
           arr[i]=start + 2 * i;
           ans=ans^arr[i];
       }
       return ans;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">leetcode Easy Level End</span>									
<span class="textStyle">LEETCODE Easy Level End</span>									
<span class="textStyle">LeetCode Easy Level End</span>									
<span class="textStyle">leetcode Easy Level End</span>									
<span class="textStyle">Leetcode Easy Level End</span>									
<span class="textStyle">leetcode Easy Level End</span>									
<span class="textStyle">LEETCODE Easy Level End</span>									
<hr>							
<span class="textStyle">leetcode Medium Level start</span>									
<span class="textStyle">LEETCODE Medium Level start</span>									
<span class="textStyle">LeetCode Medium Level start</span>									
<span class="textStyle">leetcode Medium Level start</span>									
<span class="textStyle">Leetcode Medium Level start</span>									
<span class="textStyle">leetcode Medium Level start</span>									
<span class="textStyle">LEETCODE Medium Level start</span>									
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Reverse Integer</span>
Input: x = 123
Output: 321
Input: x = -123
Output: -321
class Solution {
    public int reverse(int x) {
         
        int rev = 0;
        while (x != 0) {
            int pop = x % 10;
            x /= 10;
            if (rev > Integer.MAX_VALUE/10 || (rev == Integer.MAX_VALUE / 10 && pop > 7)) return 0;
            if (rev < Integer.MIN_VALUE/10 || (rev == Integer.MIN_VALUE / 10 && pop < -8)) return 0;
            rev = rev * 10 + pop;
        }
        return rev;
    }
    
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Remove Duplicates from Sorted Array II</span>
Input: nums = [1,1,1,2,2,3]
Output: 5, nums = [1,1,2,2,3,_]
Explanation: Your function should return k = 5, with the first five elements of nums being
 1, 1, 2, 2 and 3 respectively.
It does not matter what you leave beyond the returned k (hence they are underscores).
Input: nums = [0,0,1,1,1,1,2,3,3]
Output: 7, nums = [0,0,1,1,2,3,3,_,_]
Explanation: Your function should return k = 7, with the first seven elements of nums being 
0, 0, 1, 1, 2, 3 and 3 respectively.
It does not matter what you leave beyond the returned k (hence they are underscores).
class Solution {
    public int removeDuplicates(int[] nums) {
         if(nums.length< 3) return nums.length;
        int n=2;
        for(int i=2;i< nums.length;i++){
            if(nums[i]!=nums[n-2]){
                nums[n++]=nums[i];
            }
        }
        return n;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle"> Find the Index of the First Occurrence in a String</span>
 Input: haystack = "sadbutsad", needle = "sad"
Output: 0
Explanation: "sad" occurs at index 0 and 6.
The first occurrence is at index 0, so we return 0.
Input: haystack = "leetcode", needle = "leeto"
Output: -1
Explanation: "leeto" did not occur in "leetcode", so we return -1.
class Solution {
    public int strStr(String haystack, String needle) {
       if(needle.isEmpty())
           return 0;
        if(haystack.equals(needle))
            return 0;
        int m=haystack.length();
        int n=needle.length();
        if(m< n)
            return -1;
        for(int i=0;i< =m-n;i++){
            int j;
            for(j=0;j< n;j++){
                if(haystack.charAt(i+j)!=needle.charAt(j))
                    break;
            }
            if(j==n)
                return i;
        }
        return -1;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Min Stack</span>
Input
["MinStack","push","push","push","getMin","pop","top","getMin"]
[[],[-2],[0],[-3],[],[],[],[]]

Output
[null,null,null,null,-3,null,0,-2]

Explanation
MinStack minStack = new MinStack();
minStack.push(-2);
minStack.push(0);
minStack.push(-3);
minStack.getMin(); // return -3
minStack.pop();
minStack.top();    // return 0
minStack.getMin(); // return -2
class MinStack {

    /** initialize your data structure here. */
    Stack<Integer> stack=new Stack();
    Stack<Integer> min_val=new Stack();
    public MinStack() {
        
    }
    
    public void push(int val) {
        if(min_val.isEmpty()||val<=min_val.peek()){
            min_val.push(val);
        }
        stack.push(val);
    }
    
    public void pop() {
        if(stack.peek().equals(min_val.peek())){
            min_val.pop();
        }
        stack.pop();
    }
    
    public int top() {
        return stack.peek();
    }
    
    public int getMin() {
        return min_val.peek();
    }
}

/**
 * Your MinStack object will be instantiated and called as such:
 * MinStack obj = new MinStack();
 * obj.push(val);
 * obj.pop();
 * int param_3 = obj.top();
 * int param_4 = obj.getMin();
 */
 <span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Factorial Trailing Zeroes</span>
Input: n = 3
Output: 0
Explanation: 3! = 6, no trailing zero.
Input: n = 5
Output: 1
Explanation: 5! = 120, one trailing zero.
class Solution {
    public int trailingZeroes(int n) {
      int ans=0;
        while(n>0){
            n=n/5;
            ans=ans+n;
        }
        return ans;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Two Sum II - Input Array Is Sorted</span>
Input: numbers = [2,7,11,15], target = 9
Output: [1,2]
Explanation: The sum of 2 and 7 is 9. Therefore, index1 = 1, index2 = 2. We return [1, 2].
Input: numbers = [2,3,4], target = 6
Output: [1,3]
Explanation: The sum of 2 and 4 is 6. Therefore index1 = 1, index2 = 3. We return [1, 3].
class Solution {
    public int[] twoSum(int[] numbers, int target) {
        int[] result=new int[2];
        int left=0,right=numbers.length-1;
        while(left< right){
            int l=numbers[left];
            int r=numbers[right];
            if(l+r==target){
                result[0]=left+1;
                result[1]=right+1;
                break;
            }
            else if(l+r< target){
                left++;
            }else{
                right--;
            }
        }
        return result;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Count Primes</span>
Input: n = 10
Output: 4
Explanation: There are 4 prime numbers less than 10, they are 2, 3, 5, 7.
Input: n = 0
Output: 0
class Solution {
    public int countPrimes(int n) {
        if(n<=2)return 0;
        boolean[] com=new boolean[n];
        int limit=(int)Math.sqrt(n);
        for(int i=2;i<=limit;i++){
            if(com[i]==false){
                for(int j=i*i;j< n;j=j+i){
                    com[j]=true;
                }
            }
        }
        int count=0;
        for(int i=2;i< n;i++){
            if(com[i]==false)
                count++;
        }
        return count;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Delete Node in a Linked List</span>
Input: head = [4,5,1,9], node = 5
Output: [4,1,9]
Explanation: You are given the second node with value 5, 
the linked list should become 4 -> 1 -> 9 after calling your function.
Input: head = [4,5,1,9], node = 1
Output: [4,5,9]
Explanation: You are given the third node with value 1, the linked list should 
become 4 -> 5 -> 9 after calling your function.
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public void deleteNode(ListNode node) {
        node.val=node.next.val;
        node.next=node.next.next;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle"> Lowest Common Ancestor of a Binary Search Tree</span>
 Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8
Output: 6
Explanation: The LCA of nodes 2 and 8 is 6.
Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4
Output: 2
Explanation: The LCA of nodes 2 and 4 is 2, since a node can be a 
descendant of itself according to the LCA definition.
Input: root = [2,1], p = 2, q = 1
Output: 2
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */

class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
     if(p.val< root.val&&q.val< root.val){
         return lowestCommonAncestor(root.left,p,q);
     }   
        if(p.val>root.val&&q.val>root.val){
            return lowestCommonAncestor(root.right,p,q);
        }
        return root;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">3Sum</span>
Input: nums = [-1,0,1,2,-1,-4]
Output: [[-1,-1,2],[-1,0,1]]
Explanation: 
nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0.
nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0.
nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0.
The distinct triplets are [-1,0,1] and [-1,-1,2].
Notice that the order of the output and the order of the triplets does not matter.
Input: nums = [0,1,1]
Output: []
Explanation: The only possible triplet does not sum up to 0.
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        int n=nums.length;
        if(n< 3)return new ArrayList();
        List< List< Integer>> result=new ArrayList<>();
        Arrays.sort(nums);
        for(int i=0;i< n-2;i++){
            if(i==0||nums[i]!=nums[i-1]){
                int j=i+1;
                int k=n-1;
                while(j< k){
                    int sum=nums[i]+nums[j]+nums[k];
                    if(sum==0){
                        result.add(Arrays.asList(nums[i],nums[j],nums[k]));
                        while(j< k&&nums[j]==nums[j+1])
                            j++;
                        while(j< k&&nums[k]==nums[k-1])
                            k--;
                        j++;k--;
                        
                    }
                    else if(sum>0){
                        k--;
                    }else{
                        j++;
                    }
                }
            }
        }
        return result;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Container With Most Water</span>
Input: height = [1,8,6,2,5,4,8,3,7]
Output: 49
Explanation: The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. 
In this case, the max area of water (blue section) the container can contain is 49.
Input: height = [1,1]
Output: 1
class Solution {
    public int maxArea(int[] height) {
       int i=0;
        int j=height.length-1;
        int water=0;
        while(i< j){
            int w=j-i;
            int h=Math.min(height[i],height[j]);
            water=Math.max(water,h*w);
            if(height[i]< height[j]){
                i++;
            }else{
                j--;
            }
        }
        return water;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Minimum Moves to Equal Array Elements</span>
Input: nums = [1,2,3]
Output: 3
Explanation: Only three moves are needed (remember each move increments two elements):
[1,2,3]  =>  [2,3,3]  =>  [3,4,3]  =>  [4,4,4]
Input: nums = [1,1,1]
Output: 0
class Solution {
    public int minMoves(int[] nums) {
        Arrays.sort(nums);
        int n=nums.length;
        int res=0;
        for(int i=n-1;i>=0;i--){
            res+=nums[i]-nums[0];
        }
        return res;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Permutations</span>
Input: nums = [1,2,3]
Output: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
Input: nums = [0,1]
Output: [[0,1],[1,0]]
class Solution {
    public List<List<Integer>> permute(int[] nums) {
       List<List<Integer>> result=new ArrayList<>();
        backtrack(result,nums,0);
        return result;
    }
    public void backtrack(List<List<Integer>> result,int[] nums,int start){
        if(start==nums.length){
            result.add(toList(nums));
        }else{
            for(int i=start;i< nums.length;i++){
                swap(i,start,nums);
                backtrack(result,nums,start+1);
                 swap(i,start,nums);
            }
        }
    }
    public List<Integer> toList(int[] nums){
        List<Integer> res=new ArrayList<>();
        for(int iu:nums){
            res.add(iu);
        }
        return res;
    }
    public void swap(int i,int j,int[] nums){
        int temp=nums[i];
        nums[i]=nums[j];
        nums[j]=temp;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Permutations II</span>
Input: nums = [1,1,2]
Output:
[[1,1,2],
 [1,2,1],
 [2,1,1]]
 Input: nums = [1,2,3]
Output: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
class Solution {
    public List<List<Integer>> permuteUnique(int[] nums) {
     List<List<Integer>> result=new ArrayList<>();
        backtrack(result,nums,0);
        return result;
    }
    public void backtrack(List<List<Integer>> result,int[] nums,int start){
        if(start==nums.length){
            result.add(toList(nums));
        }else{
            for(int i=start;i< nums.length;i++){
                if(i!=start&&!canpermute(start,i,nums))continue;
                swap(i,start,nums);
                backtrack(result,nums,start+1);
                 swap(i,start,nums);
            }
        }
    }
    public List<Integer> toList(int[] nums){
        List<Integer> res=new ArrayList<>();
        for(int iu:nums){
            res.add(iu);
        }
        return res;
    }
    public void swap(int i,int j,int[] nums){
        int temp=nums[i];
        nums[i]=nums[j];
        nums[j]=temp;
    }
    public boolean canpermute(int start,int curr,int[] nums){
        for(int i=start;i< curr;i++){
            if(nums[i]==nums[curr])
                return false;
        }
         return true;
    }
   
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Rotate Image</span>
Input: matrix = [[1,2,3],[4,5,6],[7,8,9]]
Output: [[7,4,1],[8,5,2],[9,6,3]]
Input: matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]
Output: [[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]
class Solution {
    public void rotate(int[][] matrix) {
       int n=matrix.length;
        for(int i=0;i< n;i++){
            for(int j=i;j< n;j++){
                int temp=matrix[i][j];
                matrix[i][j]=matrix[j][i];
                matrix[j][i] =temp;             
            }
        }
         for(int i=0;i< n;i++){
            for(int j=0;j< n/2;j++){
                int temp=matrix[i][j];
                matrix[i][j]=matrix[i][n-j-1];
               matrix[i][n-j-1] =temp;             
            }
        }
          
      
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Jump Game II</span>
Input: nums = [2,3,1,1,4]
Output: 2
Explanation: The minimum number of jumps to reach the last index is 2. 
Jump 1 step from index 0 to 1, then 3 steps to the last index.
Input: nums = [2,3,0,1,4]
Output: 2
class Solution {
    public int jump(int[] nums) {
       int n=nums.length;
        int[] dp=new int[n];
        Arrays.fill(dp,Integer.MAX_VALUE);
        dp[n-1]=0;
        for(int i=n-2;i>=0;i--){
            int min=Integer.MAX_VALUE;
            for(int j=i+1;j<=Math.min(n-1,i+nums[i]);j++){
                min=Math.min(min,dp[j]);
            }
            if(min!=Integer.MAX_VALUE){
                dp[i]=min+1;
            }
        }
        return dp[0];
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Combination Sum</span>
Input: candidates = [2,3,6,7], target = 7
Output: [[2,2,3],[7]]
Explanation:
2 and 3 are candidates, and 2 + 2 + 3 = 7. Note that 2 can be used multiple times.
7 is a candidate, and 7 = 7.
These are the only two combinations.
Input: candidates = [2,3,5], target = 8
Output: [[2,2,2,2],[2,3,3],[3,5]]
class Solution {
   
    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        List<List<Integer>> result=new ArrayList();
        backtracking(candidates,0,target,new ArrayList(),result);
        return result;
    }
     private void backtracking(int[] cand,int start,int target,List<Integer> list,List<List<Integer>> result){
        if(target< 0)
            return;
        if(target==0)
            result.add(new ArrayList(list));
        for(int i=start;i< cand.length;i++){
            list.add(cand[i]);
            backtracking(cand,i,target-cand[i],list,result);
            list.remove(list.size()-1);
        }
    }
    
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Peak Index in a Mountain Array</span>
Input: arr = [0,1,0]
Output: 1
Input: arr = [0,2,1,0]
Output: 1
class Solution {
    public int peakIndexInMountainArray(int[] arr) {
       int max=arr[0];
        int index=0;
        for(int i=0;i< arr.length;i++){
            if(max< arr[i]){
                max=arr[i];
                index=i;
            }
        }
        return index;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Search in Rotated Sorted Array</span>
Input: nums = [4,5,6,7,0,1,2], target = 0
Output: 4
Input: nums = [4,5,6,7,0,1,2], target = 3
Output: -1
class Solution {
    public int search(int[] nums, int target) {
       int lo=0;
       int hi=nums.length-1;
       while(lo<=hi){
           int mid=(lo+hi)/2;
           if(nums[mid]==target){
               return mid;
           }else if(nums[lo]<=nums[mid]){
               if(target>=nums[lo]&&nums[mid]>target){
                   hi=mid-1;
               }else{
                   lo=mid+1;
               }
           }else if(nums[mid]<=nums[hi]){
               if(target>nums[mid]&&nums[hi]>=target){
                   lo=mid+1;
               }else{
                   hi=mid-1;
               }
           }
       } 
        return -1;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Find Minimum in Rotated Sorted Array</span>
Input: nums = [3,4,5,1,2]
Output: 1
Explanation: The original array was [1,2,3,4,5] rotated 3 times.
Input: nums = [11,13,15,17]
Output: 11
Explanation: The original array was [11,13,15,17] and it was rotated 4 times. 
class Solution {
    public int findMin(int[] arr) {
       int lo=0;
        int hi=arr.length-1;
        if(arr[lo]<=arr[hi]){
            return arr[0];
        }
        while(lo<=hi){
            int mid=(lo+hi)/2;
            
            if(arr[mid]>arr[mid+1]){
                return arr[mid+1];
            }else if(arr[mid]< arr[mid-1]){
                return arr[mid];
            }else if(arr[lo]<=arr[mid]){
                lo=mid+1;
            }else if(arr[mid]<=arr[hi]){
                hi=mid-1;
            }
        }
        return -1;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Koko Eating Bananas</span>
Input: piles = [3,6,7,11], h = 8
Output: 4
Input: piles = [30,11,23,4,20], h = 5
Output: 30
Input: piles = [30,11,23,4,20], h = 6
Output: 23
class Solution {
    public int minEatingSpeed(int[] piles, int h) {
      int max=Integer.MIN_VALUE;
        for(int val:piles){
            max=Math.max(val,max);
        }
        int lo=0;
        int hi=max;
        int speed=Integer.MAX_VALUE;
        if(hi==piles.length){
            return max;
        }
        while(lo<=hi){
            int sp=lo+(hi-lo)/2;
            if(ispossibe(piles,h,sp)==true){
                speed=sp;
                hi=sp-1;
            }else{
                lo=sp+1;
            }
        }
        return speed;
    }
    public boolean ispossibe(int[] piles,int h,int sp){
        int time=0;
        for(int i=0;i< piles.length;i++){
            time+=(int)Math.ceil(piles[i]*1.0/sp);
        }
        return time<=h;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Add Two Numbers</span>
Input: l1 = [2,4,3], l2 = [5,6,4]
Output: [7,0,8]
Explanation: 342 + 465 = 807.
Input: l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]
Output: [8,9,9,9,0,0,0,1]
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        ListNode dummy=new ListNode(0);
        ListNode l3=dummy;
        int carry=0;
        while(l1!=null||l2!=null){
            int l1value=(l1!=null)?l1.val:0;
            int l2value=(l2!=null)?l2.val:0;
            int current=l1value+l2value+carry;
            carry=current/10;
            int lastdigit=current%10;
            ListNode newnode=new ListNode(lastdigit);
            l3.next=newnode;
            if(l1!=null)l1=l1.next;
            if(l2!=null)l2=l2.next;
            l3=l3.next;
        }
        if(carry>0){
            ListNode newnode=new ListNode(1);
            l3.next=newnode;
            l3=l3.next;
        }
        return dummy.next;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Longest Palindromic Substring</span>
Input: s = "babad"
Output: "bab"
Explanation: "aba" is also a valid answer..
Input: s = "cbbd"
Output: "bb"
class Solution {
    public String longestPalindrome(String s) {
        int start=0,end=0;
        for(int i=0;i< s.length();i++){
            int odd=expand(s,i,i);
            int even=expand(s,i,i+1);
            
            int len=Math.max(odd,even);
            if(len>end-start){
                start=i-(len-1)/2;
                end=i+len/2;
            }
        }
        return s.substring(start,end+1);
    }
    int expand(String s,int i,int j){
        while(i>=0&&j< s.length()&&s.charAt(i)==s.charAt(j)){
            i--;
            j++;
        }
        return j-i-1;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Longest Substring Without Repeating Characters</span>
Input: s = "abcabcbb"
Output: 3
Explanation: The answer is "abc", with the length of 3.
Input: s = "pwwkew"
Output: 3
Explanation: The answer is "wke", with the length of 3.
Notice that the answer must be a substring, "pwke" is a subsequence and not a substring.
class Solution {
    public int lengthOfLongestSubstring(String s) {
       int ans=0;
        int i=-1;
        int j=-1;
        HashMap< Character,Integer> map=new HashMap();
        while(true){
            boolean f1=false;
            boolean f2=false;
            while(i< s.length()-1){
                f1=true;
                i++;
                char ch=s.charAt(i);
                map.put(ch,map.getOrDefault(ch,0)+1);
                if(map.get(ch)==2){
                    break;
                }else{
                    int len=i-j;
                    if(len>ans){
                        ans=len;
                    }
                }
            }
            while(j< i){
                j++;
                f2=true;
                char ch=s.charAt(j);
                map.put(ch,map.get(ch)-1);
                if(map.get(ch)==1){
                    break;
                }
            }
            if(f1==false&&f2==false){
                break;
            }
        }
        return ans;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Pow(x, n)</span>
Input: x = 2.00000, n = 10
Output: 1024.00000
Input: x = 2.00000, n = -2
Output: 0.25000
Explanation: 2-2 = 1/22 = 1/4 = 0.25
class Solution {
    public double myPow(double x, int n) {
      
        return answer(x,n);
    }
    double answer(double x,long n){
          if(n==0)return 1.0;
        if(n==1)return x;
        if(n< 0){
            return answer(1/x,-n);
        }
        double ans=answer(x*x,n/2);
        if(n%2==1)
            ans*=x;
        return ans;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Palindrome Partitioning</span>
Input: s = "aab"
Output: [["a","a","b"],["aa","b"]]
Input: s = "a"
Output: [["a"]]
class Solution {
    public List<List<String>> partition(String s) {
     List<List<String>> res=new ArrayList<>();
     List<String> path=new ArrayList<>();
        myfunction(0,s,path,res);
        return res;
    }
    void myfunction(int index,String s,List<String> path,List<List<String>> res){
        if(index==s.length()){
            res.add(new ArrayList<>(path));
            return;
        }
        for(int i=index;i< s.length();i++){
            if(isplain(s,index,i)){
                path.add(s.substring(index,i+1));
                myfunction(i+1,s,path,res);
                path.remove(path.size()-1);
            }
        }
    }
    boolean isplain(String s,int start, int end){
        while(start<=end){
            if(s.charAt(start++)!=s.charAt(end--)){
                return false;
            }
        }
        return true;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Letter Combinations of a Phone Number</span>
Input: digits = "23"
Output: ["ad","ae","af","bd","be","bf","cd","ce","cf"]
Input: digits = "2"
Output: ["a","b","c"]
class Solution {
    String[] map=new String[]{"","","abc","def","ghi","jkl","mno","pqrs","tuv","wxyz"};
    List<String> result=null;
    public List<String> letterCombinations(String digits) {
        result=new ArrayList<>();
        if(digits.length()==0)return result;
        dfs(0,digits,new StringBuilder());
        return result;
    }
    void dfs(int length,String digit,StringBuilder temp){
        if(length==digit.length()){
            result.add(temp.toString());
            return;
        }
        char ch=digit.charAt(length);
        String str=map[ch-'0'];
        for(char c:str.toCharArray()){
            temp.append(c);
            dfs(length+1,digit,temp);
            temp.deleteCharAt(temp.length()-1);
        }
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Rotate Array</span>
Input: nums = [1,2,3,4,5,6,7], k = 3
Output: [5,6,7,1,2,3,4]
Explanation:
rotate 1 steps to the right: [7,1,2,3,4,5,6]
rotate 2 steps to the right: [6,7,1,2,3,4,5]
rotate 3 steps to the right: [5,6,7,1,2,3,4]
Input: nums = [-1,-100,3,99], k = 2
Output: [3,99,-1,-100]
Explanation: 
rotate 1 steps to the right: [99,-1,-100,3]
rotate 2 steps to the right: [3,99,-1,-100]
class Solution {
    public void rotate(int[] nums, int k) {
      int n=nums.length;
        k%=n;
        reverse(nums,0,n-k-1);
        reverse(nums,n-k,n-1);
        reverse(nums,0,n-1);
    }
    public void reverse(int[] arr,int l,int r){
        while(l< r){
            int tem=arr[l];
            arr[l]=arr[r];
            arr[r]=tem;
            l++;r--;
        }
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Triangle</span>
Input: triangle = [[2],[3,4],[6,5,7],[4,1,8,3]]
Output: 11
Explanation: The triangle looks like:
   2
  3 4
 6 5 7
4 1 8 3
The minimum path sum from top to bottom is 2 + 3 + 5 + 1 = 11 (underlined above).
Input: triangle = [[-10]]
Output: -10
class Solution {
    public int minimumTotal(List< List< Integer>> t) {
        for(int i=1;i< t.size();i++){
            for(int j=0;j< t.get(i).size();j++){
                int sum=0;
                if(j==0){
                    sum=t.get(i).get(j)+t.get(i-1).get(j);
                }else if(j==t.get(i).size()-1){
                    sum=t.get(i).get(j)+t.get(i-1).get(t.get(i-1).size()-1);
                }else{
                    int min=Math.min(t.get(i-1).get(j),t.get(i-1).get(j-1));
                    sum=min+t.get(i).get(j);
                }
                t.get(i).set(j,sum);
            }
        }
        return Collections.min(t.get(t.size()-1));
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Permutation in String</span>
Input: s1 = "ab", s2 = "eidbaooo"
Output: true
Explanation: s2 contains one permutation of s1 ("ba").
Input: s1 = "ab", s2 = "eidboaoo"
Output: false
class Solution {
    public boolean checkInclusion(String s1, String s2) {
       if(s1.length()>s2.length())return false;
        int[] count=new int[26];
        for(char c:s1.toCharArray())
            count[c-'a']+=1;
        int start=0;
        for(int i=0;i< s1.length();i++){
            count[s2.charAt(i)-'a']-=1;
            
        }
        boolean match=true;
        for(int c:count){
            if(c!=0){
                match=false;
                break;
            }
        }
        if(match)
            return true;
        start++;
        while(start<=s2.length()-s1.length()){
            int index1=s2.charAt(start-1)-'a';
            int index2=s2.charAt(start+s1.length()-1)-'a';
            count[index1]+=1;
            count[index2]-=1;
            match=true;
            for(int c:count){
                if(c!=0){
                    match=false;
                    break;
                }
            }
            if(match)
                return true;
            start++;
                  
        }
        return false;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Jump Game</span>
Input: nums = [2,3,1,1,4]
Output: true
Explanation: Jump 1 step from index 0 to 1, then 3 steps to the last index.
Input: nums = [3,2,1,0,4]
Output: false
Explanation: You will always arrive at index 3 no matter what. 
Its maximum jump length is 0, which makes it impossible to reach the last index.
class Solution {
    public boolean canJump(int[] nums) {
      int max=0;
        for(int i=0;i< nums.length;i++){
            if(nums[i]+i>max)
                max=nums[i]+i;
            if(max==i)
                break;
        }
        return max>=nums.length-1;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Merge Intervals</span>
Input: intervals = [[1,3],[2,6],[8,10],[15,18]]
Output: [[1,6],[8,10],[15,18]]
Explanation: Since intervals [1,3] and [2,6] overlap, merge them into [1,6].
Input: intervals = [[1,4],[4,5]]
Output: [[1,5]]
Explanation: Intervals [1,4] and [4,5] are considered overlapping.
class Solution {
    public int[][] merge(int[][] intervals) {
        Arrays.sort(intervals,(a,b)->Integer.compare(a[0],b[0]));
        ArrayList<int[]> list=new ArrayList<>();
        
        for(int[] inv:intervals){
            if(list.size()==0){
                list.add(inv);
            }else{
                int pre[]=list.get(list.size()-1);
                if(inv[0]<=pre[1]){
                    pre[1]=Math.max(pre[1],inv[1]);
                }else{
                    list.add(inv);
                }
            }
        }
        return list.toArray(new int[list.size()][]);
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Spiral Matrix</span>
Input: matrix = [[1,2,3],[4,5,6],[7,8,9]]
Output: [1,2,3,6,9,8,7,4,5]
Input: matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]
Output: [1,2,3,4,8,12,11,10,9,5,6,7]
class Solution {
    public List<Integer> spiralOrder(int[][] mat) {
    int T,B,L,R,dir;
    T=0;
    B=mat.length-1;
    L=0;
    R=mat[0].length-1;
    dir=0;
    int i;
    ArrayList<Integer> ans=new ArrayList<>();
    while(T<=B && L<=R){
        if(dir==0){
            for(i=L;i<=R;i++)
                ans.add(mat[T][i]);
            T++;
        }
        else if(dir==1){
            for(i=T;i<=B;i++)
                ans.add(mat[i][R]);
            R--;
        }
        else if(dir==2){
            for(i=R;i>=L;i--)
                ans.add(mat[B][i]);
            B--;
        }
        else if(dir==3){
            for(i=B;i>=T;i--)
                ans.add(mat[i][L]);
            L++;
        }
        dir=(dir+1)%4;
    }
    return ans; 
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Spiral Matrix II</span>
Input: n = 3
Output: [[1,2,3],[8,9,4],[7,6,5]]
Input: n = 1
Output: [[1]]
class Solution {
    public int[][] generateMatrix(int n) {
        int r1=0,r2=n-1,c1=0,c2=n-1;
        int[][] arr=new int[n][n];
        int val=1;
        while(r1<=r2&&c1<=c2){
            for(int c=c1;c<=c2;c++)
                arr[r1][c]=val++;
            
            for(int r=r1+1;r<=r2;r++)
                arr[r][c2]=val++;
            
            if(r1< r2&&c1< c2){
                for(int c=c2-1;c>c1;c--)
                    arr[r2][c]=val++;
                for(int r=r2;r>r1;r--)
                    arr[r][c1]=val++;
            }
            r1++;c1++;r2--;c2--;
        }
        return arr;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Word Search</span>
Input: board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "ABCCED"
Output: true
Input: board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "SEE"
Output: true
class Solution {
    public boolean exist(char[][] board, String word) {
      int r=board.length;
        int c=board[0].length;
        
        for(int i=0;i< r;i++)
            for(int j=0;j< c;j++)
                if(board[i][j]==word.charAt(0)&&search(board,i,j,word,0))
                    return true;
        return false;
    }
    public boolean search(char[][] board,int i,int j,String word,int idx){
        if(idx==word.length()-1)return true;
        board[i][j]-=65;
        
        if(i>0&&board[i-1][j]==word.charAt(idx+1)&&search(board,i-1,j,word,idx+1)) return true;
        
         if(j>0&&board[i][j-1]==word.charAt(idx+1)&&search(board,i,j-1,word,idx+1)) return true;
        
         if(i< board.length-1&&board[i+1][j]==word.charAt(idx+1)&&search(board,i+1,j,word,idx+1)) return true;
        
         if(j< board[0].length-1&&board[i][j+1]==word.charAt(idx+1)&&search(board,i,j+1,word,idx+1)) return true;
        
        board[i][j]+=65;
        return false;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Subsets</span>
Input: nums = [1,2,3]
Output: [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]
Input: nums = [0]
Output: [[],[0]]
class Solution {
    List<List<Integer>> res=new ArrayList<List<Integer>>();
    public List<List<Integer>> subsets(int[] nums) {
        if(nums.length==0)
            return res;
        bt(0,new ArrayList<Integer>(),nums);
        return res;
    }
    public void bt(int start,ArrayList<Integer> curr,int[] nums){
        res.add(new ArrayList<Integer>(curr));
        for(int i=start;i< nums.length;i++){
            curr.add(nums[i]);
            bt(i+1,curr,nums);
            curr.remove(curr.size()-1);
        }
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Combinations</span>
Input: n = 4, k = 2
Output: [[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]
Explanation: There are 4 choose 2 = 6 total combinations.
Note that combinations are unordered, i.e., [1,2] and [2,1] are considered to be the same combination.
Input: n = 1, k = 1
Output: [[1]]
Explanation: There is 1 choose 1 = 1 total combination.
class Solution {
    public List<List<Integer>> combine(int n, int k) {
        List<List<Integer>> subset=new ArrayList();
        generate(1,n,new ArrayList(),subset,k);
        return subset;
    }
    public void generate(int start,int n,List<Integer> curr,List<List<Integer>> subset,int k){
        if(curr.size()==k){
            subset.add(new ArrayList(curr));
            return;
        }
        for(int i=start;i<=n;i++){
            curr.add(i);
            generate(i+1,n,curr,subset,k);
            curr.remove(curr.size()-1);
        }
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Search a 2D Matrix</span>
Input: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3
Output: true
Input: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13
Output: false
class Solution {
    public boolean searchMatrix(int[][] matrix, int target) {
      int r=selectrow(matrix,target);
        if(r==-1)return false;
        boolean isfound=binary(matrix,r,target);
        return isfound;
    }
    boolean binary(int[][] mat,int row,int target){
          int low=0;
        int high=mat[0].length-1;
        while(low<=high){
            int mid=(low+high)/2;
            if(mat[row][mid]==target){
                return true;
            }else if(mat[row][mid]< target){
                low=mid+1;
            }else {
                high=mid-1;
            }
        }
        return false;
    }
    int selectrow(int[][] mat,int target){
        int low=0;
        int high=mat.length-1;
        int lc=mat[0].length-1;
        while(low<=high){
            int mid=(low+high)/2;
            if(mat[mid][0]<=target&&target<=mat[mid][lc]){
                return mid;
            }else if(mat[mid][0]< target){
                low=mid+1;
            }else if(mat[mid][0]>target){
                high=mid-1;
            }
        }
        return -1;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Set Matrix Zeroes</span>
Input: matrix = [[1,1,1],[1,0,1],[1,1,1]]
Output: [[1,0,1],[0,0,0],[1,0,1]]
Input: matrix = [[0,1,2,0],[3,4,5,2],[1,3,1,5]]
Output: [[0,0,0,0],[0,4,5,0],[0,3,1,0]]
class Solution {
    public void setZeroes(int[][] matrix) {
        int colaa=1;
        int row=matrix.length;
        int col=matrix[0].length;
        
        for(int i=0;i< row;i++){
            if(matrix[i][0]==0)colaa=0;
            for(int j=1;j< col;j++){
                if(matrix[i][j]==0)
                    matrix[i][0]=matrix[0][j]=0;
            }
        }
        
        for(int i=row-1;i>=0;i--){
            for(int j=col-1;j>=1;j--){
                if(matrix[i][0]==0||matrix[0][j]==0)
                    matrix[i][j]=0;
                
            }
            if(colaa==0)
                    matrix[i][0]=0;
        }
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Unique Paths</span>
Input: m = 3, n = 7
Output: 28
Input: m = 3, n = 2
Output: 3
Explanation: From the top-left corner, there are a total of 3 ways to reach the bottom-right corner:
1. Right -> Down -> Down
2. Down -> Down -> Right
3. Down -> Right -> Down
class Solution {
    public int uniquePaths(int m, int n) {
      int[][] dp=new int[m][n];
        for(int i=0;i< dp[0].length;i++){
            dp[0][i]=1;
        }
         for(int i=0;i< dp.length;i++){
            dp[i][0]=1;
        }
         for(int i=1;i< dp.length;i++){
            for(int j=1;j< dp[0].length;j++){
            dp[i][j]=dp[i-1][j]+dp[i][j-1];
        }
        }
        return dp[m-1][n-1];
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Unique Paths II</span>
Input: obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]
Output: 2
Explanation: There is one obstacle in the middle of the 3x3 grid above.
There are two ways to reach the bottom-right corner:
1. Right -> Right -> Down -> Down
2. Down -> Down -> Right -> Right
Input: obstacleGrid = [[0,1],[0,0]]
Output: 1
class Solution {
    public int uniquePathsWithObstacles(int[][] obstacleGrid) {
        int m=obstacleGrid.length;
        int n=obstacleGrid[0].length;
       int[][] dp=new int[m][n];
        if(obstacleGrid[0][0]==1)return 0;
        for(int i=0;i< dp[0].length;i++){
            if(obstacleGrid[0][i]==0){
                  dp[0][i]=1;
             }else{
                 break;
             }
            dp[0][i]=1;
        }
         for(int i=0;i< dp.length;i++){
             if(obstacleGrid[i][0]==0){
                  dp[i][0]=1;
             }else{
                 break;
             }
                
        }
         for(int i=1;i< dp.length;i++){
            for(int j=1;j< dp[0].length;j++){
                 if(obstacleGrid[i][j]==1){
                  dp[i][j]=0;
             }else{
                    dp[i][j]=dp[i-1][j]+dp[i][j-1];  
                 }
           
        }
        }
        return dp[m-1][n-1];  
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Insert Interval</span>
Input: intervals = [[1,3],[6,9]], newInterval = [2,5]
Output: [[1,5],[6,9]]
Input: intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]
Output: [[1,2],[3,10],[12,16]]
Explanation: Because the new interval [4,8] overlaps with [3,5],[6,7],[8,10].
class Solution {
    public int[][] insert(int[][] intervals, int[] newInterval) {
       List<int[]> res=new ArrayList();
        int i=0;
        int n=intervals.length;
        while(i< n&&intervals[i][1]< newInterval[0])
            res.add(intervals[i++]);
        int[] ml=newInterval;
        
        while(i< n&&intervals[i][0]<=newInterval[1]){
            ml[0]=Math.min(ml[0],intervals[i][0]);
            ml[1]=Math.max(ml[1],intervals[i++][1]);
        }
        
        res.add(ml);
        while(i< n)
            res.add(intervals[i++]);
        return res.toArray(new int[res.size()][2]);
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Valid Sudoku</span>
Input: board = 
[["5","3",".",".","7",".",".",".","."]
,["6",".",".","1","9","5",".",".","."]
,[".","9","8",".",".",".",".","6","."]
,["8",".",".",".","6",".",".",".","3"]
,["4",".",".","8",".","3",".",".","1"]
,["7",".",".",".","2",".",".",".","6"]
,[".","6",".",".",".",".","2","8","."]
,[".",".",".","4","1","9",".",".","5"]
,[".",".",".",".","8",".",".","7","9"]]
Output: true
class Solution {
    public boolean isValidSudoku(char[][] board) {
       HashSet seen=new HashSet();
        for(int i=0;i< 9;i++){
            for(int j=0;j< 9;j++){
                if(board[i][j]!='.'){
                    if(!seen.add("row"+i+board[i][j])||!seen.add("column"+j+board[i][j])){
                        return false;
                    }
                    if(!seen.add("box"+(i/3)*3+j/3+board[i][j])){
                        return false;
                    }
                }
            }
        }
        return true;  
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Kth Largest Element in an Array</span>
Input: nums = [3,2,1,5,6,4], k = 2
Output: 5
Input: nums = [3,2,3,1,2,4,5,5,6], k = 4
Output: 4
class Solution {
    public int findKthLargest(int[] nums, int k) {
      int ans=directapproch(nums,k);
        int ans2=queueapp(nums,k);
        return ans2;
    }
    int queueapp(int[] nums,int k){
        PriorityQueue<Integer> pq=new PriorityQueue<>(k+1);
        for(int i:nums){
            pq.add(i);
            if(pq.size()>k){
                pq.poll();
            }
        }
        return pq.poll();
    }
     int directapproch(int[] nums,int k){
         Arrays.sort(nums);
        return nums[nums.length-k];
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Number of Islands</span>
Input: grid = [
  ["1","1","1","1","0"],
  ["1","1","0","1","0"],
  ["1","1","0","0","0"],
  ["0","0","0","0","0"]
]
Output: 1
Input: grid = [
  ["1","1","0","0","0"],
  ["1","1","0","0","0"],
  ["0","0","1","0","0"],
  ["0","0","0","1","1"]
]
Output: 3
class Solution {
    public int numIslands(char[][] grid) {
       if(grid.length==0)return 0;
        int island=0;
        for(int i=0;i< grid.length;i++){
            for(int j=0;j< grid[0].length;j++){
                if(grid[i][j]=='1'){
                    dfs(grid,i,j);
                    island++;
                }
            }
        }
        return island;
    }
    void dfs(char[][] grid,int i,int j){
        if(i< 0||j< 0||i>grid.length-1||j>grid[0].length-1)return;
        if(grid[i][j]=='0')return;
        
        grid[i][j]='0';
          dfs(grid,i+1,j);
          dfs(grid,i-1,j);
          dfs(grid,i,j+1);
          dfs(grid,i,j-1);
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">House Robber</span>
 Input: nums = [1,2,3,1]
Output: 4
Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).
Total amount you can rob = 1 + 3 = 4.
Input: nums = [2,7,9,3,1]
Output: 12
Explanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).
Total amount you can rob = 2 + 9 + 1 = 12.
class Solution {
    public int rob(int[] nums) {
      int n=nums.length;
        if(n==0)return 0;
        if(n==1)return nums[0];
        int v1=nums[0];
        int v2=Math.max(v1,nums[1]);
        
        for(int i=2;i< n;i++){
            int temp=v2;
            v2=Math.max(v2,v1+nums[i]);
            v1=temp;
        }
         return v2;
    }
   
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Find Peak Element</span>
Input: nums = [1,2,3,1]
Output: 2
Explanation: 3 is a peak element and your function should return the index number 2.
Input: nums = [1,2,1,3,5,6,4]
Output: 5
Explanation: Your function can return either index number 1 where the peak element is 2, 
or index number 5 where the peak element is 6.
class Solution {
    public int findPeakElement(int[] nums) {
       if(nums.length==1)return 0;
        for(int i=0;i< nums.length;i++){
            if(i==0&&nums[0]>nums[1])return 0;
            if(i==nums.length-1&&nums[i]>nums[i-1])return nums.length-1;
            if(nums[i]>nums[i+1]&&nums[i]>nums[i-1])return i;
        }
        return -1;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Maximum Product Subarray</span>
Input: nums = [2,3,-2,4]
Output: 6
Explanation: [2,3] has the largest product 6.
Input: nums = [-2,0,-1]
Output: 0
Explanation: The result cannot be 2, because [-2,-1] is not a subarray.
class Solution {
    public int maxProduct(int[] nums) {
        int ans= Integer.MIN_VALUE;
        int pro=1;
        for(int i=0;i< nums.length;i++){
            pro*=nums[i];
            ans=Math.max(ans,pro);
            if(pro==0)
                pro=1;
        }
        pro=1;
        for(int i=nums.length-1;i>=0;i--){
             pro*=nums[i];
          ans=Math.max(ans,pro);
            if(pro==0)
                pro=1;
        }
        return ans;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Single Number II</span>
Input: nums = [2,2,3,2]
Output: 3
Input: nums = [0,1,0,1,0,1,99]
Output: 99
class Solution {
    public int singleNumber(int[] nums) {
      int one=0,sec=0;
        for(int i:nums){
            one=~sec&(one^i);
            sec=~one&(sec^i);
        }
        return one;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Gas Station</span>
Input: gas = [1,2,3,4,5], cost = [3,4,5,1,2]
Output: 3
Explanation:
Start at station 3 (index 3) and fill up with 4 unit of gas. Your tank = 0 + 4 = 4
Travel to station 4. Your tank = 4 - 1 + 5 = 8
Travel to station 0. Your tank = 8 - 2 + 1 = 7
Travel to station 1. Your tank = 7 - 3 + 2 = 6
Travel to station 2. Your tank = 6 - 4 + 3 = 5
Travel to station 3. The cost is 5. Your gas is just enough to travel back to station 3.
Therefore, return 3 as the starting index.
Input: gas = [2,3,4], cost = [3,4,3]
Output: -1
Explanation:
You can't start at station 0 or 1, as there is not enough gas to travel to the next station.
Let's start at station 2 and fill up with 4 unit of gas. Your tank = 0 + 4 = 4
Travel to station 0. Your tank = 4 - 3 + 2 = 3
Travel to station 1. Your tank = 3 - 3 + 3 = 3
You cannot travel back to station 2, as it requires 4 unit of gas but you only have 3.
Therefore, you can't travel around the circuit once no matter where you start.
class Solution {
    public int canCompleteCircuit(int[] gas, int[] cost) {
        int n=gas.length;
        int total=0;
        int surplus=0;
        int s=0;
        for(int i=0;i< n;i++){
            total+=gas[i]-cost[i];
            surplus+=gas[i]-cost[i];
            if(surplus< 0){
                surplus=0;
                s=i+1;
            }
        }
        return (total< 0)?-1:s;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Surrounded Regions</span>
Input: board = [["X","X","X","X"],["X","O","O","X"],["X","X","O","X"],["X","O","X","X"]]
Output: [["X","X","X","X"],["X","X","X","X"],["X","X","X","X"],["X","O","X","X"]]
Explanation: Notice that an 'O' should not be flipped if:
- It is on the border, or
- It is adjacent to an 'O' that should not be flipped.
The bottom 'O' is on the border, so it is not flipped.
The other three 'O' form a surrounded region, so they are flipped.
class Solution {
    void dfs(char[][] board,int i,int j){
        if(i>board.length-1||i< 0||j>board[0].length||j< 0)return;
        
        if(board[i][j]=='O')board[i][j]='-';
        
        if(i>0&&board[i-1][j]=='O')
             dfs(board,i-1,j);///
         if(i< board.length-1&&board[i+1][j]=='O')
             dfs(board,i+1,j);///
         if(j>0&&board[i][j-1]=='O')
             dfs(board,i,j-1);///
         if(j< board[0].length-1&&board[i][j+1]=='O')
             dfs(board,i,j+1);///
        return;
        
    }
    public void solve(char[][] board) {
        if(board.length==0||board[0].length==0)return;
        
        int row=board.length;
        int col=board[0].length;
        
        for(int i=0;i< row;i++){
            if(board[i][0]=='O')
                dfs(board,i,0);
            if(board[i][col-1]=='O')
                 dfs(board,i,col-1);
        }
        ////////////
         for(int j=0;j< col;j++){
            if(board[0][j]=='O')
                dfs(board,0,j);
            if(board[row-1][j]=='O')
                 dfs(board,row-1,j);
        }
        ///////////
        for(int i=0;i< row;i++){
           for(int j=0;j< col;j++){
                if(board[i][j]=='O'){
                     board[i][j]='X';
                }else if(board[i][j]=='-'){
                     board[i][j]='O';
                }
              
           
           }
        }
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Longest Consecutive Sequence</span>
Input: nums = [100,4,200,1,3,2]
Output: 4
Explanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4.
Input: nums = [0,3,7,2,5,8,4,6,0,1]
Output: 9
class Solution {
    public int longestConsecutive(int[] arr) {
      HashMap<Integer,Boolean> map=new HashMap<>();
        
        for(int val:arr){
            map.put(val,true);
        }
        for(int val:arr){
            if(map.containsKey(val-1)){
                map.put(val,false);
            }
        }
        int msp=0,m1=0;
        for(int val:arr){
            if(map.get(val)==true){
                int t1=1;
                int tsp=val;
                while(map.containsKey(tsp+t1)){
                    t1++;
                }
                if(t1>m1){
                    msp=tsp;
                    m1=t1;
                }
            }
        }
     
        return m1;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Binary Tree Right Side View</span>
Input: root = [1,2,3,null,5,null,4]
Output: [1,3,4]
Input: root = [1,null,3]
Output: [1,3]
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public List<Integer> rightSideView(TreeNode root) {
        List<Integer> res=new ArrayList<>();
        if(root==null)return res;
        Queue<TreeNode> q=new LinkedList<>();
        q.add(root);
        while(q.size()>0){
            int count=q.size();
            while(count-->0){
                TreeNode val=q.remove();
                if(count==0)
                    res.add(val.val);
                if(val.left!=null)
                    q.add(val.left);
                if(val.right!=null)
                    q.add(val.right);
            }
        }
         return res;
    }
   
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Clone Graph</span>
Input: adjList = [[2,4],[1,3],[2,4],[1,3]]
Output: [[2,4],[1,3],[2,4],[1,3]]
Explanation: There are 4 nodes in the graph.
1st node (val = 1)'s neighbors are 2nd node (val = 2) and 4th node (val = 4).
2nd node (val = 2)'s neighbors are 1st node (val = 1) and 3rd node (val = 3).
3rd node (val = 3)'s neighbors are 2nd node (val = 2) and 4th node (val = 4).
4th node (val = 4)'s neighbors are 1st node (val = 1) and 3rd node (val = 3).
Input: adjList = [[]]
Output: [[]]
Explanation: Note that the input contains one empty list. 
The graph consists of only one node with val = 1 and it does not have any neighbors.
/*
// Definition for a Node.
class Node {
    public int val;
    public List<Node> neighbors;
    public Node() {
        val = 0;
        neighbors = new ArrayList<Node>();
    }
    public Node(int _val) {
        val = _val;
        neighbors = new ArrayList<Node>();
    }
    public Node(int _val, ArrayList<Node> _neighbors) {
        val = _val;
        neighbors = _neighbors;
    }
}
*/

class Solution {
    Map<Node,Node> map=new HashMap<>();
    public Node cloneGraph(Node node) {
        if(node==null)return null;
        Node newnode=new Node(node.val);
        map.put(node,newnode);
        for(Node n:node.neighbors){
            if(map.containsKey(n)){
                newnode.neighbors.add(map.get(n));
            }else{
                newnode.neighbors.add(cloneGraph(n));
            }
        }
        return newnode;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Sum Root to Leaf Numbers</span>
Input: root = [1,2,3]
Output: 25
Explanation:
The root-to-leaf path 1->2 represents the number 12.
The root-to-leaf path 1->3 represents the number 13.
Therefore, sum = 12 + 13 = 25.
Input: root = [4,9,0,5,1]
Output: 1026
Explanation:
The root-to-leaf path 4->9->5 represents the number 495.
The root-to-leaf path 4->9->1 represents the number 491.
The root-to-leaf path 4->0 represents the number 40.
Therefore, sum = 495 + 491 + 40 = 1026.
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public int sumNumbers(TreeNode root) {
       return function(root,0); 
    }
    int function(TreeNode node,int temp){
        if(node==null)return 0;
        if(node.left==null&&node.right==null)
            return temp*10+node.val;
        return function(node.left,temp*10+node.val)+function(node.right,temp*10+node.val);
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Populating Next Right Pointers in Each Node II</span>
Input: root = [1,2,3,4,5,null,7]
Output: [1,#,2,3,#,4,5,7,#]
Explanation: Given the above binary tree (Figure A), your function should populate each next pointer
 to point to its next right node, just like in Figure B. 
The serialized output is in level order as connected by the next pointers, with '#' 
signifying the end of each level.
/*
// Definition for a Node.
class Node {
    public int val;
    public Node left;
    public Node right;
    public Node next;

    public Node() {}
    
    public Node(int _val) {
        val = _val;
    }

    public Node(int _val, Node _left, Node _right, Node _next) {
        val = _val;
        left = _left;
        right = _right;
        next = _next;
    }
};
*/

class Solution {
    public Node connect(Node root) {
       if(root==null)return null;
        Queue<Node> q=new LinkedList<>();
        q.add(root);
        while(!q.isEmpty()){
            int si=q.size();
            Node dummy=new Node(0);
            while(si-->0){
                Node node =q.remove();
                dummy.next=node;
                dummy=dummy.next;
                
                if(node.left!=null)
                    q.add(node.left);
                if(node.right!=null)
                    q.add(node.right);
            }
        }
        return root;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Populating Next Right Pointers in Each Node</span>
Input: root = [1,2,3,4,5,6,7]
Output: [1,#,2,3,#,4,5,6,7,#]
Explanation: Given the above perfect binary tree (Figure A), your function should populate each 
next pointer to point to its next right node, just like in Figure B. 
The serialized output is in level order as connected by the next pointers, with '#' 
signifying the end of each level.
/*
// Definition for a Node.
class Node {
    public int val;
    public Node left;
    public Node right;
    public Node next;

    public Node() {}
    
    public Node(int _val) {
        val = _val;
    }

    public Node(int _val, Node _left, Node _right, Node _next) {
        val = _val;
        left = _left;
        right = _right;
        next = _next;
    }
};
*/

class Solution {
    public Node connect(Node root) {
       if(root==null||root.left==null||root.right==null)return root;
        
        root.left.next=root.right;
        if(root.next!=null)
            root.right.next=root.next.left;
        connect(root.left);
        connect(root.right);
        return root;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Flatten Binary Tree to Linked List</span>
Input: root = [1,2,5,3,4,null,6]
Output: [1,null,2,null,3,null,4,null,5,null,6]
Input: root = [0]
Output: [0]
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public void flatten(TreeNode root) {
        if(root==null)return;
        TreeNode templ=root.left;
        TreeNode tempr=root.right;
        root.left=null;
        flatten(templ);
        flatten(tempr);
        root.right=templ;
        TreeNode curr=root;
        while(curr.right!=null)
            curr=curr.right;
        curr.right=tempr;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Path Sum II</span>
Input: root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22
Output: [[5,4,11,2],[5,8,4,5]]
Explanation: There are two paths whose sum equals targetSum:
5 + 4 + 11 + 2 = 22
5 + 8 + 4 + 5 = 22
Input: root = [1,2,3], targetSum = 5
Output: []
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public List<List<Integer>> pathSum(TreeNode root, int target) {
        List<List<Integer>> res=new ArrayList<>();
        pathsum(root,target,new ArrayList(),res);
        return res;
    }
    void pathsum(TreeNode root, int sum,List<Integer> path,List<List<Integer>> res){
        if(root==null)return;
        path.add(root.val);
        if(root.left==null&&root.right==null&&sum==root.val)
            res.add(path);
        pathsum(root.left,sum-root.val,new ArrayList(path),res);
        pathsum(root.right,sum-root.val,new ArrayList(path),res);
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Product of Array Except Self</span>
Input: nums = [1,2,3,4]
Output: [24,12,8,6]
Input: nums = [-1,1,0,-3,3]
Output: [0,0,9,0,0]
class Solution {
    public int[] productExceptSelf(int[] nums) {
       int[] right=new int[nums.length];
        int pro=1;
        for(int i=nums.length-1;i>=0;i--){
            pro*=nums[i];
            right[i]=pro;
        }
        pro=1;
        int[] res=new int[nums.length];
        for(int i=0;i< nums.length-1;i++){
            int lp=pro;
            int rp=right[i+1];
            res[i]=lp*rp;
            pro*=nums[i];
        }
        res[nums.length-1]=pro;
        return res;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Largest Number</span>
Input: nums = [10,2]
Output: "210"
Input: nums = [3,30,34,5,9]
Output: "9534330"
class Solution {
    public String largestNumber(int[] arr) {
       if(arr.length==0)return "";
        
        String[] sa=new String[arr.length];
        for(int i=0;i< arr.length;i++){
            sa[i]=Integer.toString(arr[i]);
        }
        Arrays.sort(sa,new Comparator<String>(){
            public int compare(String a,String b){
                String s1=a+b;
                String s2=b+a;
                return s2.compareTo(s1);
            }
        });
        
        if(sa[0].equals("0"))
            return "0";
        StringBuilder sb=new StringBuilder();
        for(String s:sa){
            sb.append(s);
        }
        return sb.toString();
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Majority Element II</span>
Input: nums = [3,2,3]
Output: [3]
Input: nums = [1]
Output: [1]
class Solution {
    boolean isgreate(int[] arr,int val){
        int count=0;
        for(int i:arr){
            if(i==val)
                count++;
        }
        return count>arr.length/3;
    }
    public List<Integer> majorityElement(int[] arr) {
        int val1=arr[0];
        int val2=arr[0];
        int count1=1;
        int count2=0;
        int i=1;
        while(i< arr.length){
            if(arr[i]==val1){
                count1++;
            }else if(arr[i]==val2){
                count2++;
            }else{
                if(count1==0){
                    val1=arr[i];
                    count1=1;
                }else if(count2==0){
                    val2=arr[i];
                    count2=1;
                }else{
                    count1--;
                    count2--;
                }
            }
            i++;
        }
        ArrayList<Integer> res=new ArrayList<>();
        if(isgreate(arr,val1)==true){
            res.add(val1);
        }
        if(val1!=val2&&isgreate(arr,val2)==true){
            res.add(val2);
        }
        return res;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Combination Sum III</span>
Input: k = 3, n = 7
Output: [[1,2,4]]
Explanation:
1 + 2 + 4 = 7
There are no other valid combinations.
Input: k = 3, n = 9
Output: [[1,2,6],[1,3,5],[2,3,4]]
Explanation:
1 + 2 + 6 = 9
1 + 3 + 5 = 9
2 + 3 + 4 = 9
There are no other valid combinations.
class Solution {
    List<List<Integer>> res=new ArrayList();
    //////
     void myfunction(List<Integer> com,int k,int n,int s){
        if(k==com.size()){
            if(n==0)res.add(new ArrayList<Integer>(com));
             return;
        }
            for(int i=s;i<=9;i++){
                com.add(i);
                myfunction(com,k,n-i,i+1);
                com.remove(com.size()-1);
            }
        
    }
    /////
    public List<List<Integer>> combinationSum3(int k, int n) {
        List<Integer> com=new ArrayList();
        myfunction(com,k,n,1);
        return res;
    }
   
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Game of Life</span>
Input: board = [[0,1,0],[0,0,1],[1,1,1],[0,0,0]]
Output: [[0,0,0],[1,0,1],[0,1,1],[0,1,0]]
Input: board = [[1,1],[1,0]]
Output: [[1,1],[1,1]]
class Solution {
     int[][] dir=new int[][]{{-1,-1},{-1,0},{-1,1},{0,-1},{0,1},{1,-1},{1,0},{1,1}};
    public void gameOfLife(int[][] board){
        int m=board.length;
        int n=board[0].length;
        int[][] rs=new int[m][n];
        
        for(int i=0;i< m;i++){
            for(int j=0;j< n;j++){
                int count=0;
                for(int[] d:dir){
                    int p=i+d[0];
                    int q=j+d[1];
                    
                    if(p>=0&&p< m&&q>=0&&q< n&&board[p][q]==1){
                        count++;
                    }
                }
                    if(board[i][j]==1){
                        if(count==2||count==3){
                            rs[i][j]=1;
                        }
                    }
                    else{
                        if(count==3){
                            rs[i][j]=1;
                        }
                    }
                }
            
           
        }
         for(int i=0;i< m;i++){
                for(int j=0;j< n;j++){
                    board[i][j]=rs[i][j];
                }
            }
        
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Find the Duplicate Number</span>
Input: nums = [1,3,4,2,2]
Output: 2
Input: nums = [3,1,3,4,2]
Output: 3
class Solution {
    public int findDuplicate(int[] arr) {
       Arrays.sort(arr); 
        int i=1;
        for(;i< arr.length;i++){
            if(arr[i]==arr[i-1])
                return arr[i];
        }
        return arr[i];
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Peeking Iterator</span>
["PeekingIterator", "next", "peek", "next", "next", "hasNext"]
[[[1, 2, 3]], [], [], [], [], []]
Output
[null, 1, 2, 2, 3, false]
Explanation
PeekingIterator peekingIterator = new PeekingIterator([1, 2, 3]); // [1,2,3]
peekingIterator.next();    // return 1, the pointer moves to the next element [1,2,3].
peekingIterator.peek();    // return 2, the pointer does not move [1,2,3].
peekingIterator.next();    // return 2, the pointer moves to the next element [1,2,3]
peekingIterator.next();    // return 3, the pointer moves to the next element [1,2,3]
peekingIterator.hasNext(); // return False
// Java Iterator interface reference:
// https://docs.oracle.com/javase/8/docs/api/java/util/Iterator.html

class PeekingIterator implements Iterator<Integer> {
    Iterator<Integer> itr=null;
    Integer nextval=null;
	public PeekingIterator(Iterator<Integer> iterator) {
	    // initialize any member here.
        itr=iterator;
        if(hasNext())
            nextval=itr.next();
	    
	}
	
    // Returns the next element in the iteration without advancing the iterator.
	public Integer peek() {
        return nextval;
	}
	
	// hasNext() and next() should behave the same as in the Iterator interface.
	// Override them if needed.
	@Override
	public Integer next() {
	   Integer val=nextval;
        if(itr.hasNext()){
            nextval=itr.next();
        }else{
            nextval=null;
        }
        return val;
	}
	
	@Override
	public boolean hasNext() {
	    return nextval!=null||itr.hasNext();
	}
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">H-Index</span>
Input: citations = [3,0,6,1,5]
Output: 3
Explanation: [3,0,6,1,5] means the researcher has 5 papers in total and each of them had 
received 3, 0, 6, 1, 5 citations respectively.
Since the researcher has 3 papers with at least 3 citations each and the remaining two with 
no more than 3 citations each, their h-index is 3.
Input: citations = [1,3,1]
Output: 1
class Solution {
    public int hIndex(int[] citations) {
       Arrays.sort(citations);
        int n=citations.length;
        int i;
        for(i=1;i<=n;i++){
            if(citations[n-i]< i)break;
        }
        return i-1;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Search a 2D Matrix II</span>
Input: matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 5
Output: true
Input: matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 20
Output: false
class Solution {
    public boolean searchMatrix(int[][] m, int target) {
      int r=0;
        int c=m[0].length-1;
        while(r<m.length&&c>=0){
            if(m[r][c]==target){
                return true;
            }else if(m[r][c]>target){
                c--;
            }else{
                r++;
            }
        }
        return false;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">House Robber II</span>
Input: nums = [2,3,2]
Output: 3
Explanation: You cannot rob house 1 (money = 2) and then rob house 3 (money = 2), 
because they are adjacent houses.
Input: nums = [1,2,3,1]
Output: 4
Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).
Total amount you can rob = 1 + 3 = 4.
class Solution {
    public int rob(int[] arr) {
      if(arr.length==1)return arr[0];
        return Math.max(myfun(arr,0,arr.length-1),myfun(arr,1,arr.length));
    }
    int myfun(int[] arr,int s,int e){
        int p2=0,p1=0,max=0;
        for(int i=s;i< e;i++){
            max=Math.max(p2+arr[i],p1);
            p2=p1;
            p1=max;
        }
        return max;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Divide Two Integers</span>
Input: dividend = 10, divisor = 3
Output: 3
Explanation: 10/3 = 3.33333.. which is truncated to 3.
Input: dividend = 7, divisor = -3
Output: -2
Explanation: 7/-3 = -2.33333.. which is truncated to -2.
class Solution {
    public int divide(int dividend, int divisor) {
        if(dividend==1<< 31&&divisor==-1)return Integer.MAX_VALUE;
        boolean sign=(dividend>=0)==(divisor>=0)?true:false;
        dividend=Math.abs(dividend);
        divisor=Math.abs(divisor);
        int res=0;
        while(dividend-divisor>=0){
            int count=0;
            while(dividend-(divisor<<1 << count)>=0){
                count++;
            }
            res+=1<< count;
            dividend-=divisor<< count;
        }
        return sign?res:-res;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Can I Win</span>
Input: maxChoosableInteger = 10, desiredTotal = 11
Output: false
Explanation:
No matter which integer the first player choose, the first player will lose.
The first player can choose an integer from 1 up to 10.
If the first player choose 1, the second player can only choose integers from 2 up to 10.
The second player will win by choosing 10 and get a total = 11, which is >= desiredTotal.
Same with other integers chosen by the first player, the second player will always win.
Input: maxChoosableInteger = 10, desiredTotal = 0
Output: true
class Solution {
    HashMap<String,Boolean> map=new HashMap();
    public boolean canIWin(int max, int des) {
        if(((1+max)*max)/2< des)return false;
        char[] state=new char[max+1];
        Arrays.fill(state,'0');
        return backtrack(max,des,state);
    }
    boolean backtrack(int max,int des,char[] state){
        String key=new String(state);
        if(map.containsKey(key))
            return map.get(key);
        for(int i=1;i<=max;i++){
            if(state[i]=='1')
                continue;
            state[i]='1';
            if(des-i<=0||!backtrack(max,des-i,state)){
            map.put(key,true);
            state[i]='0';
            return true;
        }
        state[i]='0';
    }
    map.put(key,false);
    return false;
}
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Partition List</span>
Input: head = [1,4,3,2,5,2], x = 3
Output: [1,2,2,4,3,5]
Input: head = [2,1], x = 2
Output: [1,2]
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode partition(ListNode head, int x) {
        ListNode small=new ListNode(0);
        ListNode hi=new ListNode(0);
        ListNode smallheaf=small,higherhead=hi;
        while(head!=null){
            if(head.val< x){
                smallheaf.next=head;
                smallheaf=smallheaf.next;
            }else{
               higherhead.next=head;
                higherhead=higherhead.next;
            }
            head=head.next;
        }
        higherhead.next=null;
        smallheaf.next=hi.next;
        return small.next;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Reverse Linked List II</span>
Input: head = [1,2,3,4,5], left = 2, right = 4
Output: [1,4,3,2,5]
Input: head = [5], left = 1, right = 1
Output: [5]
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode reverseBetween(ListNode head, int m, int n) {
        if(head==null)return null;
        ListNode pre=null;
        ListNode currentnode=head;
        while(m>1){
            pre=currentnode;
            currentnode=currentnode.next;
            m--;n--;
        }
        ListNode connection=pre;
        ListNode tail=currentnode;
        while(n>0){
            ListNode nextnode=currentnode.next;
            currentnode.next=pre;
            pre=currentnode;
            currentnode=nextnode;
            n--;
        }
        if(connection!=null){
            connection.next=pre;
        }else{
            head=pre;
        }
        tail.next=currentnode;
        return head;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Convert Sorted List to Binary Search Tree</span>
Input: head = [-10,-3,0,5,9]
Output: [0,-3,9,-10,null,5]
Explanation: One possible answer is [0,-3,9,-10,null,5], which represents the shown height balanced
BST.
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public TreeNode sortedListToBST(ListNode head) {
        if(head==null)return null;
        ListNode mid=mid(head);
        TreeNode root=new TreeNode(mid.val);
        if(head==mid)return root;
        root.left=sortedListToBST(head);
        root.right=sortedListToBST(mid.next);
        return root;
    }
    public ListNode mid(ListNode head){
        ListNode fast=head;
        ListNode slow=head;
        ListNode prev=head;
        while(fast!=null&&fast.next!=null){
            prev=slow;
            slow=slow.next;
            fast=fast.next.next;
        }
        if(prev!=null)
            prev.next=null;
        return slow;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Copy List with Random Pointer</span>
Input: head = [[7,null],[13,0],[11,4],[10,2],[1,0]]
Output: [[7,null],[13,0],[11,4],[10,2],[1,0]]
Input: head = [[1,1],[2,1]]
Output: [[1,1],[2,1]]
/*
// Definition for a Node.
class Node {
    int val;
    Node next;
    Node random;

    public Node(int val) {
        this.val = val;
        this.next = null;
        this.random = null;
    }
}
*/

class Solution {
    public Node copyRandomList(Node head) {
       HashMap<Node,Node> map=new HashMap<>();
        Node curr=head;
        Node nhead=new Node(-1);
        Node prev=nhead;
        while(curr!=null){
            Node node =new Node(curr.val);
            prev.next=node;
            map.put(curr,node);
            prev=prev.next;
            curr=curr.next;
        }
        nhead=nhead.next;
        Node c1=head;
        Node c2=nhead;
        while(c1!=null){
            c2.random=(c1.random!=null)?map.get(c1.random):null;
            c1=c1.next;
            c2=c2.next;
        }
        return nhead;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Integer to Roman</span>
Input: num = 3
Output: "III"
Explanation: 3 is represented as 3 ones.
Input: num = 58
Output: "LVIII"
Explanation: L = 50, V = 5, III = 3.
class Solution {
    public String intToRoman(int num) {
       int[] intcode={1000,900,500,400,100,90,50,40,10,9,5,4,1};
        String[] code={"M","CM","D","CD","C","XC","L","XL","X","IX","V","IV","I"};
            
            StringBuilder sb=new StringBuilder();
            for(int i=0;i< intcode.length;i++)
                while(num>=intcode[i]){
                    sb.append(code[i]);
                    num-=intcode[i];
                }
                       return sb.toString();
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Generate Parentheses</span>
Input: n = 3
Output: ["((()))","(()())","(())()","()(())","()()()"]
Input: n = 1
Output: ["()"]
class Solution {
    public List<String> generateParenthesis(int n) {
        List<String> res=new ArrayList();
        findall("(",1,0,res,n);
        return res;
    }
    void findall(String curr,int o,int c,List<String> res,int n){
        if(curr.length()==2*n){
            res.add(curr);
            return;
        }
        if(o< n) findall(curr+"(",o+1,c,res,n);
        if(c< o) findall(curr+")",o,c+1,res,n);
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Multiply Strings</span>
Input: num1 = "2", num2 = "3"
Output: "6"
Input: num1 = "123", num2 = "456"
Output: "56088"
class Solution {
    public String multiply(String arr1, String arr2) {
        if(arr1.equals("0")||arr2.equals("0"))return "0";
        int l1=arr1.length();
        int l2=arr2.length();
        int[] res=new int[l1+l2+1];
        int i=l2-1;
        int pf=0;//poer factor
        while(i>=0){
            int ival=arr2.charAt(i)-'0';
            i--;
            int j=l1-1;
            int k=res.length-1-pf;
            int carry=0;
            while(j>=0||carry!=0){
                int jval=j>=0?arr1.charAt(j)-'0':0;
                j--;
                int prod=ival*jval+carry+res[k];
                res[k]=prod%10;
                carry=prod/10;
                k--;
            }
            pf++;
        }
        String str="";
        boolean flag=false;
        for(int val:res){
            if(val==0&&flag==false){
                continue;
            }else{
                flag=true;
                str+=val;
            }
        }
        return str;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Group Anagrams</span>
Input: strs = ["eat","tea","tan","ate","nat","bat"]
Output: [["bat"],["nat","tan"],["ate","eat","tea"]]
Input: strs = ["a"]
Output: [["a"]]
class Solution {
    public List<List<String>> groupAnagrams(String[] strs) {
        List<List<String>> res=new ArrayList<List<String>>();
        if(strs.length==0)return res;
        HashMap<String,ArrayList<String>> hm=new HashMap<>();
        
        for(String str:strs){
            int[] count=new int[26];
            for(int i=0;i< str.length();i++){
                count[str.charAt(i)-'a']++;
            }
            StringBuilder sb=new StringBuilder();
            for(int c:count){
                sb.append(c);
                sb.append("#");
            }
            String rep=sb.toString();
            if(hm.containsKey(rep)){
                ArrayList<String> ana=hm.get(rep);
                ana.add(str);
                hm.put(rep,ana);
            }else{
                ArrayList<String> ana=new ArrayList<>();
                ana.add(str);
                hm.put(rep,ana);
            }
        }
        for(List<String> val:hm.values())
            res.add(val);
        return res;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Subsets II</span>
Input: nums = [1,2,2]
Output: [[],[1],[1,2],[1,2,2],[2],[2,2]]
Input: nums = [0]
Output: [[],[0]]
class Solution {
      List<List<Integer>> res=new ArrayList<List<Integer>>();
    public List<List<Integer>> subsetsWithDup(int[] nums) {
        Arrays.sort(nums);
         if(nums.length==0)
            return res;
        bt(0,new ArrayList<Integer>(),nums);
        return res;
    }
    public void bt(int start,ArrayList<Integer> curr,int[] nums){
        res.add(new ArrayList<Integer>(curr));
        for(int i=start;i< nums.length;i++){
            if(i>start&&nums[i-1]==nums[i])continue;
            curr.add(nums[i]);
            bt(i+1,curr,nums);
            curr.remove(curr.size()-1);
        }
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">K-th Symbol in Grammar</span>
Input: n = 1, k = 1
Output: 0
Explanation: row 1: 0
Input: n = 2, k = 1
Output: 0
Explanation: 
row 1: 0
row 2: 01
class Solution {
    public int kthGrammar(int n, int k) {
        long s=(long)Math.pow(2,n-1);
        long f=0;
        while(s>2){
            if(k>s/2){
                k-=s/2;
                f++;
            }
            s/=2;
        }
        k--;
        if(f%2==1)
            k=1-k;
        return k;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Predict the Winner</span>
Input: nums = [1,5,2]
Output: false
Explanation: Initially, player 1 can choose between 1 and 2. 
If he chooses 2 (or 1), then player 2 can choose from 1 (or 2) and 5. If player 2 chooses 5, 
then player 1 will be left with 1 (or 2). 
So, final score of player 1 is 1 + 2 = 3, and player 2 is 5. 
Hence, player 1 will never be the winner and you need to return false.
Input: nums = [1,5,233,7]
Output: true
Explanation: Player 1 first chooses 1. Then player 2 has to choose between 5 and 7. 
No matter which number player 2 choose, player 1 can choose 233.
Finally, player 1 has more score (234) than player 2 (12), so you need to return True 
representing player1 can win.
class Solution {
    public boolean PredictTheWinner(int[] nums) {
        if(nums.length%2==0)return true;
        long sum=0;
        for(int i=0;i< nums.length;i++)
            sum+=nums[i];
        return 2*check(nums,0,nums.length-1)>=sum;
    }
    ///
    long check(int[] arr,int s,int e){
        if(s==e)return arr[e];
        long a=arr[s]+Math.min(check(arr,s+2,e),check(arr,s+1,e-1));
        long b=arr[e]+Math.min(check(arr,s,e-2),check(arr,s+1,e-1));
        return Math.max(a,b);
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Decode String</span>
Input: s = "3[a]2[bc]"
Output: "aaabcbc"
Input: s = "3[a2[c]]"
Output: "accaccacc"
Input: s = "2[abc]3[cd]ef"
Output: "abcabccdcdcdef"
class Solution {
    public String decodeString(String s) {
       Stack<Integer> is=new Stack<>();
       Stack<String> ss=new Stack<>();
        int ptr=0;
        String res="";
        while(ptr< s.length()){
            char curr=s.charAt(ptr);
            if(Character.isDigit(curr)){
                int num=0;
                while(Character.isDigit(s.charAt(ptr))){
                    num=num*10+s.charAt(ptr)-'0';
                    ptr++;
                }
                is.push(num);
            }else if(curr=='['){
                ss.push(res);
                res="";
                ptr++;
            }else if(curr==']'){
                StringBuilder sb=new StringBuilder(ss.pop());
                int count=is.pop();
                for(int i=1;i<=count;i++)
                    sb.append(res);
                res=sb.toString();
                ptr++;
            }else{
                res+=curr;
                ptr++;
            }
        }
        return res;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Reorder List</span>
Input: head = [1,2,3,4]
Output: [1,4,2,3]
Input: head = [1,2,3,4,5]
Output: [1,5,2,4,3]
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public void reorderList(ListNode head) {
      if(head==null||head.next==null)return;
        ListNode slow=head;
        ListNode fast=head;
        ListNode prev=head;
        while(fast!=null&&fast.next!=null){
            prev=slow;
            slow=slow.next;
            fast=fast.next.next;
        }
        prev.next=null;
        ListNode l1=head;
        ListNode l2=reverse(slow);
        merge(l1,l2);
    }
    void merge(ListNode l1,ListNode l2){
        while(l2!=null){
            ListNode next=l1.next;
            l1.next=l2;
            l1=l2;
            l2=next;
        }
    }
    ListNode reverse(ListNode l2){
        if(l2==null)return null;
        ListNode prev=null;
        ListNode curr=l2;
        ListNode next=l2.next;
        while(curr!=null){
            next=curr.next;
            curr.next=prev;
            prev=curr;
            curr=next;
        }
        return prev;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Swap Nodes in Pairs</span>
Input: head = [1,2,3,4]
Output: [2,1,4,3]
Input: head = [1]
Output: [1]
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode swapPairs(ListNode head) {
        ListNode dummy=new ListNode();
        dummy.next=head;
        swap(dummy);
        return dummy.next;
    }
    void swap(ListNode node){
        if(node==null)return;
        ListNode first=node.next;
        ListNode second=null;
        if(first!=null)
            second=first.next;
        if(second!=null){
            ListNode secondnext=second.next;
            second.next=first;
            node.next=second;
            first.next=secondnext;
            swap(first);
        }
            
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Find Kth Bit in Nth Binary String</span>
Input: n = 3, k = 1
Output: "0"
Explanation: S3 is "0111001".
The 1st bit is "0".
Input: n = 4, k = 11
Output: "1"
Explanation: S4 is "011100110110001".
The 11th bit is "1".
class Solution {
    public char findKthBit(int n, int k) {
       String[] str=new String[n];
        str[0]="0";
        for(int i=1;i< n;i++)
            str[i]=formstring(str[i-1]);
        return str[n-1].charAt(k-1);
    }
    String formstring(String str){
        return str+"1"+reverse(invert(str));
    }
    String reverse(String str){
        return new StringBuilder(str).reverse().toString();
    }
    String invert(String str){
        StringBuilder sb=new StringBuilder();
        for(char c:str.toCharArray()){
            if(c=='1'){
                sb.append('0');
            }else{
                 sb.append('1');
            }
        }
        return sb.toString();
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">All Possible Full Binary Trees</span>
Input: n = 7
Output: [[0,0,0,null,null,0,0,null,null,0,0],[0,0,0,null,null,0,0,0,0],[0,0,0,0,0,0,0],
[0,0,0,0,0,null,null,null,null,0,0],[0,0,0,0,0,null,null,0,0]]
Input: n = 3
Output: [[0,0,0]]
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public List<TreeNode> allPossibleFBT(int n) {
        return helper(n);
    }
    List<TreeNode> helper(int n){
        if(n==1){
            ArrayList<TreeNode> base=new ArrayList<>();
            base.add(new TreeNode(0));
            return base;
        }
        List<TreeNode> ans=new ArrayList<>();
        for(int i=1;i< n;i=i+2){
            List<TreeNode> left=helper(i);
            List<TreeNode> right=helper(n-i-1);
            for(TreeNode l:left){
                for(TreeNode r:right){
                    TreeNode root=new TreeNode(0);
                    root.left=l;
                    root.right=r;
                    ans.add(root);
                }
            }
        }
        return ans;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Different Ways to Add Parentheses</span>
Input: expression = "2-1-1"
Output: [0,2]
Explanation:
((2-1)-1) = 0 
(2-(1-1)) = 2
Input: expression = "2*3-4*5"
Output: [-34,-14,-10,-10,10]
Explanation:
(2*(3-(4*5))) = -34 
((2*3)-(4*5)) = -14 
((2*(3-4))*5) = -10 
(2*((3-4)*5)) = -10 
(((2*3)-4)*5) = 10
class Solution {
    public List<Integer> diffWaysToCompute(String exp) {
        List<Integer> res=new ArrayList<>();
        for(int i=0;i< exp.length();i++){
            char c=exp.charAt(i);
            if(c=='-'||c=='+'||c=='*'){
                String a=exp.substring(0,i);
                String b=exp.substring(i+1);
                List<Integer> a1=diffWaysToCompute(a);
                List<Integer> b1=diffWaysToCompute(b);
                for(int x:a1){
                    for(int y:b1){
                        if(c=='-'){
                            res.add(x-y);
                        }else if(c=='+'){
                            res.add(x+y);
                        }else if(c=='*'){
                            res.add(x*y);
                        }
                    }
                }
            }
        }
        if(res.size()==0)
            res.add(Integer.valueOf(exp));
        return res;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Maximum Subarray</span>
Given an integer array nums, find the subarray which has the largest sum and return its sum.
Input: nums = [-2,1,-3,4,-1,2,1,-5,4]
Output: 6
Explanation: [4,-1,2,1] has the largest sum = 6.
Input: nums = [5,4,-1,7,8]
Output: 23
class Solution {
    public int maxSubArray(int[] nums) {
       int sum=0;
        int maximum=nums[0];
        for(int i=0;i< nums.length;i++){
            sum=sum+nums[i];
            if(sum>maximum) maximum=sum;
            if(sum< 0) sum=0;
        }
        return maximum;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Matchsticks to Square</span>
Input: matchsticks = [1,1,2,2,2]
Output: true
Explanation: You can form a square with length 2, one side of the square came two sticks 
with length 1.
Input: matchsticks = [3,3,3,3,4]
Output: false
Explanation: You cannot find a way to form a square with all the matchsticks.
class Solution {
    public boolean makesquare(int[] m) {
        if(m.length< 4)return false;
        int peri=0;
        for(int i:m)
            peri+=i;
        if(peri%4!=0)
            return false;
        int side=peri/4;
        int[] sides=new int[]{side,side,side,side};
        return function(m,0,sides);
    }
    boolean function(int[] nums,int i,int[] sides){
        if(i==nums.length)
            return sides[0]==0&&sides[1]==0&&sides[2]==0&&sides[3]==0;
        for(int j=0;j< 4;j++){
            if(nums[i]>sides[j])continue;
            sides[j]-=nums[i];
            if(function(nums,i+1,sides))return true;
            sides[j]+=nums[i];
        }
        return false;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Beautiful Arrangement</span>
Input: n = 2
Output: 2
Explanation: 
The first beautiful arrangement is [1,2]:
    - perm[1] = 1 is divisible by i = 1
    - perm[2] = 2 is divisible by i = 2
The second beautiful arrangement is [2,1]:
    - perm[1] = 2 is divisible by i = 1
    - i = 2 is divisible by perm[2] = 1
Input: n = 1
Output: 1
class Solution {
    int count=0;
    public int countArrangement(int n) {
       boolean[] vis=new boolean[n+1];
        cal(n,1,vis);
        return count;
    }
    void cal(int n,int pos,boolean[] vis){
        if(pos>n)count++;
        for(int i=1;i<=n;i++){
            if(!vis[i]&&(pos%i==0||i%pos==0)){
                vis[i]=true;
                cal(n,pos+1,vis);
                vis[i]=false;
            }
        }
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Verify Preorder Serialization of a Binary Tree</span>
Input: preorder = "9,3,4,#,#,1,#,#,2,#,6,#,#"
Output: true
Input: preorder = "1,#"
Output: false
class Solution {
    public boolean isValidSerialization(String s) {
       String[] nodes=s.split(",");
        int v=1;
        for(String n:nodes){
            v--;
            if(v< 0)return false;
            if(!n.equals("#")){
                v+=2;
            }
        }
        return v==0;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Remove Duplicate Letters</span>
Input: s = "bcabc"
Output: "abc"
Input: s = "cbacdcbc"
Output: "acdb"
class Solution {
    public String removeDuplicateLetters(String s) {
       Stack<Character> st=new Stack();
        int[] fre=new int[26];
        boolean exit[]=new boolean[26];
        for(int i=0;i< s.length();i++){
            char ch=s.charAt(i);
            fre[ch-'a']++;
        }
        for(int i=0;i< s.length();i++){
            char ch=s.charAt(i);
            fre[ch-'a']--;
            if(exit[ch-'a'])
                continue;
            while(st.size()>0&&st.peek()>ch&&fre[st.peek()-'a']>0){
                char rem=st.pop();
                exit[rem-'a']=false;
            }
            st.push(ch);
            exit[ch-'a']=true;
        }
        char ans[]=new char[st.size()];
        int i=ans.length-1;
        while(i>=0)
            ans[i--]=st.pop();
        return new String(ans);
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Basic Calculator II</span>
Input: s = "3+2*2"
Output: 7
class Solution {
    public int calculate(String s) {
        if(s==null||s.length()==0)return 0;
        Stack<Integer> st=new Stack();
        int curr=0;
        char op='+';
        char[] ch=s.toCharArray();
        for(int i=0;i< ch.length;i++){
            if(Character.isDigit(ch[i])){
                curr=curr*10+ch[i]-'0';
            }
            if(!Character.isDigit(ch[i])&&ch[i]!=' '||i==ch.length-1){
                if(op=='+'){
                    st.push(curr);
                }else if(op=='-'){
                    st.push(-curr);
                }else if(op=='*'){
                    st.push(st.pop()*curr);
                }else if(op=='/'){
                    st.push(st.pop()/curr);
                }
                op=ch[i];
                curr=0;
            }
        }
        int sum=0;
        while(!st.isEmpty())
            sum+=st.pop();
        return sum;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Binary Search Tree Iterator</span>
Input
["BSTIterator", "next", "next", "hasNext", "next", "hasNext", "next", "hasNext", "next", "hasNext"]
[[[7, 3, 15, null, null, 9, 20]], [], [], [], [], [], [], [], [], []]
Output
[null, 3, 7, true, 9, true, 15, true, 20, false]

Explanation
BSTIterator bSTIterator = new BSTIterator([7, 3, 15, null, null, 9, 20]);
bSTIterator.next();    // return 3
bSTIterator.next();    // return 7
bSTIterator.hasNext(); // return True
bSTIterator.next();    // return 9
bSTIterator.hasNext(); // return True
bSTIterator.next();    // return 15
bSTIterator.hasNext(); // return True
bSTIterator.next();    // return 20
bSTIterator.hasNext(); // return False
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class BSTIterator {
    List<Integer> list=new ArrayList<>();
    int index=0;
    public BSTIterator(TreeNode root) {
        inorder(root);
    }
    void inorder(TreeNode root){
        if(root==null)return;
        inorder(root.left);
        list.add(root.val);
         inorder(root.right);
    }
    
    public int next() {
        return list.get(index++);
    }
    
    public boolean hasNext() {
       return index< list.size(); 
    }
}

/**
 * Your BSTIterator object will be instantiated and called as such:
 * BSTIterator obj = new BSTIterator(root);
 * int param_1 = obj.next();
 * boolean param_2 = obj.hasNext();
 */
 <span id="line">---------------------------------------------------------------</span>
 <span class="textStyle">Best Time to Buy and Sell Stock with Cooldown</span>
Input: prices = [1,2,3,0,2]
Output: 3
Explanation: transactions = [buy, sell, cooldown, buy, sell]
class Solution {
    public int maxProfit(int[] prices) {
        int len=prices.length;
        if(len<=1)return 0;
        if(len==2&&prices[1]>prices[0])
            return prices[1]-prices[0];
        else if(len==2&&prices[0]>prices[1])
            return 0;
        int dp[][]=new int[len][2];
        dp[0][0]=0;
        dp[0][1]=-prices[0];
        dp[1][0]=Math.max(dp[0][0],dp[0][1]+prices[1]);
        dp[1][1]=Math.max(dp[0][1],dp[0][0]-prices[1]);
        for(int i=2;i< len;i++){
            dp[i][0]=Math.max(dp[i-1][0],dp[i-1][1]+prices[i]);
            dp[i][1]=Math.max(dp[i-1][1],dp[i-2][0]-prices[i]);
        }
        return dp[len-1][0];
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Range Sum Query 2D - Immutable</span>
Input
["NumMatrix", "sumRegion", "sumRegion", "sumRegion"]
[[[[3, 0, 1, 4, 2], [5, 6, 3, 2, 1], [1, 2, 0, 1, 5], [4, 1, 0, 1, 7], [1, 0, 3, 0, 5]]], 
[2, 1, 4, 3], [1, 1, 2, 2], [1, 2, 2, 4]]
Output
[null, 8, 11, 12]

Explanation
NumMatrix numMatrix = new NumMatrix([[3, 0, 1, 4, 2], [5, 6, 3, 2, 1], [1, 2, 0, 1, 5], 
[4, 1, 0, 1, 7], [1, 0, 3, 0, 5]]);
numMatrix.sumRegion(2, 1, 4, 3); // return 8 (i.e sum of the red rectangle)
numMatrix.sumRegion(1, 1, 2, 2); // return 11 (i.e sum of the green rectangle)
numMatrix.sumRegion(1, 2, 2, 4); // return 12 (i.e sum of the blue rectangle)
class NumMatrix {
    int[][] dp;
    public NumMatrix(int[][] matrix) {
        if(matrix.length==0||matrix[0].length==0)return;
        int row=matrix.length;
        int col=matrix[0].length;
        dp=new int[row+1][col+1];
        for(int i=0;i< row;i++){
            for(int j=0;j< col;j++){
                dp[i+1][j+1]=matrix[i][j]+dp[i][j+1]+dp[i+1][j]-dp[i][j];
            }
        }
    }
    
    public int sumRegion(int row1, int col1, int row2, int col2) {
        return dp[row2+1][col2+1]-dp[row2+1][col1]-dp[row1][col2+1]+dp[row1][col1];
    }
}

/**
 * Your NumMatrix object will be instantiated and called as such:
 * NumMatrix obj = new NumMatrix(matrix);
 * int param_1 = obj.sumRegion(row1,col1,row2,col2);
 */
 <span id="line">---------------------------------------------------------------</span>
 <span class="textStyle">Longest Increasing Subsequence</span>
Input: nums = [10,9,2,5,3,7,101,18]
Output: 4
Explanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4.
Input: nums = [0,1,0,3,2,3]
Output: 4
Input: nums = [7,7,7,7,7,7,7]
Output: 1
class Solution {
    public int lengthOfLIS(int[] arr) {
        if(arr.length==1)return 1;
        int omax=0;
        int[] dp=new int[arr.length];
        dp[0]=1;
        for(int i=1;i< dp.length;i++){
            int max=0;
            for(int j=0;j< i;j++){
                if(arr[j]< arr[i]){
                    if(dp[j]>max){
                        max=dp[j];
                    }
                }
            }
            dp[i]=max+1;
            if(dp[i]>=omax){
                omax=dp[i];
            }
        }
        return omax;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">H-Index II</span>
Input: citations = [0,1,3,5,6]
Output: 3
Explanation: [0,1,3,5,6] means the researcher has 5 papers in total and each of them had received 
0, 1, 3, 5, 6 citations respectively.
Since the researcher has 3 papers with at least 3 citations each and the remaining two with no more
 than 3 citations each, their h-index is 3.
 Input: citations = [1,2,100]
Output: 2
class Solution {
    public int hIndex(int[] c) {
        int n=c.length;
        int lo=0;
        int hi=n-1;
        while(lo<=hi){
            int mid=lo+(hi-lo)/2;
            if(c[mid]< n-mid)
                lo=mid+1;
            else
                hi=mid-1;
        }
        return n-lo;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Best Time to Buy and Sell Stock II</span>
Input: prices = [7,1,5,3,6,4]
Output: 7
Explanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.
Then buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.
Total profit is 4 + 3 = 7.
Input: prices = [1,2,3,4,5]
Output: 4
Explanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.
Total profit is 4.
class Solution {
    public int maxProfit(int[] p) {
       if(p.length==0)return 0;
        int pro=0;
        for(int i=0;i< p.length-1;i++){
            if(p[i]< p[i+1])
                pro+=p[i+1]-p[i];
        }
        return pro;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Search in Rotated Sorted Array II</span>
Input: nums = [2,5,6,0,0,1,2], target = 0
Output: true
Input: nums = [2,5,6,0,0,1,2], target = 3
Output: false
class Solution {
    public boolean search(int[] nums, int target){
        int left=0;
        int right=nums.length-1;
        while(left<=right){
            if(nums[left]==target||nums[right]==target){
                return true;
            }else if(target>nums[left]){
                while(left< right&&nums[left+1]==nums[left]){
                    left++;
                }
                left++;
            }else if(target< nums[right]){
                while(left< right&&nums[right-1]==nums[right]){
                    right--;
                }
                right--;
            }else{
                break;
                    
            }
        }
        return false;
        
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Minimum Path Sum</span>
Input: grid = [[1,3,1],[1,5,1],[4,2,1]]
Output: 7
Explanation: Because the path 1 → 3 → 1 → 1 → 1 minimizes the sum.
Input: grid = [[1,2,3],[4,5,6]]
Output: 12
class Solution {
    public int minPathSum(int[][] arr) {
        int n=arr.length;
        int m=arr[0].length;
        int[][] dp=new int[n][m];
        
        for(int i=dp.length-1;i>=0;i--){
            for(int j=dp[0].length-1;j>=0;j--){
                if(i==dp.length-1&&j==dp[0].length-1){
                    dp[i][j]=arr[i][j];
                }else if(i==dp.length-1){
                    dp[i][j]=dp[i][j+1]+arr[i][j];
                }else if(j==dp[0].length-1){
                    dp[i][j]=dp[i+1][j]+arr[i][j];
                }else{
                    dp[i][j]=Math.min(dp[i+1][j],dp[i][j+1])+arr[i][j];
                }
            }
        }
        return dp[0][0];
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Insert Delete GetRandom O(1)</span>
Input
["RandomizedSet", "insert", "remove", "insert", "getRandom", "remove", "insert", "getRandom"]
[[], [1], [2], [2], [], [1], [2], []]
Output
[null, true, false, true, 2, true, false, 2]

Explanation
RandomizedSet randomizedSet = new RandomizedSet();
randomizedSet.insert(1); // Inserts 1 to the set. Returns true as 1 was inserted successfully.
randomizedSet.remove(2); // Returns false as 2 does not exist in the set.
randomizedSet.insert(2); // Inserts 2 to the set, returns true. Set now contains [1,2].
randomizedSet.getRandom(); // getRandom() should return either 1 or 2 randomly.
randomizedSet.remove(1); // Removes 1 from the set, returns true. Set now contains [2].
randomizedSet.insert(2); // 2 was already in the set, so return false.
randomizedSet.getRandom();//Since 2 is the only num in the set, getRandom() will always return 2.
class RandomizedSet {
    private Map<Integer,Integer> map;
    private List<Integer> list;
    private Random random;
    /** Initialize your data structure here. */
    public RandomizedSet() {
        map=new HashMap();
        list=new ArrayList();
        random=new Random();
    }
    
    /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */
    public boolean insert(int val) {
        if(map.containsKey(val))return false;
        map.put(val,list.size());
        list.add(val);
        return true;
    }
    
    /** Removes a value from the set. Returns true if the set contained the specified element. */
    public boolean remove(int val) {
        if(!map.containsKey(val))return false;
        int index=map.get(val);
        int last=list.get(list.size()-1);
        list.set(index,last);
        map.put(last,index);
        map.remove(val);
        list.remove(list.size()-1);
        return true;
    }
    
    /** Get a random element from the set. */
    public int getRandom() {
        int index=random.nextInt(list.size());
        return list.get(index);
    }
}

/**
 * Your RandomizedSet object will be instantiated and called as such:
 * RandomizedSet obj = new RandomizedSet();
 * boolean param_1 = obj.insert(val);
 * boolean param_2 = obj.remove(val);
 * int param_3 = obj.getRandom();
 */
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Combination Sum IV</span>
Input: nums = [1,2,3], target = 4
Output: 7
Explanation:
The possible combination ways are:
(1, 1, 1, 1)
(1, 1, 2)
(1, 2, 1)
(1, 3)
(2, 1, 1)
(2, 2)
(3, 1)
Note that different sequences are counted as different combinations.
class Solution {
    int[] dp;
    public int combinationSum4(int[] nums, int target) {
        dp=new int[target+1];
        Arrays.fill(dp,-1);
        dp[0]=1;
        helper(nums,target);
        return dp[target];
    }
    int helper(int[] nums,int target){
        if(dp[target]>-1){
            return dp[target];
        }
         int res=0;
            for(int i:nums){
                if(i<=target){
                    res+=helper(nums,target-i);
                }
            }
            dp[target]=res;
            return dp[target];
        
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Wiggle Subsequence</span>
Input: nums = [1,7,4,9,2,5]
Output: 6
Explanation: The entire sequence is a wiggle sequence with differences (6, -3, 5, -7, 3).
Input: nums = [1,17,5,10,13,15,10,5,16,8]
Output: 7
Explanation: There are several subsequences that achieve this length.
One is [1, 17, 10, 13, 10, 16, 8] with differences (16, -7, 3, -3, 6, -8).
class Solution {
    public int wiggleMaxLength(int[] arr) {
        if(arr.length<=1)
            return arr.length;
        int up=1;
        int down=1;
        for(int i=0;i< arr.length-1;i++){
            if(arr[i]< arr[i+1]){
                up=down+1;
            }else if(arr[i]>arr[i+1]){
                down=up+1;
            }
        }
        return Math.max(up,down);
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Coin Change</span>
Input: coins = [1,2,5], amount = 11
Output: 3
Explanation: 11 = 5 + 5 + 1
Input: coins = [2], amount = 3
Output: -1
class Solution {
    public int coinChange(int[] coins, int amount) {
       if(amount==0)return 0;
        int[] dp=new int[amount+1];
        Arrays.fill(dp,amount+1);
        dp[0]=0;
        for(int coin:coins){
            for(int i=coin;i<=amount;i++){
                dp[i]=Math.min(dp[i],dp[i-coin]+1);
            }
        }
        return dp[amount]<=amount?dp[amount]:-1;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Minimum Size Subarray Sum</span>
Input: target = 7, nums = [2,3,1,2,4,3]
Output: 2
Explanation: The subarray [4,3] has the minimal length under the problem constraint.
Input: target = 4, nums = [1,4,4]
Output: 1
Input: target = 11, nums = [1,1,1,1,1,1,1,1]
Output: 0
class Solution {
    public int minSubArrayLen(int target, int[] nums) {
        int n=nums.length;
        int res=Integer.MAX_VALUE;
        int left=0;
        int valsum=0;
        for(int i=0;i< nums.length;i++){
            int currentnumber=nums[i];
            valsum+=currentnumber;
            while(valsum>=target){
                res=Math.min(res,i+1-left);
                valsum-=nums[left];
                left++;
            }
        }
        return (res!=Integer.MAX_VALUE)?res:0;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Word Break</span>
Input: s = "leetcode", wordDict = ["leet","code"]
Output: true
Explanation: Return true because "leetcode" can be segmented as "leet code".
Input: s = "applepenapple", wordDict = ["apple","pen"]
Output: true
Explanation: Return true because "applepenapple" can be segmented as "apple pen apple".
Note that you are allowed to reuse a dictionary word.
Input: s = "catsandog", wordDict = ["cats","dog","sand","and","cat"]
Output: false
class Solution {
    public boolean wordBreak(String s, List<String> w) {
      
        int[] dp=new int[s.length()];
        for(int i=0;i< dp.length;i++){
            for(int j=0;j<=i;j++){
                String word=s.substring(j,i+1);
                if(w.contains(word)){
                    if(j>0){
                    dp[i]+=dp[j-1];
                    }else{
                        dp[i]+=1;
                    }
                }
            }
        }
        return dp[s.length()-1]>0;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Unique Binary Search Trees</span>
Input: n = 3
Output: 5
Input: n = 1
Output: 1
class Solution {
    public int numTrees(int n) {
      int[] dp=new int[n+1];
        dp[0]=1;
        dp[1]=1;
        for(int i=2;i<=n;i++){
            int l=0;
            int r=i-1;
            while(l<=i-1){
                dp[i]+=dp[l]*dp[r];
                l++;r--;
            }
        }
        return dp[n];
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Unique Binary Search Trees II</span>
Input: n = 3
Output: [[1,null,2,null,3],[1,null,3,2],[2,1,3],[3,1,null,null,2],[3,2,null,1]]
Input: n = 1
Output: [[1]]
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public List<TreeNode> generateTrees(int n) {
        return shivshambu(1,n);
    }
    List<TreeNode> shivshambu(int start,int end){
        List<TreeNode> list=new ArrayList<>();
        if(start>end){
            list.add(null);
            return list;
        }
        if(start==end){
            list.add(new TreeNode(start));
            return list;
        }
        for(int i=start;i<=end;i++){
            List<TreeNode> left=shivshambu(start,i-1);
            List<TreeNode> right=shivshambu(i+1,end);
            for(TreeNode lroot:left){
                for(TreeNode rroot:right){
                    TreeNode root=new TreeNode(i);
                    root.left=lroot;
                    root.right=rroot;
                    list.add(root);
                }
            }
        }
        return list;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Rotate Function</span>
Input: nums = [4,3,2,6]
Output: 26
Explanation:
F(0) = (0 * 4) + (1 * 3) + (2 * 2) + (3 * 6) = 0 + 3 + 4 + 18 = 25
F(1) = (0 * 6) + (1 * 4) + (2 * 3) + (3 * 2) = 0 + 4 + 6 + 6 = 16
F(2) = (0 * 2) + (1 * 6) + (2 * 4) + (3 * 3) = 0 + 6 + 8 + 9 = 23
F(3) = (0 * 3) + (1 * 2) + (2 * 6) + (3 * 4) = 0 + 2 + 12 + 12 = 26
So the maximum value of F(0), F(1), F(2), F(3) is F(3) = 26.
Input: nums = [100]
Output: 0
class Solution {
    public int maxRotateFunction(int[] nums) {
        int sum=0;
        int n=nums.length;
        int f=0;
        for(int i=0;i< n;i++){
            sum+=nums[i];
            f+=i*nums[i];
        }
        int rent=f;
        for(int k=1;k< n;k++){
            f=f-sum+n*nums[k-1];
            rent=Math.max(rent,f);
        }
        return rent;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Integer Replacement</span>
Input: n = 8
Output: 3
Explanation: 8 -> 4 -> 2 -> 1
Input: n = 7
Output: 4
Explanation: 7 -> 8 -> 4 -> 2 -> 1
or 7 -> 6 -> 3 -> 2 -> 1
class Solution {
    public int integerReplacement(int n) {
      return function((long)n);  
    }
    int function(long n){
        int ans=0;
        if(n<=1){
            ans=0;
        }else if(n%2==0){
            ans=1+function(n/2);
        }else{
            ans=1+Math.min(function(n+1),function(n-1));
        }
        return ans;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Arithmetic Slices</span>
Input: nums = [1,2,3,4]
Output: 3
Explanation: We have 3 arithmetic slices in nums: [1, 2, 3], [2, 3, 4] and [1,2,3,4] itself.
class Solution {
    public int numberOfArithmeticSlices(int[] arr) {
        if(arr.length<=2)return 0;
        int[] dp=new int[arr.length];
        int ans=0;
        for(int i=2;i< arr.length;i++){
            if(arr[i]-arr[i-1]==arr[i-1]-arr[i-2]){
                dp[i]=dp[i-1]+1;
                ans+=dp[i];
            }
        }
        return ans;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Partition Equal Subset Sum</span>
Input: nums = [1,5,11,5]
Output: true
Explanation: The array can be partitioned as [1, 5, 5] and [11].
Input: nums = [1,2,3,5]
Output: false
Explanation: The array cannot be partitioned into equal sum subsets.
class Solution {
    public boolean canPartition(int[] nums) {
        int sum=0;
        for(int s:nums)
            sum+=s;
        if(sum%2!=0)return false;
        int half=sum/2;
        boolean[][] dp=new boolean[nums.length+1][half+1];
        for(int i=0;i< dp.length;i++)
            dp[i][0]=true;
        for(int i=1;i< dp.length;i++){
            for(int j=1;j< dp[0].length;j++){
                if(nums[i-1]<=j){
                    dp[i][j]=dp[i-1][j]||dp[i-1][j-nums[i-1]];
                }else{
                    dp[i][j]=dp[i-1][j];
                }
            }
        }
        return dp[nums.length][half];
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Non-overlapping Intervals</span>
Input: intervals = [[1,2],[2,3],[3,4],[1,3]]
Output: 1
Explanation: [1,3] can be removed and the rest of the intervals are non-overlapping.
Input: intervals = [[1,2],[1,2],[1,2]]
Output: 2
Explanation: You need to remove two [1,2] to make the rest of the intervals non-overlapping.
class Solution {
    public int eraseOverlapIntervals(int[][] inte) {
        if(inte==null||inte.length==0)return 0;
        Arrays.sort(inte,new Comparator<int[]>(){
            public int compare(int[] a,int[] b){
                return a[0]-b[0];
            }
        });
        
        LinkedList<int[]> res=new LinkedList<>();
        res.add(inte[0]);
        
        for(int i=1;i< inte.length;i++){
            int[] curr=inte[i];
            int[] last=res.getLast();
            
            if(last[1]>curr[0]){
                last[1]=Math.min(last[1],curr[1]);
                res.removeLast();
                res.addLast(last);
            }else{
                res.addLast(curr);
            }
        }
        return inte.length-res.size();
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Unique Substrings in Wraparound String</span>
Input: s = "a"
Output: 1
Explanation: Only the substring "a" of s is in base.
Input: s = "cac"
Output: 2
Explanation: There are two substrings ("a", "c") of s in base.
class Solution {
    public int findSubstringInWraproundString(String p) {
      int len=p.length();
        char[] ch=p.toCharArray();
        int[] dp=new int[26];
        int count=1;
        for(int i=0;i< len;i++){
            if(i==0){
                count=1;
                dp[ch[i]-'a']=1;
            }else{
                if((ch[i]-ch[i-1]-1)%26==0){
                    count++;
                }else{
                    count=1;
                }
                dp[ch[i]-'a']=Math.max(dp[ch[i]-'a'],count);
            }
        }
        int res=0;
        for(int i=0;i< 26;i++)
            res+=dp[i];
        return res;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Bitwise AND of Numbers Range</span>
Input: left = 5, right = 7
Output: 4
Input: left = 0, right = 0
Output: 0
Input: left = 1, right = 2147483647
Output: 0
class Solution {
    public int rangeBitwiseAnd(int l, int r) {
        int res=0;
        while(l<r){
          l>>=1;
            r>>=1;
            res++;
        }
        return r<< res;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Single Number III</span>
Input: nums = [1,2,1,3,2,5]
Output: [3,5]
Explanation:  [5, 3] is also a valid answer.
Input: nums = [0,1]
Output: [1,0]
class Solution {
    public int[] singleNumber(int[] nums) {
      int xy=0;
        for(int n:nums)
            xy^=n;
        xy&=-xy;
        int[] res=new int[2];
        for(int n:nums){
            if((xy & n)==0){
                res[0]^=n;
            }else{
                res[1]^=n;
            }
        }
        return res;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Sum of Two Integers</span>
Input: a = 1, b = 2
Output: 3
Input: a = 2, b = 3
Output: 5
class Solution {
    public int getSum(int x, int y) {
       while(y!=0){
           int c=x&y;
           x=x^y;
           y=c<< 1;
       } 
        return x;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Longest Turbulent Subarray</span>
Input: arr = [9,4,2,10,7,8,8,1,9]
Output: 5
Explanation: arr[1] > arr[2] < arr[3] > arr[4] < arr[5]
Input: arr = [4,8,12,16]
Output: 2
class Solution {
    public int maxTurbulenceSize(int[] arr) {
        if(arr.length< 2)
            return arr.length;
        int max=1;
        int start=0;
        int end=0;
        int len=arr.length;
        while(start+1< len){
            if(arr[start]==arr[start+1]){
                start++;
                continue;
            }
            end=start+1;
            while(end+1< len&&function(arr,end)){
                end++;
            }
            max=Math.max(max,end-start+1);
            start=end;
        }
        return max;
    }
    boolean function(int[] arr,int k){
        return (arr[k]>arr[k-1]&&arr[k]>arr[k+1])||(arr[k]< arr[k-1]&&arr[k]< arr[k+1]);
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Binary Subarrays With Sum</span>
Input: nums = [1,0,1,0,1], goal = 2
Output: 4
Explanation: The 4 subarrays are bolded and underlined below:
[1,0,1,0,1]
[1,0,1,0,1]
[1,0,1,0,1]
[1,0,1,0,1]
Input: nums = [0,0,0,0,0], goal = 0
Output: 15
class Solution {
    public int numSubarraysWithSum(int[] nums, int goal) {
        return help(nums,goal)-help(nums,goal-1);
    }
    int help(int[] arr,int s){
        if(s< 0)return 0;
        int i=0;
        int res=0;
        for(int j=0;j< arr.length;j++){
            s-=arr[j];
            while(s< 0){
                s+=arr[i++];
            }
            res+=j-i+1;
        }
        return res;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Fruit Into Baskets</span>
Input: fruits = [1,2,1]
Output: 3
Explanation: We can pick from all 3 trees.
Input: fruits = [0,1,2,2]
Output: 3
Explanation: We can pick from trees [1,2,2].
If we had started at the first tree, we would only pick from trees [0,1].
Input: fruits = [1,2,3,2,2]
Output: 4
Explanation: We can pick from trees [2,3,2,2].
If we had started at the first tree, we would only pick from trees [1,2].
class Solution {
    public int totalFruit(int[] arr) {
        int last=-1;
        int second=-1;
        int lastcount=0;
        int currentmax=0;
        int max=0;
        for(Integer fru:arr){
            if((fru==last)||(fru==second)){
                currentmax+=1;
            }else{
                currentmax=lastcount+1;
            }
            if(fru==last){
                lastcount+=1;
            }else{
                lastcount=1;
            }
            if(fru!=last){
                second=last;
                last=fru;
            }
            max=Math.max(currentmax,max);
        }
        return max;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Maximum Length of Repeated Subarray</span>
Input: nums1 = [1,2,3,2,1], nums2 = [3,2,1,4,7]
Output: 3
Explanation: The repeated subarray with maximum length is [3,2,1].
Input: nums1 = [0,0,0,0,0], nums2 = [0,0,0,0,0]
Output: 5
Explanation: The repeated subarray with maximum length is [0,0,0,0,0].
class Solution {
    public int findLength(int[] arr1, int[] arr2) {
        int[][] dp=new int[arr1.length+1][arr2.length+1];
        int ans=0;
        for(int i=1;i< dp.length;i++){
            for(int j=1;j< dp[0].length;j++){
                if(arr1[i-1]==arr2[j-1]){
                    dp[i][j]=dp[i-1][j-1]+1;
                }
                ans=Math.max(ans,dp[i][j]);
            }
        }
        return ans;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Subarray Product Less Than K</span>
Input: nums = [10,5,2,6], k = 100
Output: 8
Explanation: The 8 subarrays that have product less than 100 are:
[10], [5], [2], [6], [10, 5], [5, 2], [2, 6], [5, 2, 6]
Note that [10, 5, 2] is not included as the product of 100 is not strictly less than k.
Input: nums = [1,2,3], k = 0
Output: 0
class Solution {
    public int numSubarrayProductLessThanK(int[] arr, int k) {
        if(k<=1)return 0;
        int prod=1;
        int res=0;
        int left=0;
        int right=0;
        while(right< arr.length){
            prod*=arr[right];
            while(prod>=k){
                prod/=arr[left];
                left++;
            }
            res+=right-left+1;
            right++;
        }
        return res;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Find All Anagrams in a String</span>
Input: s = "cbaebabacd", p = "abc"
Output: [0,6]
Explanation:
The substring with start index = 0 is "cba", which is an anagram of "abc".
The substring with start index = 6 is "bac", which is an anagram of "abc".
Input: s = "abab", p = "ab"
Output: [0,1,2]
Explanation:
The substring with start index = 0 is "ab", which is an anagram of "ab".
The substring with start index = 1 is "ba", which is an anagram of "ab".
The substring with start index = 2 is "ab", which is an anagram of "ab".
class Solution {
    public List<Integer> findAnagrams(String s, String p) {
        List<Integer> res=new ArrayList();
        if(s.length()==0||p==null)return res;
        int[] ch=new int[26];
        for(char c:p.toCharArray()){
            ch[c-'a']++;
        }
        int left=0;
        int right=0;
        int count=p.length();
        while(right< s.length()){
            if(ch[s.charAt(right++)-'a']-->=1)
                count--;
            if(count==0)
                res.add(left);
            if(right-left==p.length()&&ch[s.charAt(left++)-'a']++>=0)
                count++;
        }
        return res;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Longest Repeating Character Replacement</span>
Input: s = "ABAB", k = 2
Output: 4
Explanation: Replace the two 'A's with two 'B's or vice versa.
Input: s = "AABABBA", k = 1
Output: 4
Explanation: Replace the one 'A' in the middle with 'B' and form "AABBBBA".
The substring "BBBB" has the longest repeating letters, which is 4.
class Solution {
    public int characterReplacement(String s, int k) {
        int n=s.length();
        int[] charcount=new int[26];
        int windstart=0;
        int maxlength=0;
        int maxcount=0;
        for(int i=0;i< n;i++){
            charcount[s.charAt(i)-'A']++;
            int current=charcount[s.charAt(i)-'A'];
            maxcount=Math.max(maxcount,current);
            while(i-windstart-maxcount+1>k){
                charcount[s.charAt(windstart)-'A']--;
                windstart++;
            }
            maxlength=Math.max(maxlength,i-windstart+1);
        }
        return maxlength;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Longest Substring with At Least K Repeating Characters</span>
Input: s = "aaabb", k = 3
Output: 3
Explanation: The longest substring is "aaa", as 'a' is repeated 3 times.
Input: s = "ababbc", k = 2
Output: 5
Explanation: The longest substring is "ababb", as 'a' is repeated 2 times and 'b' is repeated 3 times.
class Solution {
    public int longestSubstring(String s, int k) {
       return help(s.toCharArray(),0,s.length(),k); 
    }
    int help(char[] ch,int start,int end,int k){
        if(end-start< k)return 0;
        int[] count=new int[26];
        for(int i=start;i< end;i++){
            count[ch[i]-'a']++;
        }
        for(int i=start;i< end;i++){
            if(count[ch[i]-'a']< k){
                int j=i+1;
                while(j< end&&count[ch[j]-'a']< k){
                    j++;
                }
                return Math.max(help(ch,start,i,k),help(ch,j,end,k));
            }
        }
        return end-start;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Reveal Cards In Increasing Order</span>
Input: deck = [17,13,11,2,3,5,7]
Output: [2,13,3,11,5,17,7]
Explanation: 
We get the deck in the order [17,13,11,2,3,5,7] (this order does not matter), and reorder it.
After reordering, the deck starts as [2,13,3,11,5,17,7], where 2 is the top of the deck.
We reveal 2, and move 13 to the bottom.  The deck is now [3,11,5,17,7,13].
We reveal 3, and move 11 to the bottom.  The deck is now [5,17,7,13,11].
We reveal 5, and move 17 to the bottom.  The deck is now [7,13,11,17].
We reveal 7, and move 13 to the bottom.  The deck is now [11,17,13].
We reveal 11, and move 17 to the bottom.  The deck is now [13,17].
We reveal 13, and move 17 to the bottom.  The deck is now [17].
We reveal 17.
Since all the cards revealed are in increasing order, the answer is correct.
Input: deck = [1,1000]
Output: [1,1000]
class Solution {
    public int[] deckRevealedIncreasing(int[] deck) {
        int n=deck.length;
        int[] res=new int[n];
        Arrays.sort(deck);
        Queue<Integer> q=new LinkedList<Integer>();
        for(int i=0;i< n;i++)
            q.offer(i);
        for(int i=0;i< n;i++){
            res[q.poll()]=deck[i];
            q.offer(q.poll());
        }
        return res;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Array of Doubled Pairs</span>
Input: arr = [3,1,3,6]
Output: false
Input: arr = [4,-2,2,-4]
Output: true
Explanation: We can take two groups, [-2,-4] and [2,4] to form [-2,-4,2,4] or [2,4,-2,-4].
class Solution {
    public boolean canReorderDoubled(int[] arr) {
        Map<Integer,Integer> count=new TreeMap<>();
        for(int i:arr)
            count.put(i,count.getOrDefault(i,0)+1);
        for(int i:count.keySet()){
            if(count.get(i)==0)
                continue;
            int target=i< 0?i/2:i*2;
            if(i< 0&&i%2!=0)
                return false;
            if(count.get(i)>count.getOrDefault(target,0)){
                return false;
            }
            count.put(target,count.get(target)-count.get(i));
        }
        return true;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Pancake Sorting</span>
Input: arr = [3,2,4,1]
Output: [4,2,4,3]
Explanation: 
We perform 4 pancake flips, with k values 4, 2, 4, and 3.
Starting state: arr = [3, 2, 4, 1]
After 1st flip (k = 4): arr = [1, 4, 2, 3]
After 2nd flip (k = 2): arr = [4, 1, 2, 3]
After 3rd flip (k = 4): arr = [3, 2, 1, 4]
After 4th flip (k = 3): arr = [1, 2, 3, 4], which is sorted.
Input: arr = [1,2,3]
Output: []
Explanation: The input is already sorted, so there is no need to flip anything.
Note that other answers, such as [3, 3], would also be accepted.
class Solution {
    public List<Integer> pancakeSort(int[] arr) {
        List<Integer> lst=new ArrayList<>();
        int end=arr.length;
        while(end!=1){
            int index=find(arr,end);
            swap(arr,index);
            swap(arr,end-1);
            lst.add(index+1);
            lst.add(end);
            end--;
        }
        return lst;
    }
    private int find(int[] a,int target){
        for(int i=0;i< a.length;i++){
            if(a[i]==target){
                return i;
            }
        }
        return -1;
    }
    private void swap(int[] a,int end){
        int start=0;
        while(start< end){
            int temp=a[start];
            a[start++]=a[end];
            a[end--]=temp;
        }
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">K Closest Points to Origin</span>
Input: points = [[1,3],[-2,2]], k = 1
Output: [[-2,2]]
Explanation:
The distance between (1, 3) and the origin is sqrt(10).
The distance between (-2, 2) and the origin is sqrt(8).
Since sqrt(8) < sqrt(10), (-2, 2) is closer to the origin.
We only want the closest k = 1 points from the origin, so the answer is just [[-2,2]].
Input: points = [[3,3],[5,-1],[-2,4]], k = 2
Output: [[3,3],[-2,4]]
Explanation: The answer [[-2,4],[3,3]] would also be accepted.
class Solution {
    public int[][] kClosest(int[][] point, int k) {
        if(point==null)return null;
        PriorityQueue<int[]> pq=new PriorityQueue<int[]>(new Comparator<int[]>(){
            public int compare(int[] p1,int[] p2){
                return (p2[0]*p2[0]+p2[1]*p2[1])-(p1[0]*p1[0]+p1[1]*p1[1]);
            }
        });
        for(int i=0;i< point.length;i++){
            pq.add(point[i]);
            if(pq.size()>k){
                pq.remove();
            }
        }
        int[][] res=new int[k][2];
        int i=0;
        while(!pq.isEmpty()){
            res[i]=pq.remove();
            i++;
        }
        return res;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Subarray Sums Divisible by K</span>
Input: nums = [4,5,0,-2,-3,1], k = 5
Output: 7
Explanation: There are 7 subarrays with a sum divisible by k = 5:
[4, 5, 0, -2, -3, 1], [5], [5, 0], [5, 0, -2, -3], [0], [0, -2, -3], [-2, -3]
Input: nums = [5], k = 9
Output: 0
class Solution {
    public int subarraysDivByK(int[] nums, int k) {
        int ans=0;
        HashMap<Integer,Integer> map=new HashMap<>();
        map.put(0,1);
        int sum=0;
        int rem=0;
        for(int i=0;i< nums.length;i++){
            sum+=nums[i];
            rem=sum%k;
            if(rem< 0)
                rem+=k;
            if(map.containsKey(rem)){
                ans+=map.get(rem);
                map.put(rem,map.get(rem)+1);
            }else{
                map.put(rem,1);
            }
        }
        return ans;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Sum of Even Numbers After Queries</span>
Input: nums = [1,2,3,4], queries = [[1,0],[-3,1],[-4,0],[2,3]]
Output: [8,6,2,4]
Explanation: At the beginning, the array is [1,2,3,4].
After adding 1 to nums[0], the array is [2,2,3,4], and the sum of even values is 2 + 2 + 4 = 8.
After adding -3 to nums[1], the array is [2,-1,3,4], and the sum of even values is 2 + 4 = 6.
After adding -4 to nums[0], the array is [-2,-1,3,4], and the sum of even values is -2 + 4 = 2.
After adding 2 to nums[3], the array is [-2,-1,3,6], and the sum of even values is -2 + 6 = 4.
Input: nums = [1], queries = [[4,0]]
Output: [0]
class Solution {
    public int[] sumEvenAfterQueries(int[] num, int[][] que) {
        int[] out=new int[que.length];
        int even=0;
        for(int val:num){
            if(val%2==0){
                even+=val;
            }
        }
        for(int i=0;i< que.length;i++){
            int index=que[i][1];
            int value=que[i][0];
            if(num[index]%2==0)
                even-=num[index];
            num[index]+=value;
             if(num[index]%2==0)
                even+=num[index];
            out[i]=even;
        }
        return out;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Interval List Intersections</span>
Input: firstList = [[0,2],[5,10],[13,23],[24,25]], secondList = [[1,5],[8,12],[15,24],[25,26]]
Output: [[1,2],[5,5],[8,10],[15,23],[24,24],[25,25]]
Input: firstList = [[1,3],[5,9]], secondList = []
Output: []
class Solution {
    public int[][] intervalIntersection(int[][] a, int[][] b) {
        int i=0,j=0,k=0;
        List<int[]> res=new ArrayList<>();
        while(i< a.length&&j< b.length){
            if(b[j][0]>a[i][1]){
                i++;
            }else if(a[i][0]>b[j][1]){
                j++;
            }else{
                int aa=Math.max(a[i][0],b[j][0]);
                int bb=Math.min(a[i][1],b[j][1]);
                res.add(new int[]{aa,bb});
                if(a[i][1]< b[j][1])i++;
                else j++;
            }
        }
        int[][] ans=new int[res.size()][];
        for(int[] t:res)
            ans[k++]=t;
        return ans;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Next Greater Element III</span>
Input: nums = [1,2,1]
Output: [2,-1,2]
Explanation: The first 1's next greater number is 2; 
The number 2 can't find next greater number. 
The second 1's next greater number needs to search circularly, which is also 2.
Input: nums = [1,2,3,4,3]
Output: [2,3,4,-1,4]
class Solution {
    public int[] nextGreaterElements(int[] num) {
        int n=num.length;
        int[] arr=new int[n];
        Arrays.fill(arr,-1);
        Stack<Integer> stack=new Stack();
        for(int i=0;i< n*2;i++){
            while(!stack.isEmpty()&&num[stack.peek()]< num[i%n]){
                arr[stack.pop()]=num[i%n];
            }
            if(i< n)
                stack.push(i);
        }
        return arr;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle"> 132 Pattern</span>
 Input: nums = [1,2,3,4]
Output: false
Explanation: There is no 132 pattern in the sequence.
Input: nums = [3,1,4,2]
Output: true
Explanation: There is a 132 pattern in the sequence: [1, 4, 2].
Input: nums = [-1,3,2,0]
Output: true
Explanation: There are three 132 patterns in the sequence: [-1, 3, 2], [-1, 3, 0] and [-1, 2, 0].
class Solution {
    public boolean find132pattern(int[] nums) {
        int n=nums.length;
        int min[]=new int[n];
        min[0]=nums[0];
        for(int i=1;i< n;i++){
            min[i]=Math.min(min[i-1],nums[i]);
        }
        Stack<Integer> st=new Stack<>();
        boolean found=false;
        for(int j=n-1;j>=0;j--){
            while(st.size()>0&&st.peek()<=min[j])
                st.pop();
            if(st.size()>0&&st.peek()< nums[j]){
                found=true;
                break;
            }
            st.push(nums[j]);
        }
       return found; 
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Minimum Moves to Equal Array Elements II</span>
 Input: nums = [1,2,3]
Output: 2
Explanation:
Only two moves are needed (remember each move increments or decrements one element):
[1,2,3]  =>  [2,2,3]  =>  [2,2,2]
Input: nums = [1,10,2,9]
Output: 16
class Solution {
    public int minMoves2(int[] nums) {
        int n=nums.length;
        Arrays.sort(nums);
        int med=n%2==0?(nums[n/2]+nums[n/2-1])/2:nums[n/2];
        int s=0;
        for(int nn:nums)
            s+=Math.abs(nn-med);
        return s;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Implement Rand10() Using Rand7()</span>
Input: n = 1
Output: [2]
Input: n = 2
Output: [2,8]
Input: n = 3
Output: [3,8,10]
/**
 * The rand7() API is already defined in the parent class SolBase.
 * public int rand7();
 * @return a random integer in the range 1 to 7
 */
class Solution extends SolBase {
    public int rand10() {
        int r,i,c;
        do{
            r=rand7();
            c=rand7();
            i=c+(r-1)*7;
        }while(i>40);
        return 1+(i)%10;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Diagonal Traverse</span>
Input: mat = [[1,2,3],[4,5,6],[7,8,9]]
Output: [1,2,4,7,5,3,6,8,9]
Input: mat = [[1,2],[3,4]]
Output: [1,2,3,4]
class Solution {
    public int[] findDiagonalOrder(int[][] mat) {
        if(mat.length==0||mat[0].length==0)return new int[0];
        int m=mat.length;
        int n=mat[0].length;
        int[] arr=new int[m*n];
        int i=0;
        int row=0;
        int col=0;
        boolean up=true;
        while(row< m&&col< n){
            if(up){
                while(row>0&&col< n-1){
                    arr[i++]=mat[row][col];
                    row--;col++;
                }
                arr[i++]=mat[row][col];
                if(col==n-1){
                    row++;
                }else{
                    col++;
                }
            }
            else{
                while(col>0&&row< m-1){
                    arr[i++]=mat[row][col];
                    row++;col--;
                }
                arr[i++]=mat[row][col];
                if(row==m-1){
                    col++;
                }else{
                    row++;
                }
            }
               up=!up;
        }
     
            return arr;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Find All Duplicates in an Array</span>
Input: nums = [4,3,2,7,8,2,3,1]
Output: [2,3]
Input: nums = [1,1,2]
Output: [1]
class Solution {
    public List<Integer> findDuplicates(int[] nums) {
        List<Integer> res=new ArrayList<>();
        if(nums.length==1)return res;
        
        for(int i=0;i< nums.length;i++){
            int index=Math.abs(nums[i])-1;
            if(nums[index]< 0)
                res.add(Math.abs(nums[i]));
            nums[index]=-nums[index];
        }
        return res;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Add Two Numbers III</span>
Input: l1 = [7,2,4,3], l2 = [5,6,4]
Output: [7,8,0,7]
Input: l1 = [2,4,3], l2 = [5,6,4]
Output: [8,0,7]
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        if(l1==null|l2==null)
            return l1!=null?l1:l2;
        ListNode c1=reverse(l1);
        ListNode c2=reverse(l2);
        ListNode head=new ListNode(-1);
        ListNode itr=head;
        int carry=0;
        while(c1!=null||c2!=null||carry!=0){
            int sum=carry+(c1!=null?c1.val:0)+(c2!=null?c2.val:0);
            int id=sum%10;
            carry=sum/10;
            itr.next=new ListNode(id);
            itr=itr.next;
            if(c1!=null)
                c1=c1.next;
            if(c2!=null)
                c2=c2.next;
        }
        return reverse(head.next);
    }
    /////////////////
    ListNode reverse(ListNode head){
        if(head==null||head.next==null)
            return head;
        ListNode prev=null;
        ListNode curr=head;
        while(curr!=null){
            ListNode forw=curr.next;
            curr.next=prev;
            prev=curr;
            curr=forw;
        }
        return prev;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Sort Characters By Frequency</span>
Input: s = "tree"
Output: "eert"
Explanation: 'e' appears twice while 'r' and 't' both appear once.
So 'e' must appear before both 'r' and 't'. Therefore "eetr" is also a valid answer.
Input: s = "cccaaa"
Output: "aaaccc"
Explanation: Both 'c' and 'a' appear three times, so both "cccaaa" and "aaaccc" are valid answers.
Note that "cacaca" is incorrect, as the same characters must be together.
class Solution {
    public String frequencySort(String s) {
        Map<Character,Integer> map=new HashMap<>();
        for(char c:s.toCharArray())
            map.put(c,map.getOrDefault(c,0)+1);
        List<Character>[] bucket=new List[s.length()+1];
        for(Character key:map.keySet()){
            int fre=map.get(key);
            if(bucket[fre]==null){
                bucket[fre]=new ArrayList<>();
            }
            bucket[fre].add(key);
        }
        StringBuilder sb=new StringBuilder();
        for(int i=bucket.length-1;i>=0;i--){
            if(bucket[i]!=null){
                for(char c:bucket[i]){
                    for(int j=0;j< map.get(c);j++){
                        sb.append(c);
                    }
                }
            }
        }
        return sb.toString();
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Remove K Digits</span>
Given string num representing a non-negative integer num, and an integer k, return the smallest 
possible integer after removing k digits from num.
Input: num = "1432219", k = 3
Output: "1219"
Explanation: Remove the three digits 4, 3, and 2 to form the new number 1219 which is the smallest.
Input: num = "10200", k = 1
Output: "200"
Explanation: Remove the leading 1 and the number is 200. Note that the output must not contain 
leading zeroes.
class Solution {
    public String removeKdigits(String num, int k) {
        int digit=num.length()-k;
        if(num.length()<=k)return "0";
        int top=-1;
        int start=0;
        char[] st=num.toCharArray();
        for(int i=0;i< st.length;i++){
            while(top>=0&&st[top]>st[i]&&k>0){
                top--;
                k--;
            }
            top++;
            st[top]=st[i];
        }
        while(start<=top&&st[start]=='0')start++;
        String ans="";
        for(int i=start;i< digit;i++){
            ans=ans+st[i];
        }
        if(ans.equals(""))return "0";
        return ans;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Kth Smallest Element in a Sorted Matrix</span>
Input: matrix = [[1,5,9],[10,11,13],[12,13,15]], k = 8
Output: 13
Explanation: The elements in the matrix are [1,5,9,10,11,12,13,13,15], and the 8th smallest 
number is 13
Input: matrix = [[-5]], k = 1
Output: -5
class Solution {
    public int kthSmallest(int[][] mat, int k) {
        PriorityQueue<Integer> p=new PriorityQueue<Integer>((a,b)->(b-a));
        
        for(int i=0;i< mat.length;i++){
            for(int j=0;j< mat[0].length;j++){
                p.offer(mat[i][j]);
                if(p.size()>k)
                    p.poll();
            }
        }
        return p.peek();
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">01 Matrix</span>
Input: mat = [[0,0,0],[0,1,0],[0,0,0]]
Output: [[0,0,0],[0,1,0],[0,0,0]]
Input: mat = [[0,0,0],[0,1,0],[1,1,1]]
Output: [[0,0,0],[0,1,0],[1,2,1]]
class Solution {
    public int[][] updateMatrix(int[][] mat) {
        Queue<int[]> q=new LinkedList<>();
        for(int i=0;i< mat.length;i++){
            for(int j=0;j< mat[0].length;j++){
                if(mat[i][j]==0){
                    q.add(new int[]{i,j});
                }else{
                    mat[i][j]=-1;
                }
            }
        }
        int[][] dir={{0,1},{-1,0},{1,0},{0,-1}};
        int length=0;
        while(!q.isEmpty()){
            int size=q.size();
            length++;
            while(size-->0){
                int[] cell=q.poll();
                for(int[] d:dir){
                    int r=cell[0]+d[0];
                    int c=cell[1]+d[1];
                    if(r< 0||c< 0||r==mat.length||c==mat[0].length||mat[r][c]!=-1)
                        continue;
                    mat[r][c]=length;
                    q.add(new int[]{r,c});
                }
            }
        }
        return mat;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Shortest Unsorted Continuous Subarray</span>
Input: nums = [2,6,4,8,10,9,15]
Output: 5
Explanation: You need to sort [6, 4, 8, 10, 9] in ascending order to make the whole array 
sorted in ascending order.
Input: nums = [1,2,3,4]
Output: 0
class Solution {
    public int findUnsortedSubarray(int[] nums) {
        int min=Integer.MAX_VALUE;
        int max=Integer.MIN_VALUE;
        for(int i=0;i< nums.length-1;i++){
            if(nums[i]>nums[i+1])
                min=Math.min(min,nums[i+1]);
        }
        ////////
         for(int i=nums.length-1;i>0;i--){
            if(nums[i]< nums[i-1])
                max=Math.max(max,nums[i-1]);
        }
        int l=0;int r=0;
        for(int i=0;i< nums.length;i++){
            if(nums[i]>min){
                l=i;
                break;
            }
        }
        for(int i=nums.length-1;i>=0;i--){
            if(nums[i]< max){
                r=i;
                break;
            }
        }
        return r-l>0?r-l+1:0;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Valid Triangle Number</span>
Input: nums = [2,2,3,4]
Output: 3
Explanation: Valid combinations are: 
2,3,4 (using the first 2)
2,3,4 (using the second 2)
2,2,3
Input: nums = [4,2,3,4]
Output: 4
class Solution {
    public int triangleNumber(int[] nums) {
        int ans=0;
        if(nums.length< 3)return ans;
        Arrays.sort(nums);
        for(int i=2;i< nums.length;i++){
            int left=0;
            int right=i-1;
            while(left< right){
                if(nums[left]+nums[right]>nums[i]){
                    ans+=(right-left);
                    right--;
                }else{
                    left++;
                }
            }
        }
        return ans;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Sum of Square Numbers</span>
Input: c = 5
Output: true
Explanation: 1 * 1 + 2 * 2 = 5
Input: c = 3
Output: false
class Solution {
    public boolean judgeSquareSum(int c) {
        int left=0;
        long right=(int)Math.sqrt(c);
        while(left<=right){
            long total=left*left+right*right;
            if(total==c){
                return true;
            }else if(total>c){
                right--;
            }else{
                left++;
            }
        }
        return false;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Partition Labels</span>
Input: s = "ababcbacadefegdehijhklij"
Output: [9,7,8]
Explanation:
The partition is "ababcbaca", "defegde", "hijhklij".
This is a partition so that each letter appears in at most one part.
A partition like "ababcbacadefegde", "hijhklij" is incorrect, because it splits s into less parts.
Input: s = "eccbbbbdec"
Output: [10]
class Solution {
    public List<Integer> partitionLabels(String s) {
        HashMap<Character,Integer> map=new HashMap<>();
        for(int i=0;i< s.length();i++){
            char ch=s.charAt(i);
            map.put(ch,i);
        }
        List<Integer> res=new ArrayList<>();
        int prev=-1;
        int max=0;
        for(int i=0;i< s.length();i++){
            char ch=s.charAt(i);
            max=Math.max(max,map.get(ch));
            if(max==i){
                res.add(max-prev);
                prev=max;
            }
        }
        return res;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Minimum Increment to Make Array Unique</span>
Input: nums = [1,2,2]
Output: 1
Explanation: After 1 move, the array could be [1, 2, 3].
Input: nums = [3,2,1,2,1,7]
Output: 6
Explanation: After 6 moves, the array could be [3, 4, 1, 2, 5, 7].
It can be shown with 5 or less moves that it is impossible for the array to have all unique values.
class Solution {
    public int minIncrementForUnique(int[] nums) {
       Arrays.sort(nums);
        int res=0;
        for(int i=1;i< nums.length;i++){
            int pre=nums[i-1];
            int curr=nums[i];
            if(pre>=curr){
                res+=pre-curr+1;
                nums[i]=pre+1;
            }
        }
        return res;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">3Sum With Multiplicity</span>
Input: arr = [1,1,2,2,3,3,4,4,5,5], target = 8
Output: 20
Explanation: 
Enumerating by the values (arr[i], arr[j], arr[k]):
(1, 2, 5) occurs 8 times;
(1, 3, 4) occurs 8 times;
(2, 2, 4) occurs 2 times;
(2, 3, 3) occurs 2 times.
Input: arr = [1,1,2,2,2,2], target = 5
Output: 12
Explanation: 
arr[i] = 1, arr[j] = arr[k] = 2 occurs 12 times:
We choose one 1 from [1,1] in 2 ways,
and two 2s from [2,2,2,2] in 6 ways.
class Solution {
    public int threeSumMulti(int[] arr, int target) {
       int mod=1_000_000_007;
       long res=0;
        for(int i=0;i< arr.length;i++){
            int count[]=new int[101];
            for(int j=i+1;j< arr.length;j++){
                int k=target-arr[i]-arr[j];
                if(k>=0&&k<=100&&count[k]>0){
                    res+=count[k];
                    res%=mod;
                }
                count[arr[j]]++;
            }
        }
        return (int)res;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">RLE Iterator</span>
Input
["RLEIterator", "next", "next", "next", "next"]
[[[3, 8, 0, 9, 2, 5]], [2], [1], [1], [2]]
Output
[null, 8, 8, 5, -1]

Explanation
RLEIterator rLEIterator = new RLEIterator([3, 8, 0, 9, 2, 5]); // This maps to the sequence [8,8,8,5,5].
rLEIterator.next(2); // exhausts 2 terms of the sequence, returning 8. The remaining sequence is now [8, 5, 5].
rLEIterator.next(1); // exhausts 1 term of the sequence, returning 8. The remaining sequence is now [5, 5].
rLEIterator.next(1); // exhausts 1 term of the sequence, returning 5. The remaining sequence is now [5].
rLEIterator.next(2); // exhausts 2 terms, returning -1. This is because the first term exhausted was 5,
but the second term did not exist. Since the last term exhausted does not exist, we return -1.
class RLEIterator {
    int[] arr;
    int p;
    public RLEIterator(int[] encoding) {
      arr=encoding;
      p=0;
    }
    
    public int next(int n) {
        while(n>0&&p< arr.length){
            int curr=arr[p];
            arr[p]=n>arr[p]?0:arr[p]-n;
            n=n>curr?n-curr:0;
            p=n==0?p:p+2;
        }
         return p< arr.length?arr[p+1]:-1;
    }
   
}

/**
 * Your RLEIterator object will be instantiated and called as such:
 * RLEIterator obj = new RLEIterator(encoding);
 * int param_1 = obj.next(n);
 */
 <span id="line">---------------------------------------------------------------</span>
 <span class="textStyle">Reordered Power of 2</span>
Input: n = 1
Output: true
Input: n = 10
Output: false
class Solution {
    public boolean reorderedPowerOf2(int n) {
       int[] countn=count(n);
        int num=1;
        for(int i=0;i< 31;i++){
            if(Arrays.equals(countn,count(num)))
            return true;
            num=num<< 1;
        }
        return false;
    }
    //////////////////
    int[] count(int n){
        int[] arr=new int[10];
        while(n>0){
            arr[n%10]++;
            n/=10;
        }
        return arr;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Reorganize String</span>
Input: s = "aab"
Output: "aba"
Input: s = "aaab"
Output: ""
class Solution {
    class pair{
        char ch;
        int f;
        public pair(char ch,int f){
            this.ch=ch;
            this.f=f;
        }
    }
    ///////////////
    public String reorganizeString(String s) {
        int[] map=new int[26];
        for(int i=0;i< s.length();i++){
            map[s.charAt(i)-'a']++;
        }
        PriorityQueue<pair> pq=new PriorityQueue<>((a,b)->(b.f-a.f));
        for(int i=0;i< 26;i++){
            if(map[i]>0)
                pq.add(new pair((char)('a'+i),map[i]));
        }
        StringBuilder ans=new StringBuilder();
        pair block=pq.poll();
        ans.append(block.ch);
        block.f--;
        while(pq.size()>0){
            pair temp=pq.poll();
            ans.append(temp.ch);
            temp.f--;
            if(block.f>0)
                pq.add(block);
            block=temp;
            
        }
        if(block.f>0)return "";
        return ans.toString();
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Task Scheduler</span>
Input: tasks = ["A","A","A","B","B","B"], n = 2
Output: 8
Explanation: 
A -> B -> idle -> A -> B -> idle -> A -> B
There is at least 2 units of time between any two same tasks.
Input: tasks = ["A","A","A","B","B","B"], n = 0
Output: 6
Explanation: On this case any permutation of size 6 would work since n = 0.
["A","A","A","B","B","B"]
["A","B","A","B","A","B"]
["B","B","B","A","A","A"]
...
And so on.
Input: tasks = ["A","A","A","A","A","A","B","C","D","E","F","G"], n = 2
Output: 16
Explanation: 
One possible solution is
A -> B -> C -> A -> D -> E -> A -> F -> G -> A -> idle -> idle -> A -> idle -> idle -> A
class Solution {
    public int leastInterval(char[] tasks, int n) {
        int[] fre=new int[26];
        for(int i:tasks)
            fre[i-'A']++;
        Arrays.sort(fre);
        
        int fmax=fre[25];
        int idle=(fmax-1)*n;
        
        for(int i=fre.length-2;i>=0 && idle>0;--i)
            idle-=Math.min(fmax-1,fre[i]);
        idle=Math.max(0,idle);
        return idle+tasks.length;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Sort an Array</span>
Input: nums = [5,2,3,1]
Output: [1,2,3,5]
Explanation: After sorting the array, the positions of some numbers are not changed 
(for example, 2 and 3), while the positions of other numbers are changed (for example, 1 and 5).
Input: nums = [5,1,1,2,0,0]
Output: [0,0,1,1,2,5]
Explanation: Note that the values of nums are not necessairly unique.
class Solution {
    public int[] sortArray(int[] nums) {
        Arrays.sort(nums);
        return nums;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Beautiful Array</span>
Input: n = 4
Output: [2,1,4,3]
Input: n = 5
Output: [3,1,2,5,4]
class Solution {
    public int[] beautifulArray(int n) {
        ArrayList<Integer> ans=new ArrayList<>();
        ans.add(1);
        while(ans.size()< n){
            ArrayList< Integer> temp=new ArrayList<>();
            for(int el:ans){
                if(2*el-1<=n)
                    temp.add(el*2-1);
            }
            ///
             for(int el:ans){
                if(2*el<=n)
                    temp.add(el*2);
            }
            ans=temp;
        }
        int[] res=new int[n];
        for(int i=0;i< n;i++){
            res[i]=ans.get(i);
        }
        return res;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Delete Node in a BST</span>
Input: root = [5,3,6,2,4,null,7], key = 3
Output: [5,4,6,2,null,null,7]
Explanation: Given key to delete is 3. So we find the node with value 3 and delete it.
One valid answer is [5,4,6,2,null,null,7], shown in the above BST.
Please notice that another valid answer is [5,2,6,null,4,null,7] and it's also accepted.
Input: root = [5,3,6,2,4,null,7], key = 0
Output: [5,3,6,2,4,null,7]
Explanation: The tree does not contain a node with value = 0.
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public TreeNode deleteNode(TreeNode root, int key) {
        if(root==null)return null;
        if(root.val< key){
            root.right=deleteNode(root.right,key);
        }else if(root.val>key){
            root.left=deleteNode(root.left,key);
        }else{
            if(root.left!=null&&root.right!=null){
                int v=findmax(root.left,Integer.MIN_VALUE);
                root.val=v;
                root.left=deleteNode(root.left,v);
                return root;
            }else if(root.left!=null){
                return root.left;
            }else if(root.right!=null){
                return root.right;
            }else{
                return null;
            }
        }
          return root;
    }
  
    /////////////////
    int findmax(TreeNode root,int max){
        while(root!=null){
            max=Math.max(max,root.val);
            root=root.right;
        }
        return max;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Path Sum III</span>
Input: root = [10,5,-3,3,2,null,11,3,-2,null,1], targetSum = 8
Output: 3
Explanation: The paths that sum to 8 are shown.
Input: root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22
Output: 3
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    int total=0;
    public int pathSum(TreeNode root, int sum) {
      if(root==null)return 0;
        HashMap<Integer,Integer> map=new HashMap();
        map.put(0,1);
        findsum(root,0,sum,map);
        return total;
    }
    /////////////
    void findsum(TreeNode curr,int sum,int target,HashMap<Integer,Integer> map){
        if(curr==null)return;
        sum+=curr.val;
        if(map.containsKey(sum-target))
            total+=map.get(sum-target);
        map.put(sum,map.getOrDefault(sum,0)+1);
        findsum(curr.left,sum,target,map);
        findsum(curr.right,sum,target,map);
        map.put(sum,map.get(sum)-1);
        return;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">House Robber III</span>
Input: root = [3,2,3,null,3,null,1]
Output: 7
Explanation: Maximum amount of money the thief can rob = 3 + 3 + 1 = 7.
Input: root = [3,4,5,1,3,null,1]
Output: 9
Explanation: Maximum amount of money the thief can rob = 4 + 5 = 9.
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    Map<TreeNode,Integer> map=new HashMap<>();
    public int rob(TreeNode root) {
        if(root==null)return 0;
        if(map.containsKey(root))
            return map.get(root);
        int sum=root.val;
        if(root.left!=null){
            sum+=rob(root.left.left);
            sum+=rob(root.left.right);
        }
         if(root.right!=null){
            sum+=rob(root.right.left);
            sum+=rob(root.right.right);
        }
        int nextsum=rob(root.left)+rob(root.right);
        int res=Math.max(sum,nextsum);
        map.put(root,res);
        return res;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Kth Smallest Element in a BST</span>
Input: root = [3,1,4,null,2], k = 1
Output: 1
Input: root = [5,3,6,2,4,null,null,1], k = 3
Output: 3
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    int count=0;
    int out=0;
    public int kthSmallest(TreeNode root, int k) {
        function(root,k);
        return out;
    }
    void function(TreeNode root,int k){
        if(root.left!=null)
            function(root.left,k);
        count++;
        if(count==k){
            out=root.val;
            return;
        }
        if(root.right!=null)
            function(root.right,k);
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Count Complete Tree Nodes</span>
Input: root = [1,2,3,4,5,6]
Output: 6
Input: root = [1]
Output: 1
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public int countNodes(TreeNode root) {
      if(root==null)return 0;
        TreeNode left=root,right=root;
        int hl=0,hr=0;
        while(left!=null){
            hl++;
            left=left.left;
        }
        while(right!=null){
            hr++;
            right=right.right;
        }
        if(hl==hr)
            return (1<< hl)-1;
        return 1+countNodes(root.left)+countNodes(root.right);
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Binary Tree Level Order Traversal II</span>
Input: root = [3,9,20,null,null,15,7]
Output: [[15,7],[9,20],[3]]
Input: root = [1]
Output: [[1]]
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public List<List<Integer>> levelOrderBottom(TreeNode root) {
       List res=new ArrayList();
        if(root==null)
            return res;
        Queue<TreeNode> q=new LinkedList<TreeNode>();
        q.offer(root);
        while(!q.isEmpty()){
            ArrayList<Integer> level=new ArrayList();
            int size=q.size();
            for(int i=0;i< size;i++){
                TreeNode head=q.poll();
                level.add(head.val);
                if(head.left!=null)
                    q.offer(head.left);
                if(head.right!=null)
                    q.offer(head.right);
            }
            res.add(0,level);
        }
        return res;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Construct Binary Tree from Inorder and Postorder Traversal</span>
Input: inorder = [9,3,15,20,7], postorder = [9,15,7,20,3]
Output: [3,9,20,null,null,15,7]
Input: inorder = [-1], postorder = [-1]
Output: [-1]
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public TreeNode buildTree(int[] inorder, int[] postorder) {
       int len=inorder.length;
        return help(inorder,postorder,0,len-1,0,len-1);
    }
    TreeNode help(int[] inorder,int[] postorder,int instart,int inend,int poststart,int postend){
        if(instart>inend)
            return null;
        int rootval=postorder[postend];
        TreeNode root=new TreeNode(rootval);
        int rootindex=instart;
        for(;rootindex<=inend;rootindex++){
            if(inorder[rootindex]==rootval)
                break;
        }
        int lefttreesize=rootindex-instart;
        int righttreesize=inend-rootindex;
        
        root.left=help(inorder,postorder,instart,rootindex-1,poststart,poststart+lefttreesize-1);
        
          root.right=help(inorder,postorder,rootindex+1,inend,postend-righttreesize,postend-1);
        return root;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Reach a Number</span>
Input: target = 2
Output: 3
Explanation:
On the 1st move, we step from 0 to 1 (1 step).
On the 2nd move, we step from 1 to -1 (2 steps).
On the 3rd move, we step from -1 to 2 (3 steps).
Input: target = 3
Output: 2
Explanation:
On the 1st move, we step from 0 to 1 (1 step).
On the 2nd move, we step from 1 to 3 (2 steps).
class Solution {
    public int reachNumber(int target) {
       if(target==0)return 0;
        int sum=0;
        int step=0;
        target=Math.abs(target);
        while(sum< target){
            sum+=step;
            step++;
        }
        while((sum-target)%2==1){
            sum+=step;
            step++;
        }
        return step-1;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Single Element in a Sorted Array</span>
Input: nums = [1,1,2,3,3,4,4,8,8]
Output: 2
Input: nums = [3,3,7,7,10,11,11]
Output: 10
class Solution {
    public int singleNonDuplicate(int[] nums) {
       int ans=0;
        for(int n:nums)
            ans^=n;
        return ans;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Next Permutation</span>
Input: nums = [1,2,3]
Output: [1,3,2]
Input: nums = [3,2,1]
Output: [1,2,3]
Input: nums = [1,1,5]
Output: [1,5,1]
class Solution {
    public void nextPermutation(int[] nums) {
        int i=nums.length-2;
        while(i>=0&&nums[i]>=nums[i+1])
            i--;
        if(i>=0){
            int j=nums.length-1;
            while(j>=0&&nums[j]<=nums[i])
                j--;
            swap(nums,i,j);
        }
        reverse(nums,i+1);
    }
    ///
    void swap(int[] nums,int i,int j){
        int temp=nums[i];
        nums[i]=nums[j];
        nums[j]=temp;
    }
    void reverse(int[] nums,int start){
        int end=nums.length-1;
        while(start< end){
            swap(nums,start,end);
            start++;
            end--;
        }
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Coin Change II</span>
Input: amount = 5, coins = [1,2,5]
Output: 4
Explanation: there are four ways to make up the amount:
5=5
5=2+2+1
5=2+1+1+1
5=1+1+1+1+1
Input: amount = 10, coins = [10]
Output: 1
class Solution {
    public int change(int amount, int[] coins){
        HashMap<String,Integer> hm=new HashMap<String,Integer>();
       return help(amount,coins,0,hm); 
    }
    int help(int am,int[] co,int index,HashMap<String,Integer> hm){
        if(am==0)
            return 1;
        if(am< 0||index==co.length)return 0;
        String key=am+"ans"+index;
        if(hm.containsKey(key))
            return hm.get(key);
        int res=0;
        for(int i=index;i< co.length;i++){
            if(am>=co[i])
                res+=help(am-co[i],co,i,hm);
        }
         hm.put(key,res);
         return res;
    }
   
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Longest Palindromic Subsequence</span>
Input: s = "bbbab"
Output: 4
Explanation: One possible longest palindromic subsequence is "bbbb".
Input: s = "cbbd"
Output: 2
Explanation: One possible longest palindromic subsequence is "bb".
class Solution {
    public int longestPalindromeSubseq(String s) {
        String text1=s;
        String text2=new StringBuilder(s).reverse().toString();
        int[][] dp=new int[text1.length()+1][text2.length()+1];
        for(int i=1;i< dp.length;i++){
            for(int j=1;j< dp[0].length;j++){
                if(text1.charAt(i-1)==text2.charAt(j-1)){
                    dp[i][j]=dp[i-1][j-1]+1;
                }else{
                    dp[i][j]=Math.max(dp[i][j-1],dp[i-1][j]);
                }
            }
        }
        return dp[text1.length()][text2.length()];
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Remove Duplicates from Sorted List II</span>
Input: head = [1,2,3,3,4,4,5]
Output: [1,2,5]
Input: head = [1,1,1,2,3]
Output: [2,3]
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode deleteDuplicates(ListNode head) {
     ListNode dummy=new ListNode(0,head);
        ListNode prev=dummy;
        while(head!=null){
            if(head.next!=null&&head.val==head.next.val){
                while(head.next!=null&&head.val==head.next.val){
                    head=head.next;
                }
                prev.next=head.next;
            }else{
                prev=prev.next;
            }
            head=prev.next;
        }
        return dummy.next;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Simplify Path</span>
Input: path = "/home/"
Output: "/home"
Explanation: Note that there is no trailing slash after the last directory name.
Input: path = "/../"
Output: "/"
Explanation: Going one level up from the root directory is a no-op, as the root 
level is the highest level you can go.
Input: path = "/home//foo/"
Output: "/home/foo"
Explanation: In the canonical path, multiple consecutive slashes are replaced by a single one.
class Solution {
    public String simplifyPath(String path) {
        Stack<String> s=new Stack<>();
        StringBuilder res=new StringBuilder();
        String[] p=path.split("/");
        for(int i=0;i< p.length;i++){
            if(!s.isEmpty()&&p[i].equals(".."))
                s.pop();
            else if(!p[i].equals("")&&!p[i].equals(".")&&!p[i].equals(".."))
                    s.push(p[i]);
        }
                    if(s.isEmpty())return "/";
                    while(!s.isEmpty()){
                        res.insert(0,s.pop()).insert(0,"/");
                    }
                    return res.toString();
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Rotate List</span>
Input: head = [1,2,3,4,5], k = 2
Output: [4,5,1,2,3]
Input: head = [0,1,2], k = 4
Output: [2,0,1]
 /**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode rotateRight(ListNode head, int k) {
       if(head==null||k==0)return head;
        int len=0;
        ListNode tail=head;
        while(tail.next!=null){
            len++;
            tail=tail.next;
        }
        len++;
        tail.next=head;
        int point=len-k%len;
        tail=head;
        while(point-->1){
            tail=tail.next;
        }
        head=tail.next;
        tail.next=null;
        return head;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Random Point in Non-overlapping Rectangles</span>
Input
["Solution", "pick", "pick", "pick", "pick", "pick"]
[[[[-2, -2, 1, 1], [2, 2, 4, 6]]], [], [], [], [], []]
Output
[null, [1, -2], [1, -1], [-1, -2], [-2, -2], [0, 0]]

Explanation
Solution solution = new Solution([[-2, -2, 1, 1], [2, 2, 4, 6]]);
solution.pick(); // return [1, -2]
solution.pick(); // return [1, -1]
solution.pick(); // return [-1, -2]
solution.pick(); // return [-2, -2]
solution.pick(); // return [0, 0]
class Solution {
    int[][] rects;
    Random r=new Random();
    int total=0;
    List<Integer> sum=new ArrayList<>();
    public Solution(int[][] rects) {
        this.rects=rects;
        for(int[] rec:rects){
            total+=(rec[2]-rec[0]+1)*(rec[3]-rec[1]+1);
            sum.add(total);
        }
    }
    
    public int[] pick() {
        int target=r.nextInt(total);
        int lo=0,hi=rects.length-1;
        while(lo< hi){
            int mid=lo+(hi-lo)/2;
            if(target>=sum.get(mid))
                lo=mid+1;
            else
                hi=mid;
        }
        int[] rect=rects[lo];
        int x1=rect[0];
        int y1=rect[1];
        int x2=rect[2];
        int y2=rect[3];
        int x=r.nextInt(x2-x1+1);
        int y=r.nextInt(y2-y1+1);
        return new int[]{x1+x,y1+y};
    }
}

/**
 * Your Solution object will be instantiated and called as such:
 * Solution obj = new Solution(rects);
 * int[] param_1 = obj.pick();
 */
 <span id="line">---------------------------------------------------------------</span>
 <span class="textStyle">Linked List Random Nodes</span>
Input
["Solution", "getRandom", "getRandom", "getRandom", "getRandom", "getRandom"]
[[[1, 2, 3]], [], [], [], [], []]
Output
[null, 1, 3, 2, 2, 3]

Explanation
Solution solution = new Solution([1, 2, 3]);
solution.getRandom(); // return 1
solution.getRandom(); // return 3
solution.getRandom(); // return 2
solution.getRandom(); // return 2
solution.getRandom(); // return 3
// getRandom() should return either 1, 2, or 3 randomly. Each element should have equal probability of returning.
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {

    /** @param head The linked list's head.
        Note that the head is guaranteed to be not null, so it contains at least one node. */
    ArrayList<Integer> arr=new ArrayList<>();
    public Solution(ListNode head) {
        while(head!=null){
            arr.add(head.val);
            head=head.next;
        }
    }
    
    /** Returns a random node's value. */
    public int getRandom() {
        return arr.get((int)(Math.random()*arr.size()));
    }
}

/**
 * Your Solution object will be instantiated and called as such:
 * Solution obj = new Solution(head);
 * int param_1 = obj.getRandom();
 */
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">4Sum II</span>
Input: nums1 = [1,2], nums2 = [-2,-1], nums3 = [-1,2], nums4 = [0,2]
Output: 2
Explanation:
The two tuples are:
1. (0, 0, 0, 1) -> nums1[0] + nums2[0] + nums3[0] + nums4[1] = 1 + (-2) + (-1) + 2 = 0
2. (1, 1, 0, 0) -> nums1[1] + nums2[1] + nums3[0] + nums4[0] = 2 + (-1) + (-1) + 0 = 0
Input: nums1 = [0], nums2 = [0], nums3 = [0], nums4 = [0]
Output: 1
class Solution {
    public int fourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4) {
        Map<Integer,Integer> map=new HashMap<>();
        for(int i:nums1){
            for(int j:nums2){
                int sum=i+j;
                map.put(-sum,map.getOrDefault(-sum,0)+1);
            }
        }
        //
        int count=0;
         for(int k:nums3){
            for(int l:nums4){
                int sum=k+l;
                count+=map.getOrDefault(sum,0);
            }
        }
        return count;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Insertion Sort List</span>
Input: head = [4,2,1,3]
Output: [1,2,3,4]
Input: head = [-1,5,3,4,0]
Output: [-1,0,3,4,5]
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode insertionSortList(ListNode head) {
      if(head==null||head.next==null)return head;
        ListNode temp=head;
        while(temp!=null){
            ListNode next=temp.next;
            ListNode start=head;
            ListNode prev=head;
            while(start!=next){
                if(start.val>temp.val){
                    temp.next=start;
                    if(start==head){
                        head=temp;
                    }else{
                        prev.next=temp;
                    }
                    while(start.next!=temp){
                        start=start.next;
                    }
                    start.next=next;
                   
                }
                 prev=start;
                    start=start.next;
            }
            temp=next;
        }
        return head;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Count Numbers with Unique Digits</span>
Input: n = 2
Output: 91
Explanation: The answer should be the total numbers in the range of 0 ≤ x < 100, 
excluding 11,22,33,44,55,66,77,88,99
class Solution {
    public int countNumbersWithUniqueDigits(int n) {
      int[] dp=new int[9];
        dp[0]=1;
        dp[1]=9;
        if(n==0)return 1;
        int sum=10;
        int v=9;
        for(int i=2;i<=n;i++){
            dp[i]=dp[i-1]*v--;
            sum+=dp[i];
        }
        return sum;
        
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Integer Break</span>
Input: n = 2
Output: 1
Explanation: 2 = 1 + 1, 1 × 1 = 1.
Input: n = 10
Output: 36
Explanation: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36.
class Solution {
    public int integerBreak(int n) {
       int[] dp=new int[n+1];
        for(int i=1;i<=n;i++){
            for(int j=1;j<=i;j++){
                dp[i]=Math.max(dp[i],(i-j)*j);
                dp[i]=Math.max(dp[i],dp[j]*(i-j));
            }
        }
        return dp[n];
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Perfect Squares</span>
Input: n = 12
Output: 3
Explanation: 12 = 4 + 4 + 4.
Input: n = 13
Output: 2
Explanation: 13 = 4 + 9.
class Solution {
    public int numSquares(int n) {
       int[] dp=new int[n+1];
        dp[0]=0;
        dp[1]=1;
        for(int i=2;i<=n;i++){
            int min=Integer.MAX_VALUE;
            for(int j=1;j*j<=i;j++){
               int rem=i-j*j;
                if(dp[rem]< min){
                    min=dp[rem];
                }
            }
            dp[i]=min+1;
        }
        return dp[n];
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Ugly Number II</span>
Input: n = 10
Output: 12
Explanation: [1, 2, 3, 4, 5, 6, 8, 9, 10, 12] is the sequence of the first 10 ugly numbers.
Input: n = 1
Output: 1
Explanation: 1 has no prime factors, therefore all of its prime factors are limited to 2, 3, and 5.
class Solution {
    UglyNumber ugly=new UglyNumber();
    
    public int nthUglyNumber(int n) {
        
        return ugly.result[n-1];
    }
}

class UglyNumber{
    int[] result;
    
    public UglyNumber(){
        result=new int[1690];
        result[0]=1;
        
        int v2=0,v3=0,v5=0;
        
        for(int i=1;i< 1690;i++){
            
            result[i]=Math.min(result[v2]*2,Math.min(result[v3]*3,result[v5]*5));

            if(result[i]==result[v2]*2){
                v2++;
            }
            if(result[i]==result[v3]*3){
                v3++;
            }
            if(result[i]==result[v5]*5){
                v5++;
            }
            
        }
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Super Pow</span>
Input: a = 2, b = [3]
Output: 8
Input: a = 2, b = [1,0]
Output: 1024
import java.math.BigInteger ; 
class Solution {
    public int superPow(int a, int[] b) {
       StringBuilder sb=new StringBuilder();
        for(int n:b){
            sb.append(n);
        }
        BigInteger p = BigInteger.valueOf(a) ; 
        
        BigInteger q = new BigInteger("1337");
        
        BigInteger l = new BigInteger(sb.toString()); 
        
        p= p.modPow(l,q)  ;
        
        return p.intValue();  
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Lexicographical Numbers</span>
Input: n = 13
Output: [1,10,11,12,13,2,3,4,5,6,7,8,9]
Input: n = 2
Output: [1,2]
class Solution {
    ArrayList<Integer> res=new ArrayList<>();
    public List<Integer> lexicalOrder(int n) {
       for(int i=1;i<=9;i++){
           dfs(i,n);
       }
        return res;
    }
    void dfs(int i,int n){
        if(i>n)return;
        res.add(i);
        for(int j=0;j< 10;j++){
            dfs(10*i+j,n);
        }
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Contiguous Array</span>
Input: nums = [0,1]
Output: 2
Explanation: [0, 1] is the longest contiguous subarray with an equal number of 0 and 1.
Input: nums = [0,1,0]
Output: 2
Explanation: [0, 1] (or [1, 0]) is a longest contiguous subarray with equal number of 0 and 1.
class Solution {
    public int findMaxLength(int[] nums) {
       if(nums==null||nums.length==0)return 0;
        
        for(int i=0;i< nums.length;i++){
            if(nums[i]==0)
                nums[i]=-1;
        }
        //
        int sum=0;
        int max=0;
        Map<Integer,Integer> map=new HashMap<>();
        map.put(0,-1);
        for(int i=0;i< nums.length;i++){
            sum+=nums[i];
            if(map.containsKey(sum)){
                int last=map.get(sum);
                max=Math.max(max,i-last);
            }else{
                map.put(sum,i);
            }
        }
        return max;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Nth Digit</span>
Input: n = 3
Output: 3
Input: n = 11
Output: 0
Explanation: The 11th digit of the sequence 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, ... is a 0, 
which is part of the number 10.
class Solution {
    public int findNthDigit(int n) {
       long step = 1;
        long size = 9 * (int)Math.pow(10, step-1);
        while (n > step * size) {
            n -= step * size;
            step++;
            size = 9 * (int)Math.pow(10, step-1);
        }        
        long number = size/9 + (long)Math.ceil((n*1.0d)/step) -1;
        char ansDigit = String.valueOf(number).charAt((int)((n%step-1+step)%step));
        return (int)(ansDigit - '0');
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Maximum XOR of Two Numbers in an Array</span>
Input: nums = [3,10,5,25,2,8]
Output: 28
Explanation: The maximum result is 5 XOR 25 = 28.
Input: nums = [14,70,53,83,49,91,36,80,92,51,66,70]
Output: 127
class Solution {
    public int findMaximumXOR(int[] nums) {
       int m=0;
        int max=0;
        for(int i=31;i>=0;i--){
            m=m|(1<< i);
            Set< Integer> set=new HashSet();
            for(int num:nums)
                set.add(m&num);
            int temp=max|(1<< i);
            for(int pre:set){
                if(set.contains(temp^pre)){
                    max=temp;
                    break;
                }
            }
        }
        return max;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Find First and Last Position of Element in Sorted Array</span>
Input: nums = [5,7,7,8,8,10], target = 8
Output: [3,4]
Input: nums = [5,7,7,8,8,10], target = 6
Output: [-1,-1]
class Solution {
    public int[] searchRange(int[] arr, int target) {
        int[] ans={-1,-1};
      if(arr.length==0)return ans; 
        int low=0;
        int high=arr.length-1;
        while(low<=high){
            int mid=(low+high)/2;
            if(arr[mid]==target){
                ans[0]=mid;
                high=mid-1;
            }else if(arr[mid]< target){
                low=mid+1;
            }else{
                high=mid-1;
            }
        }
        /////////////
          low=0;
         high=arr.length-1;
        while(low<=high){
            int mid=(low+high)/2;
            if(arr[mid]==target){
                ans[1]=mid;
                low=mid+1;;
            }else if(arr[mid]< target){
                low=mid+1;
            }else{
                high=mid-1;
            }
        }
        return ans;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">151. Reverse Words in a String</span>
Input: s = "the sky is blue"
Output: "blue is sky the"
Input: s = "  hello world  "
Output: "world hello"
Explanation: Your reversed string should not contain leading or trailing spaces.
class Solution {
    public String reverseWords(String s) {
        Stack<String> st=new Stack<>();
        String temp="";
        String ans="";
        for(int i=0;i< s.length();i++){
            if(s.charAt(i)==' '){
                if(temp.length()>0)
                    st.push(temp);
                temp="";
            }else{
                temp=temp+s.charAt(i);
            }
        }
            ans=ans+temp;
            while(!st.isEmpty()){
                ans=ans+" "+st.pop();
            }
            if(ans.length()!=0&&ans.charAt(0)==' ')
                ans=ans.substring(1);
        return ans;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">18. 4Sum</span>
Input: nums = [1,0,-1,0,-2,2], target = 0
Output: [[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]
Input: nums = [2,2,2,2,2], target = 8
Output: [[2,2,2,2]]
class Solution {
    public List<List<Integer>> fourSum(int[] nums, int target) {
         List<List<Integer>> ans = new ArrayList<>();
    if(nums.length< 4)
        return ans;
    Arrays.sort(nums);
    if(nums[0]>0 && target< 0)
        return ans;
    for(int i=0;i< nums.length;i++){
        
        while(i!=0 && i< nums.length && nums[i]==nums[i-1])
            ++i;
        for(int j=i+1;j< nums.length;j++){
            while(j< nums.length && j-1!=i && nums[j]==nums[j-1])
                ++j;
            
            int low = j+1;
            int high=nums.length-1;
            while(low< high){
                
                if(nums[i]+nums[j]+nums[low]+nums[high]==target){
                    List<Integer> list = new ArrayList<>();
                    list.add(nums[i]);
                    list.add(nums[j]);
                    list.add(nums[low]);
                    list.add(nums[high]);
                    ans.add(list);
                    while(low< high && nums[low]==nums[low+1])
                        ++low;
                    while(low< high && nums[high]==nums[high-1])
                        --high;
                    
                    ++low;
                    --high;
                }else if (nums[i]+nums[j]+nums[low]+nums[high]< target)
                    ++low;
                else
                    --high;
            }
        }
    }
        
    
    return ans;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">1457. Pseudo-Palindromic Paths in a Binary Tree</span>
Input: root = [2,3,1,3,1,null,1]
Output: 2 
Explanation: The figure above represents the given binary tree. There are three paths going from the root node to leaf nodes: the red path [2,3,3], the green path [2,1,1], and the path [2,3,1]. Among these paths only red path and green path are pseudo-palindromic paths since the red path [2,3,3] can be rearranged in [3,2,3] (palindrome) and the green path [2,1,1] can be rearranged in [1,2,1] (palindrome).
Input: root = [2,1,1,1,3,null,null,null,null,null,1]
Output: 1 
Explanation: The figure above represents the given binary tree. There are three paths going from the root node to leaf nodes: the green path [2,1,1], the path [2,1,3,1], and the path [2,1]. Among these paths only the green path is pseudo-palindromic since [2,1,1] can be rearranged in [1,2,1] (palindrome).
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    int ans = 0;
    public int pseudoPalindromicPaths (TreeNode root) {
        ans = 0;
        dfs(root, 0);
        return ans;
    }
    private void dfs(TreeNode root, int count) {
        if (root == null) return;
        count ^= 1 << (root.val - 1);
        dfs(root.left, count);
        dfs(root.right, count);
        if (root.left == null && root.right ==  null && (count & (count - 1)) == 0) ans++;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">990. Satisfiability of Equality Equations</span>
Input: equations = ["a==b","b!=a"]
Output: false
Explanation: If we assign say, a = 1 and b = 1, then the first equation is satisfied, but not the second.
There is no way to assign the variables to satisfy both equations.
Input: equations = ["b==a","a==b"]
Output: true
Explanation: We could assign a = 1 and b = 1 to satisfy both equations.
class Solution {
   
    int[] parent = new int[26]; // parent is the root of the tree
    int[] size = new int[26];  //size is used to make the tree degree lower
    public boolean equationsPossible(String[] equations) {
        for(int i = 0; i < 26; i++){ // make themselves their parents
            size[i] = 1;
            parent[i] = i;
        }
        for(String s: equations){  // if "a == b" connet the a, b
            if(s.charAt(1) == '='){
                int a = s.charAt(0) - 'a';
                int b = s.charAt(3) - 'a';
                connect(a, b);
            }
        }
        //if "a != b" check whether these two has been connected
        for(String s : equations){
            if(s.charAt(1) == '!'){
                int a = s.charAt(0) - 'a';
                int b = s.charAt(3) - 'a';
                if(checkConnection(a, b)) return false;
            }
        }
        return true;
    }
    public  void connect(int a, int b){
        int roota = findRoot(a);
        int rootb = findRoot(b);
        if(roota == rootb) return;
        if(size[roota] >= size[rootb]){
            parent[rootb] = roota;
            size[roota] += size[rootb];
        }else{
            parent[roota] = rootb;
            size[rootb] += size[roota];
        }
    }
    public  int findRoot(int a){
        while(parent[a] != a){
            parent[a] = parent[parent[a]];
            a = parent[a];
        }
        return a;
    }
    public  boolean checkConnection(int a, int b){
        int roota = findRoot(a);
        int rootb = findRoot(b);
        if(roota == rootb) return true;
        return false;
        
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">838. Push Dominoes</span>
Input: dominoes = "RR.L"
Output: "RR.L"
Explanation: The first domino expends no additional force on the second domino.
Input: dominoes = ".L.R...LR..L.."
Output: "LL.RR.LLRRLL.."
class Solution {
    public String pushDominoes(String dominoes) {
      StringBuilder sb = new StringBuilder(dominoes);
        
        int n = sb.length();
        
        
        //mark true for all the unpushed block, after pushing a bloch in right direction
        char prev = '.';
        boolean[] forward = new boolean[n];
        for(int i = 0; i < n; i++){
            char c = dominoes.charAt(i);
            if(c == '.'){
                if(prev == 'R') forward[i] = true; 
            }else{
                prev = c;
            }
        }
        
        //mark true for all the unpushed block, after pushing a block in left direction
        prev = '.';
        boolean[] backward  = new boolean[n];
        for(int i = n - 1; i >= 0; i--){
            char c = dominoes.charAt(i);
            if(c == '.'){
                if(prev == 'L') backward[i] = true; 
            }else{
                prev = c;
            }
        }
        
        int i = 0;
        while(i < n){
            if(backward[i] && !forward[i]){
                //fall block as there is force in left direction
                sb.setCharAt(i++, 'L');
                
            }else if(!backward[i] && forward[i]){
                //fall block as there is force in right direction
                sb.setCharAt(i++, 'R');
                
            }else if(backward[i] && forward[i]){
                //fall block as there is force in both  direction
                int j = (i + 1);
                while(j < n && backward[j] && forward[j]){
                    j++;
                }
                pushDominoesInBetween(sb, i, j - 1);
                i = j;
            }else{
                i++;
            }
            
        }
        
        return sb.toString();
    }
    
    
    private void pushDominoesInBetween(StringBuilder sb, int l, int r){
        while(l < r){
            sb.setCharAt(l++, 'R');
            sb.setCharAt(r--, 'L');
        }  
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">19. Remove Nth Node From End of List</span>
Input: head = [1,2,3,4,5], n = 2
Output: [1,2,3,5]
Input: head = [1,2], n = 1
Output: [1]
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        //find length of tge linked list
        int length=1;
        ListNode curr=head;
        while(curr.next!=null){
            curr=curr.next;
            length++;
        }

        ListNode temp=head;
        ListNode prev=null;
        for(int i=0;i< length-n;i++){
            prev=temp;
            temp=temp.next;
        }
        if(length-n==0){
            temp=temp.next;
            return temp;
        }
        else{
            prev.next=temp.next;
        }
        return head;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">1143. Longest Common Subsequence</span>
Input: text1 = "abcde", text2 = "ace" 
Output: 3  
Explanation: The longest common subsequence is "ace" and its length is 3.
Input: text1 = "abc", text2 = "abc"
Output: 3
Explanation: The longest common subsequence is "abc" and its length is 3.
Input: text1 = "abc", text2 = "def"
Output: 0
Explanation: There is no such common subsequence, so the result is 0.
class Solution {
    public int longestCommonSubsequence(String s, String p) {
        // DFS -> DFS + memo -> DP
        int[][] dp = new int[s.length()+1][p.length()+1];
        for(int[] row: dp) {
            Arrays.fill(row, -1);
        }
        return helper(s,p,0,0,dp);
    }
    
    private int helper(String s, String p, int i, int j, int[][] dp) {
        if(dp[i][j]!=-1){
            return dp[i][j];
        }
        int res = -1;
        if(i==s.length() || j==p.length()) {
            res = 0;
        } else {
            if(s.charAt(i)==p.charAt(j)) {
                res = helper(s,p,i+1,j+1,dp) + 1;
            } else {
                res = Math.max(helper(s,p,i+1,j,dp), helper(s,p,i,j+1,dp));
            }
        }
        
        dp[i][j] = res;
        return dp[i][j];
    }
}

  // int m = s.length();
  //       int n = p.length();
  //       int[][] dp = new int[m+1][n+1];
  //       for(int i=m-1;i>=0;i--) {
  //           for(int j=n-1;j>=0;j--) {
  //               if(s.charAt(i)==p.charAt(j)) {
  //                   dp[i][j] = dp[i+1][j+1] + 1;
  //               } else {
  //                   dp[i][j] = Math.max(dp[i+1][j], dp[i][j+1]);
  //               }
  //           }
  //       }
  //       return dp[0][0];
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">994. Rotting Oranges</span>
Input: grid = [[2,1,1],[1,1,0],[0,1,1]]
Output: 4
Input: grid = [[2,1,1],[0,1,1],[1,0,1]]
Output: -1
Explanation: The orange in the bottom left corner (row 2, column 0) is never rotten, because rotting only happens 4-directionally.
Input: grid = [[0,2]]
Output: 0
Explanation: Since there are already no fresh oranges at minute 0, the answer is just 0.
class Solution {
    public int orangesRotting(int[][] grid) {
          if(grid == null || grid.length == 0) return 0;
        int rows = grid.length;
        int cols = grid[0].length;
        Queue<int[]> queue = new LinkedList<>();
        int count_fresh = 0;
        //Put the position of all rotten oranges in queue
        //count the number of fresh oranges
        for(int i = 0 ; i < rows ; i++) {
            for(int j = 0 ; j < cols ; j++) {
                if(grid[i][j] == 2) {
                    queue.offer(new int[]{i , j});
                }
                else if(grid[i][j] == 1) {
                    count_fresh++;
                }
            }
        }
        //if count of fresh oranges is zero --> return 0 
        if(count_fresh == 0) return 0;
        int count = 0;
        int[][] dirs = {{1,0},{-1,0},{0,1},{0,-1}};
        //bfs starting from initially rotten oranges
        while(!queue.isEmpty()) {
            ++count;
            int size = queue.size();
            for(int i = 0 ; i < size ; i++) {
                int[] point = queue.poll();
                for(int dir[] : dirs) {
                    int x = point[0] + dir[0];
                    int y = point[1] + dir[1];
                    //if x or y is out of bound
                    //or the orange at (x , y) is already rotten
                    //or the cell at (x , y) is empty
                        //we do nothing
                    if(x < 0 || y < 0 || x >= rows || y >= cols || grid[x][y] == 0 || grid[x][y] == 2) continue;
                    //mark the orange at (x , y) as rotten
                    grid[x][y] = 2;
                    //put the new rotten orange at (x , y) in queue
                    queue.offer(new int[]{x , y});
                    //decrease the count of fresh oranges by 1
                    count_fresh--;
                }
            }
        }
        return count_fresh == 0 ? count-1 : -1;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">739. Daily Temperatures</span>
Input: temperatures = [73,74,75,71,69,72,76,73]
Output: [1,1,4,2,1,1,0,0]
Input: temperatures = [30,40,50,60]
Output: [1,1,1,0]
Input: temperatures = [30,60,90]
Output: [1,1,0]
class Solution {
    public int[] dailyTemperatures(int[] temp) {
           int n= temp.length;
        int[] ans = new int[n];
        Stack<Integer> st = new Stack<>();
        for(int i=n-1;i>=0;i--){
            while(!st.isEmpty() && temp[i]>=temp[st.peek()]){
                st.pop();
            }
            
            if(!st.isEmpty()){
                ans[i] = st.peek() - i;
            }
            st.push(i);
        }
        
        return ans; 
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">647. Palindromic Substrings</span>
Input: s = "abc"
Output: 3
Explanation: Three palindromic strings: "a", "b", "c".
Input: s = "aaa"
Output: 6
Explanation: Six palindromic strings: "a", "a", "a", "aa", "aa", "aaa".
class Solution {
    public int countSubstrings(String s) {
          int n = s.length();
        boolean dp[][] = new boolean[n][n];
        int count = 0;
        // 1 length strings
        for (int i = 0; i < n; i++) {
            count++;
            dp[i][i] = true;
        }
        
        // n = 10
        // len = 4
        // start = 0 to 6
        // end = 3 to 9
        
        for (int len = 2; len <= n; len++) {
            for (int start = 0; start <= n-len; start++) {
                int end = start+len-1;
                if (len == 2) {
                    if(s.charAt(start) == s.charAt(end)) {
                        count++;
                        dp[start][end] = true;
                    }
                } else {
                    if (s.charAt(start) == s.charAt(end) && dp[start+1][end-1]) {
                        count++;
                        dp[start][end] = true;
                    }
                }
            }
        }
        return count;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">658. Find K Closest Elements</span>
Input: arr = [1,2,3,4,5], k = 4, x = 3
Output: [1,2,3,4]
Input: arr = [1,2,3,4,5], k = 4, x = -1
Output: [1,2,3,4]
class Solution {
    public List<Integer> findClosestElements(int[] arr, int k, int x) {
        ArrayList<Integer> list=new ArrayList<>();
        PriorityQueue<pair> pq=new PriorityQueue<>(Collections.reverseOrder());
        for(int i=0;i< arr.length;i++){
            if(pq.size()< k){
                pq.add(new pair(arr[i],Math.abs(arr[i]-x)));
            }else{
                if(pq.peek().gap>Math.abs(arr[i]-x)){
                    pq.remove();
                    pq.add(new pair(arr[i],Math.abs(arr[i]-x)));
                }
            }
        }
            while(pq.size()>0){
                pair rem=pq.remove();
                list.add(rem.val);
            }
            Collections.sort(list);
                           return list;
    }
    ///////////
    class pair implements Comparable<pair>{
        int val;
        int gap;
        pair(){}
        pair(int val,int gap){
            this.val=val;
            this.gap=gap;
        }
        public int compareTo(pair o){
            if(this.gap==o.gap){
                return this.gap-o.val;
            }else{
                return this.gap-o.gap;
            }
        }
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">146. LRU Cache</span>
Input
["LRUCache", "put", "put", "get", "put", "get", "put", "get", "get", "get"]
[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]
Output
[null, null, null, 1, null, -1, null, -1, 3, 4]

Explanation
LRUCache lRUCache = new LRUCache(2);
lRUCache.put(1, 1); // cache is {1=1}
lRUCache.put(2, 2); // cache is {1=1, 2=2}
lRUCache.get(1);    // return 1
lRUCache.put(3, 3); // LRU key was 2, evicts key 2, cache is {1=1, 3=3}
lRUCache.get(2);    // returns -1 (not found)
lRUCache.put(4, 4); // LRU key was 1, evicts key 1, cache is {4=4, 3=3}
lRUCache.get(1);    // return -1 (not found)
lRUCache.get(3);    // return 3
lRUCache.get(4);    // return 4
import java.util.Hashtable;


public class LRUCache {

class DLinkedNode {
  int key;
  int value;
  DLinkedNode pre;
  DLinkedNode post;
}

/**
 * Always add the new node right after head;
 */
private void addNode(DLinkedNode node) {
    
  node.pre = head;
  node.post = head.post;

  head.post.pre = node;
  head.post = node;
}

/**
 * Remove an existing node from the linked list.
 */
private void removeNode(DLinkedNode node){
  DLinkedNode pre = node.pre;
  DLinkedNode post = node.post;

  pre.post = post;
  post.pre = pre;
}

/**
 * Move certain node in between to the head.
 */
private void moveToHead(DLinkedNode node){
  this.removeNode(node);
  this.addNode(node);
}

// pop the current tail. 
private DLinkedNode popTail(){
  DLinkedNode res = tail.pre;
  this.removeNode(res);
  return res;
}

private Hashtable< Integer, DLinkedNode> 
  cache = new Hashtable< Integer, DLinkedNode>();
private int count;
private int capacity;
private DLinkedNode head, tail;

public LRUCache(int capacity) {
  this.count = 0;
  this.capacity = capacity;

  head = new DLinkedNode();
  head.pre = null;

  tail = new DLinkedNode();
  tail.post = null;

  head.post = tail;
  tail.pre = head;
}

public int get(int key) {

  DLinkedNode node = cache.get(key);
  if(node == null){
    return -1; // should raise exception here.
  }

  // move the accessed node to the head;
  this.moveToHead(node);

  return node.value;
}


public void put(int key, int value) {
  DLinkedNode node = cache.get(key);

  if(node == null){

    DLinkedNode newNode = new DLinkedNode();
    newNode.key = key;
    newNode.value = value;

    this.cache.put(key, newNode);
    this.addNode(newNode);

    ++count;

    if(count > capacity){
      // pop the tail
      DLinkedNode tail = this.popTail();
      this.cache.remove(tail.key);
      --count;
    }
  }else{
    // update the value.
    node.value = value;
    this.moveToHead(node);
  }
}

}

/**
 * Your LRUCache object will be instantiated and called as such:
 * LRUCache obj = new LRUCache(capacity);
 * int param_1 = obj.get(key);
 * obj.put(key,value);
 */
 <span id="line">---------------------------------------------------------------</span>
 <span class="textStyle">148. Sort List</span>
Input: head = [4,2,1,3]
Output: [1,2,3,4]
Input: head = [-1,5,3,4,0]
Output: [-1,0,3,4,5]
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
   
    public ListNode sortList(ListNode head) {
       if (head == null || head.next == null)
      return head;
        
    // step 1. cut the list to two halves
    ListNode prev = null, slow = head, fast = head;
    
    while (fast != null && fast.next != null) {
      prev = slow;
      slow = slow.next;
      fast = fast.next.next;
    }
    
    prev.next = null;
    
    // step 2. sort each half
    ListNode l1 = sortList(head);
    ListNode l2 = sortList(slow);
    
    // step 3. merge l1 and l2
    return merge(l1, l2);
  }
  
  ListNode merge(ListNode l1, ListNode l2) {
    ListNode l = new ListNode(0), p = l;
    
    while (l1 != null && l2 != null) {
      if (l1.val < l2.val) {
        p.next = l1;
        l1 = l1.next;
      } else {
        p.next = l2;
        l2 = l2.next;
      }
      p = p.next;
    }
    
    if (l1 != null)
      p.next = l1;
    
    if (l2 != null)
      p.next = l2;
    
    return l.next;
}
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">105. Construct Binary Tree from Preorder and Inorder Traversal</span>
Input: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]
Output: [3,9,20,null,null,15,7]
Input: preorder = [-1], inorder = [-1]
Output: [-1]
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public TreeNode buildTree(int[] preorder, int[] inorder) {
    return helper(0, 0, inorder.length - 1, preorder, inorder);
}

public TreeNode helper(int preStart, int inStart, int inEnd, int[] preorder, int[] inorder) {
    if (preStart > preorder.length - 1 || inStart > inEnd) {
        return null;
    }
    TreeNode root = new TreeNode(preorder[preStart]);
    int inIndex = 0; // Index of current root in inorder
    for (int i = inStart; i <= inEnd; i++) {
        if (inorder[i] == root.val) {
            inIndex = i;
        }
    }
    root.left = helper(preStart + 1, inStart, inIndex - 1, preorder, inorder);
    root.right = helper(preStart + inIndex - inStart + 1, inIndex + 1, inEnd, preorder, inorder);
    return root;
}
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">103. Binary Tree Zigzag Level Order Traversal</span>
Input: root = [3,9,20,null,null,15,7]
Output: [[3],[20,9],[15,7]]
Input: root = [1]
Output: [[1]]
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public List<List<Integer>> zigzagLevelOrder(TreeNode root) 
    {
        List<List<Integer>> sol = new ArrayList<>();
        travel(root, sol, 0);
        return sol;
    }
    
    private void travel(TreeNode curr, List<List<Integer>> sol, int level)
    {
        if(curr == null) return;
        
        if(sol.size() <= level)
        {
            List<Integer> newLevel = new LinkedList<>();
            sol.add(newLevel);
        }
        
        List<Integer> collection  = sol.get(level);
        if(level % 2 == 0) collection.add(curr.val);
        else collection.add(0, curr.val);
        
        travel(curr.left, sol, level + 1);
        travel(curr.right, sol, level + 1);
        
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">102. Binary Tree Level Order Traversal</span>
Input: root = [3,9,20,null,null,15,7]
Output: [[3],[9,20],[15,7]]
Input: root = [1]
Output: [[1]]
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
   
       List<List<Integer>> ans = new ArrayList<>();
    public List<List<Integer>> levelOrder(TreeNode root) {
    
          levelorder( root, 0 );
        return ans;
        
    }
       public void levelorder(TreeNode root, int level){
           if (root == null) return;
           
           if (ans.size() < level+1)
               ans.add(new ArrayList<>());
           ans.get(level).add(root.val);
           
           levelorder(root.left, level+1);
           levelorder(root.right, level+1);
       }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">98. Validate Binary Search Tree</span>
Input: root = [2,1,3]
Output: true
Input: root = [5,1,4,null,null,3,6]
Output: false
Explanation: The root node's value is 5 but its right child's value is 4.
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    private boolean flag=true;
    TreeNode prev=null;
    public boolean isValidBST(TreeNode root) {
        inorder(root);
        return flag;
    }
    public void inorder(TreeNode root){
        if(root==null) return;
        
        inorder(root.left);
        
        if(prev!=null && root.val<=prev.val){
            flag=false;
            return;
        }
        prev=root;
        
        inorder(root.right);
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">91. Decode Ways</span>
Input: s = "12"
Output: 2
Explanation: "12" could be decoded as "AB" (1 2) or "L" (12).
Input: s = "226"
Output: 3
Explanation: "226" could be decoded as "BZ" (2 26), "VF" (22 6), or "BBF" (2 2 6).
class Solution {
    public int numDecodings(String s) {
        if(s.charAt(0)=='0')return 0;
       int[] dp=new int[s.length()];
        dp[0]=1;
        for(int i=1;i< dp.length;i++){
            if(s.charAt(i-1)=='0'&&s.charAt(i)=='0'){
               dp[i]=0; 
            }else if(s.charAt(i-1)=='0'&&s.charAt(i)!='0'){
                dp[i]=dp[i-1];
            }else if(s.charAt(i-1)!='0'&&s.charAt(i)=='0'){
                if(s.charAt(i-1)=='1'||s.charAt(i-1)=='2'){
                     dp[i]=(i>=2?dp[i-2]:1);
                }else{
                    dp[i]=0; 
                }
            }else{
                if(Integer.parseInt(s.substring(i-1,i+1))<=26){
                    dp[i]=dp[i-1]+(i>=2?dp[i-2]:1);
                }else{
                    dp[i]=dp[i-1];
                }
            } 
        }
        return dp[s.length()-1];
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">1155. Number of Dice Rolls With Target Sum</span>
Input: n = 1, k = 6, target = 3
Output: 1
Explanation: You throw one die with 6 faces.
There is only one way to get a sum of 3.
Input: n = 2, k = 6, target = 7
Output: 6
Explanation: You throw two dice, each with 6 faces.
There are 6 ways to get a sum of 7: 1+6, 2+5, 3+4, 4+3, 5+2, 6+1.
class Solution {
     static Integer[][]dp;
    static int MOD=(int) (1e9+7);
    public int numRollsToTarget(int n, int k, int target) {
        dp=new Integer[105][10005];
        return solver(n,k,target);
    }

	private int solver(int n, int k, int target) {
        // System.out.println(n+" "+target);
		if(n==0) {
			if(target==0)return 1;
			else return 0;
		}
        if(dp[n][target]!=null)return dp[n][target];
		int choose=0;
		for(int i=1;i<=k;i++) {
			if(i<=target)choose=(choose+(solver(n-1,k,target-i)))%MOD;
		}
		return dp[n][target]=choose%MOD;
	}
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">1578. Minimum Time to Make Rope Colorful</span>
Input: colors = "abaac", neededTime = [1,2,3,4,5]
Output: 3
Explanation: In the above image, 'a' is blue, 'b' is red, and 'c' is green.
Bob can remove the blue balloon at index 2. This takes 3 seconds.
There are no longer two consecutive balloons of the same color. Total time = 3.
Input: colors = "abc", neededTime = [1,2,3]
Output: 0
Explanation: The rope is already colorful. Bob does not need to remove any balloons from the rope.
class Solution {
    public int minCost(String colors, int[] neededTime) {
         int i=0;
        int ans=0;
        while(i< colors.length()) {
            long sum=0;
            int max=Integer.MIN_VALUE;
            while(i+1< colors.length() && colors.charAt(i+1)==colors.charAt(i)) {
                sum+=neededTime[i];
                max=Math.max(max, neededTime[i]);
                i++;
            }
            max=Math.max(max, neededTime[i]);
            sum+=neededTime[i];
            //debug 
            // System.out.println(max+" "+sum+"i="+i);
            sum-=max;
            ans+=sum;
            i++;
        }
        return ans;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">207. Course Schedule</span>
Input: numCourses = 2, prerequisites = [[1,0]]
Output: true
Explanation: There are a total of 2 courses to take. 
To take course 1 you should have finished course 0. So it is possible.
Input: numCourses = 2, prerequisites = [[1,0],[0,1]]
Output: false
Explanation: There are a total of 2 courses to take. 
To take course 1 you should have finished course 0, and to take course 0 you should also have finished course 1. So it is impossible.
class Solution {
    public boolean canFinish(int numCourses, int[][] prerequisites) {
        List<List<Integer>> graph = new ArrayList<>();
        for(int i = 0; i < numCourses; i++){
            graph.add(new ArrayList<Integer>());
        }
        for(int i = 0; i < prerequisites.length; i++){
            int course = prerequisites[i][0];
            int pre = prerequisites[i][1];
            graph.get(course).add(pre);
        }
        int[] visited = new int[numCourses];
        for(int i = 0; i < numCourses; i++){
            if(findCircle(i, graph, visited)){
                return false;
            }
        }
        return true;
    }
    public boolean findCircle(int cur, List<List<Integer>> graph, int[] visited){
        if(visited[cur] == 1){
            return true;
        }
        if(visited[cur] == 2){
            return false;
        }
        visited[cur] = 1;
        for(int next : graph.get(cur)){
            if(findCircle(next, graph, visited)){
                return true;
            }
        }
        visited[cur] = 2;
        return false;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">208. Implement Trie (Prefix Tree)</span>
Input
["Trie", "insert", "search", "search", "startsWith", "insert", "search"]
[[], ["apple"], ["apple"], ["app"], ["app"], ["app"], ["app"]]
Output
[null, null, true, false, true, null, true]

Explanation
Trie trie = new Trie();
trie.insert("apple");
trie.search("apple");   // return True
trie.search("app");     // return False
trie.startsWith("app"); // return True
trie.insert("app");
trie.search("app");     // return True
class Trie {
    
    TrieNode root = new TrieNode();

    public Trie() {
        
    }
    
    public void insert(String word) {
        TrieNode current = root;
        for(char ch : word.toCharArray()){
            if(!current.children.containsKey(ch)){
                current.children.put(ch, new TrieNode());
            }
            current = current.children.get(ch);
        }
        current.children.put('*', null);
    }
    
    public boolean search(String word) {
        TrieNode node = root;
        for(char ch : word.toCharArray()){
            if(!node.children.containsKey(ch)){
                return false;
            }
            node = node.children.get(ch);
        }
        return node.children.containsKey('*');
    }
    
    public boolean startsWith(String prefix) {
        TrieNode node = root;
        for(char ch : prefix.toCharArray()){
            if(!node.children.containsKey(ch)){
                return false;
            }
            node = node.children.get(ch);
        }
        return true;
    }
    
    static class TrieNode{
        Map< Character, TrieNode> children = new HashMap<>();
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">221. Maximal Square</span>
Input: matrix = [["1","0","1","0","0"],["1","0","1","1","1"],["1","1","1","1","1"],["1","0","0","1","0"]]
Output: 4
Input: matrix = [["0","1"],["1","0"]]
Output: 1
class Solution {
    public int maximalSquare(char[][] matrix) {
        int max_square_size = 0;
        int[][] int_matrix = new int[matrix.length][matrix[0].length];

        for (int i = 0; i < matrix.length; i++) {
            for (int j = 0; j < matrix[0].length; j++) {
                int_matrix[i][j] = matrix[i][j] == '1' ? 1 : 0;
                if (int_matrix[i][j] == 1) {
                    if ( i > 0 && j > 0 ) {
                        int min = int_matrix[i - 1][j - 1] < int_matrix[i - 1][j] ? int_matrix[i - 1][j - 1] : int_matrix[i - 1][j];
                        min = int_matrix[i][j - 1] < min ? int_matrix[i][j - 1] : min;
                        int_matrix[i][j] += min;
                    }
                    if ( max_square_size < int_matrix[i][j] ) {
                        max_square_size =  int_matrix[i][j];
                    }
                }
            }
        }

        return max_square_size * max_square_size;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">236. Lowest Common Ancestor of a Binary Tree</span>
Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
Output: 3
Explanation: The LCA of nodes 5 and 1 is 3.
Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4
Output: 5
Explanation: The LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself according to the LCA definition.
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        return ancestorHelper( root,  p, q);
    }
    
    
    TreeNode ancestorHelper(TreeNode root, TreeNode p, TreeNode q){
        if(root == null || root==p || root == q) return root;
         
        TreeNode leftFound = ancestorHelper(root.left, p, q);
        TreeNode rightFound = ancestorHelper(root.right, p, q);
        
       if(rightFound != null && leftFound != null)
            return root;
        if(leftFound != null)
        return leftFound;
         if(rightFound != null)
        return rightFound;
        
        return null;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">560. Subarray Sum Equals K</span>
Input: nums = [1,1,1], k = 2
Output: 2
Input: nums = [1,2,3], k = 3
Output: 2
class Solution {
    public int subarraySum(int[] nums, int k){
        HashMap<Integer,Integer> map=new HashMap<>();
        int sum=0;
        int count=0;
        map.put(sum,1);
        for(int i=0;i< nums.length;i++){
            sum+=nums[i];
            if(map.containsKey(sum-k)){
                count=count+map.get(sum-k);
            }
            if(map.containsKey(sum)){
                map.put(sum,map.get(sum)+1);
            }else{
                map.put(sum,1);
            }
        }
        return count;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">328. Odd Even Linked List</span>
Input: head = [1,2,3,4,5]
Output: [1,3,5,2,4]
Input: head = [2,1,3,5,6,4,7]
Output: [2,3,6,7,1,5,4]
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode oddEvenList(ListNode head) {
       if(head== null || head.next==null){
            return head;
        } 
    
        ListNode EvenList=new ListNode(-1);
        ListNode OddList=new  ListNode(-1);
        
        ListNode CurrEven=EvenList; 
        ListNode CurrOdd=OddList;
        
        ListNode curr=head;
        int i=1;
        while(curr!=null){
            
            if(i%2!=0){
                CurrOdd.next=curr;
                CurrOdd=curr;
                curr=curr.next;
             }
            else{
                CurrEven.next=curr;
                CurrEven=curr;
                curr=curr.next;
              }
            i++;
            }
         CurrOdd.next=EvenList.next;
         CurrEven.next=null;;
          return OddList.next;       
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">384. Shuffle an Array</span>
Input
["Solution", "shuffle", "reset", "shuffle"]
[[[1, 2, 3]], [], [], []]
Output
[null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]

Explanation
Solution solution = new Solution([1, 2, 3]);
solution.shuffle();    // Shuffle the array [1,2,3] and return its result.
                       // Any permutation of [1,2,3] must be equally likely to be returned.
                       // Example: return [3, 1, 2]
solution.reset();      // Resets the array back to its original configuration [1,2,3]. Return [1, 2, 3]
solution.shuffle();    // Returns the random shuffling of array [1,2,3]. Example: return [1, 3, 2]

public class Solution {
    private int[] nums;
    private Random random;

    public Solution(int[] nums) {
        this.nums = nums;
        random = new Random();
    }
    
    /** Resets the array to its original configuration and return it. */
    public int[] reset() {
        return nums;
    }
    
    /** Returns a random shuffling of the array. */
    public int[] shuffle() {
        if(nums == null) return null;
        int[] a = nums.clone();
        for(int j = 1; j < a.length; j++) {
            int i = random.nextInt(j + 1);
            swap(a, i, j);
        }
        return a;
    }
    
    private void swap(int[] a, int i, int j) {
        int t = a[i];
        a[i] = a[j];
        a[j] = t;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">210. Course Schedule II</span>
Input: numCourses = 2, prerequisites = [[1,0]]
Output: [0,1]
Explanation: There are a total of 2 courses to take. To take course 1 you should have finished course 0. So the correct course order is [0,1].
Input: numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]
Output: [0,2,1,3]
Explanation: There are a total of 4 courses to take. To take course 3 you should have finished both courses 1 and 2. Both courses 1 and 2 should be taken after you finished course 0.
So one correct course order is [0,1,2,3]. Another correct ordering is [0,2,1,3].
class Solution {
    public int[] findOrder(int numCourses, int[][] prerequisites) {
       // create adjacency list
		List<List<Integer>> adj = new ArrayList<>();

		for (int i = 0; i < numCourses; i++) {
			adj.add(new ArrayList<>());
		}

		for (int[] arr : prerequisites) {
			adj.get(arr[1]).add(arr[0]);
		}

		// create pre requisites for cycle detetction and topological sort
		// stack is used to store elements that appear in reverse order in the
		// topological sort
		// example == 1->2->3->4 , here 4 will be pushed first as we do DFS, reach the
		// end of DFS and then add element to stack
		// so we will get the topological sorted values in stack
		Stack<Integer> st = new Stack<>();
		boolean visited[] = new boolean[numCourses];
		boolean recstack[] = new boolean[numCourses];

		// run the code for cycle detection
		for (int i = 0; i < adj.size(); i++) {
			if (visited[i] == false) {
				if (isCycle(visited, recstack, adj, i, st))
					return new int[] {}; // if cycle present return empty array
			}
		}

		// else convert stack to int []
		Collections.reverse(st);
		List<Integer> ls = new ArrayList<>(st);
		int[] example1 = ls.stream().mapToInt(i -> i).toArray();
		return example1;
	}

	// simple directed graph cycle detection
	boolean isCycle(boolean[] visited, boolean[] recstack, List<List<Integer>> adj, int v, Stack<Integer> st) {

		visited[v] = true;
		recstack[v] = true;
		for (int i : adj.get(v)) {

			if (visited[i] == false) {
				if (isCycle(visited, recstack, adj, i, st))
					return true;
			} else if (recstack[i])
				return true;

		}

		recstack[v] = false;
		// here we add element to stack only after all its descendents are added, giving
		// topological sorting
		st.add(v);
		return false; 
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">142. Linked List Cycle II</span>
Input: head = [3,2,0,-4], pos = 1
Output: tail connects to node index 1
Explanation: There is a cycle in the linked list, where tail connects to the second node.
Input: head = [1,2], pos = 0
Output: tail connects to node index 0
Explanation: There is a cycle in the linked list, where tail connects to the first node.
/**
 * Definition for singly-linked list.
 * class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    public ListNode detectCycle(ListNode head) {
        ListNode fast=head;
        ListNode slow=head;
        int l=0;
    //Calculating size of cycle
        while(fast!=null && fast.next!=null){
            fast=fast.next.next;
            slow=slow.next;
            
            if(fast==slow){
                ListNode temp=slow;
                do{
                    l++;
                    temp=temp.next;
                }while(temp!=slow);
                break;
            }
        }
        
        if(l==0){
            return null;
        }
       slow=head;
        for(int i=0;i< l;i++){
            slow=slow.next;
        }
        
        while(head!=slow){
            head=head.next;
            slow=slow.next;
        }
        return head; 
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">623. Add One Row to Tree</span>
Input: root = [4,2,6,3,1,5], val = 1, depth = 2
Output: [4,1,1,2,null,null,6,3,1,5]
Input: root = [4,2,null,3,1], val = 1, depth = 3
Output: [4,2,null,1,1,3,null,null,1]
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public TreeNode addOneRow(TreeNode root, int val, int depth) {
      // Base case 4
        if(depth == 1)
        {
            TreeNode node = createNode(val);
            node.left = root;
            return node;
        }
        // go for left sub tree.
        func(root.left,root,true,val,depth,1);
        // go for right sub tree.
        func(root.right,root,false,val,depth,1);
        return root;
    }
    
    private void func(TreeNode currentNode,TreeNode parentNode, boolean left ,int val, int maxDepth, int currentDepth) {
        // Base case 1
        if(currentDepth ==  maxDepth-1) {
          TreeNode node = createNode(val);
            // Base case 2
          if(left) {
              node.left = parentNode.left;
              parentNode.left = node;
          }else {
              // Base case 3
              node.right = parentNode.right;
              parentNode.right = node;
          }
          return;
      }
        //Base case
        if(currentNode == null){
              return;
          }
        // Left sub tree
      func(currentNode.left,currentNode,true,val,maxDepth,currentDepth+1);
        // right sub tree
      func(currentNode.right,currentNode,false,val,maxDepth,currentDepth+1);
    }
    
    private TreeNode createNode(int val) {
        return new TreeNode(val);
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">97. Interleaving String</span>
Input: s1 = "aabcc", s2 = "dbbca", s3 = "aadbbcbcac"
Output: true
Explanation: One way to obtain s3 is:
Split s1 into s1 = "aa" + "bc" + "c", and s2 into s2 = "dbbc" + "a".
Interleaving the two splits, we get "aa" + "dbbc" + "bc" + "a" + "c" = "aadbbcbcac".
Since s3 can be obtained by interleaving s1 and s2, we return true.
Input: s1 = "aabcc", s2 = "dbbca", s3 = "aadbbbaccc"
Output: false
Explanation: Notice how it is impossible to interleave s2 with any other string to obtain s3.
class Solution {
    private boolean[][] invalid;
    private char[] c1;
    private char[] c2;
    private char[] c3;
    public boolean isInterleave(String s1, String s2, String s3) {
        c1 = s1.toCharArray();
        c2 = s2.toCharArray();
        c3 = s3.toCharArray();
        int m = s1.length(),n=s2.length();
        if(m+n != s3.length())
            return false;
        invalid = new boolean[m+1][n+1];
        return dfs(0,0,0);
    }
    
    public boolean dfs(int i, int j, int k){
        if(invalid[i][j])
            return false;
        
        if(k == c3.length)
            return true;
        
        boolean valid = 
            i< c1.length && c1[i] == c3[k] && dfs(i+1,j,k+1) || 
            j< c2.length && c2[j] == c3[k] && dfs(i,j+1,k+1);
        
        if(!valid)
            invalid[i][j] = true;
        
        return valid;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">99. Recover Binary Search Tree</span>
Input: root = [1,3,null,null,2]
Output: [3,1,null,null,2]
Explanation: 3 cannot be a left child of 1 because 3 > 1. Swapping 1 and 3 makes the BST valid.
Input: root = [3,1,4,null,null,2]
Output: [2,1,4,null,null,3]
Explanation: 2 cannot be in the right subtree of 3 because 2 < 3. Swapping 2 and 3 makes the BST valid.
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    TreeNode prev = null, first = null, second = null;
    public void recoverTree(TreeNode root) {
        correctBST(root);
        int temp = first.val;
        first.val = second.val;
        second.val = temp;
    }
    public void correctBST(TreeNode root){
        if(root == null) return;
        correctBST(root.left);
        if(prev != null && root.val < prev.val){
            if(first == null) first = prev;
            second = root;
        }
        prev = root;
        correctBST(root.right);    
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">319. Bulb Switcher</span>
Input: n = 3
Output: 1
Explanation: At first, the three bulbs are [off, off, off].
After the first round, the three bulbs are [on, on, on].
After the second round, the three bulbs are [on, off, on].
After the third round, the three bulbs are [on, off, off]. 
So you should return 1 because there is only one bulb is on.
Input: n = 1
Output: 1
Input: n = 0
Output: 0
class Solution {
    public int bulbSwitch(int n) {
          if(n==0)
            return 0;
        double sq=Math.sqrt(n);
        double floor=Math.floor(sq);
        
        return (int)floor;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">318. Maximum Product of Word Lengths</span>
Input: words = ["abcw","baz","foo","bar","xtfn","abcdef"]
Output: 16
Explanation: The two words can be "abcw", "xtfn".
Input: words = ["a","ab","abc","d","cd","bcd","abcd"]
Output: 4
Explanation: The two words can be "ab", "cd".
Input: words = ["a","aa","aaa","aaaa"]
Output: 0
Explanation: No such pair of words.
class Solution {
    public int maxProduct(String[] words) {
       int n = words.length;
        List<Set<Character>> lst = new ArrayList(n);
        int max = 0;

        for(String word : words) {	
            Set<Character> set = new HashSet();
            lst.add(set);
            for(int i=0; i< word.length(); i++) {
                set.add( word.charAt(i) );
            }
        }

        for(int i=0; i< n; i++) {
            Set< Character> setI = lst.get(i);
            for(int j=i+1; j< n; j++) {
                boolean hasCommon = false;
                Set< Character> setJ = lst.get(j);
                for(Character c : setI) {
                    if( setJ.contains(c) ) {
                        hasCommon = true;
                        break;
                    }
                }

                if( !hasCommon ) 
                    max = Math.max(max, words[i].length()*words[j].length());	
            }
        }
        return max;  
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">981. Time Based Key-Value Store</span>
Input
["TimeMap", "set", "get", "get", "set", "get", "get"]
[[], ["foo", "bar", 1], ["foo", 1], ["foo", 3], ["foo", "bar2", 4], ["foo", 4], ["foo", 5]]
Output
[null, null, "bar", "bar", null, "bar2", "bar2"]

Explanation
TimeMap timeMap = new TimeMap();
timeMap.set("foo", "bar", 1);  // store the key "foo" and value "bar" along with timestamp = 1.
timeMap.get("foo", 1);         // return "bar"
timeMap.get("foo", 3);         // return "bar", since there is no value corresponding to foo at timestamp 3 and timestamp 2, then the only value is at timestamp 1 is "bar".
timeMap.set("foo", "bar2", 4); // store the key "foo" and value "bar2" along with timestamp = 4.
timeMap.get("foo", 4);         // return "bar2"
timeMap.get("foo", 5);         // return "bar2"
class TimeMap {
//brute force method
Map<String,String> map;
public TimeMap() {
map=new HashMap<>();
}

public void set(String key, String value, int timestamp) {
    String x=key+" "+timestamp;
    map.put(x,value);
}

public String get(String key, int timestamp) {
   
    String x=key+" "+timestamp;
    String ret="";
    while(timestamp>0)
    {   x=key+" "+timestamp;
        if(map.containsKey(x))
        {
            
            return map.get(x);
        }
        timestamp--;
    }
    return ret;
        
    }
}

/**
 * Your TimeMap object will be instantiated and called as such:
 * TimeMap obj = new TimeMap();
 * obj.set(key,value,timestamp);
 * String param_2 = obj.get(key,timestamp);
 */
 <span id="line">---------------------------------------------------------------</span>
 <span class="textStyle">2134. Minimum Swaps to Group All 1's Together II</span>
Input: nums = [0,1,0,1,1,0,0]
Output: 1
Explanation: Here are a few of the ways to group all the 1's together:
[0,0,1,1,1,0,0] using 1 swap.
[0,1,1,1,0,0,0] using 1 swap.
[1,1,0,0,0,0,1] using 2 swaps (using the circular property of the array).
There is no way to group all 1's together with 0 swaps.
Thus, the minimum number of swaps required is 1.
Input: nums = [0,1,1,1,0,0,1,1,0]
Output: 2
Explanation: Here are a few of the ways to group all the 1's together:
[1,1,1,0,0,0,0,1,1] using 2 swaps (using the circular property of the array).
[1,1,1,1,1,0,0,0,0] using 2 swaps.
There is no way to group all 1's together with 0 or 1 swaps.
Thus, the minimum number of swaps required is 2.
class Solution {
    public int minSwaps(int[] nums) {
        int len = nums.length;
		int totalOne = 0;

		for (int i = 0; i < len; i++) {
			if (nums[i] == 1)
				totalOne++;
		}
		if (len == totalOne || totalOne == 0)
			return 0;
		int min = Integer.MAX_VALUE;
		int i = 0;
		int count = 0;
		for (int k = i; k < totalOne; k++) {
			if (nums[k] == 0)
				count++;
		}
		min = Math.min(min, count);
		i++;
		for (; i < len; i++) {
			int j = (i + totalOne - 1) % len;
			if (nums[j] == 0 && nums[i - 1] == 1)
				count++;
			else if (nums[j] == 1 && nums[i - 1] == 0)
				count--;
			min = Math.min(min, count);
		}
		return min;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">2149. Rearrange Array Elements by Sign</span>
Input: nums = [3,1,-2,-5,2,-4]
Output: [3,-2,1,-5,2,-4]
Explanation:
The positive integers in nums are [3,1,2]. The negative integers are [-2,-5,-4].
The only possible way to rearrange them such that they satisfy all conditions is [3,-2,1,-5,2,-4].
Other ways such as [1,-2,2,-5,3,-4], [3,1,2,-2,-5,-4], [-2,3,-5,1,-4,2] are incorrect because they do not satisfy one or more conditions. 
Input: nums = [-1,1]
Output: [1,-1]
Explanation:
1 is the only positive integer and -1 the only negative integer in nums.
So nums is rearranged to [1,-1].
class Solution {
    public int[] rearrangeArray(int[] nums) {
         int e=0,o=1;
        int[] ans = new int[nums.length];
        
        for(int i = 0;i< nums.length;i++)
        {
            if(nums[i] >0)
            {
                ans[e] = nums[i];
                e = e+2;
            }
            else
            {
                ans[o] = nums[i];
                o=o+2;
            }
        }
        
        return ans;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">2161. Partition Array According to Given Pivot</span>
Input: nums = [9,12,5,10,14,3,10], pivot = 10
Output: [9,5,3,10,10,12,14]
Explanation: 
The elements 9, 5, and 3 are less than the pivot so they are on the left side of the array.
The elements 12 and 14 are greater than the pivot so they are on the right side of the array.
The relative ordering of the elements less than and greater than pivot is also maintained. [9, 5, 3] and [12, 14] are the respective orderings.
Input: nums = [-3,4,3,2], pivot = 2
Output: [-3,2,4,3]
Explanation: 
The element -3 is less than the pivot so it is on the left side of the array.
The elements 4 and 3 are greater than the pivot so they are on the right side of the array.
The relative ordering of the elements less than and greater than pivot is also maintained. [-3] and [4, 3] are the respective orderings.
class Solution {
    public int[] pivotArray(int[] nums, int pivot) {
       int [] res = new int[nums.length];
		int left=0, right=nums.length-1;
		for(int i=0; i< nums.length; ++i){
			if(nums[i]< pivot)
				res[left++]=nums[i];
			if(nums[nums.length-i-1]>pivot){
				res[right--]=nums[nums.length-i-1];
			}
		}
		while(left <= right){
			res[left++]=pivot;
		}
		return res; 
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">2244. Minimum Rounds to Complete All Tasks</span>
Input: tasks = [2,2,3,3,2,4,4,4,4,4]
Output: 4
Explanation: To complete all the tasks, a possible plan is:
- In the first round, you complete 3 tasks of difficulty level 2. 
- In the second round, you complete 2 tasks of difficulty level 3. 
- In the third round, you complete 3 tasks of difficulty level 4. 
- In the fourth round, you complete 2 tasks of difficulty level 4.  
It can be shown that all the tasks cannot be completed in fewer than 4 rounds, so the answer is 4.
Input: tasks = [2,3,3]
Output: -1
Explanation: There is only 1 task of difficulty level 2, but in each round, you can only complete either 2 or 3 tasks of the same difficulty level. Hence, you cannot complete all the tasks, and the answer is -1.
class Solution {
    public int minimumRounds(int[] tasks) {
         HashMap<Integer, Integer> map = new HashMap<>();
        for(int task: tasks) {
            map.put(task, map.getOrDefault(task, 0) + 1);
        }
        int rounds = 0;
        for(int key: map.keySet()) {
            int count = map.get(key);
            if(count < 2) return -1;
            if(count < 3) {
                rounds += 1;
            } else {
                if(count % 3 == 0) {
                    rounds += (count / 3);
                } else {
                    rounds += (count / 3) + 1;
                }
            }
        }
        return rounds;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">2256. Minimum Average Difference</span>
Input: nums = [2,5,3,9,5,3]
Output: 3
Explanation:
- The average difference of index 0 is: |2 / 1 - (5 + 3 + 9 + 5 + 3) / 5| = |2 / 1 - 25 / 5| = |2 - 5| = 3.
- The average difference of index 1 is: |(2 + 5) / 2 - (3 + 9 + 5 + 3) / 4| = |7 / 2 - 20 / 4| = |3 - 5| = 2.
- The average difference of index 2 is: |(2 + 5 + 3) / 3 - (9 + 5 + 3) / 3| = |10 / 3 - 17 / 3| = |3 - 5| = 2.
- The average difference of index 3 is: |(2 + 5 + 3 + 9) / 4 - (5 + 3) / 2| = |19 / 4 - 8 / 2| = |4 - 4| = 0.
- The average difference of index 4 is: |(2 + 5 + 3 + 9 + 5) / 5 - 3 / 1| = |24 / 5 - 3 / 1| = |4 - 3| = 1.
- The average difference of index 5 is: |(2 + 5 + 3 + 9 + 5 + 3) / 6 - 0| = |27 / 6 - 0| = |4 - 0| = 4.
The average difference of index 3 is the minimum average difference so return 3.
Input: nums = [0]
Output: 0
Explanation:
The only index is 0 so return 0.
The average difference of index 0 is: |0 / 1 - 0| = |0 - 0| = 0.
class Solution {
    public int minimumAverageDifference(int[] nums) {
        int n = nums.length;
        long[] res = new long[n];
        long postSum=0;
        long preSum =0;

        for(int a:nums){
            postSum +=a;
        }
        long sum = postSum;
        for(int i=0;i< n-1;i++){
            postSum -=nums[i];
            preSum  +=nums[i];
        
            long a = postSum/(n-i-1);
            long b = preSum/(i+1);
            res[i] = (long)Math.abs(a-b);
        }
        res[n-1] = (long)sum/n;
        int index=-1;
        long min = Long.MAX_VALUE;
        for(int i=0;i< n;i++){
            if(res[i]< min){
                min = res[i];
                index=i;
            }
        }
        return index; 
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">638. Shopping Offers</span>
Input: price = [2,5], special = [[3,0,5],[1,2,10]], needs = [3,2]
Output: 14
Explanation: There are two kinds of items, A and B. Their prices are $2 and $5 respectively. 
In special offer 1, you can pay $5 for 3A and 0B
In special offer 2, you can pay $10 for 1A and 2B. 
You need to buy 3A and 2B, so you may pay $10 for 1A and 2B (special offer #2), and $4 for 2A.
Input: price = [2,3,4], special = [[1,1,0,4],[2,2,1,9]], needs = [1,2,1]
Output: 11
Explanation: The price of A is $2, and $3 for B, $4 for C. 
You may pay $4 for 1A and 1B, and $9 for 2A ,2B and 1C. 
You need to buy 1A ,2B and 1C, so you may pay $4 for 1A and 1B (special offer #1), 
and $3 for 1B, $4 for 1C. 
You cannot add more items, though only $9 for 2A ,2B and 1C.
/*
1. We can see this problem as a graph traversal problem. 
2. Graph representation: 
	** vertex: `needs` array.  In example1:  [3, 2], number of items need to buy
	** neighbors:  
			- Not using special offer, buy directly  [0, 0]
			- Using special offer:  [0, 2] and [2, 0]
3. What we need to do in this graph
		- we need to find a path from [3, 2] to [0, 0] which has the smallest cost
		- so this is a all paths problem, we can use dfs backtracking.
	** what is the base case: when we reach the  vertex [0, 0]
	** what we need to return: the smallest cost we can get when starting from vertex [a, b]
	** in the meantime, we can use memorization to record the result we already know to 
	avoid duplicated computation
4. Time Complexity: 
	- We can think of the corresponding recursion tree.
	- Braching factor: the number of valid special offers + 1 (buy directly)
	- Height of tree: the largetest number of special offers we can use
	- O(branching factor ^ height of tree)
5. Space Complexity:
	- O(height of tree)
	*/
class Solution {
    public int shoppingOffers(List<Integer> price, List<List<Integer>> special, List<Integer> 
	needs) {
        if (price == null || price.size() == 0 || needs == null || needs.size() == 0) {
            return 0;
        }
        
        int[] min = new int[]{Integer.MAX_VALUE};
        Map<List<Integer>, Integer> memo = new HashMap<>();
        int res= dfs(needs, price, special, memo);
        return res;
    }
    
    private int dfs(List<Integer> needs, List<Integer> price, List<List<Integer>> special, 
					Map<List<Integer>, Integer> memo) {
        if (memo.containsKey(needs)) {
            return memo.get(needs);
        }
        if (allZero(needs)) {  
            return 0;
        }
        int min = Integer.MAX_VALUE;
        // not using special offer, buy directly
        int total1 = 0;
        for (int i = 0; i < needs.size(); i++) {
            total1 += needs.get(i) * price.get(i);
        }
        min = Math.min(total1, min);
        // buy special offer
        int total2 = Integer.MAX_VALUE;
        for (int i = 0; i < special.size(); i++) {
            List<Integer> offer = special.get(i);
            int val = offer.get(offer.size()-1);
            boolean valid = true;
            for (int j = 0; j < offer.size()-1; j++) {
                if (needs.get(j) < offer.get(j)) {
                    valid = false;
                }
            }
            if (valid) {
                for (int j = 0; j < offer.size()-1; j++) {
                    int pre = needs.get(j);
                    needs.set(j, pre - offer.get(j));
                }
                total2 = val + dfs(needs, price, special, memo);
                for (int j = 0; j < offer.size()-1; j++) {
                    int pre = needs.get(j);
                    needs.set(j, pre + offer.get(j));
                }
                min = Math.min(total2, min);
            }
        }
        if (!memo.containsKey(needs)) {
            memo.put(needs, min);
        }
        return min;
    }
    
    private boolean allZero(List<Integer> list) {
        for (int i = 0; i < list.size(); i++) {
            if (list.get(i) < 0 || list.get(i) > 0) {
                return false;
            }
        }
        return true;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">652. Find Duplicate Subtrees</span>
Input: root = [1,2,3,4,null,2,4,null,null,4]
Output: [[2,4],[4]]
Input: root = [2,1,1]
Output: [[1]]
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public List<TreeNode> findDuplicateSubtrees(TreeNode root) {
    List<TreeNode> res = new LinkedList<>();
    postorder(root, new HashMap<>(), res);
    return res;
}

public String postorder(TreeNode cur, Map<String, Integer> map, List<TreeNode> res) {
    if (cur == null) return "#";  
    String serial = cur.val + "," + postorder(cur.left, map, res) + "," 
					+ postorder(cur.right, map, res);
    map.put(serial, map.getOrDefault(serial, 0) + 1);
    if (map.get(serial) == 2) res.add(cur);
    return serial;
}
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">2 Keys Keyboard</span>
Input: n = 3
Output: 3
Explanation: Initially, we have one character 'A'.
In step 1, we use Copy All operation.
In step 2, we use Paste operation to get 'AA'.
In step 3, we use Paste operation to get 'AAA'.
Input: n = 1
Output: 0
class Solution {
    public int minSteps(int n) {
       int[] dp = new int[n+1];
        for (int i = 2; i <= n; i++) {
            dp[i] = i;
            for (int j = i-1; j > 1; j--) {
                if (i % j == 0) {
                    dp[i] = dp[j] + (i/j);
                    break;
                }  
            }
        }
        return dp[n]; 
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Maximum Length of Pair Chain</span>
Input: pairs = [[1,2],[2,3],[3,4]]
Output: 2
Explanation: The longest chain is [1,2] -> [3,4].
Input: pairs = [[1,2],[7,8],[4,5]]
Output: 3
Explanation: The longest chain is [1,2] -> [4,5] -> [7,8].
class Solution {
    public int findLongestChain(int[][] pairs) {
        Arrays.sort(pairs, (a,b) -> a[1] - b[1]);
        int count = 0, i = 0, n = pairs.length;
        while (i < n) {
            count++;
            int curEnd = pairs[i][1];
            while (i < n && pairs[i][0] <= curEnd) i++;
        }
    return count; 
    }
}

<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Delete Operation for Two Strings</span>
Input: word1 = "sea", word2 = "eat"
Output: 2
Explanation: You need one step to make "sea" to "ea" and another step to make "eat" to "ea".
Input: word1 = "leetcode", word2 = "etco"
Output: 4
class Solution {
   public int minDistance(String word1, String word2) {
        int m = word1.length();
        int n = word2.length();
        int[][] dp = new int[m+1][n+1];
        for(int[] d: dp) Arrays.fill(d,-1);
        int lcs = LCS(word1,word2,m,n,dp);
        return m+n-(2*lcs);
    }
    private static int LCS(String s1,String s2,int m,int n,int[][] dp){
        if(n==0 || m==0) return 0;
        if(dp[m][n] != -1) return dp[m][n];
		
        if(s1.charAt(m-1) == s2.charAt(n-1))
            return dp[m][n] = 1+LCS(s1,s2,m-1,n-1,dp);
        else
            return dp[m][n] = Math.max(LCS(s1,s2,m-1,n,dp),LCS(s1,s2,m,n-1,dp));
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">576. Out of Boundary Paths</span>
Input: m = 2, n = 2, maxMove = 2, startRow = 0, startColumn = 0
Output: 6
Input: m = 1, n = 3, maxMove = 3, startRow = 0, startColumn = 1
Output: 12
class Solution {
    Integer[][][] memo;
    int m, n;
    int[] DIR = new int[]{0, 1, 0, -1, 0};
    public int findPaths(int m, int n, int maxMove, int startRow, int startColumn) {
        memo = new Integer[m][n][maxMove+1];
        this.m = m; this.n = n;
        return dp(startRow, startColumn, maxMove);
    }
    int dp(int r, int c, int maxMove) {
        if (r < 0 || r == m || c < 0 || c == n) return 1; 
        // Out of bound -> Count 1 way
        if (memo[r][c][maxMove] != null) return memo[r][c][maxMove];
        if (maxMove == 0) return 0;
        int ans = 0;
        for (int i = 0; i < 4; ++i) {
            ans = (ans + dp(r + DIR[i], c + DIR[i + 1], maxMove - 1)) % 1_000_000_007;
        }
        return memo[r][c][maxMove] = ans;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Continuous Subarray Sum</span>
Input: nums = [23,2,4,6,7], k = 6
Output: true
Explanation: [2, 4] is a continuous subarray of size 2 whose elements sum up to 6.
Input: nums = [23,2,6,4,7], k = 6
Output: true
Explanation: [23, 2, 6, 4, 7] is an continuous subarray of size 5 whose elements sum up to 42.
42 is a multiple of 6 because 42 = 7 * 6 and 7 is an integer.
class Solution {
    public boolean checkSubarraySum(int[] nums, int k) {
        Set<Integer> modSet=new HashSet();
        int currSum = 0, prevSum=0; 
		//when we add prevSum=0 in set it will actually check if currSum is divided by k 
        for(int n : nums) {
            currSum += n;
            if(modSet.contains(currSum%k)) {
                return true;
            }
            currSum %=k;
            modSet.add(prevSum);
            prevSum = currSum;
        }
        return false;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Total Hamming Distance</span>
Input: nums = [4,14,2]
Output: 6
Explanation: In binary representation, the 4 is 0100, 14 is 1110, and 2 is 0010 (just
showing the four bits relevant in this case).
The answer will be:
HammingDistance(4, 14) + HammingDistance(4, 2) + HammingDistance(14, 2) = 2 + 2 + 2 = 6.
Input: nums = [4,14,4]
Output: 4
class Solution {
    public int totalHammingDistance(int[] nums) {
        int total = 0, n = nums.length;
        for (int j=0;j< 32;j++) {
            int bitCount = 0;
            for (int i=0;i< n;i++) 
                bitCount += (nums[i] >> j) & 1;
                total += bitCount*(n - bitCount);
        }
    return total; 
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Heaters</span>
Input: houses = [1,2,3], heaters = [2]
Output: 1
Explanation: The only heater was placed in the position 2, 
and if we use the radius 1 standard, then all the houses can be warmed.
Input: houses = [1,2,3,4], heaters = [1,4]
Output: 1
Explanation: The two heater was placed in the position 1 and 4. 
We need to use radius 1 standard, then all the houses can be warmed.
class Solution {
    public int findRadius(int[] houses, int[] heaters) {
        Arrays.sort(heaters);
        int result = Integer.MIN_VALUE;
        
        for (int house : houses) {
            int index = Arrays.binarySearch(heaters, house);
            if (index < 0) {
        	index = -(index + 1);
            }
            int dist1 = index - 1 >= 0 ? house - heaters[index - 1] : Integer.MAX_VALUE;
            int dist2 = index < heaters.length ? heaters[index] - house : Integer.MAX_VALUE;
        
            result = Math.max(result, Math.min(dist1, dist2));
        }
        
        return result;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">436. Find Right Interval</span>
Input: intervals = [[1,2]]
Output: [-1]
Explanation: There is only one interval in the collection, so it outputs -1.
Input: intervals = [[3,4],[2,3],[1,2]]
Output: [-1,0,1]
Explanation: There is no right interval for [3,4].
The right interval for [2,3] is [3,4] since start0 = 3 is the 
smallest start that is >= end1 = 3.
The right interval for [1,2] is [2,3] since start1 = 2 is the s
mallest start that is >= end2 = 2.
Input: intervals = [[1,4],[2,3],[3,4]]
Output: [-1,2,-1]
Explanation: There is no right interval for [1,4] and [3,4].
The right interval for [2,3] is [3,4] since start2 = 3 is the 
smallest start that is >= end1 = 3.
class Solution {
    public int[] findRightInterval(int[][] intervals) {
        HashMap<Integer, Integer> map = new HashMap<>();
        int m = intervals.length;
        int n = intervals[0].length;
        int[] sp = new int[m];                  //array of starting points
        
        for(int i = 0; i < m; i++) {
            sp[i] = intervals[i][0];            
            map.put(sp[i], i);                  //(key=start_point, val=index)
        }
        
        Arrays.sort(sp);                        //sort array of starting points
        int[] result = new int[m];
        
        for(int i = 0; i < m; i++) {
            int l = 0, r = m - 1;
            boolean found = false;              //to see if result was found
            int min = -1;
            int ep = intervals[i][n - 1];       //ep = endpoint
            while(l <= r) {                     //binarySearch on arr of start points
                int mid = (l + ((r - l) / 2));
                if(sp[mid] >= ep) {
                    min = sp[mid];              
                    found = true;               
                    r = mid - 1;
                }
                else {
                    l = mid + 1;
                }
            }
            result[i] = found ? map.get(min) : -1;
        }
        return result; 
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">373. Find K Pairs with Smallest Sums</span>
Input: nums1 = [1,7,11], nums2 = [2,4,6], k = 3
Output: [[1,2],[1,4],[1,6]]
Explanation: The first 3 pairs are returned from the sequence: 
[1,2],[1,4],[1,6],[7,2],[7,4],[11,2],[7,6],[11,4],[11,6]
Input: nums1 = [1,1,2], nums2 = [1,2,3], k = 2
Output: [[1,1],[1,1]]
Explanation: The first 2 pairs are returned from the sequence: 
[1,1],[1,1],[1,2],[2,1],[1,2],[2,2],[1,3],[1,3],[2,3]
class Solution {
    public List<List<Integer>> kSmallestPairs(int[] nums1, int[] nums2, int k) {
       //In the minHeap array, 0th element refers to the curr 
	   element in nums1 and 1st element refers to curr element in nums2 
        PriorityQueue<int[]> minHeap = new 
									PriorityQueue<>((a,b) -> (a[0] + a[1]) - (b[0] + b[1]));
        
		// The 2nd element in the minHeap is the index of nums2, 
		the corresponding element of nums2 is in index1 of minHeap
        for(int i=0; i < nums1.length && i < k; i++)
            minHeap.add(new int[]{nums1[i], nums2[0], 0});
        
        List<List<Integer>> result = new ArrayList<>();
        
        for(int i=0; i < k && !minHeap.isEmpty(); i++){
            int[] curr = minHeap.poll();
            result.add(List.of(curr[0], curr[1]));
            int nums2Idx = curr[2];
            if(nums2Idx < nums2.length - 1)
                minHeap.add(new int[]{curr[0], nums2[nums2Idx + 1], nums2Idx + 1});
        }
        return result; 
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Battleships in a Board</span>
Input: board = [["X",".",".","X"],[".",".",".","X"],[".",".",".","X"]]
Output: 2
Input: board = [["."]]
Output: 0
class Solution {
    public int countBattleships(char[][] board) {
        int m = board.length;
        if (m==0) return 0;
        int n = board[0].length;
        
        int count=0;
        
        for (int i=0; i< m; i++) {
            for (int j=0; j< n; j++) {
                if (board[i][j] == '.') continue;
                if (i > 0 && board[i-1][j] == 'X') continue;
                if (j > 0 && board[i][j-1] == 'X') continue;
                count++;
            }
        }
        
        return count;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">399. Evaluate Division</span>
Input: equations = [["a","b"],["b","c"]], values = [2.0,3.0], 
queries = [["a","c"],["b","a"],["a","e"],["a","a"],["x","x"]]
Output: [6.00000,0.50000,-1.00000,1.00000,-1.00000]
Explanation: 
Given: a / b = 2.0, b / c = 3.0
queries are: a / c = ?, b / a = ?, a / e = ?, a / a = ?, x / x = ?
return: [6.0, 0.5, -1.0, 1.0, -1.0 ]
Input: equations = [["a","b"],["b","c"],["bc","cd"]], values = [1.5,2.5,5.0], 
queries = [["a","c"],["c","b"],["bc","cd"],["cd","bc"]]
Output: [3.75000,0.40000,5.00000,0.20000]
class Solution {
    public double[] calcEquation(List<List<String>> equations, 
								double[] values, List<List<String>> queries) {
        Map< String, Map< String, Double>> map = new HashMap<>();
        
        for (int i = 0; i < values.length; i++) {
            List<String> equation = equations.get(i);
            String dividend = equation.get(0);
            String divisor = equation.get(1);
            double quotient = values[i];
            if(!map.containsKey(dividend)) {
                map.put(dividend, new HashMap<>());
            }
            if (!map.containsKey(divisor)) {
                map.put(divisor, new HashMap<>());
            }
            map.get(dividend).put(divisor, quotient);
            map.get(divisor).put(dividend, 1 / quotient);
        }
        double[] res = new double[queries.size()];
        for (int i = 0; i < res.length; i++) {
            List<String> query = queries.get(i);
            if (!map.containsKey(query.get(0)) || !map.containsKey(query.get(1))) {
                res[i] = -1;
            } else{
                res[i] = dfs(map, query.get(0), query.get(1), 1.0, new HashSet<String>());
            }
        }
        return res;
    }
    private double dfs(Map< String, Map<String, Double>> map, String start, String target, double r, Set<String> seen) {
        
        if (start.equals(target)) {
            return r;
        }
        Map< String, Double> m = map.get(start);
        for (String s : m.keySet()) {
            if (seen.contains(s)) {
                continue;
            }
            seen.add(s);
            double res = dfs(map, s, target, r * m.get(s), seen);
            if (res != -1) {
                return res;
            }
            seen.remove(s);
        }
        return -1;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Design Twitter</span>
Input
["Twitter", "postTweet", "getNewsFeed", "follow", "postTweet", "getNewsFeed", "unfollow", "getNewsFeed"]
[[], [1, 5], [1], [1, 2], [2, 6], [1], [1, 2], [1]]
Output
[null, null, [5], null, null, [6, 5], null, [5]]

Explanation
Twitter twitter = new Twitter();
twitter.postTweet(1, 5); // User 1 posts a new tweet (id = 5).
twitter.getNewsFeed(1);  // User 1's news feed should return a list with 1 tweet id -> [5]. return [5]
twitter.follow(1, 2);    // User 1 follows user 2.
twitter.postTweet(2, 6); // User 2 posts a new tweet (id = 6).
twitter.getNewsFeed(1);  // User 1's news feed should return a list with 2 tweet ids -> [6, 5]. Tweet id 6 should precede tweet id 5 because it is posted after tweet id 5.
twitter.unfollow(1, 2);  // User 1 unfollows user 2.
twitter.getNewsFeed(1);  // User 1's news feed should return a list with 1 tweet id -> [5], since user 1 is no longer following user 2.
public class Twitter {
	private static int timeStamp=0;

	// easy to find if user exist
	private Map<Integer, User> userMap;

	// Tweet link to next Tweet so that we can save a lot of time
	// when we execute getNewsFeed(userId)
	private class Tweet{
		public int id;
		public int time;
		public Tweet next;

		public Tweet(int id){
			this.id = id;
			time = timeStamp++;
			next=null;
		}
	}


	// OO design so User can follow, unfollow and post itself
	public class User{
		public int id;
		public Set<Integer> followed;
		public Tweet tweet_head;

		public User(int id){
			this.id=id;
			followed = new HashSet<>();
			follow(id); // first follow itself
			tweet_head = null;
		}

		public void follow(int id){
			followed.add(id);
		}

		public void unfollow(int id){
			followed.remove(id);
		}


		// everytime user post a new tweet, add it to the head of tweet list.
		public void post(int id){
			Tweet t = new Tweet(id);
			t.next=tweet_head;
			tweet_head=t;
		}
	}




	/** Initialize your data structure here. */
	public Twitter() {
		userMap = new HashMap<Integer, User>();
	}

	/** Compose a new tweet. */
	public void postTweet(int userId, int tweetId) {
		if(!userMap.containsKey(userId)){
			User u = new User(userId);
			userMap.put(userId, u);
		}
		userMap.get(userId).post(tweetId);

	}



	// Best part of this.
	// first get all tweets lists from one user including itself and all people it followed.
	// Second add all heads into a max heap. Every time we poll a tweet with 
	// largest time stamp from the heap, then we add its next tweet into the heap.
	// So after adding all heads we only need to add 9 tweets at most into this 
	// heap before we get the 10 most recent tweet.
	public List<Integer> getNewsFeed(int userId) {
		List<Integer> res = new LinkedList<>();

		if(!userMap.containsKey(userId))   return res;

		Set<Integer> users = userMap.get(userId).followed;
		PriorityQueue<Tweet> q = new PriorityQueue<Tweet>(users.size(), (a,b)->(b.time-a.time));
		for(int user: users){
			Tweet t = userMap.get(user).tweet_head;
			// very imporant! If we add null to the head we are screwed.
			if(t!=null){
				q.add(t);
			}
		}
		int n=0;
		while(!q.isEmpty() && n< 10){
		  Tweet t = q.poll();
		  res.add(t.id);
		  n++;
		  if(t.next!=null)
			q.add(t.next);
		}

		return res;

	}

	/** Follower follows a followee. If the operation is invalid, it should be a no-op. */
	public void follow(int followerId, int followeeId) {
		if(!userMap.containsKey(followerId)){
			User u = new User(followerId);
			userMap.put(followerId, u);
		}
		if(!userMap.containsKey(followeeId)){
			User u = new User(followeeId);
			userMap.put(followeeId, u);
		}
		userMap.get(followerId).follow(followeeId);
	}

	/** Follower unfollows a followee. If the operation is invalid, it should be a no-op. */
	public void unfollow(int followerId, int followeeId) {
		if(!userMap.containsKey(followerId) || followerId==followeeId)
			return;
		userMap.get(followerId).unfollow(followeeId);
	}
}

/**
 * Your Twitter object will be instantiated and called as such:
 * Twitter obj = new Twitter();
 * obj.postTweet(userId,tweetId);
 * List<Integer> param_2 = obj.getNewsFeed(userId);
 * obj.follow(followerId,followeeId);
 * obj.unfollow(followerId,followeeId);
 */
/**
 * Your Twitter object will be instantiated and called as such:
 * Twitter obj = new Twitter();
 * obj.postTweet(userId,tweetId);
 * List<Integer> param_2 = obj.getNewsFeed(userId);
 * obj.follow(followerId,followeeId);
 * obj.unfollow(followerId,followeeId);
 */
 <span id="line">---------------------------------------------------------------</span>
 <span class="textStyle">Rectangle Area</span>
Input: ax1 = -3, ay1 = 0, ax2 = 3, ay2 = 4, bx1 = 0, by1 = -1, bx2 = 9, by2 = 2
Output: 45
Input: ax1 = -2, ay1 = -2, ax2 = 2, ay2 = 2, bx1 = -2, by1 = -2, bx2 = 2, by2 = 2
Output: 16
class Solution {
    public int computeArea(int A, int B, int C, int D, int E, int F, int G, int H) {
        int areaOfSqrA = (C-A) * (D-B);
        int areaOfSqrB = (G-E) * (H-F);
        
        int left = Math.max(A, E);
        int right = Math.min(G, C);
        int bottom = Math.max(F, B);
        int top = Math.min(D, H);
        
        //If overlap
        int overlap = 0;
        if(right > left && top > bottom)
             overlap = (right - left) * (top - bottom);
        
        return areaOfSqrA + areaOfSqrB - overlap;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">494. Target Sum</span>
Input: nums = [1,1,1,1,1], target = 3
Output: 5
Explanation: There are 5 ways to assign symbols to make the sum of nums be target 3.
-1 + 1 + 1 + 1 + 1 = 3
+1 - 1 + 1 + 1 + 1 = 3
+1 + 1 - 1 + 1 + 1 = 3
+1 + 1 + 1 - 1 + 1 = 3
+1 + 1 + 1 + 1 - 1 = 3
Input: nums = [1], target = 1
Output: 1
class Solution {
    public int findTargetSumWays(int[] nums, int target) {
        return aux(nums,0,0,target);
    }
     int aux(int[] nums, int i, int sum, int target){
                if(i==nums.length){
                    if(target == sum)return 1;
                    return 0;
                }
                //Positive
                int pos=aux(nums,i+1,sum+nums[i],target);
                //Negative
                int neg=aux(nums,i+1,sum-nums[i],target);
                
                return pos + neg;
            }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">Design Add and Search Words Data Structure</span>
Input
["WordDictionary","addWord","addWord","addWord","search","search","search","search"]
[[],["bad"],["dad"],["mad"],["pad"],["bad"],[".ad"],["b.."]]
Output
[null,null,null,null,false,true,true,true]

Explanation
WordDictionary wordDictionary = new WordDictionary();
wordDictionary.addWord("bad");
wordDictionary.addWord("dad");
wordDictionary.addWord("mad");
wordDictionary.search("pad"); // return False
wordDictionary.search("bad"); // return True
wordDictionary.search(".ad"); // return True
wordDictionary.search("b.."); // return True
class WordDictionary { public class TrieNode {
        public TrieNode[] children = new TrieNode[26];
        public String item = "";
    }
    
    private TrieNode root = new TrieNode();

    public void addWord(String word) {
        TrieNode node = root;
        for (char c : word.toCharArray()) {
            if (node.children[c - 'a'] == null) {
                node.children[c - 'a'] = new TrieNode();
            }
            node = node.children[c - 'a'];
        }
        node.item = word;
    }

    public boolean search(String word) {
        return match(word.toCharArray(), 0, root);
    }
    
    private boolean match(char[] chs, int k, TrieNode node) {
        if (k == chs.length) return !node.item.equals("");   
        if (chs[k] != '.') {
            return node.children[chs[k] - 'a'] != null && match(chs, k + 1, node.children[chs[k] - 'a']);
        } else {
            for (int i = 0; i < node.children.length; i++) {
                if (node.children[i] != null) {
                    if (match(chs, k + 1, node.children[i])) {
                        return true;
                    }
                }
            }
        }
        return false;
    }
}
/**
 * Your WordDictionary object will be instantiated and called as such:
 * WordDictionary obj = new WordDictionary();
 * obj.addWord(word);
 * boolean param_2 = obj.search(word);
 */
 <span id="line">---------------------------------------------------------------</span>
 <span class="textStyle">150. Evaluate Reverse Polish Notation</span>
Input: tokens = ["2","1","+","3","*"]
Output: 9
Explanation: ((2 + 1) * 3) = 9
Input: tokens = ["4","13","5","/","+"]
Output: 6
Explanation: (4 + (13 / 5)) = 6
Input: tokens = ["10","6","9","3","+","-11","*","/","*","17","+","5","+"]
Output: 22
Explanation: ((10 * (6 / ((9 + 3) * -11))) + 17) + 5
= ((10 * (6 / (12 * -11))) + 17) + 5
= ((10 * (6 / -132)) + 17) + 5
= ((10 * 0) + 17) + 5
= (0 + 17) + 5
= 17 + 5
= 22
class Solution {
    public int evalRPN(String[] tokens) {
        Stack<Integer>st=new Stack<>();
        for(int i=0;i< tokens.length;i++){
            if(tokens[i].equals("+")){
                int num1=st.pop();
                int num2=st.pop();
                st.push(num2+num1);   
            }else if(tokens[i].equals("-")){
                int num1=st.pop();
                int num2=st.pop();
                st.push(num2-num1);  
            }else if(tokens[i].equals("*")){
                int num1=st.pop();
                int num2=st.pop();
                st.push(num2*num1);   
            }else if(tokens[i].equals("/")){
                int num1=st.pop();
                int num2=st.pop();
                st.push(num2/num1);   
            }else{
               st.push(Integer.valueOf(tokens[i]));
            }
        }
        return st.peek();
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">553. Optimal Division</span>
Input: nums = [1000,100,10,2]
Output: "1000/(100/10/2)"
Explanation: 1000/(100/10/2) = 1000/((100/10)/2) = 200
However, the bold parenthesis in "1000/((100/10)/2)" are redundant since they do not influence the operation priority.
So you should return "1000/(100/10/2)".
Other cases:
1000/(100/10)/2 = 50
1000/(100/(10/2)) = 50
1000/100/10/2 = 0.5
1000/100/(10/2) = 2
Input: nums = [2,3,4]
Output: "2/(3/4)"
Explanation: (2/(3/4)) = 8/3 = 2.667
It can be shown that after trying all possibilities, we cannot get an expression with evaluation greater than 2.667
class Solution {
    public String optimalDivision(int[] nums) {
        String s="";
        int n=nums.length;
		
        if(n==1){
            return s+nums[0];
        }
        else if(n==2){
            s=s+nums[0]+ "/" +nums[1];
            return s;
        }
		
        for(int i=0;i< n;i++){
            if(i==0){
                s=s+nums[i];
                s=s+"/";
                s=s+"(";
            }
            else if(i==(n-1)){
                s=s+nums[i];
            }
            else{
                s=s+nums[i];
                s=s+"/";
            }
        }
        s=s+")";
        return s;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">547. Number of Provinces</span>
Input: isConnected = [[1,1,0],[1,1,0],[0,0,1]]
Output: 2
Input: isConnected = [[1,0,0],[0,1,0],[0,0,1]]
Output: 3
class Solution {
    static class Edge{
        int src;
        int dest;
        Edge(int s,int d){
            this.src=s;
            this.dest=d;
        }
    }
    public int findCircleNum(int[][] isConnected) {
        ArrayList<Edge> graph[]=new ArrayList[isConnected.length];
        for(int i=0;i< isConnected.length;i++){
            graph[i]=new ArrayList<>();
        }
        //graph creation
        for(int i=0;i< isConnected.length;i++){
            for(int j=0;j< isConnected[0].length;j++){
                if(isConnected[i][j]==1){
                   graph[i].add(new Edge(i,j));
                }       
            }
        }
        int prov=0;
        boolean vist[]=new boolean[graph.length];
        for(int i=0;i< graph.length;i++){
            if(!vist[i]){
                prov++;
                dfsUtil(graph, vist,i);
            }
        }
        return prov;
        
    }
    public static void dfsUtil(ArrayList<Edge> graph[],boolean vist[],int curr){ 
        //O(V+E)
        //visit
        vist[curr]=true;
        //call for neighbours
        for(int i=0;i< graph[curr].size();i++){
            Edge e=graph[curr].get(i);
            if(!vist[e.dest]){
                dfsUtil(graph, vist, e.dest);
            }
        }
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">539. Minimum Time Difference</span>
Input: timePoints = ["23:59","00:00"]
Output: 1
Input: timePoints = ["00:00","23:59","00:00"]
Output: 0
class Solution {
    public int findMinDifference(List<String> timePoints) {
        boolean[] mark = new boolean[24 * 60];
        for (String time : timePoints) {
            String[] t = time.split(":");
            int h = Integer.parseInt(t[0]);
            int m = Integer.parseInt(t[1]);
            if (mark[h * 60 + m]) return 0;
            mark[h * 60 + m] = true;
        }
        
        int prev = 0, min = Integer.MAX_VALUE;
        int first = Integer.MAX_VALUE, last = Integer.MIN_VALUE;
        for (int i = 0; i < 24 * 60; i++) {
            if (mark[i]) {
                if (first != Integer.MAX_VALUE) {
                    min = Math.min(min, i - prev);
                }
                first = Math.min(first, i);
                last = Math.max(last, i);
                prev = i;
            }
        }
        
        min = Math.min(min, (24 * 60 - last + first));
        
        return min; 
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">538. Convert BST to Greater Tree</span>
Input: root = [4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]
Output: [30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]
Input: root = [0,null,1]
Output: [1,null,1]
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
   
    int sum = 0;
    
    public TreeNode convertBST(TreeNode root) {
        convert(root);
        return root;
    }
    
    public void convert(TreeNode cur) {
        if (cur == null) return;
        convert(cur.right);
        cur.val += sum;
        sum = cur.val;
        convert(cur.left);
    }
    
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">537. Complex Number Multiplication</span>
Input: num1 = "1+1i", num2 = "1+1i"
Output: "0+2i"
Explanation: (1 + i) * (1 + i) = 1 + i2 + 2 * i = 2i, and you need convert it to the form of 0+2i.
Input: num1 = "1+-1i", num2 = "1+-1i"
Output: "0+-2i"
Explanation: (1 - i) * (1 - i) = 1 + i2 - 2 * i = -2i, and you need convert it to the form of 0+-2i.
class Solution {
    public String complexNumberMultiply(String num1, String num2) {
        String arr1[] = num1.split("\\+");
        String arr2[] = num2.split("\\+");
        int realPart = 0, imaginaryPart = 0;
        int temp1 = Integer.parseInt(arr1[0]);
        int temp2 = Integer.parseInt(arr1[1].replace("i", ""));
        int temp3 = Integer.parseInt(arr2[0]);
        int temp4 = Integer.parseInt(arr2[1].replace("i", ""));
        realPart = temp1*temp3 - temp2*temp4;
        imaginaryPart = temp1*temp4 + temp2*temp3;
        StringBuilder sb = new StringBuilder();
        sb.append(realPart);
        sb.append("+");
        sb.append(imaginaryPart);
        sb.append("i");
        return sb.toString();
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">654. Maximum Binary Tree</span>
Input: nums = [3,2,1,6,0,5]
Output: [6,3,5,null,2,0,null,null,1]
Explanation: The recursive calls are as follow:
- The largest value in [3,2,1,6,0,5] is 6. Left prefix is [3,2,1] and right suffix is [0,5].
    - The largest value in [3,2,1] is 3. Left prefix is [] and right suffix is [2,1].
        - Empty array, so no child.
        - The largest value in [2,1] is 2. Left prefix is [] and right suffix is [1].
            - Empty array, so no child.
            - Only one element, so child is a node with value 1.
    - The largest value in [0,5] is 5. Left prefix is [0] and right suffix is [].
        - Only one element, so child is a node with value 0.
        - Empty array, so no child.
		Input: nums = [3,2,1]
Output: [3,null,2,null,1]
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public TreeNode constructMaximumBinaryTree(int[] nums) {
        Deque<TreeNode> stack = new LinkedList<>();
        for(int i = 0; i < nums.length; i++) {
            TreeNode curr = new TreeNode(nums[i]);
            while(!stack.isEmpty() && stack.peek().val < nums[i]) {
                curr.left = stack.pop();
            }
            if(!stack.isEmpty()) {
                stack.peek().right = curr;
            }
            stack.push(curr);
        }
        
        return stack.isEmpty() ? null : stack.removeLast(); 
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">655. Print Binary Tree</span>
Input: root = [1,2]
Output: 
[["","1",""],
 ["2","",""]]
 Input: root = [1,2,3,null,4]
Output: 
[["","","","1","","",""],
 ["","2","","","","3",""],
 ["","","4","","","",""]]
 /**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
     public int getHeight(TreeNode root){
        if(root == null)
            return 0;
        return 1+Math.max(getHeight(root.left), getHeight(root.right));
    }
    public void setRows(TreeNode root, List<List<String>> ans, int i, int height, int left, int right){
        if(i >= height || root == null) return;
        int mid = (left+right)/2;
        ans.get(i).set(mid, ""+root.val);
        setRows(root.left, ans, i+1, height, left, mid-1);
        setRows(root.right, ans, i+1, height, mid+1, right);
    }
    public List<List<String>> printTree(TreeNode root) {
        int height = getHeight(root);
        List<List<String>> ans = new ArrayList<>();
        int width = (int)Math.pow(2,height)-1;
        List<String> row = new ArrayList<>();
        for(int i=0;i< width;i++)
            row.add("");
        for(int i=0;i< height;i++)
            ans.add(new ArrayList<String>(row));
        setRows(root, ans, 0, height, 0, width-1);
        return ans;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">662. Maximum Width of Binary Tree</span>
Input: root = [1,3,2,5,3,null,9]
Output: 4
Explanation: The maximum width exists in the third level with length 4 (5,3,null,9).
Input: root = [1,3,2,5,null,null,9,6,null,7]
Output: 7
Explanation: The maximum width exists in the fourth level with length 7 (6,null,null,null,null,null,7).
Input: root = [1,3,2,5]
Output: 2
Explanation: The maximum width exists in the second level with length 2 (3,2).
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public int widthOfBinaryTree(TreeNode root) {
        if(root == null) return 0;
        Queue<TreeNode> q = new LinkedList<TreeNode>();
        Map< TreeNode, Integer> m = new HashMap< TreeNode, Integer>();
        q.offer(root);
        m.put(root, 1);
        int curW = 0;
        int maxW = 0;
        while(!q.isEmpty()){
            int size = q.size();
            int start = 0;
            int end = 0;
            for(int i = 0; i < size; i++){
                TreeNode node = q.poll();
                if(i == 0) start = m.get(node);
                if(i == size - 1) end = m.get(node);
                if(node.left != null){
                    m.put(node.left, m.get(node) * 2);
                    q.offer(node.left);
                }
                if(node.right != null){
                    m.put(node.right, m.get(node) * 2 + 1);
                    q.offer(node.right);
                }
            }
            curW = end - start + 1;
            maxW = Math.max(curW, maxW);
        }
        return maxW;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">669. Trim a Binary Search Tree</span>
Input: root = [1,0,2], low = 1, high = 2
Output: [1,null,2]
Input: root = [3,0,4,null,2,null,null,1], low = 1, high = 3
Output: [3,2,null,1]
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public TreeNode trimBST(TreeNode root, int low, int high) {
         if (root == null) return null;
        
        if (root.val < low) return trimBST(root.right, low, high);
        if (root.val > high) return trimBST(root.left, low, high);
        
        root.left = trimBST(root.left, low,high);
        root.right = trimBST(root.right, low, high);
        
        return root;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">673. Number of Longest Increasing Subsequence</span>
Input: nums = [1,3,5,4,7]
Output: 2
Explanation: The two longest increasing subsequences are [1, 3, 4, 7] and [1, 3, 5, 7].
Input: nums = [2,2,2,2,2]
Output: 5
Explanation: The length of the longest increasing subsequence is 1, and there are 5 increasing subsequences of length 1, so output 5.
class Solution {
    public int findNumberOfLIS(int[] a) {
      int n = a.length, max = 1;
        // need to maintain list of decks for each length
        // in the list we need list of ending values (bottom up descending), and its counts prefix sum (bottom up)
        List<List<int[]>> decks = new ArrayList<>(); // int[0]: tail value, int[1]: count's prefix sum

        // step1 push
        for (int i = 0; i < n; i++) {
            int idx4insert = bs(a[i], decks); // key logic of 300, find where I(a[i]) belongs

            // find cnt from previous list
            int cnt = idx4insert == 0 ? 1 : getCount(decks.get(idx4insert-1), a[i]);

            // create the new element
            int[] cur = new int[] {a[i], cnt};
            List<int[]> deck;
            if (idx4insert == decks.size()) {
                decks.add(deck = new ArrayList<>());
            } else {
                deck = decks.get(idx4insert); // find the right deck
                cur[1] += deck.get(deck.size() - 1)[1]; // [1] is prefix sum of count
            }
            deck.add(cur);
        }

        // System.out.printf("Input Array:\n%s\nDecks:\n%s\n", Arrays.toString(a), toString(decks));

        var deck = decks.get(decks.size() - 1);
        return deck.get(deck.size() - 1)[1];
    }

    private int getCount(List<int[]> deck, int x) { // in a descending order list find largest smaller (no equal) 5 4 4 3: 4        
        int l = 0, r = deck.size();
        while (l < r) {
            int m = l + (r - l) / 2;
            if (deck.get(m)[0] >= x) l = m + 1;
            else r = m;
        }
        if (l == deck.size()) return 1; // first # of LIS, so count is 1;
        return deck.get(deck.size() - 1)[1] - (l == 0 ? 0 : deck.get(l-1)[1]);
    }

    private int bs(int x, List<List<int[]>> decks) { // smallest >=, i.e. insertion index, 1 3 4 4 5: 4
        int l = 0, r = decks.size();
        while (l < r) { // find smallest larger
            int m = l + (r - l) / 2;
            var deck = decks.get(m);
            int cur = deck.get(deck.size() - 1)[0];
            if (cur < x) l = m + 1;
            else r = m;
        }
        return l;
    }

    private StringBuilder toString(List<List<int[]>> decks) {
        return toString(decks, 1);
    }
    private StringBuilder toString(List<List<int[]>> decks, int w) {
        StringBuilder sb = new StringBuilder();
        sb.append("[\n");
        for (var deck : decks)
            sb.append(decktosb(deck, w));

        sb.append("]\n");
        return sb;
    }

    private StringBuilder decktosb(List<int[]> deck) {
        return decktosb(deck, 1);
    }

    private StringBuilder decktosb(List<int[]> deck, int w) {
        StringBuilder sb = new StringBuilder();
        sb.append('[');
        for (var arr : deck)
            sb.append(String.format("[%"+ w + "d, %"+ w + "d], ", arr[0], arr[1]));

        sb.setLength(sb.length() - 2);
        return sb.append("]\n");
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">670. Maximum Swap</span>
Input: num = 2736
Output: 7236
Explanation: Swap the number 2 and the number 7.
Input: num = 9973
Output: 9973
Explanation: No swap.
class Solution {
    public int maximumSwap(int num) {
         int max_digit =0;
        int d = 0;
        int temp =1,index=1;
        int n = num;
        
        while(n > 0){
            int digit = n % 10;
            n = n/10;
            if(max_digit > digit)
                d = Math.max(d , (max_digit-digit) * (temp-index));
            
            else if(max_digit < digit){
                max_digit = digit;
                index = temp;
            }
            temp = temp*10;
        }
        return num + d;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">692. Top K Frequent Words</span>
Input: words = ["i","love","leetcode","i","love","coding"], k = 2
Output: ["i","love"]
Explanation: "i" and "love" are the two most frequent words.
Note that "i" comes before "love" due to a lower alphabetical order.
Input: words = ["the","day","is","sunny","the","the","the","sunny","is","is"], k = 4
Output: ["the","is","sunny","day"]
Explanation: "the", "is", "sunny" and "day" are the four most frequent words, with the number of occurrence being 4, 3, 2 and 1 respectively.
class Solution {
    class Pair{
        String val;
        int freq;
             Pair(String val, int freq){
                 this.val=val;
                 this.freq=freq;
             }
    }
    public List<String> topKFrequent(String[] words, int k) {
        HashMap<String,Integer>map=new HashMap();
        for(int i=0;i< words.length;i++){
            map.put(words[i],map.getOrDefault(words[i],0)+1);
        }
        PriorityQueue<Pair>pq=new PriorityQueue<>((a,b)->{
            if(a.freq!=b.freq){
                return a.freq-b.freq;
            }
            return b.val.compareTo(a.val);
        });
        for(String key : map.keySet()){
            if(pq.size()< k){
                pq.add(new Pair(key,map.get(key)));
            }else{
                if(pq.peek().freq< map.get(key)){
                    pq.remove();
                    pq.add(new Pair(key,map.get(key)));
                }else if(pq.peek().freq==map.get(key)){
                     pq.add(new Pair(key,map.get(key)));
                    }
                }
            }
            while(pq.size()>k){
                pq.remove();
            }
        List<String>ans=new ArrayList();
        while(pq.size()>0){
            ans.add(0,pq.remove().val);
        }
        return ans;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">688. Knight Probability in Chessboard</span>
Input: n = 3, k = 2, row = 0, column = 0
Output: 0.06250
Explanation: There are two moves (to (1,2), (2,1)) that will keep the knight on the board.
From each of those positions, there are also two moves that will keep the knight on the board.
The total probability the knight stays on the board is 0.0625.
Input: n = 1, k = 0, row = 0, column = 0
Output: 1.00000
class Solution {
   int [][] direction =new int[][]{{2,1},{-2,1},{2,-1},{-2,-1},{1,2},{1,-2},{-1,2},{-1,-2}};
   
    public double knightProbability(int N, int K, int r, int c) {
        double [][][] ways = new double[K+1][N][N];
        ways[0][r][c]=1;
        for(int k=1; k<=K;++k){
            for(int i=0; i< N;++i){
                for(int j=0; j< N;++j){
                    for(int [] dir: direction){
                        int oldR = i-dir[0];
                        int oldC = j-dir[1];
                        if(oldR>=0 && oldC>=0 && oldR< N && oldC< N){
                            ways[k][i][j]+=(ways[k-1][oldR][oldC]/8.0);
                        }
                    }
                }
            }
        }
        double res = 0;
        for(int i=0; i< N;++i){
            for(int j=0; j< N;++j){
                res+=ways[K][i][j];
            }
        }
        return res;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">678. Valid Parenthesis String</span>
Input: s = "()"
Output: true
Input: s = "(*)"
Output: true
Input: s = "(*))"
Output: true
class Solution {
    public boolean checkValidString(String s) {
       int cmin = 0, cmax = 0; // open parentheses count in range [cmin, cmax]
        for (char c : s.toCharArray()) {
            if (c == '(') {
                cmax++;
                cmin++;
            } else if (c == ')') {
                cmax--;
                cmin--;
            } else if (c == '*') {
                cmax++; // if `*` become `(` then openCount++
                cmin--; // if `*` become `)` then openCount--
                // if `*` become `` then nothing happens
                // So openCount will be in new range [cmin-1, cmax+1]
            }
            if (cmax < 0) return false; // Currently, don't have enough open parentheses to match close parentheses-> Invalid
                                        // For example: ())(
            cmin = Math.max(cmin, 0);   // It's invalid if open parentheses count < 0 that's why cmin can't be negative
        }
        return cmin == 0; // Return  
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">687. Longest Univalue Path</span>
Input: root = [5,4,5,1,1,null,5]
Output: 2
Explanation: The shown image shows that the longest path of the same value (i.e. 5). 
Input: root = [1,4,5,4,4,null,5]
Output: 2
Explanation: The shown image shows that the longest path of the same value (i.e. 4).
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
   int len = 0; // global variable
public int longestUnivaluePath(TreeNode root) {
    if (root == null) return 0;
    len = 0;
    getLen(root, root.val);
    return len;
}

private int getLen(TreeNode node, int val) {
    if (node == null) return 0;
    int left = getLen(node.left, node.val);
    int right = getLen(node.right, node.val);
    len = Math.max(len, left + right);
    if (val == node.val)  return Math.max(left, right) + 1;
    return 0;
}
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">698. Partition to K Equal Sum Subsets</span>
Input: nums = [4,3,2,3,5,2,1], k = 4
Output: true
Explanation: It is possible to divide it into 4 subsets (5), (1, 4), (2,3), (2,3) with equal sums.
Input: nums = [1,2,3,4], k = 3
Output: false
class Solution {
    public boolean canPartitionKSubsets(int[] nums, int k) {
       int sum=0;
        for(int i:nums){
            sum+=i;
        }
        
        //sum%k must equal to 0 if not just return false
        //if we have to to divide the array greater than array size retun false(we can't)
        if(sum%k!=0 || nums.length< k) return false;
        
        //sort so we can take last element and start filling our bucket
        Arrays.sort(nums);
        
        //our target is sum/k and we have to find this in nums, k times then it is valid
        return canPartitionKSubsets(nums,sum/k,nums.length-1,new int[k]);
    
    }
    public boolean canPartitionKSubsets(int a[],int target,int i,int bucket[]){
        
        //we have taken all the elements
        if(i==-1)
            return true;
        
        //start filling the buckets
        for(int j=0;j< bucket.length;j++){
            
            //can we take this ith element
            if(bucket[j]+a[i]<=target){
            
                //if we take this element
                bucket[j]+=a[i];
                
                //go to next element (in our case go to smallest ele bcz we sorted)
                //if we can fill all buckets then return true
                if(canPartitionKSubsets(a,target,i-1,bucket))
                    return true;
                
                //means we can't fill other buckets if we take ith element so leave this element
                bucket[j]-=a[i];
            
            }
            
            //if our bucket is empty means we have not taken any elements in the buckets
            if(bucket[j]==0)
                break;
        
        }
        
        //all buckets are full but i is pointing to some element (elements still left)
        //or our bucket is empty means we haven't take any element (not valid)
        return false;
    
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">695. Max Area of Island</span>
Input: grid = [[0,0,1,0,0,0,0,1,0,0,0,0,0],
[0,0,0,0,0,0,0,1,1,1,0,0,0],
[0,1,1,0,1,0,0,0,0,0,0,0,0],
[0,1,0,0,1,1,0,0,1,0,1,0,0],
[0,1,0,0,1,1,0,0,1,1,1,0,0],
[0,0,0,0,0,0,0,0,0,0,1,0,0],
[0,0,0,0,0,0,0,1,1,1,0,0,0],
[0,0,0,0,0,0,0,1,1,0,0,0,0]]
Output: 6
Explanation: The answer is not 11, because the island must be connected 4-directionally.
class Solution {
    public int maxAreaOfIsland(int[][] grid) {
        int maxArea = 0;
        
        for (int i = 0; i < grid.length; i++)
            for (int j = 0; j < grid[0].length; j++)
                if (grid[i][j] == 1)
                    maxArea = Math.max(maxArea, dfs(grid, i, j));

        return maxArea;
    }

    public int dfs(int[][] grid, int i, int j) {
        if (i < 0 || i >= grid.length || j < 0 || j >= grid[0].length || grid[i][j] == 0) {
            return 0;
        }

        grid[i][j] = 0;
        int area = 1;

        area +=
        dfs(grid, i + 1, j) + 
        dfs(grid, i - 1, j) +
        dfs(grid, i, j + 1) +
        dfs(grid, i, j - 1);

        return area;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">714. Best Time to Buy and Sell Stock with Transaction Fee</span>
Input: prices = [1,3,2,8,4,9], fee = 2
Output: 8
Explanation: The maximum profit can be achieved by:
- Buying at prices[0] = 1
- Selling at prices[3] = 8
- Buying at prices[4] = 4
- Selling at prices[5] = 9
The total profit is ((8 - 1) - 2) + ((9 - 4) - 2) = 8.
Input: prices = [1,3,7,5,10,3], fee = 3
Output: 6
class Solution {
    public int solve(int[] prices, int fee , int i, int value,int[][] dp){
        if(i == prices.length)
            return 0;
        
        if(dp[i][value] != -1)
            return dp[i][value];
        
        if(value == 1)
            return dp[i][value] = Math.max(-prices[i] - fee + solve(prices,fee,i+1,0,dp), 0 + solve(prices,fee,i+1,1,dp));
        
        else
            return dp[i][value] = Math.max(prices[i]+solve(prices,fee,i+1,1,dp), 0 + solve(prices,fee,i+1,0,dp));
    }
    
    public int maxProfit(int[] prices, int fee) {
        int[][] dp = new int[prices.length][2];
        for(int[] row : dp)
            Arrays.fill(row,-1);
        return solve(prices,fee,0,1,dp);
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">430. Flatten a Multilevel Doubly Linked List</span>
Input: head = [1,2,3,4,5,6,null,null,null,7,8,9,10,null,null,11,12]
Output: [1,2,3,7,8,11,12,9,10,4,5,6]
Explanation: The multilevel linked list in the input is shown.
After flattening the multilevel linked list it becomes:
Input: head = [1,2,null,3]
Output: [1,3,2]
Explanation: The multilevel linked list in the input is shown.
After flattening the multilevel linked list it becomes:
/*
// Definition for a Node.
class Node {
    public int val;
    public Node prev;
    public Node next;
    public Node child;
};
*/

class Solution {
    public Node flatten(Node head) {
          if (head == null) return head;
    
    Stack<Node> stack = new Stack<>();
    stack.push(head);
    
    Node prev = new Node(0); 
    while (!stack.isEmpty()) {
        Node node = stack.pop();
        prev.next = node;
        node.prev = prev;
        prev.child = null;
        prev = node;
        
        if (node.next != null) {
            stack.push(node.next);
        }
        if (node.child != null) {
            stack.push(node.child);
        }
    }
    head.prev = null;
    return head; 
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">701. Insert into a Binary Search Tree</span>
Input: root = [4,2,7,1,3], val = 5
Output: [4,2,7,1,3,5]
Explanation: Another accepted tree is:
Input: root = [40,20,60,10,30,50,70], val = 25
Output: [40,20,60,10,30,50,70,null,null,25]
Input: root = [4,2,7,1,3,null,null,null,null,null,null], val = 5
Output: [4,2,7,1,3,5]
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
   public TreeNode insertIntoBST(TreeNode root, int val) {
        if (root == null) return new TreeNode(val);

        TreeNode n = root;

        while (true) {
            if (val < n.val) {
                if (n.left != null) n = n.left;
                else {
                    n.left = new TreeNode(val);
                    break;
                }
            }
            else {
                if (n.right != null) n = n.right;
                else {
                    n.right = new TreeNode(val);
                    break;
                }
            }
        }

        return root;
        
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">622. Design Circular Queue</span>
Input
["MyCircularQueue", "enQueue", "enQueue", "enQueue", "enQueue", "Rear", "isFull", "deQueue", "enQueue", "Rear"]
[[3], [1], [2], [3], [4], [], [], [], [4], []]
Output
[null, true, true, true, false, 3, true, true, true, 4]

Explanation
MyCircularQueue myCircularQueue = new MyCircularQueue(3);
myCircularQueue.enQueue(1); // return True
myCircularQueue.enQueue(2); // return True
myCircularQueue.enQueue(3); // return True
myCircularQueue.enQueue(4); // return False
myCircularQueue.Rear();     // return 3
myCircularQueue.isFull();   // return True
myCircularQueue.deQueue();  // return True
myCircularQueue.enQueue(4); // return True
myCircularQueue.Rear();     // return 4
class MyCircularQueue {
     int length;
     int rear, front;
     int[] q;

    public MyCircularQueue(int k) {
        q = new int[k];
        length = 0;
        front = 0;
        rear = -1;
    }

    public boolean enQueue(int value) {
        if (isFull()) {
            return false;
        }
        rear = (rear + 1) % (q.length);
        q[rear] = value;
        length++;
        return true;
    }

    public boolean deQueue() {
        if (isEmpty()) {
            return false;
        }
        front = (front + 1) % (q.length);
        length--;
        return true;
    }

    public int Front() {
        return isEmpty() ? -1 : q[front];
    }

    public int Rear() {
        return isEmpty() ? -1 : q[rear];
    }

    public boolean isEmpty() {
        return length == 0;
    }

    public boolean isFull() {
        return length == q.length;
    }
}



/**
 * Your MyCircularQueue object will be instantiated and called as such:
 * MyCircularQueue obj = new MyCircularQueue(k);
 * boolean param_1 = obj.enQueue(value);
 * boolean param_2 = obj.deQueue();
 * int param_3 = obj.Front();
 * int param_4 = obj.Rear();
 * boolean param_5 = obj.isEmpty();
 * boolean param_6 = obj.isFull();
 */
 <span id="line">---------------------------------------------------------------</span>
 <span class="textStyle">528. Random Pick with Weight</span>
Input
["Solution","pickIndex"]
[[[1]],[]]
Output
[null,0]

Explanation
Solution solution = new Solution([1]);
solution.pickIndex(); // return 0. The only option is to return 0 since there is only one element in w.
Input
["Solution","pickIndex","pickIndex","pickIndex","pickIndex","pickIndex"]
[[[1,3]],[],[],[],[],[]]
Output
[null,1,1,1,1,0]

Explanation
Solution solution = new Solution([1, 3]);
solution.pickIndex(); // return 1. It is returning the second element (index = 1) that has a probability of 3/4.
solution.pickIndex(); // return 1
solution.pickIndex(); // return 1
solution.pickIndex(); // return 1
solution.pickIndex(); // return 0. It is returning the first element (index = 0) that has a probability of 1/4.

Since this is a randomization problem, multiple answers are allowed.
All of the following outputs can be considered correct:
[null,1,1,1,1,0]
[null,1,1,1,1,1]
[null,1,1,1,0,0]
[null,1,1,1,0,1]
[null,1,0,1,0,0]
......
and so on.
class Solution {
    Random random;
    int[] wSums;
    
    public Solution(int[] w) {
        this.random = new Random();
        for(int i=1; i< w.length; ++i)
            w[i] += w[i-1];
        this.wSums = w;
    }
    
    public int pickIndex() {
        int len = wSums.length;
        int idx = random.nextInt(wSums[len-1]) + 1;
        int left = 0, right = len - 1;
        // search position 
        while(left < right){
            int mid = left + (right-left)/2;
            if(wSums[mid] == idx)
                return mid;
            else if(wSums[mid] < idx)
                left = mid + 1;
            else
                right = mid;
        }
        return left;
    }
}

/**
 * Your Solution object will be instantiated and called as such:
 * Solution obj = new Solution(w);
 * int param_1 = obj.pickIndex();
 */
 <span id="line">---------------------------------------------------------------</span>
 <span class="textStyle">310. Minimum Height Trees</span>
Input: n = 4, edges = [[1,0],[1,2],[1,3]]
Output: [1]
Explanation: As shown, the height of the tree is 1 when the root is the node with label 1 which is the only MHT.
Input: n = 6, edges = [[3,0],[3,1],[3,2],[3,4],[5,4]]
Output: [3,4]
 class Solution {
    public List<Integer> findMinHeightTrees(int n, int[][] edges) {
       if(edges.length == 0 || n == 1){
            List<Integer> res = Arrays.asList(0);
            return res;
        }
        ArrayList<Integer>[] adj = new ArrayList[n];
        int[] indegree = new int[n];
        
        for(int i=0; i< n; i++){
            adj[i] = new ArrayList<>();
        }
        
        for(int[] e: edges){
            int v = e[0];
            int u = e[1];
            
            adj[v].add(u);
            adj[u].add(v);
            indegree[u]++;
            indegree[v]++;
        }
        
        ArrayDeque<Integer> queue = new ArrayDeque<>();
        
        for(int i=0; i< n; ++i){
            if(indegree[i] == 1){
                queue.add(i);
            }
        }
        
        while(n > 2){
            int size = queue.size();
            n -= size;
            
            while(size-- > 0){
                //remove
                int rem = queue.remove();
                
                //mark*
                //work
                for(int i: adj[rem]){
                    indegree[i]--;
                    if(indegree[i] == 1){
                        queue.add(i);
                    }
                }
                //add*
            }
        }
        
        ArrayList<Integer> res = new ArrayList<>();
        while(queue.size()>0){
            res.add(queue.pop());
        }
        
        
        return res;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">307. Range Sum Query - Mutable</span>
Input
["NumArray", "sumRange", "update", "sumRange"]
[[[1, 3, 5]], [0, 2], [1, 2], [0, 2]]
Output
[null, 9, null, 8]

Explanation
NumArray numArray = new NumArray([1, 3, 5]);
numArray.sumRange(0, 2); // return 1 + 3 + 5 = 9
numArray.update(1, 2);   // nums = [1, 2, 5]
numArray.sumRange(0, 2); // return 1 + 2 + 5 = 8
class NumArray {
 static class BinaryIndexedTree {
    int[] nums;
    int[] BIT;
    int n;

    public BinaryIndexedTree(int[] nums) {
      this.nums = nums;
      this.n = nums.length;
      BIT = new int[n + 1];
      for (int i = 0; i < n; i++) {
        init(i, nums[i]);
      }
    }

    void init(int i, int val) {
      i++;
      while (i <= n) {
        BIT[i] += val;
        i += (i & -i);
      }
    }

    void update(int i, int val) {
      int diff = val - nums[i];
      nums[i] = val;
      init(i, diff);
    }

    int getSum(int i) {
      i++;
      int ret = 0;
      while (i > 0) {
        ret += BIT[i];
        i -= (i & -i);
      }
      return ret;
    }
  }

  BinaryIndexedTree binaryIndexedTree;

  public NumArray(int[] nums) {
    binaryIndexedTree = new BinaryIndexedTree(nums);
  }

  public void update(int index, int val) {
    binaryIndexedTree.update(index, val);
  }

  public int sumRange(int left, int right) {
    return binaryIndexedTree.getSum(right) - binaryIndexedTree.getSum(left - 1);
  }
}

/**
 * Your NumArray object will be instantiated and called as such:
 * NumArray obj = new NumArray(nums);
 * obj.update(index,val);
 * int param_2 = obj.sumRange(left,right);
 */
 <span id="line">---------------------------------------------------------------</span>
 <span class="textStyle">725. Split Linked List in Parts</span>
Input: head = [1,2,3], k = 5
Output: [[1],[2],[3],[],[]]
Explanation:
The first element output[0] has output[0].val = 1, output[0].next = null.
The last element output[4] is null, but its string representation as a ListNode is [].
Input: head = [1,2,3,4,5,6,7,8,9,10], k = 3
Output: [[1,2,3,4],[5,6,7],[8,9,10]]
Explanation:
The input has been split into consecutive parts with size difference at most 1, 
and earlier parts are a larger size than the later parts.
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode[] splitListToParts(ListNode head, int k) {
        ListNode[] parts = new ListNode[k];
        int len = 0;
        for (ListNode node = head; node != null; node = node.next)
            len++;
        int n = len / k, r = len % k; 
        // n : minimum guaranteed part size; 
        //r : extra nodes spread to the first r parts;
        ListNode node = head, prev = null;
        for (int i = 0; node != null && i < k; i++, r--) {
            parts[i] = node;
            for (int j = 0; j < n + (r > 0 ? 1 : 0); j++) {
                prev = node;
                node = node.next;
            }
            prev.next = null;
        }
        return parts;        
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">721. Accounts Merge</span>
Input: accounts = [["John","johnsmith@mail.com","john_newyork@mail.com"],["John","johnsmith@mail.com","john00@mail.com"],["Mary","mary@mail.com"],["John","johnnybravo@mail.com"]]
Output: [["John","john00@mail.com","john_newyork@mail.com","johnsmith@mail.com"],["Mary","mary@mail.com"],["John","johnnybravo@mail.com"]]
Explanation:
The first and second John's are the same person as they have the common email "johnsmith@mail.com".
The third John and Mary are different people as none of their email addresses are used by other accounts.
We could return these lists in any order, for example the answer [['Mary', 'mary@mail.com'], ['John', 'johnnybravo@mail.com'], 
['John', 'john00@mail.com', 'john_newyork@mail.com', 'johnsmith@mail.com']] would still be accepted.
class Solution {
    public List<List<String>> accountsMerge(List<List<String>> accounts) {
        Map< String, String> owner = new HashMap<>();
        Map< String, String> parents = new HashMap<>();
        Map< String, TreeSet<String>> unions = new HashMap<>();
        for (List<String> a : accounts) {
            for (int i = 1; i < a.size(); i++) {
                parents.put(a.get(i), a.get(i));
                owner.put(a.get(i), a.get(0));
            }
        }
        for (List<String> a : accounts) {
            String p = find(a.get(1), parents);
            for (int i = 2; i < a.size(); i++)
                parents.put(find(a.get(i), parents), p);
        }
        for(List<String> a : accounts) {
            String p = find(a.get(1), parents);
            if (!unions.containsKey(p)) unions.put(p, new TreeSet<>());
            for (int i = 1; i < a.size(); i++)
                unions.get(p).add(a.get(i));
        }
        List<List<String>> res = new ArrayList<>();
        for (String p : unions.keySet()) {
            List<String> emails = new ArrayList(unions.get(p));
            emails.add(0, owner.get(p));
            res.add(emails);
        }
        return res;
    }
    private String find(String s, Map<String, String> p) {
        return p.get(s) == s ? s : find(p.get(s), p);
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">807. Max Increase to Keep City Skyline</span>
Input: grid = [[3,0,8,4],[2,4,5,7],[9,2,6,3],[0,3,1,0]]
Output: 35
Explanation: The building heights are shown in the center of the above image.
The skylines when viewed from each cardinal direction are drawn in red.
The grid after increasing the height of buildings without affecting skylines is:
gridNew = [ [8, 4, 8, 7],
            [7, 4, 7, 7],
            [9, 4, 8, 7],
            [3, 3, 3, 3] ]
Input: grid = [[0,0,0],[0,0,0],[0,0,0]]
Output: 0
Explanation: Increasing the height of any building will result in the skyline changing.
class Solution {
    public int maxIncreaseKeepingSkyline(int[][] grid) {
        int n = grid[0].length;
        int[][] newGrid = new int[n][n];
        int sum = 0;
        int[] row = new int[n];
        int[] column = new int[n];

        for(int i =0; i< n;i++){
            int[] abc = new int[n];
            for(int p = 0 ;p< n;p++){
                abc[p] = grid[i][p]; 
            };
        Arrays.sort(abc);
        row[i] = abc[n-1];
        int[] column2 = new int[n];
        for(int j =0; j< n;j++){
           column2[j] = grid[j][i];
        }
           
       Arrays.sort(column2);
       column[i]  = column2[n-1];
   }
    for (int i = 0; i < n; i++){
        for (int j = 0; j < n; j++){
            int newNum = Math.min (row[i], column[j]);
            sum = sum - grid[i][j] + newNum;
        }
    }
    return sum;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">799. Champagne Tower</span>
Input: poured = 1, query_row = 1, query_glass = 1
Output: 0.00000
Explanation: We poured 1 cup of champange to the top glass of the tower (which is indexed as (0, 0)). There will be no excess liquid so all the glasses under the top glass will remain empty.
Input: poured = 2, query_row = 1, query_glass = 1
Output: 0.50000
Explanation: We poured 2 cups of champange to the top glass of the tower (which is indexed as (0, 0)). There is one cup of excess liquid. The glass indexed as (1, 0) and the glass indexed as (1, 1) will share the excess liquid equally, and each will get half cup of champange.
class Solution {
    public double champagneTower(int poured, int query_row, int query_glass) {
        if (poured == 0) return 0;
        int rows = 100;
        double[][] champagneTower = new double[rows + 1][rows + 1];

        champagneTower[0][0] = poured;

        for (int row = 0; row <= query_row; row++) {
            for (int column = 0; column <= row; column++) {
                double splittingWine = (champagneTower[row][column] - 1.0) / 2.0;
                if (splittingWine > 0) {
                    champagneTower[row + 1][column] += splittingWine;
                    champagneTower[row + 1][column + 1] += splittingWine;
                }
            }
        }
        return Math.min(1, champagneTower[query_row][query_glass]); 
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">769. Max Chunks To Make Sorted</span>
Input: arr = [4,3,2,1,0]
Output: 1
Explanation:
Splitting into two or more chunks will not return the required result.
For example, splitting into [4, 3], [2, 1, 0] will result in [3, 4, 0, 1, 2], which isn't sorted.
Input: arr = [1,0,2,3,4]
Output: 4
Explanation:
We can split into two chunks, such as [1, 0], [2, 3, 4].
However, splitting into [1, 0], [2], [3], [4] is the highest number of chunks possible.
class Solution {
    public int maxChunksToSorted(int[] arr) {
        if (arr == null || arr.length == 0) return 0;
        
        int[] max = new int[arr.length];
        max[0] = arr[0];
        for (int i = 1; i < arr.length; i++) {
            max[i] = Math.max(max[i - 1], arr[i]);
        }
        
        int count = 0;
        for (int i = 0; i < arr.length; i++) {
            if (max[i] == i) {
                count++;
            }
        }
        
        return count;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">756. Pyramid Transition Matrix</span>
Input: bottom = "BCD", allowed = ["BCC","CDE","CEA","FFF"]
Output: true
Explanation: The allowed triangular patterns are shown on the right.
Starting from the bottom (level 3), we can build "CE" on level 2 and then build "A" on level 1.
There are three triangular patterns in the pyramid, which are "BCC", "CDE", and "CEA". All are allowed.
Input: bottom = "AAAA", allowed = ["AAB","AAC","BCD","BBE","DEF"]
Output: false
Explanation: The allowed triangular patterns are shown on the right.
Starting from the bottom (level 4), there are multiple ways to build level 3, but trying all the possibilites, you will get always stuck before building level 1.
class Solution {
    private boolean dfs(char[] c, int i, int L, int[][] map) {
        if(L == 1) return true;
        if(i == L - 1) return dfs(c, 0, L - 1, map);
        char save = c[i], p = 'A';
        for(int v = map[c[i] - 'A'][c[i + 1] - 'A']; v != 0; v >>= 1, p++){
            if((v & 1) != 0) {
                c[i] = p;
                if(dfs(c, i + 1, L, map)) 
                    return true;
            }
            c[i] = save;
        }
        return false;
    }
    public boolean pyramidTransition(String bottom, List<String> allowed) {
        int[][] map = new int[7][7];
        for(String s: allowed)
            map[s.charAt(0) - 'A'][s.charAt(1) - 'A'] |= 1 << (s.charAt(2) - 'A');
        return dfs(bottom.toCharArray(), 0, bottom.length(), map);
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">740. Delete and Earn</span>
Input: nums = [3,4,2]
Output: 6
Explanation: You can perform the following operations:
- Delete 4 to earn 4 points. Consequently, 3 is also deleted. nums = [2].
- Delete 2 to earn 2 points. nums = [].
You earn a total of 6 points.
Input: nums = [2,2,3,3,3,4]
Output: 9
Explanation: You can perform the following operations:
- Delete a 3 to earn 3 points. All 2's and 4's are also deleted. nums = [3,3].
- Delete a 3 again to earn 3 points. nums = [3].
- Delete a 3 once more to earn 3 points. nums = [].
You earn a total of 9 points.
class Solution {
    public int deleteAndEarn(int[] nums) {
        int a[]=new int[10001];
        for(int i:nums){
            a[i]+=i;
        }
        int dp[]=new int[10001];
        dp[0]=a[0];
        dp[1]=Math.max(a[0],a[1]);
        for(int i=2;i<=10000;i++){
            dp[i]=Math.max(dp[i-2]+a[i] , dp[i-1]);
        }
        return dp[10000];    
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">743. Network Delay Time</span>
Input: times = [[2,1,1],[2,3,1],[3,4,1]], n = 4, k = 2
Output: 2
Input: times = [[1,2,1]], n = 2, k = 1
Output: 1
class Solution {
    public int networkDelayTime(int[][] times, int N, int K) {
        Map<Integer, Map<Integer,Integer>> map = new HashMap<>();
        for(int[] time : times){
            map.putIfAbsent(time[0], new HashMap<>());
            map.get(time[0]).put(time[1], time[2]);
        }
        
        //distance, node into pq
        Queue<int[]> pq = new PriorityQueue<>((a,b) -> (a[0] - b[0]));
        
        pq.add(new int[]{0, K});
        
        boolean[] visited = new boolean[N+1];
        int res = 0;
        
        while(!pq.isEmpty()){
            int[] cur = pq.remove();
            int curNode = cur[1];
            int curDist = cur[0];
            if(visited[curNode]) continue;
            visited[curNode] = true;
            res = curDist;
            N--;
            if(map.containsKey(curNode)){
                for(int next : map.get(curNode).keySet()){
                    pq.add(new int[]{curDist + map.get(curNode).get(next), next});
                }
            }
        }
        return N == 0 ? res : -1;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">738. Monotone Increasing Digits</span>
Input: n = 10
Output: 9
Input: n = 1234
Output: 1234
Input: n = 332
Output: 299
class Solution {
    public int monotoneIncreasingDigits(int n) {
        int len = size(n);
        int[] dig = new int[len];
        len--;
        while(n>0){
            dig[len] = n%10;
            n /= 10;
            len--;
        }
        n = dig.length;
        int t = 10;

        while(t>0){
            boolean change = false;
            for(int i=0;i< n-1;i++){
                if(dig[i]>dig[i+1]){
                    dig[i]--;
                    for(int j=i+1;j< n;j++){
                        dig[j]=9;
                    }
                    change = true;
                    break;
                }
            }
            if(!change){
                break;
            }
            t--;
        }
        int ans = 0;
        
        for(int i=0;i< n;i++){
            ans += dig[i]*(int)Math.pow(10,n-i-1);
        }
        return ans;
    }
    public int size(int num){
        if(0<=num && num< 10){
            return 1;
        }
        if(10<=num && num< 100){
            return 2;
        }
        if(100<=num && num< 1000){
            return 3;
        }
        if(1000<=num && num< 10000){
            return 4;
        }
        if(10000<=num && num< 100000){
            return 5;
        }
        if(100000<=num && num< 1000000){
            return 6;
        }
        if(1000000<=num && num< 10000000){
            return 7;
        }
        if(10000000<=num && num< 100000000){
            return 8;
        }
        if(100000000<=num && num< 1000000000){
            return 9;
        }
        return 10;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">735. Asteroid Collision</span>
Input: asteroids = [5,10,-5]
Output: [5,10]
Explanation: The 10 and -5 collide resulting in 10. The 5 and 10 never collide.
Input: asteroids = [8,-8]
Output: []
Explanation: The 8 and -8 collide exploding each other.
Input: asteroids = [10,2,-5]
Output: [10]
Explanation: The 2 and -5 collide resulting in -5. The 10 and -5 collide resulting in 10.
class Solution {
    public int[] asteroidCollision(int[] asteroids) {
         Deque<Integer> dq = new ArrayDeque<>();
        
        for(int i = 0; i < asteroids.length; ++i){
            int currAst = asteroids[i]; //current asteroid
    
            if(dq.size() > 0 && dq.getLast() > 0 && currAst < 0){ //opposite direction(O ---->  <---- O) //Collision will happen, E.g. [10, -6(currAst)]
                boolean flag = true;
                while(dq.size() > 0 && dq.getLast() > 0 && currAst < 0){
                    if(dq.getLast() == Math.abs(currAst)){ //[5, 10, -10(currAst)] = [5]
                        dq.removeLast();
                        flag = false;
                        break; //as both asteroid will get distroyed, so stop here
                    }else if(dq.getLast() < Math.abs(currAst)){ //[10, 10, 6, 7, 8, 9, -10(currAst)] = [10]
                        dq.removeLast();
                    }else{ //dq.getLast() > Math.abs(currAst) [10, -3(currAst)]
                        flag = false;
                        break;
                    }
                }
                
                if(flag == true) dq.addLast(currAst);
                // System.out.println(dq);
            }else if(dq.size() > 0 && dq.getLast() > 0 && currAst > 0){ //same direction, e.g. [5, 7(currAst)]
                dq.addLast(currAst);   
            }else if(dq.size() > 0 && dq.getLast() < 0 && currAst < 0){ //same direction, e.g. [-5, -9(currAst)]
                dq.addLast(currAst);   
            }else if(dq.size() > 0 && dq.getLast() < 0 && currAst > 0){ //opposite direction( <---- O  O ---->) //No collision, E.g. [-6, 10(currAst)]
                dq.addLast(currAst); 
            }else{ //dq is empty
                dq.addLast(currAst); 
            }
            // System.out.println(dq);
        }
        
        int[] res = new int[dq.size()];
        int idx = 0;
        while(dq.size() > 0){
            res[idx++] = dq.removeFirst();
        }
        return res; 
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">729. My Calendar I</span>
Input
["MyCalendar", "book", "book", "book"]
[[], [10, 20], [15, 25], [20, 30]]
Output
[null, true, false, true]

Explanation
MyCalendar myCalendar = new MyCalendar();
myCalendar.book(10, 20); // return True
myCalendar.book(15, 25); // return False, It can not be booked because time 15 is already booked by another event.
myCalendar.book(20, 30); // return True, The event can be booked, as the first event takes every time less than 20, but not including 20.
class MyCalendar {
    TreeMap<Integer,Integer> calendar = new TreeMap<>();
    public MyCalendar() {
        calendar.put(Integer.MAX_VALUE, Integer.MAX_VALUE);
    }
    public boolean book(int start, int end) {
        Map.Entry<Integer,Integer> pair = calendar.higherEntry(start);
        boolean res = end <= pair.getValue();
        if (res) calendar.put(end, start);
        return res;
        
    }
}

/**
 * Your MyCalendar object will be instantiated and called as such:
 * MyCalendar obj = new MyCalendar();
 * boolean param_1 = obj.book(start,end);
 */
 <span id="line">---------------------------------------------------------------</span>
 <span class="textStyle">901. Online Stock Span</span>
Input
["StockSpanner", "next", "next", "next", "next", "next", "next", "next"]
[[], [100], [80], [60], [70], [60], [75], [85]]
Output
[null, 1, 1, 1, 2, 1, 4, 6]

Explanation
StockSpanner stockSpanner = new StockSpanner();
stockSpanner.next(100); // return 1
stockSpanner.next(80);  // return 1
stockSpanner.next(60);  // return 1
stockSpanner.next(70);  // return 2
stockSpanner.next(60);  // return 1
stockSpanner.next(75);  // return 4, because the last 4 prices (including today's price of 75) were less than or equal to today's price.
stockSpanner.next(85);  // return 6
class StockSpanner {
Stack<int []> st;
    public StockSpanner() {
        st = new Stack<>();
    }
    
    public int next(int price) {
        int span = 1;
        while(!st.isEmpty() && st.peek()[0] <= price)
            span += st.pop()[1];
        st.push(new int[]{price, span});
        return span;
    }
}
/**
 * Your StockSpanner object will be instantiated and called as such:
 * StockSpanner obj = new StockSpanner();
 * int param_1 = obj.next(price);
 */
 <span id="line">---------------------------------------------------------------</span>
 <span class="textStyle">881. Boats to Save People</span>
Input: people = [1,2], limit = 3
Output: 1
Explanation: 1 boat (1, 2)
Input: people = [3,2,2,1], limit = 3
Output: 3
Explanation: 3 boats (1, 2), (2) and (3)
Input: people = [3,5,3,4], limit = 5
Output: 4
Explanation: 4 boats (3), (3), (4), (5)
class Solution {
    public int numRescueBoats(int[] people, int limit) {
     int n = people.length;
        
       // Arrays.sort(people);         n log n method
        
        int count[] = new int[limit+1];
        for(int p: people){
            count[p]++;                        
                                        //counting freq. of element 
        }
        int i = 0;
        for(int val = 1; val<=limit; val++){
            while(count[val]-- > 0){
                people[i++] = val; 
                                        //count sort ...sorts in O(n)
            }
        }
        
        int left = 0, right = n-1, boats = 0;       
                                            // two pointers and will check in limit
        while(left <= right){
            if(people[left] + people[right] <= limit){
                left++;
                right--;
            }
            else{
                right--;
            }
            boats++;
        }
        return boats;
                            //        O(n log n) can be optimised to O(n) using Count Sort
    }
}       
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">880. Decoded String at Index</span>
Input: s = "leet2code3", k = 10
Output: "o"
Explanation: The decoded string is "leetleetcodeleetleetcodeleetleetcode".
The 10th letter in the string is "o".
Input: s = "ha22", k = 5
Output: "h"
Explanation: The decoded string is "hahahaha".
The 5th letter is "h".
class Solution {
   public String decodeAtIndex(String str, int k) {
        long size =0 ;
        for(int i=0;i< str.length();i++) {
            char ch=str.charAt(i);
            if(Character.isDigit(ch)) {
                size*=ch-'0';
            } else {
                size++;
            }
        }
        
       for (int i = str.length()-1; i >= 0; --i) {
            char c = str.charAt(i);
            if (Character.isDigit(c)) {
                size /= c - '0';
                k %= size;
            } else {
                if(k==0 || k==size) {
                    return Character.toString(c);
                }
                size--;
            }
                
        }
        return "";
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">861. Score After Flipping Matrix</span>
Input: grid = [[0,0,1,1],[1,0,1,0],[1,1,0,0]]
Output: 39
Explanation: 0b1111 + 0b1001 + 0b1111 = 15 + 9 + 15 = 39
Input: grid = [[0]]
Output: 1
class Solution {
    public int matrixScore(int[][] grid) {
      int row= grid.length;
        int col= grid[0].length;
        
        //  There must be 1 at the starting of every row
        for(int r=0; r< row; r++){
            
            if(grid[r][0] == 0){
                grid= swapRow( r, grid );
            }
        }
        
        //  There must be max 1's in the col.
        for(int c=0; c< col; c++){
            if(countCol1(c, grid) <= (grid.length)/2){
                grid= swapCol( c, grid );
            }
            
        }
        
        int sum= 0;
        for(int r=0; r< row; r++){
            
            String s= "";
            for(int i: grid[r]){
                s+= Integer.toString(i);
            }
            sum+= Integer.parseInt(s, 2);
        }
        return sum;
    }
    
    //  Count no. of 1's in every column 
    public int countCol1(int col, int[][] grid){
        int ones= 0;
        for(int i= 0; i< grid.length; i++){
            
            if(grid[i][col] == 1){
                ones++;
            }
        }
        
        return ones;
    }
    
    //  Swap 1's with 0's in row
    public int[][] swapRow(int row, int[][] grid){
        
        for(int index= 0; index< grid[row].length; index++){
            
            if(grid[row][index] == 0){
                grid[row][index]= 1;
            }
            
            else if(grid[row][index] == 1){
                grid[row][index]= 0;
            }
            
        }
        
        return grid;
    }
    
    //  Swap 1's with 0's in column
    public int[][] swapCol(int col, int[][] grid){
        
        for(int i= 0; i< grid.length; i++){
            
            if(grid[i][col] == 0){
                grid[i][col]= 1;
            }
            
            else if(grid[i][col] == 1){
                grid[i][col]= 0;
            }
            
        }
        
        return grid;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">856. Score of Parentheses</span>
Input: s = "()"
Output: 1
Input: s = "(())"
Output: 2
class Solution {
    public int scoreOfParentheses(String S) {
         Stack<Integer> stack = new Stack<>();
        for (char c : S.toCharArray()) {
            if (c == '(') {
                stack.push(-1);
            } else {
                int cur = 0;
                while (stack.peek() != -1) {
                    cur += stack.pop();
                }
                stack.pop();
                stack.push(cur == 0 ? 1 : cur * 2);
            }
        }
        int sum = 0;
        while (!stack.isEmpty()) {
            sum += stack.pop();
        }
        return sum;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">849. Maximize Distance to Closest Person</span>
Input: seats = [1,0,0,0,1,0,1]
Output: 2
Explanation: 
If Alex sits in the second open seat (i.e. seats[2]), then the closest person has distance 2.
If Alex sits in any other open seat, the closest person has distance 1.
Thus, the maximum distance to the closest person is 2.
Input: seats = [1,0,0,0]
Output: 3
Explanation: 
If Alex sits in the last seat (i.e. seats[3]), the closest person is 3 seats away.
This is the maximum distance possible, so the answer is 3.
class Solution {
    public int maxDistToClosest(int[] seats) {
         int prefixZeroes = -1, middleZeroes = -1, suffixZeroes = -1, zeroes = 0;
        for(int i = 0;i< seats.length;i++){
            if(seats[i] == 0){
                zeroes++;
            }
            else{
                if(prefixZeroes == -1){
                    prefixZeroes = zeroes;
                }
                else{
                    middleZeroes = Math.max(middleZeroes, zeroes);
                }
                zeroes = 0;
            }
        }
        suffixZeroes = zeroes;
        return Math.max(prefixZeroes, Math.max(suffixZeroes, (middleZeroes+1)/2));
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">841. Keys and Rooms</span>
Input: rooms = [[1],[2],[3],[]]
Output: true
Explanation: 
We visit room 0 and pick up key 1.
We then visit room 1 and pick up key 2.
We then visit room 2 and pick up key 3.
We then visit room 3.
Since we were able to visit every room, we return true.
Input: rooms = [[1,3],[3,0,1],[2],[0]]
Output: false
Explanation: We can not enter room number 2 since the only key that unlocks it is in that room.
class Solution {
     boolean[] visited;
    List<List<Integer>> allRooms;

    public boolean canVisitAllRooms(List<List<Integer>> rooms) {
        allRooms = rooms;
        visited = new boolean[rooms.size()];
        goInRecursively(0, rooms.get(0));
        return allVisited();
    }

    private void goInRecursively(int room, List<Integer> keys) {
        if (visited[room]) return;

        visited[room] = true;
        for (int i = 0; i < keys.size(); i++) {
            int key = keys.get(i);
            goInRecursively(key, allRooms.get(key));
        }
    }

    private boolean allVisited() {
        for (int i = 0; i < visited.length / 2; i++) {
            if (!visited[i] || !visited[visited.length - 1 - i])
                return false;
        }
        return visited[visited.length / 2];
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">823. Binary Trees With Factors</span>
Input: arr = [2,4]
Output: 3
Explanation: We can make these trees: [2], [4], [4, 2, 2]
Input: arr = [2,4,5,10]
Output: 7
Explanation: We can make these trees: [2], [4], [5], [10], [4, 2, 2], [10, 2, 5], [10, 5, 2].
class Solution {
    public int numFactoredBinaryTrees(int[] arr) {
         Arrays.sort(arr);
        HashMap<Integer,Long>map=new HashMap<Integer,Long>();
        long ans=1;
        map.put(arr[0],ans);
        for(int i=1;i< arr.length;i++)
        {
            long sum=1;
            for(int j=0;j< i;j++)
            {
                if(arr[i]%arr[j]==0 && map.containsKey(arr[i]/arr[j]))
                    sum=sum+(map.get(arr[i]/arr[j])*map.get(arr[j]));
            }
            map.put(arr[i],sum);
            ans=ans+sum;
        }
        return (int)(ans%1000000007); 
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">820. Short Encoding of Words</span>
Input: words = ["time", "me", "bell"]
Output: 10
Explanation: A valid encoding would be s = "time#bell#" and indices = [0, 2, 5].
words[0] = "time", the substring of s starting from indices[0] = 0 to the next '#' is underlined in "time#bell#"
words[1] = "me", the substring of s starting from indices[1] = 2 to the next '#' is underlined in "time#bell#"
words[2] = "bell", the substring of s starting from indices[2] = 5 to the next '#' is underlined in "time#bell#"
Input: words = ["t"]
Output: 2
Explanation: A valid encoding would be s = "t#" and indices = [0].
class Solution {
    public int minimumLengthEncoding(String[] W) {
         Set<String> set = new HashSet<>(Arrays.asList(W));
        for (String word : W)
            if (set.contains(word))
                for (int i = 1; i < word.length(); i++) 
                    set.remove(word.substring(i));
        int ans = set.size();
        for (String word : set) ans += word.length();
        return ans;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">1024. Video Stitching</span>
Input: clips = [[0,2],[4,6],[8,10],[1,9],[1,5],[5,9]], time = 10
Output: 3
Explanation: We take the clips [0,2], [8,10], [1,9]; a total of 3 clips.
Then, we can reconstruct the sporting event as follows:
We cut [1,9] into segments [1,2] + [2,8] + [8,9].
Now we have segments [0,2] + [2,8] + [8,10] which cover the sporting event [0, 10].
Input: clips = [[0,1],[1,2]], time = 5
Output: -1
Explanation: We cannot cover [0,5] with only [0,1] and [1,2].
Input: clips = [[0,1],[6,8],[0,2],[5,6],[0,4],[0,3],[6,7],[1,3],[4,7],[1,4],[2,5],[2,6],[3,4],[4,5],[5,7],[6,9]], time = 9
Output: 3
Explanation: We can take clips [0,4], [4,7], and [6,9].
class Solution {
    public int videoStitching(int[][] clips, int time) {
         int[] dp = new int[time+ 1];
        Arrays.fill(dp, time+1);
        dp[0] = 0;
        for(int i = 0; i <= time; i++) {
            for(int[] c : clips) {
                if(i >= c[0] && i <= c[1]) dp[i] = Math.min(dp[i], dp[c[0]] + 1);
            }
            if(dp[i] == time+1) return -1;
        }
        return dp[time];
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">1010. Pairs of Songs With Total Durations Divisible by 60</span>
Input: time = [30,20,150,100,40]
Output: 3
Explanation: Three pairs have a total duration divisible by 60:
(time[0] = 30, time[2] = 150): total duration 180
(time[1] = 20, time[3] = 100): total duration 120
(time[1] = 20, time[4] = 40): total duration 60
Input: time = [60,60,60]
Output: 3
Explanation: All three pairs have a total duration of 120, which is divisible by 60.
class Solution {
    public int numPairsDivisibleBy60(int[] time) {
        int []fmap = new int[60];
        int res = 0;
        
        for(int t : time){
            int val = t % 60;
            
            if(val == 0){
                res += fmap[0];
            }else{
                res += fmap[60-val];
            }
            
            fmap[val]++;
        }
        
        return res;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">1008. Construct Binary Search Tree from Preorder Traversal</span>
Input: preorder = [8,5,1,7,10,12]
Output: [8,5,10,1,7,null,12]
Input: preorder = [1,3]
Output: [1,null,3]
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    int counter = 0;
    public TreeNode bstFromPreorder(int[] preorder) {
         // create a helper to get done
    return construct(preorder, Integer.MAX_VALUE);
}

private TreeNode construct(int[] preorder, int bound){
    
    // check for the size of array or value is max than bound
    if(counter == preorder.length || preorder[counter] > bound)
        return null;
    
    // create node
    TreeNode node = new TreeNode(preorder[counter++]);
    
    // create left
    node.left = construct(preorder, node.val);
    
    // create right
    node.right = construct(preorder, bound);
    
    //return node
    return node;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">1004. Max Consecutive Ones III</span>
Input: nums = [1,1,1,0,0,0,1,1,1,1,0], k = 2
Output: 6
Explanation: [1,1,1,0,0,1,1,1,1,1,1]
Bolded numbers were flipped from 0 to 1. The longest subarray is underlined.
Input: nums = [0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,1,1,1,1], k = 3
Output: 10
Explanation: [0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1]
Bolded numbers were flipped from 0 to 1. The longest subarray is underlined.
class Solution {
    public int longestOnes(int[] nums, int k) {
      int n = nums.length;
        int i = 0;
        int j = 0;
        int ans = Integer.MIN_VALUE;
        int countZero = 0;
        while(j < n){
            if(nums[j] == 0){
                countZero++;
            }
            
            while(countZero > k){
                if(nums[i] == 0){
                    countZero--;
                }
                i++;
            }
        ans = Math.max(ans , j - i + 1);
        j++;
        }
       return ans;  
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">946. Validate Stack Sequences</span>
Input: pushed = [1,2,3,4,5], popped = [4,5,3,2,1]
Output: true
Explanation: We might do the following sequence:
push(1), push(2), push(3), push(4),
pop() -> 4,
push(5),
pop() -> 5, pop() -> 3, pop() -> 2, pop() -> 1
Input: pushed = [1,2,3,4,5], popped = [4,3,5,1,2]
Output: false
Explanation: 1 cannot be popped before 2.
class Solution {
    public boolean validateStackSequences(int[] pushed, int[] popped) {
          Stack<Integer> stack = new Stack<>();
       int index = 0;
       for(int item : pushed){
           stack.push(item);
           while (!stack.empty() && stack.peek() == popped[index]){
               stack.pop();
               index++;
           }
       }
       return stack.empty();
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">970. Powerful Integers</span>
Input: x = 2, y = 3, bound = 10
Output: [2,3,4,5,7,9,10]
Explanation:
2 = 20 + 30
3 = 21 + 30
4 = 20 + 31
5 = 21 + 31
7 = 22 + 31
9 = 23 + 30
10 = 20 + 32
Input: x = 3, y = 5, bound = 15
Output: [2,4,6,8,10,14]
class Solution {
    public List<Integer> powerfulIntegers(int x, int y, int bound) {
       Set<Integer> result = new HashSet<>();
        for (int a = 1; a < bound; a *= x) {
            for (int b = 1; a + b <= bound; b *= y) {
                result.add(a + b);
                if (y == 1) {
                    break;
                }
            }
            if (x == 1) {
                break;
            }
        }
        return new ArrayList<>(result); 
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">979. Distribute Coins in Binary Tree</span>
Input: root = [3,0,0]
Output: 2
Explanation: From the root of the tree, we move one coin to its left child, and one coin to its right child.
Input: root = [0,3,0]
Output: 3
Explanation: From the left child of the root, we move two coins to the root [taking two moves]. Then, we move one coin from the root of the tree to the right child.
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
  int moves = 0;
    public int distributeCoins(TreeNode root) {
        getNumAndCoins(root);
        return moves;
    }
    
    /*
     * return [number_of_nodes_in_subtree, number_of_total_coins_in_subtree]
     */
    private int[] getNumAndCoins(TreeNode node) {
        if (node == null) return new int[] {0, 0};
        int[] left = getNumAndCoins(node.left);
        int[] right = getNumAndCoins(node.right);
        moves += Math.abs(left[0] - left[1]) + Math.abs(right[0] - right[1]);
        return new int[] {left[0] + right[0] + 1, left[1] + right[1] + node.val};
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">935. Knight Dialer</span>
Input: n = 1
Output: 10
Explanation: We need to dial a number of length 1, so placing the knight over any numeric cell of the 10 cells is sufficient.
Input: n = 2
Output: 20
Explanation: All the valid number we can dial are [04, 06, 16, 18, 27, 29, 34, 38, 40, 43, 49, 60, 61, 67, 72, 76, 81, 83, 92, 94]
class Solution {
    public static final int MOD = 1000000007;
    public int knightDialer(int N) {
        int[][] graph = new int[][]{{4,6},{6,8},{7,9},{4,8},{3,9,0},{},{1,7,0},{2,6},{1,3},{2,4}};
        int cnt = 0;
        Integer[][] memo = new Integer[N+1][10];
        for (int i = 0; i <= 9; i++)
            cnt = (cnt + helper(N-1, i, graph, memo)) % MOD;
        return cnt;
    }
    private int helper(int N, int cur, int[][] graph, Integer[][] memo) {
        if (N == 0)
            return 1;
        if (memo[N][cur] != null)
            return memo[N][cur];
        int cnt = 0;
        for (int nei : graph[cur])
            cnt = (cnt + helper(N-1, nei, graph, memo)) % MOD;
        memo[N][cur] = cnt;
        return cnt;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">921. Minimum Add to Make Parentheses Valid</span>
Input: s = "())"
Output: 1
Input: s = "((("
Output: 3
class Solution {
    public boolean isOpening(char c){
        return c == '(';
    }
    public int minAddToMakeValid(String s) {
        Stack<Character> st = new Stack<>();
        Stack<Character> st1 = new Stack<>();
        for(int i = 0;i< s.length();i++){
            if(isOpening(s.charAt(i))){
                st.push(s.charAt(i));
            }
            else if(!isOpening(s.charAt(i)) && !st.isEmpty()){
                st.pop();
            }
            else if(!isOpening(s.charAt(i)) && st.isEmpty()){
                st1.push(s.charAt(i));
            }
        }
        return st.size()+st1.size();
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">918. Maximum Sum Circular Subarray</span>
Input: nums = [1,-2,3,-2]
Output: 3
Explanation: Subarray [3] has maximum sum 3.
Input: nums = [5,-3,5]
Output: 10
Explanation: Subarray [5,5] has maximum sum 5 + 5 = 10.
class Solution {
    public int maxSubarraySumCircular(int[] A) {
        int nonCircularSum = kadaneMaxSum(A);
        int totalSum = 0;
        for(int i=0;i< A.length;i++){
            totalSum += A[i];
            A[i] = -A[i];
        }
              
        int circularSum = totalSum + kadaneMaxSum(A);
        if(circularSum == 0)
            return nonCircularSum;
        return Math.max(circularSum,nonCircularSum);
    }
    
    int kadaneMaxSum(int[] A){
        int currentSum = A[0];
        int maxSum = A[0];
        for(int i=1;i< A.length;i++){
            if(currentSum < 0)
                currentSum = 0;
            currentSum = A[i] + currentSum;
            maxSum = Math.max(maxSum,currentSum);
        }
        return maxSum;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">1268. Search Suggestions System</span>
Input: products = ["mobile","mouse","moneypot","monitor","mousepad"], searchWord = "mouse"
Output: [["mobile","moneypot","monitor"],["mobile","moneypot","monitor"],["mouse","mousepad"],["mouse","mousepad"],["mouse","mousepad"]]
Explanation: products sorted lexicographically = ["mobile","moneypot","monitor","mouse","mousepad"].
After typing m and mo all products match and we show user ["mobile","moneypot","monitor"].
After typing mou, mous and mouse the system suggests ["mouse","mousepad"].
Input: products = ["havana"], searchWord = "havana"
Output: [["havana"],["havana"],["havana"],["havana"],["havana"],["havana"]]
Explanation: The only word "havana" will be always suggested while typing the search word.
class Solution {
    public List<List<String>> suggestedProducts(String[] products, String searchWord) {
         PriorityQueue<String> pq = new PriorityQueue<>(3, (s1,s2) -> s1.compareTo(s2)); 
  List<List<String>> list = new ArrayList<>();
  
  for(int i = 1; i<=searchWord.length(); i++){
    String temp = searchWord.substring(0, i);
    for(String s : products){
      if(s.startsWith(temp)){
        pq.offer(s);
      }
    }
    List<String> temp_list = new ArrayList<>();
    for(int j = 0; j< 3; j++){
      if(pq.peek() != null){
        temp_list.add(pq.poll());
      }
    }
    pq.clear();
    list.add(temp_list);
  }
  return list;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">1249. Minimum Remove to Make Valid Parentheses</span>
Input: s = "lee(t(c)o)de)"
Output: "lee(t(c)o)de"
Explanation: "lee(t(co)de)" , "lee(t(c)ode)" would also be accepted.
Input: s = "a)b(c)d"
Output: "ab(c)d"
Input: s = "))(("
Output: ""
Explanation: An empty string is also valid.
class Solution {
    public String minRemoveToMakeValid(String s) {
        Stack<Integer> stack = new Stack<>();
        for(int i=0;i< s.length();i++) {
            char ch = s.charAt(i);
            if(Character.isAlphabetic(ch))
                continue;
            if(ch == '(')
                stack.push(i);
            else {
                if(!stack.isEmpty() && s.charAt(stack.peek()) == '(')
                    stack.pop();
                else stack.push(i);
            }
        }
        
        // if(stack.size() == 0) return "";
        
        StringBuilder result = new StringBuilder();
        HashSet<Integer> set = new HashSet<>(stack);
        for(int i=0;i< s.length();i++)
            if(!set.contains(i))
                result.append(s.charAt(i));
        
        return result.toString(); 
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">1209. Remove All Adjacent Duplicates in String II</span>
Input: s = "abcd", k = 2
Output: "abcd"
Explanation: There's nothing to delete.
Input: s = "deeedbbcccbdaa", k = 3
Output: "aa"
Explanation: 
First delete "eee" and "ccc", get "ddbbbdaa"
Then delete "bbb", get "dddaa"
Finally delete "ddd", get "aa"
Input: s = "pbbcggttciiippooaais", k = 2
Output: "ps"
class Solution {
   public String removeDuplicates(String s, int k) {
        Stack<CharCounter> stack = new Stack<>();
        for (int i = 0; i < s.length(); i++) {
            char c = s.charAt(i);
            if (!stack.isEmpty() && c == stack.peek().c) {
                if (stack.peek().count == k - 1) {
                    stack.pop();
                } else {
                    stack.peek().count++;
                }
            } else {
                stack.push(new CharCounter(c));
            }
        }
        StringBuilder res = new StringBuilder();
        for (CharCounter charCount : stack) {
            res.append(charCount);
        }
        return res.toString();
    }
}


class CharCounter {
    char c;
    int count;
    
    CharCounter(char c) {
        this.c = c;
        this.count = 1;
    }
    
    @Override
    public String toString() {
        return Character.toString(c).repeat(count);
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">1171. Remove Zero Sum Consecutive Nodes from Linked List</span>
Input: head = [1,2,-3,3,1]
Output: [3,1]
Note: The answer [1,2,1] would also be accepted.
Input: head = [1,2,3,-3,4]
Output: [1,2,4]
Input: head = [1,2,3,-3,-2]
Output: [1]
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode removeZeroSumSublists(ListNode head) {
        // Map from sum from index 0 to the farthest value that the sum stays unchanged.
        Map<Integer, ListNode> sumToFarthestNodeMap = new HashMap<>();
        
        // Need the dummy node to track the new head if changed.
        ListNode preHead = new ListNode(0);
        preHead.next = head;
        
        // First iteration to compute the map.
        int sum = 0;
        for (ListNode p = preHead; p != null; p = p.next) {
            sum += p.val;
            sumToFarthestNodeMap.put(sum, p);
        }
        
        // Second iteration to re-connect the nodes to the farthest node where the sum stays unchanged
        sum = 0;
        for (ListNode p = preHead; p != null; p = p.next) {
            sum += p.val;
            p.next = sumToFarthestNodeMap.get(sum).next;
        }
        
        // Done, return the head from preHead
        return preHead.next;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">1138. Alphabet Board Path</span>
Input: target = "leet"
Output: "DDR!UURRR!!DDD!"
Input: target = "code"
Output: "RR!DDRR!UUL!R!"
class Solution {
   public String alphabetBoardPath(String target) {
        if(target == null) return "";
        char[] chs = target.toCharArray();
        StringBuilder sb = new StringBuilder();
        int previ = 0, prevj = 0;
        for(int i = 0; i < chs.length; i++) {
            int curi = (chs[i] - 'a') / 5;
            int curj = (chs[i] - 'a') % 5;
            if(curi == previ && curj == prevj) {
                sb.append("!");
            } else {
                printPath(sb, previ, prevj, curi, curj); 
                sb.append("!");
                previ = curi; prevj = curj;
            }
        }
        
        return sb.toString();
    }
    
    private void printPath(StringBuilder sb, int previ, int prevj, int curi, int curj) {       
        while(curi < previ) {
            sb.append("U"); 
            curi++;
        } 
        while(curj > prevj) {
            sb.append("R"); 
            curj--;
        } 
        while(curj < prevj) {
            sb.append("L"); 
            curj++;
        }  
        while(curi > previ) {
            sb.append("D"); 
            curi--;
        }                      
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">1094. Car Pooling</span>
Input: trips = [[2,1,5],[3,3,7]], capacity = 4
Output: false
Input: trips = [[2,1,5],[3,3,7]], capacity = 5
Output: true
class Solution {
    public boolean carPooling(int[][] trips, int capacity) {
    // we need to createnew array to store the passanger's 
    //get in & get out count,so will take one array to store that
    // the array of size can be maximum upto 1000 but we can also           
    //consider the max elem in given array and we can create the 
    //array of size max+1
        int n=0;
        for(int x[]:trips){
            n=Math.max(n,x[2]);
        }
        int km[]=new int[n+1];
        for(int trip[]:trips){
            km[trip[1]]+=trip[0];
            km[trip[2]]-=trip[0];
        }
        for(int x:km){
            capacity-=x;
            if(capacity< 0){
                return false;
            }
        }
         return true;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">1091. Shortest Path in Binary Matrix</span>
Input: grid = [[0,1],[1,0]]
Output: 2
Input: grid = [[0,0,0],[1,1,0],[1,1,0]]
Output: 4
Input: grid = [[1,0,0],[1,1,0],[1,1,0]]
Output: -1
class Solution {
    private int dir[][] = new int[][]{{0,1},{0,-1},{1,0},{-1,0},{1,-1},{-1,1},{-1,-1},{1,1}};

    public int shortestPathBinaryMatrix(int[][] grid) {

        int m = grid.length;
        int n = grid[0].length;

        if(grid[0][0]==1 || grid[m-1][n-1]==1) {
            return -1;
        }

        boolean[][] visited = new boolean[m][n];
        visited[0][0] = true;
        Queue<int[]> queue = new LinkedList<>();
        queue.add(new int[]{0,0});

        int ans=0;
        while (!queue.isEmpty()) {
            int size = queue.size();
            for(int i=0;i< size;i++) {
                int[] pop = queue.remove();
                if(pop[0]==m-1 && pop[1]==n-1) {
                    return ans+1;
                }
                for (int k=0;k< 8;k++) {
                    int nextX = dir[k][0]+pop[0];
                    int nextY = dir[k][1]+pop[1];

                    if(nextX>=0 && nextX< m && nextY>=0 && nextY< n && !visited[nextX][nextY] && grid[nextX][nextY]==0) {
                        queue.add(new int[]{nextX,nextY});
                        visited[nextX][nextY]=true;
                    }

                }
            }
            ans++;
        }

        return -1;  
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">1038. Binary Search Tree to Greater Sum Tree</span>
Input: root = [4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]
Output: [30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]
Input: root = [0,null,1]
Output: [1,null,1]
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
     public TreeNode bstToGst(TreeNode root) {
        traverse(root);
        return root;
    }
    
    
    //OUR SUM FOR EACH NODE IS
    //START FROM THE MOST RIGHT NODE AND SUM IT UP
    //SUM OF THE MOST RIGHT NODE + SUM OF NODE
    //GO RIGHT RIGHT RIGHT--> SUM + NODE.VAL
    //GO LEFT.... GO RIGHT RIGHT RIGHT--> SUM + NODE.VAL
    int sum = 0;
    private void traverse(TreeNode root) {
        if(root == null) return;
        
        traverse(root.right);
        sum = sum + root.val;
        root.val = sum;
        traverse(root.left);
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">1026. Maximum Difference Between Node and Ancestor</span>
Input: root = [8,3,10,1,6,null,14,null,null,4,7,13]
Output: 7
Explanation: We have various ancestor-node differences, some of which are given below :
|8 - 3| = 5
|3 - 7| = 4
|8 - 1| = 7
|10 - 13| = 3
Among all possible differences, the maximum value of 7 is obtained by |8 - 1| = 7.
Input: root = [1,null,2,null,0,3]
Output: 3
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
   int ret = 0;
    public int maxAncestorDiff(TreeNode root) {
        helper(root, root.val, root.val);
        return ret;
    }
    private void helper(TreeNode curr, int min, int max){
        if(curr != null){
            ret = Math.max(ret, Math.abs(min - curr.val));
            ret = Math.max(ret, Math.abs(max - curr.val));
            if(curr.left != null)
                helper(curr.left, Math.min(min, curr.left.val), Math.max(max, curr.left.val));
            if(curr.right != null)
                helper(curr.right, Math.min(min, curr.right.val), Math.max(max, curr.right.val));
        }
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">1019. Next Greater Node In Linked List</span>
Input: head = [2,1,5]
Output: [5,5,0]
Input: head = [2,7,4,3,5]
Output: [7,0,5,5,0]
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public int[] nextLargerNodes(ListNode head) {
          ArrayList<Integer> list = new ArrayList<>();
        
        for(ListNode ptr = head; ptr != null ; ptr = ptr.next) 
            list.add(ptr.val);
        
        int[] ans = new int[list.size()];
        Stack<Integer> stack = new Stack<>();
        
        for(int i=0;i< ans.length;i++) {
            while(!stack.isEmpty() && list.get(i) > list.get(stack.peek()))
            {
                ans[stack.pop()] = list.get(i);
            }
            stack.push(i);
        }
        
        return ans;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">1325. Delete Leaves With a Given Value</span>
Input: root = [1,2,3,2,null,2,4], target = 2
Output: [1,null,3,null,4]
Explanation: Leaf nodes in green with value (target = 2) are removed (Picture in left). 
After removing, new nodes become leaf nodes with value (target = 2) (Picture in center).
Input: root = [1,3,3,3,2], target = 3
Output: [1,3,null,null,2]
Input: root = [1,2,null,2,null,2], target = 2
Output: [1]
Explanation: Leaf nodes in green with value (target = 2) are removed at each step.
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public TreeNode removeLeafNodes(TreeNode root, int target) {
        if(root==null) {
            return null;
        }
        TreeNode left = removeLeafNodes(root.left,target);
        TreeNode right = removeLeafNodes(root.right,target);
        if(left==null && right==null && root.val==target) {
            return null;
        }
        root.left=left;
        root.right=right;
        return root;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">1338. Reduce Array Size to The Half</span>
Input: arr = [3,3,3,3,5,5,5,2,2,7]
Output: 2
Explanation: Choosing {3,7} will make the new array [5,5,5,2,2] which has size 5 
(i.e equal to half of the size of the old array).
Possible sets of size 2 are {3,5},{3,2},{5,2}.
Choosing set {2,7} is not possible as it will make the new array [3,3,3,3,5,5,5] 
which has a size greater than half of the size of the old array.
Input: arr = [7,7,7,7,7,7]
Output: 1
Explanation: The only possible set you can choose is {7}. This will make the new array empty.
class Solution {
    public int minSetSize(int[] arr) {
       HashMap<Integer,Integer> map=new HashMap<>();
		for(int i=0;i< arr.length;i++){
			map.put(arr[i],map.getOrDefault(arr[i],0)+1);
		}

		// Create a Freq Arr. Eg : [7,7,7,3,3,3] so freq[3] will store 2 , so I will make a freq arr where each index represents frequency to a no and freq[i] -> how many times that freq is encountered.
		int [] freqarr=new int[100001];
		for(int key: map.keySet()){
			freqarr[map.get(key)]++; 
		}
		int size=arr.length;int count=0;
		for(int i=freqarr.length-1;i>=0 && size>arr.length/2;){ 
            // traverse array in rev order to greedily choose the max frequency
			if(freqarr[i]==0){
				i--;
			}else{ 
                // keep reducing the size till freq[i]==0 -> use up all high freq elements
				while(freqarr[i]!=0 && size>arr.length/2){
					size-=i;
					freqarr[i]--; 
					count++;
				}
				if(size<=arr.length/2) return count;
				i--;
			}
		}
		return count; 
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">1339. Maximum Product of Splitted Binary Tree</span>
Input: root = [1,2,3,4,5,6]
Output: 110
Explanation: Remove the red edge and get 2 binary trees 
with sum 11 and 10. Their product is 110 (11*10)
Input: root = [1,null,2,3,4,null,null,5,6]
Output: 90
Explanation: Remove the red edge and get 2 binary trees with 
sum 15 and 6.Their product is 90 (15*6)
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    static long sum;
    static long maxProd;
    public static void dfs(TreeNode root) {
        if(root == null) return;
        sum += (long)root.val;
        dfs(root.left);
        dfs(root.right);
    }
    public static long checkMax(TreeNode root) {
        if(root == null) return 0;
        long l = checkMax(root.left);
        long r = checkMax(root.right);
        maxProd = Math.max(maxProd, (l + r + root.val) * (sum - l - r - root.val));
        return l + r + root.val;
    }
    public int maxProduct(TreeNode root) {
        sum = 0;
        maxProd = 0;
        dfs(root);
        long rootProd = checkMax(root);
        return (int)(maxProd % ((int)Math.pow(10, 9) + 7));
        
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">1344. Angle Between Hands of a Clock</span>
Input: hour = 12, minutes = 30
Output: 165
Input: hour = 3, minutes = 30
Output: 75
Input: hour = 3, minutes = 15
Output: 7.5
class Solution {
    public double angleClock(int hour, int minutes) {
        final double hourHand = (hour % 12 + minutes / 60.0) * 30;
        final double minuteHand = minutes * 6;
        final double diff = Math.abs(hourHand - minuteHand);
        return Math.min(diff, 360 - diff);
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">1352. Product of the Last K Numbers</span>
Input
["ProductOfNumbers","add","add","add","add","add","getProduct","getProduct","getProduct","add","getProduct"]
[[],[3],[0],[2],[5],[4],[2],[3],[4],[8],[2]]

Output
[null,null,null,null,null,null,20,40,0,null,32]

Explanation
ProductOfNumbers productOfNumbers = new ProductOfNumbers();
productOfNumbers.add(3);        // [3]
productOfNumbers.add(0);        // [3,0]
productOfNumbers.add(2);        // [3,0,2]
productOfNumbers.add(5);        // [3,0,2,5]
productOfNumbers.add(4);        // [3,0,2,5,4]
productOfNumbers.getProduct(2); // return 20. The product of the last 2 numbers is 5 * 4 = 20
productOfNumbers.getProduct(3); // return 40. The product of the last 3 numbers is 2 * 5 * 4 = 40
productOfNumbers.getProduct(4); // return 0. The product of the last 4 numbers is 0 * 2 * 5 * 4 = 0
productOfNumbers.add(8);        // [3,0,2,5,4,8]
productOfNumbers.getProduct(2); // return 32. The product of the last 2 numbers is 4 * 8 = 32 
class ProductOfNumbers {
    final List<Integer> list;
    int lastProduct;
    public ProductOfNumbers() {
        this.list = new ArrayList<Integer>();
        lastProduct = 1;
    }
    
    public void add(int num) {
        if(num == 0){
            list.clear();
            lastProduct = 1;
        }    
        else{
            lastProduct = lastProduct * num;
            list.add(lastProduct);
        }
    }
    
    public int getProduct(int k) {
        int idx = list.size() - k;
        if(idx > 0){
            return lastProduct / list.get(idx - 1);
        }
        if(idx == 0){
            return lastProduct;
        }
        return 0;
    }
}
/**
 * Your ProductOfNumbers object will be instantiated and called as such:
 * ProductOfNumbers obj = new ProductOfNumbers();
 * obj.add(num);
 * int param_2 = obj.getProduct(k);
 */
 <span id="line">---------------------------------------------------------------</span>
 <span class="textStyle">1315. Sum of Nodes with Even-Valued Grandparent</span>
Input: root = [6,7,8,2,7,1,3,9,null,1,4,null,null,null,5]
Output: 18
Explanation: The red nodes are the nodes with even-value grandparent while the blue nodes are the even-value grandparents.
Input: root = [1]
Output: 0
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    int count=0;
    public void traverse(TreeNode root,TreeNode parent,TreeNode grandparent){
        if(root==null)
            return;
        if(grandparent!=null && grandparent.val%2==0)
            count+=root.val;
        traverse(root.left,root,parent);
        traverse(root.right,root,parent);
        
    }
    public int sumEvenGrandparent(TreeNode root) {
        count=0;
        traverse(root,null,null);
        return count;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">1314. Matrix Block Sum</span>
Input: mat = [[1,2,3],[4,5,6],[7,8,9]], k = 1
Output: [[12,21,16],[27,45,33],[24,39,28]]
Input: mat = [[1,2,3],[4,5,6],[7,8,9]], k = 2
Output: [[45,45,45],[45,45,45],[45,45,45]]
class Solution {
     public int[][] matrixBlockSum(int[][] mat, int k) {
        int[][] res = new int[mat.length][mat[0].length];
        for (int i = 0; i < mat.length; i++)
            for (int j = 0; j < mat[0].length; j++)
                res[i][j]=sumMat(k,mat,i,j);

        return res;
    }

    int sumMat(int k, int[][] mat, int i, int j) {
        int sum = 0;
        for (int a = i - k; a <= i + k; a++)
            if (a >= 0 && mat.length > a)
                for (int b = j - k; b <= j + k; b++)
                    if (b >= 0 && mat[0].length > b)
                        sum+=mat[a][b];

        return sum;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">1305. All Elements in Two Binary Search Trees</span>
Input: root1 = [2,1,4], root2 = [1,0,3]
Output: [0,1,1,2,3,4]
Input: root1 = [1,null,8], root2 = [8,1]
Output: [1,1,8,8]
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public List<Integer> getAllElements(TreeNode root1, TreeNode root2) { 
        ArrayList<Integer> list = new ArrayList<>();
        helper(root1, list);
        helper(root2, list);
        Collections.sort(list);
        return list;
    }
    public void helper(TreeNode root, ArrayList<Integer> l){
        if(root==null)
            return;
        l.add(root.val);
        helper(root.left,l);
        helper(root.right,l);
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">1297. Maximum Number of Occurrences of a Substring</span>
Input: s = "aababcaab", maxLetters = 2, minSize = 3, maxSize = 4
Output: 2
Explanation: Substring "aab" has 2 ocurrences in the original string.
It satisfies the conditions, 2 unique letters and size 3 (between minSize and maxSize).
Input: s = "aaaa", maxLetters = 1, minSize = 3, maxSize = 3
Output: 2
Explanation: Substring "aaa" occur 2 times in the string. It can overlap.
class Solution {
    public int maxFreq(String s, int maxLetters, int minSize, int maxSize) {
        Map<String, Integer> res = new HashMap<>();
        Map<Character, Integer> map = new HashMap<>();
        int left = 0, right = 0;
        int max = 0;
        
        while(right < s.length()) {
            char curr = s.charAt(right);
            map.put(curr, map.getOrDefault(curr, 0) + 1);

            while(map.size() > maxLetters || right - left + 1 > maxSize) {
                char leftChar = s.charAt(left);
                map.put(leftChar, map.get(leftChar) - 1);
                if(map.get(leftChar) == 0) {
                    map.remove(leftChar);
                }
                left++;
            }
            while(map.size() <= maxLetters && right - left + 1 >= minSize 
               && right - left + 1 <= maxSize) {
                String str = s.substring(left, right + 1);
                res.put(str, res.getOrDefault(str ,0) + 1);
                max = Math.max(max, res.get(str));
                
                char leftChar = s.charAt(left);
                map.put(leftChar, map.get(leftChar) - 1);
                if(map.get(leftChar) == 0) {
                    map.remove(leftChar);
                }
                left++;
            }
            right++;
        }
        return max; 
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">1291. Sequential Digits</span>
Input: low = 100, high = 300
Output: [123,234]
Input: low = 1000, high = 13000
Output: [1234,2345,3456,4567,5678,6789,12345]
class Solution {
    public List<Integer> sequentialDigits(int low, int high) {
        int[] allNums = {12,23,34,45,56,67,78,89,
                         123,234,345,456,567,678,789,
                         1234,2345,3456,4567,5678,6789,
                         12345,23456,34567,45678,56789,
                         123456,234567,345678,456789,
                         1234567,2345678,3456789,
                         12345678,23456789,
                         123456789};
        List<Integer> res = new ArrayList<>();
        int n = allNums.length;
        for (int i = 0; i < n; i++) {
            if (allNums[i] < low) continue;
            if (allNums[i] > high) break;
            res.add(allNums[i]);
        }
        return res; 
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">1451. Rearrange Words in a Sentence</span>
Input: text = "Leetcode is cool"
Output: "Is cool leetcode"
Explanation: There are 3 words, "Leetcode" of length 8, "is" of length 2 and "cool" of length 4.
Output is ordered by length and the new first word starts with capital letter.
Input: text = "Keep calm and code on"
Output: "On and keep calm code"
Explanation: Output is ordered as follows:
"On" 2 letters.
"and" 3 letters.
"keep" 4 letters in case of tie order by position in original text.
"calm" 4 letters.
"code" 4 letters.
Input: text = "To be or not to be"
Output: "To be or to be not"
class Solution {
    public String arrangeWords(String text) {
          String []s = text.toLowerCase().split(" ");
        Arrays.sort(s, (a,b) ->  a.length() - b.length());
        String ans = String.join(" ", s);
        return Character.toUpperCase(ans.charAt(0)) + ans.substring(1); 
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">1438. Longest Continuous Subarray With Absolute Diff Less Than or Equal to Limit</span>
Input: nums = [8,2,4,7], limit = 4
Output: 2 
Explanation: All subarrays are: 
[8] with maximum absolute diff |8-8| = 0 <= 4.
[8,2] with maximum absolute diff |8-2| = 6 > 4. 
[8,2,4] with maximum absolute diff |8-2| = 6 > 4.
[8,2,4,7] with maximum absolute diff |8-2| = 6 > 4.
[2] with maximum absolute diff |2-2| = 0 <= 4.
[2,4] with maximum absolute diff |2-4| = 2 <= 4.
[2,4,7] with maximum absolute diff |2-7| = 5 > 4.
[4] with maximum absolute diff |4-4| = 0 <= 4.
[4,7] with maximum absolute diff |4-7| = 3 <= 4.
[7] with maximum absolute diff |7-7| = 0 <= 4. 
Therefore, the size of the longest subarray is 2.
Input: nums = [10,1,2,4,7,2], limit = 5
Output: 4 
Explanation: The subarray [2,4,7,2] is the longest since the maximum absolute diff is |2-7| = 5 <= 5.
class Solution {
    public int longestSubarray(int[] nums, int limit) {
        Deque<Integer> maxDeque = new LinkedList<>();
        Deque<Integer> minDeque = new LinkedList<>();

        int res = 1;
        int l = 0;

        // find the longest subarray for every right pointer by shrinking               left pointer
        for (int r = 0; r < nums.length; ++r) {

	    // update maxDeque with new right pointer
	        while (!maxDeque.isEmpty() && maxDeque.peekLast() < nums[r]) {
		        maxDeque.removeLast();
	        }
	    maxDeque.addLast(nums[r]);

	// update minDeque with new right pointer
	while (!minDeque.isEmpty() && minDeque.peekLast() > nums[r]) {
		minDeque.removeLast();
	}
	minDeque.addLast(nums[r]);

	// shrink left pointer if exceed limit
	while (maxDeque.peekFirst() - minDeque.peekFirst() > limit) {
		if (maxDeque.peekFirst() == nums[l]) maxDeque.pollFirst();
		if (minDeque.peekFirst() == nums[l]) minDeque.pollFirst();
		++l;  // shrink it!
	}

	// update res
	res = Math.max(res, r - l + 1);
}

return res;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">1423. Maximum Points You Can Obtain from Cards</span>
Input: cardPoints = [1,2,3,4,5,6,1], k = 3
Output: 12
Explanation: After the first step, your score will always be 1. However, choosing the rightmost card first will maximize your total score. The optimal strategy is to take the three cards on the right, giving a final score of 1 + 6 + 5 = 12.
Input: cardPoints = [2,2,2], k = 2
Output: 4
Explanation: Regardless of which two cards you take, your score will always be 4.
Input: cardPoints = [9,7,7,9,7,7,9], k = 7
Output: 55
Explanation: You have to take all the cards. Your score is the sum of points of all cards.
class Solution {
    public int maxScore(int[] cardPoints, int k) {
        int n = cardPoints.length;
        int totalSum = 0, minSubarray = 0;

	    for (int i=0, currSum=0; i< n; i++) {
		    totalSum += cardPoints[i];
		    currSum += cardPoints[i];
		    if (i < n-k){
                 minSubarray += cardPoints[i];
            }else {
			    currSum -= cardPoints[i-(n-k)];
			    minSubarray = Math.min(minSubarray, currSum);
		    }
	    }
	    return totalSum - minSubarray;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">1395. Count Number of Teams</span>
Input: rating = [2,5,3,4,1]
Output: 3
Explanation: We can form three teams given the conditions. (2,3,4), (5,4,1), (5,3,1). 
Input: rating = [2,1,3]
Output: 0
Explanation: We can't form any team given the conditions.
Input: rating = [1,2,3,4]
Output: 4
class Solution {
    public int numTeams(int[] rating) {
        if(rating == null || rating.length == 0){
            return 0;
        }
        int len = rating.length;
        int[] dp = new int[len];
        int count = 0;

        // first < r[i] < r[j] < r[k] order
        for(int i = 0; i < len; i++){
            for(int j = i; j >= 0; j--){
                if(rating[i] > rating[j]){
                    dp[i]++;
                    count = count + dp[j];
                }
            }
        }
        
        //System.out.println(count);
        dp = new int[len];
        
        for(int i = 0; i < len; i++){
            for(int j = i; j >= 0; j--){
                if(rating[i] < rating[j]){
                    dp[i]++;
                    count = count + dp[j];
                }
            }
        }
        return count;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">1386. Cinema Seat Allocation</span>
Input: n = 3, reservedSeats = [[1,2],[1,3],[1,8],[2,6],[3,1],[3,10]]
Output: 4
Explanation: The figure above shows the optimal allocation for four groups, where seats mark with blue are already reserved and contiguous seats mark with orange are for one group.
Input: n = 2, reservedSeats = [[2,1],[1,8],[2,6]]
Output: 2
Input: n = 4, reservedSeats = [[4,3],[1,4],[4,6],[1,7]]
Output: 4
class Solution {
    public int maxNumberOfFamilies(int n, int[][] reservedSeats) {
        Map<Integer, Integer> graph = new HashMap<>();
        for (int[] reserved : reservedSeats) {
            int row = reserved[0];
            int col = reserved[1];
            graph.put(row, graph.getOrDefault(row, 0) | (1 << col)); 
            // create a bit vector of reserved seats
        }
        int max = 0;
        for (int row : graph.keySet()) {
            int reserved = graph.get(row);
            int cnt = 0;
            if ((reserved &  60) == 0) cnt += 1; 
            // check if seats 2,3,4,5 are available
            if ((reserved & 960) == 0) cnt += 1; 
            // check if seats 6,7,8,9 are available
            if ((reserved & 240) == 0 && cnt == 0) cnt = 1; 
            // check if seats 4,5,6,7 are available
            max += cnt;
        }
        return max + 2 * (n - graph.size());
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">1376. Time Needed to Inform All Employees</span>
Input: n = 1, headID = 0, manager = [-1], informTime = [0]
Output: 0
Explanation: The head of the company is the only employee in the company.
Input: n = 6, headID = 2, manager = [2,2,-1,2,2,2], informTime = [0,0,1,0,0,0]
Output: 1
Explanation: The head of the company with id = 2 is the direct manager of all the employees 
				in the company and needs 1 minute to inform them all.
The tree structure of the employees in the company is shown.
class Solution {
    public int numOfMinutes(int n, int headID, int[] manager, int[] informTime) {
        Map<Integer, List<Integer>> map = new HashMap<>();
        for(int i = 0; i < n; i++){
            map.putIfAbsent(manager[i], new ArrayList<>());
            map.get(manager[i]).add(i);
        }
        return helper(informTime, map, headID);
    }
    
    private int helper(int[] informTime, Map< Integer, List< Integer>> map, int curr){
        if(!map.containsKey(curr)) return 0;
        
        int min = 0;
        List<Integer> list = map.get(curr);
        
        for(int i = 0; i < list.size(); i++){
            min = Math.max(helper(informTime, map, list.get(i)), min);
        }
        
        return min + informTime[curr];
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">1372. Longest ZigZag Path in a Binary Tree</span>
Input: root = [1,null,1,1,1,null,null,1,1,null,1,null,null,null,1,null,1]
Output: 3
Explanation: Longest ZigZag path in blue nodes (right -> left -> right).
Input: root = [1,1,1,null,1,null,null,1,1,null,1]
Output: 4
Explanation: Longest ZigZag path in blue nodes (left -> right -> left -> right).
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    int MAX;
    Map<TreeNode, int []> dp;
    public int longestZigZag(TreeNode root) {
        //postorder traversal
        //Map stores left from node and right from node
        dp = new HashMap<>();
        dfs(root);
        return MAX;
    }

    //returns max length from here if you go in a particular direction
    private void dfs(TreeNode root){
        if(root == null) return;

        if(root.left == null && root.right == null){
            dp.put(root, new int[]{0,0});
            return;
        }
        //In dp value int []
        //index 0 represents left direction
        //index 1 represents right direction
        dfs(root.left);
        dfs(root.right);

        int left = 0, right = 0;

        if(dp.get(root.left) != null)
            left = 1 + dp.get(root.left)[1]; //we go right after left
        
        if(dp.get(root.right) != null)
            right = 1 + dp.get(root.right)[0]; //we go left after right
        dp.put(root, new int[]{left, right});
        MAX = Math.max(MAX, Math.max(left,right));
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">1367. Linked List in Binary Tree</span>
Input: head = [4,2,8], root = [1,4,4,null,2,2,null,1,null,6,8,null,null,null,null,1,3]
Output: true
Explanation: Nodes in blue form a subpath in the binary Tree.  
Input: head = [1,4,2,6], root = [1,4,4,null,2,2,null,1,null,6,8,null,null,null,null,1,3]
Output: true
Input: head = [1,4,2,6,8], root = [1,4,4,null,2,2,null,1,null,6,8,null,null,null,null,1,3]
Output: false
Explanation: There is no path in the binary tree that contains all the elements of the linked list from head.
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public boolean isSubPath(ListNode head, TreeNode root) {
        if (head == null) return true;
        if (root == null) return false;
        return dfs(head, root) || isSubPath(head, root.left) || isSubPath(head, root.right);
    }
    private boolean dfs(ListNode head, TreeNode root) {
        if (head == null) return true;
        if (root == null) return false;
        return head.val == root.val && (dfs(head.next, root.left) || dfs(head.next, root.right));  
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">1362. Closest Divisors</span>
Input: num = 8
Output: [3,3]
Explanation: For num + 1 = 9, the closest divisors are 3 & 3, for num + 2 = 10, the closest divisors are 2 & 5, hence 3 & 3 is chosen.
Input: num = 123
Output: [5,25]
Input: num = 999
Output: [40,25]
class Solution {
   public int[] closestDivisors(int num) {
        int[] v1 = calculateClosestFactors(num+1);
        int[] v2 = calculateClosestFactors(num+2);
        return v1[1]-v2[0]< v2[1]-v2[0]?v1:v2;
    }

    private int[] calculateClosestFactors(int num) {
        int sqrt = (int)(Math.sqrt(num));
        for (int v1=sqrt;v1>=1;v1--) {
            int v2 = num/v1;
            if(num%v1==0 && num%v2==0) {
                return new int[]{v1,v2};
            }
        }
        return new int[]{0,Integer.MAX_VALUE};
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">1574. Shortest Subarray to be Removed to Make Array Sorted</span>
Input: arr = [1,2,3,10,4,2,3,5]
Output: 3
Explanation: The shortest subarray we can remove is [10,4,2] of length 3. The remaining elements after that will be [1,2,3,3,5] which are sorted.
Another correct solution is to remove the subarray [3,10,4].
Input: arr = [5,4,3,2,1]
Output: 4
Explanation: Since the array is strictly decreasing, we can only keep a single element. Therefore we need to remove a subarray of length 4, either [5,4,3,2] or [4,3,2,1].
Input: arr = [1,2,3]
Output: 0
Explanation: The array is already non-decreasing. We do not need to remove any elements.
class Solution {
    public int findLengthOfShortestSubarray(int[] arr) {
         int left = 0;
        while(left + 1 < arr.length && arr[left] <= arr[left+1]) left++;
        if(left == arr.length - 1) return 0;
        
        int right = arr.length - 1;
        while(right > left && arr[right-1] <= arr[right]) right--;
        int result = Math.min(arr.length - left - 1, right);
        
        int i = 0;
        int j = right;
        while(i <= left && j < arr.length) {
            if(arr[j] >= arr[i]) {
                result = Math.min(result, j - i - 1);
                i++;
            }else {
                j++;
            }   
        }
        return result;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">1567. Maximum Length of Subarray With Positive Product</span>
Input: nums = [1,-2,-3,4]
Output: 4
Explanation: The array nums already has a positive product of 24.
Input: nums = [0,1,-2,-3,-4]
Output: 3
Explanation: The longest subarray with positive product is [1,-2,-3] which has a product of 6.
Notice that we cannot include 0 in the subarray since that'll make the product 0 which is not positive.
Input: nums = [-1,-2,-3,0,1]
Output: 2
Explanation: The longest subarray with positive product is [-1,-2] or [-2,-3].
class Solution {
    public int getMaxLen(int[] nums) {
        int positive = 0, negative = 0;    // length of positive and negative results
        int ans = 0;
        for(int x : nums) {
            if(x == 0)  {
                positive = 0;
                negative = 0;
            }
            else if(x > 0) {
                positive++;
                negative = negative == 0 ? 0  : negative+1;
            }
            else {
                int temp = positive;
                positive = negative == 0 ? 0  : negative+1;
                negative = temp+1;
            }
            ans = Math.max(ans, positive);
        }
        return ans; 
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">1558. Minimum Numbers of Function Calls to Make Target Array</span>
Input: nums = [1,5]
Output: 5
Explanation: Increment by 1 (second element): [0, 0] to get [0, 1] (1 operation).
Double all the elements: [0, 1] -> [0, 2] -> [0, 4] (2 operations).
Increment by 1 (both elements)  [0, 4] -> [1, 4] -> [1, 5] (2 operations).
Total of operations: 1 + 2 + 2 = 5.
Input: nums = [2,2]
Output: 3
Explanation: Increment by 1 (both elements) [0, 0] -> [0, 1] -> [1, 1] (2 operations).
Double all the elements: [1, 1] -> [2, 2] (1 operation).
Total of operations: 2 + 1 = 3.
Input: nums = [4,2,5]
Output: 6
Explanation: (initial)[0,0,0] -> [1,0,0] -> [1,0,1] -> [2,0,2] -> [2,1,2] -> [4,2,4] -> [4,2,5](nums).
class Solution {
   int maxOpOne = Integer.MIN_VALUE;
    public int minOperations(int[] nums) {
        int res = 0;
        for (int n : nums) res += getOpZero(n);
        return res + maxOpOne;
    }
    
    private int getOpZero(int n) {
        int res = 0, opOne = 0;
        while (n > 0) {
            res += n % 2; // op == 0;
            n /= 2;
            if (n > 0) opOne++; // op == 1;
        }
        maxOpOne = Math.max(maxOpOne, opOne);
        return res;
        
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">1557. Minimum Number of Vertices to Reach All Nodes</span>
Input: n = 6, edges = [[0,1],[0,2],[2,5],[3,4],[4,2]]
Output: [0,3]
Explanation: It's not possible to reach all the nodes from a single vertex. From 0 we can reach [0,1,2,5]. From 3 we can reach [3,4,2,5]. So we output [0,3].
Input: n = 5, edges = [[0,1],[2,1],[3,1],[1,4],[2,4]]
Output: [0,2,3]
Explanation: Notice that vertices 0, 3 and 2 are not reachable from any other node, so we must include them. Also any of these vertices can reach nodes 1 and 4.
class Solution {
    public static int findParent(int[] parent, int i) {
        if(parent[i] == i) return i;
        return parent[i] = findParent(parent, parent[i]);
    }
    public List<Integer> findSmallestSetOfVertices(int n, List<List<Integer>> edges) {
        int[] parent = new int[n];
        boolean[] visited = new boolean[n];
        for(int i = 0; i < n; i++) parent[i] = i;
        for(int i = 0; i < edges.size(); i++) {
            List<Integer> curr = edges.get(i);
            int sv = curr.get(0);
            int ev = curr.get(1);
            if(visited[ev]) continue;
            int p1 = findParent(parent, sv);
            int p2 = findParent(parent, ev);
            parent[p2] = p1; 
            visited[ev] = true;
        }
        List<Integer> ans = new ArrayList<>();
        for(int i = 0; i < n; i++) if(parent[i] == i) ans.add(i);
        return ans;
        
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">1525. Number of Good Ways to Split a String</span>
Input: s = "aacaba"
Output: 2
Explanation: There are 5 ways to split "aacaba" and 2 of them are good. 
("a", "acaba") Left string and right string contains 1 and 3 different letters respectively.
("aa", "caba") Left string and right string contains 1 and 3 different letters respectively.
("aac", "aba") Left string and right string contains 2 and 2 different letters respectively (good split).
("aaca", "ba") Left string and right string contains 2 and 2 different letters respectively (good split).
("aacab", "a") Left string and right string contains 3 and 1 different letters respectively.
Input: s = "abcd"
Output: 1
Explanation: Split the string as follows ("ab", "cd").
class Solution {
    public int numSplits(String s) {
        int rc[] = new int[26], lc[] = new int[26];
        int l = 0, r = 0, res = 0;
        for (char c : s.toCharArray()) if (rc[c - 'a']++ == 0) r++;
        for (char c : s.toCharArray()) {
            if (lc[c - 'a']++ == 0) l++;
            if (--rc[c - 'a'] == 0) r--;
            if (l == r) res++;
        }
        return res;  
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">1492. The kth Factor of n</span>
Input: n = 12, k = 3
Output: 3
Explanation: Factors list is [1, 2, 3, 4, 6, 12], the 3rd factor is 3.
Input: n = 7, k = 2
Output: 7
Explanation: Factors list is [1, 7], the 2nd factor is 7.
Input: n = 4, k = 4
Output: -1
Explanation: Factors list is [1, 2, 4], there is only 3 factors. We should return -1.
class Solution {
    public int kthFactor(int n, int k) {
        int cnt = 0;
        List<Integer> l = new ArrayList<>();
        for(int i = 1; i * i <= n; i++) {
            if (n % i == 0) {
                if (i * i != n) l.add(n / i);
                if (++cnt == k) return i;
            }
        }
        if (l.size() + cnt < k) return -1;
        return l.get(l.size() - (k - cnt)); 
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">1481. Least Number of Unique Integers after K Removals</span>
Input: arr = [5,5,4], k = 1
Output: 1
Explanation: Remove the single 4, only 5 is left.
Input: arr = [4,3,1,1,3,3,2], k = 3
Output: 2
Explanation: Remove 4, 2 and either one of the two 1s or three 3s. 1 and 3 will be left.
class Solution {
    public int findLeastNumOfUniqueInts(int[] arr, int k) {
         Arrays.sort(arr);
        int a =0;
        int max = arr[arr.length-1];
        for(int i =arr.length-1 ; i>=0 ; i--){
            if(arr[i]==max) a++;
            else break;
        }
        ArrayList <Integer> ls = new ArrayList<>();
        HashSet <Integer> hs = new HashSet<>();
        int c =0;
        for (int i = 0; i < arr.length ; i++) {
            int len = hs.size();
            hs.add(arr[i]);
            if(hs.size()==len) {
                c++;
            }
            else{
                ls.add(c+1);
                c=0;
            }
        }
        ls.add(a);
        ls.remove(0);
        Collections.sort(ls);
        int count =k , ans=0;
        for (int i = 0; i < ls.size() ; i++) {
            if(ls.get(i)-count<=0){
                count -= ls.get(i);
                ans++;
            }
            else{
                break;
            }
        }
        return ls.size()-ans;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">1472. Design Browser History</span>
Input:
["BrowserHistory","visit","visit","visit","back","back","forward","visit","forward","back","back"]
[["leetcode.com"],["google.com"],["facebook.com"],["youtube.com"],[1],[1],[1],["linkedin.com"],[2],[2],[7]]
Output:
[null,null,null,null,"facebook.com","google.com","facebook.com",null,"linkedin.com","google.com","leetcode.com"]

Explanation:
BrowserHistory browserHistory = new BrowserHistory("leetcode.com");
browserHistory.visit("google.com");       // You are in "leetcode.com". Visit "google.com"
browserHistory.visit("facebook.com");     // You are in "google.com". Visit "facebook.com"
browserHistory.visit("youtube.com");      // You are in "facebook.com". Visit "youtube.com"
browserHistory.back(1);                   // You are in "youtube.com", move back to "facebook.com" return "facebook.com"
browserHistory.back(1);                   // You are in "facebook.com", move back to "google.com" return "google.com"
browserHistory.forward(1);                // You are in "google.com", move forward to "facebook.com" return "facebook.com"
browserHistory.visit("linkedin.com");     // You are in "facebook.com". Visit "linkedin.com"
browserHistory.forward(2);                // You are in "linkedin.com", you cannot move forward any steps.
browserHistory.back(2);                   // You are in "linkedin.com", move back two steps to "facebook.com" then to "google.com". return "google.com"
browserHistory.back(7);                   // You are in "google.com", you can move back only one step to "leetcode.com". return "leetcode.com"
class BrowserHistory {
 private Stack<String> back;
    private Stack<String> forward;
    private String curPage = "";
    public BrowserHistory(String homepage) {
        back = new Stack<>();
        curPage = homepage;
        forward = new Stack<>();
    }
    public void visit(String url) {
        if (curPage != "") back.push(curPage);
        curPage = url;
        forward = new Stack<>();
    }
    public String back(int steps) {
        while (!back.isEmpty() && steps-- != 0) {
            forward.push(curPage);
            curPage = back.pop();
        }
        return curPage;
    }
    public String forward(int steps) {
        if (forward.isEmpty()) return curPage;  
        while (!forward.isEmpty() && steps-- != 0) {
            back.push(curPage);
            curPage = forward.pop();
        }
        return curPage;
    }
}

/**
 * Your BrowserHistory object will be instantiated and called as such:
 * BrowserHistory obj = new BrowserHistory(homepage);
 * obj.visit(url);
 * String param_2 = obj.back(steps);
 * String param_3 = obj.forward(steps);
 */
 <span id="line">---------------------------------------------------------------</span>
 <span class="textStyle">1466. Reorder Routes to Make All Paths Lead to the City Zero</span>
Input: n = 6, connections = [[0,1],[1,3],[2,3],[4,0],[4,5]]
Output: 3
Explanation: Change the direction of edges show in red such that each node can reach the node 0 (capital).
 Input: n = 5, connections = [[1,0],[1,2],[3,2],[3,4]]
Output: 2
Explanation: Change the direction of edges show in red such that each node can reach the node 0 (capital).
class Solution {
    public int minReorder(int n, int[][] connections) {
        Set<String> st = new HashSet<>();
        Map<Integer, Set<Integer>> map = new HashMap<>();
        for (int[] c : connections) {
            st.add(c[0] + "," + c[1]);
            map.computeIfAbsent(c[0], k -> new HashSet<>());
            map.computeIfAbsent(c[1], k -> new HashSet<>());
            map.get(c[0]).add(c[1]);
            map.get(c[1]).add(c[0]);
        }
        
        Queue<Integer> q = new LinkedList<>();
        q.add(0);
        int res = 0;
        boolean[] vs = new boolean[n];
        vs[0] = true;
        while (!q.isEmpty()) {
            int c = q.poll();
            for (int next : map.getOrDefault(c, new HashSet<>())) {
                if (vs[next]) continue;
                vs[next] = true;
                if (!st.contains(next + "," + c)) res++;
                q.offer(next);
            }
        }
        return res;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">1456. Maximum Number of Vowels in a Substring of Given Length</span>
Input: s = "abciiidef", k = 3
Output: 3
Explanation: The substring "iii" contains 3 vowel letters.
Input: s = "aeiou", k = 2
Output: 2
Explanation: Any substring of length 2 contains 2 vowels.
Input: s = "leetcode", k = 3
Output: 2
Explanation: "lee", "eet" and "ode" contain 2 vowels.
class Solution {
   
        public static boolean check(char ch) {
        return (ch == 'a' || ch == 'e' || ch == 'i' | ch == 'o' || ch == 'u');
    }
    public int maxVowels(String s, int k) {
        int max = 0, n = s.length();
        int count = 0;
        for(int i = 0; i < k; i++) {
            if(check(s.charAt(i))) count++;
        }
        max = count;
		// build first window size k
        for(int  i = k; i < n; i++) {
			// remove the contribution of the (i - k)th character which is no longer in the window
            if(check(s.charAt(i - k))) count--;
			// add the contribution of the current character
            if(check(s.charAt(i))) count++;
			// update max at for each window of size k
            max = Math.max(max, count);
        }
        return max;
    }
}
<span id="line">---------------------------------------------------------------</span>

<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">2485. Find the Pivot Integer</span>
Input: n = 8
Output: 6
Explanation: 6 is the pivot integer since: 1 + 2 + 3 + 4 + 5 + 6 = 6 + 7 + 8 = 21.
Input: n = 1
Output: 1
Explanation: 1 is the pivot integer since: 1 = 1.
class Solution {
       public int pivotInteger(int n) {
        int rightSum = n * (n + 1) / 2;
        for (int i = 1, leftSum = 0; i <= n; ++i) {
            rightSum -= i;
            if (leftSum == rightSum) {
                return i;
            }else if (leftSum > rightSum) {
                return -1;
            }
            leftSum += i;
        }
        return -1;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">1769. Minimum Number of Operations to Move All Balls to Each Box</span>
Input: boxes = "110"
Output: [1,1,3]
Explanation: The answer for each box is as follows:
1) First box: you will have to move one ball from the second box to the first box in one operation.
2) Second box: you will have to move one ball from the first box to the second box in one operation.
3) Third box: you will have to move one ball from the first box to the third box in two operations, and move one ball from the second box to the third box in one operation.
Input: boxes = "001011"
Output: [11,8,5,4,3,4]
class Solution {
    public int[] minOperations(String boxes) {
         //ok i understood the problem
        //create an returning array of size bixes.length
        
        int n=boxes.length();
        int ans[]=new int[n];
        
//         for(int i=0;i< n;i++)
//         {
//             int x=0;
//             for(int j=0;j< n;j++)
//             {
//                 if(boxes.charAt(j)=='1')
//                     x+=Math.abs(i-j);
//             }
//             ans[i]=x;
//         }
//         return ans;
        
        //Another approach
        //calculating sum approach
        //taking example of "001011" where for first char i have 3 1's totaling 2+4+5=11
        //now for char at 2. i have to substract 3 as all 1's need less 1 times so total 3 place and result will be 11-3=8
        //similarly for next it will be 8-3=5
        //now at index = 3, i can see there are 2 balls that will take 5 operations for index 2 and there is 1 ball on the left which will need to traverse 1 step ahaed then total steps = 5 - 2 + 1 => 4
        
        int count=0,sum=0;
        
        for(int i=0;i< n;i++)
        {
            if(boxes.charAt(i)=='1')
            {count++;sum+=i;}
        }
        ans[0]=sum;
        
        int backcount=0;
        if(boxes.charAt(0)=='1')
            {count--;backcount++;}
        
        for(int i=1;i< n;i++)
        {
            ans[i]=ans[i-1]-count+backcount;
            if(boxes.charAt(i)=='1')
            {count--;backcount++;}
        }
        return ans; 
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">1764. Form Array by Concatenating Subarrays of Another Array</span>
Input: groups = [[1,-1,-1],[3,-2,0]], nums = [1,-1,0,1,-1,-1,3,-2,0]
Output: true
Explanation: You can choose the 0th subarray as [1,-1,0,1,-1,-1,3,-2,0] and the 1st one as [1,-1,0,1,-1,-1,3,-2,0].
These subarrays are disjoint as they share no common nums[k] element.
Input: groups = [[10,-2],[1,2,3,4]], nums = [1,2,3,4,10,-2]
Output: false
Explanation: Note that choosing the subarrays [1,2,3,4,10,-2] and [1,2,3,4,10,-2] is incorrect because they are not in the same order as in groups.
[10,-2] must come before [1,2,3,4].
Input: groups = [[1,2,3],[3,4]], nums = [7,7,1,2,3,4,7,7]
Output: false
Explanation: Note that choosing the subarrays [7,7,1,2,3,4,7,7] and [7,7,1,2,3,4,7,7] is invalid because they are not disjoint.
They share a common elements nums[4] (0-indexed).
class Solution {
    public boolean canChoose(int[][] groups, int[] nums) {
        int i=0;
        for(int start =0;i < groups.length && groups[i].length+start <= nums.length;start++)
            if(search(groups[i], nums, start)) 
                start += groups[i++].length - 1;
        return i==groups.length;
    }
    private boolean search(int[] group, int[] nums, int start) {
        for(int i=0;i< group.length;i++) 
            if(group[i] != nums[i+start])
                return false;
        return true;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">1749. Maximum Absolute Sum of Any Subarray</span>
Input: nums = [1,-3,2,3,-4]
Output: 5
Explanation: The subarray [2,3] has absolute sum = abs(2+3) = abs(5) = 5.
Input: nums = [2,-5,1,-4,3,-2]
Output: 8
Explanation: The subarray [-5,1,-4] has absolute sum = abs(-5+1-4) = abs(-8) = 8.
class Solution {
    public int maxAbsoluteSum(int[] nums) {
          int min=0;
        int max=0;
        int c=0;
        for(int i=0;i< nums.length;i++){
            c+=nums[i];
            if(max< c) max=c;
            if(c< 0) c=0;
        }
        c=0;
        for(int i=0;i< nums.length;i++){
            c+=nums[i];
            if(min>c) min=c;
            if(c>0) c=0;
        }return Math.max(Math.abs(max),Math.abs(min));
    }
}

<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">1721. Swapping Nodes in a Linked List</span>
Input: head = [1,2,3,4,5], k = 2
Output: [1,4,3,2,5]
Input: head = [7,9,6,6,7,8,3,0,9,5], k = 5
Output: [7,9,6,6,8,7,3,0,9,5]
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode swapNodes(ListNode head, int k) {
          ListNode s = head;
        ListNode f = head;
        int len = size(head);
        for(int i=0; i< len - k; i++){
            f=f.next;
        }
        while(k>1){
            s=s.next;
            k--;
        }
        int temp = f.val;
        f.val = s.val;
        s.val = temp;
        
        return head;
    }
    private int size(ListNode head){
        int count =1;
        ListNode temp = head;
        while(temp.next!=null){
          temp = temp.next;
            count++;
        }
        return count;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">1711. Count Good Meals</span>
Input: deliciousness = [1,3,5,7,9]
Output: 4
Explanation: The good meals are (1,3), (1,7), (3,5) and, (7,9).
Their respective sums are 4, 8, 8, and 16, all of which are powers of 2.
Input: deliciousness = [1,1,1,3,3,3,7]
Output: 15
Explanation: The good meals are (1,1) with 3 ways, (1,3) with 9 ways, and (1,7) with 3 ways.
class Solution {
    int mod = 1000000007;
    public int countPairs(int[] arr) {
        Map<Integer, Integer> map = new HashMap<>();
        int n = arr.length;
        long res = 0;
        for (int num : arr) {
            int power = 1;
            for (int i = 0; i < 22; i++) {
                if (map.containsKey(power - num)) {
                    res += map.get(power - num);
                    res %= mod;
                }
                power *= 2;
            }
            map.put(num, map.getOrDefault(num, 0) + 1);
        }
        return (int) res;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">334. Increasing Triplet Subsequence</span>
Input: nums = [1,2,3,4,5]
Output: true
Explanation: Any triplet where i < j < k is valid.
Input: nums = [5,4,3,2,1]
Output: false
Explanation: No triplet exists.
Input: nums = [2,1,5,0,4,6]
Output: true
Explanation: The triplet (3, 4, 5) is valid because nums[3] == 0 < nums[4] == 4 < nums[5] == 6.
class Solution {
    public boolean increasingTriplet(int[] nums) {
         int max1 = Integer.MAX_VALUE;
       int max2 = Integer.MAX_VALUE;
       for(int n : nums) {
           if(n <= max1) max1 = n;
           else if(n <= max2) max2 = n;
           else return true;
       }
       return false;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">1679. Max Number of K-Sum Pairs</span>
Input: nums = [1,2,3,4], k = 5
Output: 2
Explanation: Starting with nums = [1,2,3,4]:
- Remove numbers 1 and 4, then nums = [2,3]
- Remove numbers 2 and 3, then nums = []
There are no more pairs that sum up to 5, hence a total of 2 operations.
Input: nums = [3,1,3,4,3], k = 6
Output: 1
Explanation: Starting with nums = [3,1,3,4,3]:
- Remove the first two 3's, then nums = [1,4,3]
There are no more pairs that sum up to 6, hence a total of 1 operation.
class Solution {
    public int maxOperations(int[] nums, int k) {
        HashMap<Integer,Integer>map=new HashMap<>();
        int count=0;
        for(int i=0;i< nums.length;i++){
            //to check if that k-nums[i] present and had some value left or already paired
            if(map.containsKey(k-nums[i])&&map.get(k-nums[i])>0){
                count++;
                map.put(k-nums[i],map.get(k-nums[i])-1);
            }else{
                //getOrDefault is easy way it directly checks if value is 0 returns 0 where I added 1
                //and if some value is present then it return that value "similar to map.get(i)" and I added 1 on it 
                map.put(nums[i],map.getOrDefault(nums[i],0)+1);
            }
        }
        return count; 
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">1670. Design Front Middle Back Queue</span>
Input:
["FrontMiddleBackQueue", "pushFront", "pushBack", "pushMiddle", "pushMiddle", "popFront", "popMiddle", "popMiddle", "popBack", "popFront"]
[[], [1], [2], [3], [4], [], [], [], [], []]
Output:
[null, null, null, null, null, 1, 3, 4, 2, -1]

Explanation:
FrontMiddleBackQueue q = new FrontMiddleBackQueue();
q.pushFront(1);   // [1]
q.pushBack(2);    // [1, 2]
q.pushMiddle(3);  // [1, 3, 2]
q.pushMiddle(4);  // [1, 4, 3, 2]
q.popFront();     // return 1 -> [4, 3, 2]
q.popMiddle();    // return 3 -> [4, 2]
q.popMiddle();    // return 4 -> [2]
q.popBack();      // return 2 -> []
q.popFront();     // return -1 -> [] (The queue is empty)
/**
 * We shall implement two lists i.e. front half and rear half or back half
 * whose sizes are denoted by fSize and bSize respectively
 * 
 * We'll make sure that after each push or pop operation
 * 		Either fSize == bSize
 * 		Or fSize == bSize-1
 * By maintaining this, we can make the pushMiddle and popMiddle efficient
 * For fSize == bSize, pushMiddle will push it in the back half and popMiddle will pop from the front half
 * For fSize == bSize-1, pushMiddle will push it in the front half and popMiddle will pop from the back half
 * To maintain this, we shall always push the first element in the back half irrespective of its requirement
 * So if bSize is 0, we are pushing the first element
 * if fSize is 0, we are pushing the second element
 * 
 * front and back denote the two ends of our queue
 * frontEnd and backEnd denote the joining point i.e. if we have to make a single list, we have to join these two points
 * 
 * e.g->
 * 5 6 8 9 2 3 4
 * Here 5 is front, 8 is frontEnd, 9 is backEnd and 4 is back
 * 
 * 5 6 8 9 2 3 4 6
 * Here 5 is front, 9 is frontEnd, 2 is backEnd and 6 is back
 * */
class Node
{
    Node front;
    int val;
    Node back;
    Node(int v)
    {
        val = v;
    }
}
class FrontMiddleBackQueue {
    Node front, frontEnd, back, backEnd;
    int fSize, bSize;
    public FrontMiddleBackQueue() {
        front = frontEnd = back = backEnd = null;
        fSize = bSize = 0;
    }
    
    public void pushFront(int val) {
        if (bSize == 0) //if first element, push in back half
        {
            back = new Node(val);
            backEnd = back;
            ++bSize;
        }
        else if (fSize == 0) //if second element, push in front half
        {
            front = new Node(val);
            frontEnd = front;
            ++fSize;
        }
        else //in all other cases, push in front
        {
            Node newNode = new Node(val);
            front.front = newNode;
            newNode.back = front;
            front = newNode;
            ++fSize;
            if (fSize > bSize) //if fSize exceeds bSize, move one node from the front half to the back half
                moveFrontEndToBackEnd();
        }
    }
    
    public void pushMiddle(int val) {
        if (bSize == 0) //if first element, push in back half
        {
            back = new Node(val);
            backEnd = back;
            ++bSize;
        }
        else //otherwise
        {
            Node newNode = new Node(val);
            if (fSize == bSize) //if sizes are same, push in back half
            {
                newNode.back = backEnd;
                backEnd.front = newNode;
                backEnd = newNode;
                ++bSize;
            }
            else //otherwise (fSize is guaranteed to be smaller) push in front half
            {
                if (fSize == 0)
                {
                    front = frontEnd = newNode;
                }
                else
                {
                    newNode.front = frontEnd;
                    frontEnd.back = newNode;
                    frontEnd = frontEnd.back;
                }
                ++fSize;
            }
        }
    }
    
    public void pushBack(int val) {
        if (bSize == 0)
        {
            back = new Node(val);
            backEnd = back;
            ++bSize;
        }
        else
        {
            Node newNode = new Node(val);
            back.back = newNode;
            newNode.front = back;
            back = newNode;
            ++bSize;
            if (bSize == fSize+2) //if the gap exceeds 1, move one node from back half to front half
                moveBackEndToFrontEnd();
        }
    }
    
    public int popFront() {
        int val = 0;
        if (bSize == 0) //if no elements
        {
            val = -1;
        }
        else if (fSize == 0) //if only one element is remaining (guaranteed to be in the back half)
        {
            val = back.val;
            back = backEnd = null;
            bSize = 0;
        }
        else //in all other cases, remove from front
        {
            val = front.val;
            front = front.back;
            if (front == null) frontEnd = null;
            else front.front = null;
            --fSize;
            if (bSize == fSize+2) //if the difference exceeds 1, move one node from back half to front half
                moveBackEndToFrontEnd();
        }
        return val;
    }
    
    public int popMiddle() {
        int val = 0;
        if (bSize == 0) //if no elements
        {
            val = -1;
        }
        else if (fSize == 0) //if only one element is remaining (guaranteed to be in the back half)
        {
            val = back.val;
            back = backEnd = null;
            bSize = 0;
        }
        else //in all other cases
        {
            val = 0;
            if (fSize == bSize) //if sizes are same, pop from front half
            {
                val = frontEnd.val;
                frontEnd = frontEnd.front;
                if (frontEnd == null) front = null;
                else frontEnd.back = null;
                --fSize;
            }
            else //otherwise (fSize is guaranteed to be smaller) pop from back half
            {
                val = backEnd.val;
                backEnd = backEnd.back;
                if (backEnd == null) back = null;
                else backEnd.front = null;
                --bSize;
            }
        }
        return val;
    }
    
    public int popBack() {
        int val = 0;
        if (fSize == 0 && bSize == 0) //if no elements
        {
            val = -1;
        }
        else if (fSize == 0) //if only one element is remaining
        {
            val = back.val;
            back = backEnd = null;
            bSize = 0;
        }
        else //in all other cases, remove from back
        {
            val = back.val;
            back = back.front;
            if (back == null) backEnd = null;
            else back.back = null;
            --bSize;
            if (bSize < fSize) //if bSize decreases
                moveFrontEndToBackEnd(); //move one node from front half to back half
        }
        return val;
    }
    
    private void moveBackEndToFrontEnd()
    {
        if (fSize == 0) //if front half has no elements (back half is guaranteed to have only one element)
        {
            front = frontEnd = backEnd;
            backEnd = backEnd.back;
        }
        else //otherwise
        {
            frontEnd.back = backEnd;
            backEnd = backEnd.back;
            frontEnd.back.front = frontEnd;
            frontEnd = frontEnd.back;
        }
        frontEnd.back = backEnd.front = null;
        ++fSize;
        --bSize;
    }
    
    private void moveFrontEndToBackEnd()
    {
        if (bSize == 0) //if back half has no elements (front half is guaranteed to have 2 elements)
        {
            back = backEnd = front;
            front = frontEnd = null;
            backEnd.front = backEnd.back = null;
        }
        else //otherwise
        {
            backEnd.front = frontEnd;
            frontEnd = frontEnd.front;
            backEnd.front.back = backEnd;
            backEnd = backEnd.front;
            backEnd.front = frontEnd.back = null;
        }
        --fSize;
        ++bSize;
    }
}

/**
 * Your FrontMiddleBackQueue object will be instantiated and called as such:
 * FrontMiddleBackQueue obj = new FrontMiddleBackQueue();
 * obj.pushFront(val);
 * obj.pushMiddle(val);
 * obj.pushBack(val);
 * int param_4 = obj.popFront();
 * int param_5 = obj.popMiddle();
 * int param_6 = obj.popBack();*/
 <span id="line">---------------------------------------------------------------</span>
 <span class="textStyle">1658. Minimum Operations to Reduce X to Zero</span>
Input: nums = [1,1,4,2,3], x = 5
Output: 2
Explanation: The optimal solution is to remove the last two elements to reduce x to zero.
Input: nums = [5,6,7,8,9], x = 4
Output: -1
Input: nums = [3,2,20,1,1,3], x = 10
Output: 5
Explanation: The optimal solution is to remove the last three elements and the first two elements (5 operations in total) to reduce x to zero.
class Solution {
    public int minOperations(int[] nums, int x) {
       int target = -x;
for (int num : nums) target += num;

if (target == 0) return nums.length;  // since all elements are positive, we have to take all of them

Map<Integer, Integer> map = new HashMap<>();
map.put(0, -1);
int sum = 0;
int res = Integer.MIN_VALUE;

for (int i = 0; i < nums.length; ++i) {

	sum += nums[i];
	if (map.containsKey(sum - target)) {
		res = Math.max(res, i - map.get(sum - target));
	}

    // no need to check containsKey since sum is unique
	map.put(sum, i);
}

return res == Integer.MIN_VALUE ? -1 : nums.length - res; 
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">1642. Furthest Building You Can Reach</span>
Input: heights = [4,2,7,6,9,14,12], bricks = 5, ladders = 1
Output: 4
Explanation: Starting at building 0, you can follow these steps:
- Go to building 1 without using ladders nor bricks since 4 >= 2.
- Go to building 2 using 5 bricks. You must use either bricks or ladders because 2 < 7.
- Go to building 3 without using ladders nor bricks since 7 >= 6.
- Go to building 4 using your only ladder. You must use either bricks or ladders because 6 < 9.
It is impossible to go beyond building 4 because you do not have any more bricks or ladders.
Input: heights = [4,12,2,7,3,18,20,3,19], bricks = 10, ladders = 2
Output: 7
class Solution {
    public int furthestBuilding(int[] heights, int bricks, int ladders) {
     PriorityQueue<Integer> pq = new PriorityQueue<>(Collections.reverseOrder());

	for (int i=0; i< heights.length-1; i++) {
		if (heights[i] >= heights[i+1]) continue;
		bricks -= heights[i+1] - heights[i];
		pq.add(heights[i+1] - heights[i]);

		if (bricks < 0) {
			bricks += pq.poll();
			if (ladders > 0) ladders--;
			else return i;
		}
	}

	return heights.length - 1;   
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">16. 3Sum Closest</span>
Input: nums = [-1,2,1,-4], target = 1
Output: 2
Explanation: The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).
Input: nums = [0,0,0], target = 1
Output: 0
Explanation: The sum that is closest to the target is 0. (0 + 0 + 0 = 0).
class Solution {
    public int threeSumClosest(int[] nums, int target) {
       int result=nums[0]+nums[1]+nums[nums.length-1];
        Arrays.sort(nums);
        for(int i=0;i< nums.length-2;i++){
            int a=i+1;
            int b=nums.length-1;
            while(a< b){
                int curr=nums[i]+nums[a]+nums[b];
                if(curr>target){
                    b-=1;
                }else{
                    a+=1;
                }
                if(Math.abs(curr-target)< Math.abs(result-target)){
                   result=curr; 
                }
            }
        }
        return result;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">1980. Find Unique Binary String</span>
Input: nums = ["01","10"]
Output: "11"
Explanation: "11" does not appear in nums. "00" would also be correct.
Input: nums = ["00","01"]
Output: "11"
Explanation: "11" does not appear in nums. "10" would also be correct.
Input: nums = ["111","011","001"]
Output: "101"
Explanation: "101" does not appear in nums. "000", "010", "100", and "110" would also be correct.
class Solution {
     public String findDifferentBinaryString(String[] nums) {
        Set<String> set = new HashSet<>();
        for(String s:nums) set.add(s);
        for(int i=0;i<=Math.pow(nums.length,2);i++) {
            String s = convertToBinary(i, nums.length);
            if(!set.contains(s)) return s;
        }
        return null;
    }
    private String convertToBinary(int n, int digits) {
        StringBuilder sb = new StringBuilder();
        for(int i=digits-1;i>=0;i--) 
            sb.append((n&1<< i) !=0 ?"1":"0");
        return sb.toString();
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">1968. Array With Elements Not Equal to Average of Neighbors</span>
Input: nums = [1,2,3,4,5]
Output: [1,2,4,5,3]
Explanation:
When i=1, nums[i] = 2, and the average of its neighbors is (1+4) / 2 = 2.5.
When i=2, nums[i] = 4, and the average of its neighbors is (2+5) / 2 = 3.5.
When i=3, nums[i] = 5, and the average of its neighbors is (4+3) / 2 = 3.5.
Input: nums = [6,2,0,9,7]
Output: [9,7,6,2,0]
Explanation:
When i=1, nums[i] = 7, and the average of its neighbors is (9+6) / 2 = 7.5.
When i=2, nums[i] = 6, and the average of its neighbors is (7+2) / 2 = 4.5.
When i=3, nums[i] = 2, and the average of its neighbors is (6+0) / 2 = 3.
class Solution {
    public int[] rearrangeArray(int[] nums) {
         Arrays.sort(nums);
        for (int i = 1; i < nums.length; i += 2) {
            int tmp = nums[i];
            nums[i] = nums[i - 1];
            nums[i - 1] = tmp;
        }
        return nums;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">1926. Nearest Exit from Entrance in Maze</span>
Input: maze = [["+","+",".","+"],[".",".",".","+"],["+","+","+","."]], entrance = [1,2]
Output: 1
Explanation: There are 3 exits in this maze at [1,0], [0,2], and [2,3].
Initially, you are at the entrance cell [1,2].
- You can reach [1,0] by moving 2 steps left.
- You can reach [0,2] by moving 1 step up.
It is impossible to reach [2,3] from the entrance.
Thus, the nearest exit is [0,2], which is 1 step away.
Input: maze = [["+","+","+"],[".",".","."],["+","+","+"]], entrance = [1,0]
Output: 2
Explanation: There is 1 exit in this maze at [1,2].
[1,0] does not count as an exit since it is the entrance cell.
Initially, you are at the entrance cell [1,0].
- You can reach [1,2] by moving 2 steps right.
Thus, the nearest exit is [1,2], which is 2 steps away.
Input: maze = [[".","+"]], entrance = [0,0]
Output: -1
Explanation: There are no exits in this maze.
class Solution {
    public int nearestExit(char[][] maze, int[] entrance) {
        int rows = maze.length, cols = maze[0].length, queueSize;
        Queue<int[]> queue = new LinkedList<>();
        boolean[][] visited = new boolean[rows][cols];
        int[] curr;
        int[][] dirs = {{0,1},{0,-1},{1,0},{-1,0}};
        int x, y, steps = 0;
        
        queue.offer(entrance);
        visited[entrance[0]][entrance[1]] = true;
        
        while (!queue.isEmpty()) {
            queueSize = queue.size();
            steps++;
            
            for (int i=0;i< queueSize;i++) {
                curr = queue.poll();
                
                for (int[] dir: dirs) {
                    x = dir[0]+curr[0];                    
                    y = dir[1]+curr[1];
                    
                    if (x< 0||x>=rows||y< 0||y>=cols) continue;
                    if (visited[x][y] || maze[x][y] == '+') continue;
                    
					// check if we have reached boundary
                    if (x==0||x==rows-1||y==0||y==cols-1) return steps;
                    
                    queue.offer(new int[]{x, y});
                    visited[x][y] = true;
                }
            }
        }
        
        return -1; 
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">1910. Remove All Occurrences of a Substring</span>
Input: s = "daabcbaabcbc", part = "abc"
Output: "dab"
Explanation: The following operations are done:
- s = "daabcbaabcbc", remove "abc" starting at index 2, so s = "dabaabcbc".
- s = "dabaabcbc", remove "abc" starting at index 4, so s = "dababc".
- s = "dababc", remove "abc" starting at index 3, so s = "dab".
Now s has no occurrences of "abc".
Input: s = "axxxxyyyyb", part = "xy"
Output: "ab"
Explanation: The following operations are done:
- s = "axxxxyyyyb", remove "xy" starting at index 4 so s = "axxxyyyb".
- s = "axxxyyyb", remove "xy" starting at index 3 so s = "axxyyb".
- s = "axxyyb", remove "xy" starting at index 2 so s = "axyb".
- s = "axyb", remove "xy" starting at index 1 so s = "ab".
Now s has no occurrences of "xy".
class Solution {
    public String removeOccurrences(String s, String part) {
        while(s.contains(part)){
            s = s.replaceFirst(part,"");
        }
        return s;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">449. Serialize and Deserialize BST</span>
Input: root = [2,1,3]
Output: [2,1,3]
Input: root = []
Output: []
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Codec {
  public String serialize(TreeNode root){
        if(root == null) return "";
        Queue<TreeNode> q = new LinkedList<>();
        StringBuilder res = new StringBuilder();
        q.add(root);
        while(!q.isEmpty()){
            TreeNode curr = q.poll();
            if(curr == null){
                res.append("n ");
                continue;
            }
            res.append(curr.val + " ");
            q.add(curr.left);
            q.add(curr.right);
        }
        return res.toString();
    }
    public TreeNode deserialize(String data){
        if(data == "") return null;
        Queue<TreeNode> q = new LinkedList<>();
        String[] val = data.split(" ");
        TreeNode root = new TreeNode(Integer.parseInt(val[0]));
        q.add(root);
        for(int i = 1; i < val.length; i++){
            TreeNode curr = q.poll();
            if(!val[i].equals("n")){
                TreeNode left = new TreeNode(Integer.parseInt(val[i]));
                curr.left = left;
                q.add(left);
            }
            if(!val[++i].equals("n")){
                TreeNode right = new TreeNode(Integer.parseInt(val[i]));
                curr.right = right;
                q.add(right);
            }
        }
        return root;
    }
}

// Your Codec object will be instantiated and called as such:
// Codec ser = new Codec();
// Codec deser = new Codec();
// String tree = ser.serialize(root);
// TreeNode ans = deser.deserialize(tree);
// return ans;
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">75. Sort Colors</span>
Input: nums = [2,0,2,1,1,0]
Output: [0,0,1,1,2,2]
Input: nums = [2,0,1]
Output: [0,1,2]
class Solution {
    public void sortColors(int[] nums) {
        	int l=0;
	    	int r=nums.length-1; 
	    	int curr =0;
	    	
	    	while (curr<=r) {
	    		
	    		if (nums[curr] == 0 && curr>=l) {
	    			
	    			swap(nums, l, curr);
	    			l++;
	    			
	    		}else if (nums[curr] == 2 && curr< r) {
	    			
	    			swap(nums, r, curr);
	    			r--;
	    			continue;
	    		}
	    		curr++;
	    	}
	        
	    }

		private void swap(int[] nums, int l, int curr) {
			int temp = nums[l];
			nums[l] = nums[curr];
			nums[curr] = temp;
		}
    }
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">347. Top K Frequent Elements</span>
Input: nums = [1,1,1,2,2,3], k = 2
Output: [1,2]
Input: nums = [1], k = 1
Output: [1]
class Solution {
    public int[] topKFrequent(int[] nums, int k) {
        if( k == nums.length)
            return nums;

        int res[] = new int[k];
        HashMap<Integer, Integer> hm = new HashMap<>();

        for(int n: nums)
            hm.put(n, hm.getOrDefault(n, 0)+1);

        PriorityQueue<Integer> pq = new PriorityQueue<>((a,b) -> hm.get(b) - hm.get(a));

        for(int i: hm.keySet())
            pq.offer(i);

        for(int i=0; i< k;i++)
            res[i] = pq.poll();

        return res;
    }
}

<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">1328. Break a Palindrome</span>
Input: palindrome = "abccba"
Output: "aaccba"
Explanation: There are many ways to make "abccba" not a palindrome, such as "zbccba", "aaccba", and "abacba".
Of all the ways, "aaccba" is the lexicographically smallest.
Input: palindrome = "a"
Output: ""
Explanation: There is no way to replace a single character to make "a" not a palindrome, so return an empty string.
class Solution {
      public String breakPalindrome(String palindrome) {
        if(palindrome.length() == 1){
            return "";
        }
        char [] array = palindrome.toCharArray();
        int s = 0;
        int e = palindrome.length();
        while(s< e){
            if(array[s]!='a'){
                array[s] = 'a';
                break;
            }
            s++;
        }
		// check for case "aaabaaa"
		// Here, from above loop, array will become "aaaaaaa"
		// So  check  if array is palindrome after change , if  yes, then change the last char of orginal string to b.
        if(isPalindrome(new String(array))){
            array = palindrome.toCharArray();
            array[e-1]='b';
        }
        return new String(array);
    }
    
    private boolean isPalindrome(String palindrome) {
        int s = 0;
        int e = palindrome.length()-1;
        while(s< e)
        {
            if(palindrome.charAt(s)==palindrome.charAt(e)){
                s++;
                e--;
            }else{
                return false;
            }
        }
        return true;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">1792. Maximum Average Pass Ratio</span>
Input: classes = [[1,2],[3,5],[2,2]], extraStudents = 2
Output: 0.78333
Explanation: You can assign the two extra students to the first class. The average pass ratio will be equal to (3/4 + 3/5 + 2/2) / 3 = 0.78333.
Input: classes = [[2,4],[3,9],[4,5],[2,10]], extraStudents = 4
Output: 0.53485
class Solution {
    public double maxAverageRatio(int[][] classes, int extraStudents) {
        PriorityQueue<int[]> queue = new PriorityQueue<>(new Cmp());
        for(int[] c: classes) queue.offer(c);   
        // add all to priority queue
        for(;extraStudents > 0;extraStudents--){    
            // add extra student to class that will max increase the average
            int[] c = queue.poll();
            c[0]++; c[1]++;
            queue.offer(c);
        }
        double result =0;
        while(!queue.isEmpty()) {       // Calculate sum of pass ratios
            int[] c = queue.poll();
            result += (double)c[0]/c[1];
        }
        return result/classes.length;    // return average
    }
}
class Cmp implements Comparator<int[]> {
    // to sort in descending order of diff when 1 is added to class
    public int compare(int[] x, int[] y) {
        double xDiff = (double)(x[0]+1)/(x[1]+1) - (double)x[0]/x[1], yDiff = (double)(y[0]+1)/(y[1]+1) - (double)y[0]/y[1];
        return xDiff > yDiff? -1 : 1;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">2130. Maximum Twin Sum of a Linked List</span>
Input: head = [5,4,2,1]
Output: 6
Explanation:
Nodes 0 and 1 are the twins of nodes 3 and 2, respectively. All have twin sum = 6.
There are no other nodes with twins in the linked list.
Thus, the maximum twin sum of the linked list is 6. 
Input: head = [4,2,2,3]
Output: 7
Explanation:
The nodes with twins present in this linked list are:
- Node 0 is the twin of node 3 having a twin sum of 4 + 3 = 7.
- Node 1 is the twin of node 2 having a twin sum of 2 + 2 = 4.
Thus, the maximum twin sum of the linked list is max(7, 4) = 7. 
Input: head = [1,100000]
Output: 100001
Explanation:
There is only one node with a twin in the linked list having twin sum of 1 + 100000 = 100001.
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public int pairSum(ListNode head) {
        ListNode head1 = null;
        ListNode temp=head;
        int c=0;
        while(temp!=null){
            c++;
            ListNode node=new ListNode(temp.val);
            if(head1==null){
                head1=node;
            }else{
                node.next=head1;
                head1=node;
            }
            temp=temp.next;
        }
        int max=0;
        for(int i=0;i<(c/2);i++){
            while(head!=null && head1!=null){
                if((head.val+head1.val)>max){
                    max=head.val+head1.val;
                }
            head=head.next;
            head1=head1.next;
        }
    }
    return max; 
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">2125. Number of Laser Beams in a Bank</span>
Input: bank = ["011001","000000","010100","001000"]
Output: 8
Explanation: Between each of the following device pairs, there is one beam. In total, there are 8 beams:
 * bank[0][1] -- bank[2][1]
 * bank[0][1] -- bank[2][3]
 * bank[0][2] -- bank[2][1]
 * bank[0][2] -- bank[2][3]
 * bank[0][5] -- bank[2][1]
 * bank[0][5] -- bank[2][3]
 * bank[2][1] -- bank[3][2]
 * bank[2][3] -- bank[3][2]
Note that there is no beam between any device on the 0th row with any on the 3rd row.
This is because the 2nd row contains security devices, which breaks the second condition.
Input: bank = ["000","111","000"]
Output: 0
Explanation: There does not exist two devices located on two different rows.
class Solution {
    public int numberOfBeams(String[] bank) {
        int pOnes=0; int res=0;
        for(String s: bank){
            int count=0;
            for(char ch: s.toCharArray()){
                if(ch=='1'){
                    count++;
				}
            }
           if(count>0){
                res+=(count*pOnes);
                pOnes=count;
            }
        }
        return res;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">2116. Check if a Parentheses String Can Be Valid</span>
Input: s = "))()))", locked = "010100"
Output: true
Explanation: locked[1] == '1' and locked[3] == '1', so we cannot change s[1] or s[3].
We change s[0] and s[4] to '(' while leaving s[2] and s[5] unchanged to make s valid.
Input: s = "()()", locked = "0000"
Output: true
Explanation: We do not need to make any changes because s is already valid.
Input: s = ")", locked = "0"
Output: false
Explanation: locked permits us to change s[0]. 
Changing s[0] to either '(' or ')' will not make s valid.
class Solution {
    public boolean canBeValid(String s, String locked) {
         int n = s.length();
        if (n % 2 != 0) return false;
        
        int possibleOpens = 0;
        int fixedCloses = 0;
        
        for (int i = 0; i < n; i ++) {
            if (s.charAt(i) == '(' || locked.charAt(i) == '0') {
                possibleOpens++;
            } else {
                fixedCloses++;
            }
            
            if (fixedCloses > possibleOpens) return false;
        }
        
        int possibleCloses = 0;
        int fixedOpens = 0;
        
        for (int i = n - 1; i >= 0; i--) {
            if (s.charAt(i) == ')' || locked.charAt(i) == '0') {
                possibleCloses++;
            } else {
                fixedOpens++;
            }
            
            if (fixedOpens > possibleCloses) return false;
        }
        
        return true; 
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">2110. Number of Smooth Descent Periods of a Stock</span>
Input: prices = [3,2,1,4]
Output: 7
Explanation: There are 7 smooth descent periods:
[3], [2], [1], [4], [3,2], [2,1], and [3,2,1]
Note that a period with one day is a smooth descent period by the definition.
Input: prices = [8,6,7,7]
Output: 4
Explanation: There are 4 smooth descent periods: [8], [6], [7], and [7]
Note that [8,6] is not a smooth descent period as 8 - 6 ≠ 1.
Input: prices = [1]
Output: 1
Explanation: There is 1 smooth descent period: [1]
class Solution {
    public long getDescentPeriods(int[] prices) {
        int start=0,end=0;
        long count=1;
        for(end=1;end< prices.length;end++){
            if(prices[end] == prices[end-1]-1){
                count += end-start+1;
            }else{
                start = end;
                count++;
            }
        }
        return count;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">2109. Adding Spaces to a String</span>
Input: s = "LeetcodeHelpsMeLearn", spaces = [8,13,15]
Output: "Leetcode Helps Me Learn"
Explanation: 
The indices 8, 13, and 15 correspond to the underlined characters in "LeetcodeHelpsMeLearn".
We then place spaces before those characters.
Input: s = "icodeinpython", spaces = [1,5,7,9]
Output: "i code in py thon"
Explanation:
The indices 1, 5, 7, and 9 correspond to the underlined characters in "icodeinpython".
We then place spaces before those characters.
Input: s = "spacing", spaces = [0,1,2,3,4,5,6]
Output: " s p a c i n g"
Explanation:
We are also able to place spaces before the first character of the string.
class Solution {
    public String addSpaces(String s, int[] spaces) {
        int j = 0,curr = 0;
        StringBuilder sb = new StringBuilder();
        while(curr< s.length()){
           
             if(j< spaces.length&&spaces[j]==curr){
                 
                sb.append(" ");
                j++;
    
                }
                sb.append(s.charAt(curr));
                curr++;

        }

        return sb.toString();
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">2024. Maximize the Confusion of an Exam</span>
Input: answerKey = "TTFF", k = 2
Output: 4
Explanation: We can replace both the 'F's with 'T's to make answerKey = "TTTT".
There are four consecutive 'T's.
Input: answerKey = "TFFT", k = 1
Output: 3
Explanation: We can replace the first 'T' with an 'F' to make answerKey = "FFFT".
Alternatively, we can replace the second 'T' with an 'F' to make answerKey = "TFFF".
In both cases, there are three consecutive 'F's.
Input: answerKey = "TTFTTFTT", k = 1
Output: 5
Explanation: We can replace the first 'F' to make answerKey = "TTTTTFTT"
Alternatively, we can replace the second 'F' to make answerKey = "TTFTTTTT". 
In both cases, there are five consecutive 'T's.
class Solution {
    public int maxConsecutiveAnswers(String answerKey, int k) {
	return Math.max(flipper(answerKey, k, 'F'), flipper(answerKey, k, 'T'));
}

public int flipper(String answerKey, int k, char countLetter) {
	int max = 0;
	int count = 0;
	LinkedList< Integer> queue = new LinkedList<>();
	for (int i = 0; i < answerKey.length(); i++) {
		char letter = answerKey.charAt(i);
		if (letter == countLetter) count++;
		else if (k > 0) {
			queue.add(i);
			k--;
			count++;
		} else {
			queue.add(i);
			max = Math.max(count, max);
			Integer firstEncountered = queue.removeFirst();
			count = i - firstEncountered;
		}
	}
	max = Math.max(count, max);
	return max;
}
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">2012. Sum of Beauty in the Array</span>
Input: nums = [1,2,3]
Output: 2
Explanation: For each index i in the range 1 <= i <= 1:
- The beauty of nums[1] equals 2.
Input: nums = [2,4,6,4]
Output: 1
Explanation: For each index i in the range 1 <= i <= 2:
- The beauty of nums[1] equals 1.
- The beauty of nums[2] equals 0.
Input: nums = [3,2,1]
Output: 0
Explanation: For each index i in the range 1 <= i <= 1:
- The beauty of nums[1] equals 0.
class Solution {
    public int sumOfBeauties(int[] nums) {
         int[] minInRight = new int[nums.length];
        minInRight[nums.length - 1] = nums[nums.length - 1];
        for (int i = nums.length - 2; i >= 2; i--)
            minInRight[i] = Math.min(minInRight[i + 1], nums[i]);

        int maxInLeft = nums[0], sum = 0;
        for (int i = 1; i < nums.length - 1; i++){
            if (nums[i] > maxInLeft && nums[i] < minInRight[i + 1])  sum += 2;
            else if (nums[i] > nums[i - 1] && nums[i] < nums[i + 1]) sum += 1;

            maxInLeft = Math.max(maxInLeft, nums[i]);
        }
        return sum;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span class="textStyle">1981. Minimize the Difference Between Target and Chosen Elements</span>
Input: mat = [[1,2,3],[4,5,6],[7,8,9]], target = 13
Output: 0
Explanation: One possible choice is to:
- Choose 1 from the first row.
- Choose 5 from the second row.
- Choose 7 from the third row.
The sum of the chosen elements is 13, which equals the target, so the absolute difference is 0.
Input: mat = [[1],[2],[3]], target = 100
Output: 94
Explanation: The best possible choice is to:
- Choose 1 from the first row.
- Choose 2 from the second row.
- Choose 3 from the third row.
The sum of the chosen elements is 6, and the absolute difference is 94.
class Solution {
    public int minimizeTheDifference(int[][] mat, int target) {
        Integer[][] dp = new Integer[mat.length][5001];
        return minDiff(mat, 0, target,0, dp);
    }
    
    public int minDiff(int[][] mat,int index,int target, int val, Integer[][] dp){
        if(index == mat.length){
            return Math.abs(val - target);
        }
        if(dp[index][val] != null){
            return dp[index][val];
        }
        
        int res = Integer.MAX_VALUE;
        for(int i = 0; i < mat[0].length; i++){
            res = Math.min(res, minDiff(mat, index + 1, target, val + mat[index][i], dp));
        }
        
        return dp[index][val] = res;
    }
}
<span id="line">---------------------------------------------------------------</span>
<span id="line">---------------------------------------------------------------</span>
        </pre>
</body>
</html>